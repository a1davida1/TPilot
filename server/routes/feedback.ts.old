import { Router, type Request, type Response } from 'express';
import { z } from 'zod';
import { authenticateToken, type AuthRequest } from '../middleware/auth.js';
import { logger } from '../bootstrap/logger.js';
import { db } from '../db.js';
import { feedback } from '@shared/schema';
import { eq, desc } from 'drizzle-orm';

const router = Router();

// Feedback submission schema
const feedbackSchema = z.object({
  type: z.enum(['bug', 'feature', 'general', 'praise']),
  message: z.string().min(1).max(1000),
  url: z.string().optional(),
  userAgent: z.string().optional(),
});

/**
 * POST /api/feedback
 * Submit user feedback (bug report, feature request, etc)
 */
router.post('/', authenticateToken(false), async (req: AuthRequest, res: Response) => {
  try {
    const { type, message, url, userAgent } = feedbackSchema.parse(req.body);
    
    const userId = req.user?.id || null;
    const userEmail = req.user?.email || null;
    const username = req.user?.username || 'Anonymous';
    
    // Store feedback in database
    const [newFeedback] = await db.insert(feedback).values({
      userId,
      type,
      message,
      pageUrl: url,
      userAgent,
      status: 'pending'
    }).returning({ id: feedback.id });
    
    logger.info('Feedback submitted', { 
      feedbackId: newFeedback.id, 
      type, 
      userId,
      url 
    });
    
    // Send email notification to admin (non-blocking)
    // TODO: Implement email service
    /*
    const adminEmail = process.env.ADMIN_EMAIL || 'thottopilot@thottopilot.com';
    
    sendEmail({
      to: adminEmail,
      subject: `[ThottoPilot Beta] New ${type} feedback from ${username}`,
      html: `
        <h2>New Feedback Received</h2>
        <p><strong>Type:</strong> ${type}</p>
        <p><strong>From:</strong> ${username} (${userEmail || 'not logged in'})</p>
        <p><strong>Page:</strong> ${url || 'Unknown'}</p>
        <hr>
        <p><strong>Message:</strong></p>
        <p>${message.replace(/\n/g, '<br>')}</p>
        <hr>
        <p><small>Feedback ID: ${newFeedback.id}</small></p>
        <p><small>User Agent: ${userAgent || 'Unknown'}</small></p>
      `
    }).catch((error: any) => {
      logger.error('Failed to send feedback email notification', { error });
    });
    */
    
    // For now, just log that feedback was received
    logger.info('New feedback received - email notification skipped', {
      feedbackId: newFeedback.id,
      type,
      username,
      adminEmail: process.env.ADMIN_EMAIL || 'not configured'
    });
    
    res.json({
      success: true,
      feedbackId: newFeedback.id,
      message: 'Thank you for your feedback! We\'ll review it shortly.'
    });
    
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid feedback data',
        details: error.errors
      });
    }
    
    logger.error('Failed to submit feedback', { error: error.message });
    res.status(500).json({
      error: 'Failed to submit feedback',
      message: 'Please try again or email support@thottopilot.com'
    });
  }
});

/**
 * GET /api/feedback/my-feedback
 * Get user's submitted feedback
 */
router.get('/my-feedback', authenticateToken(true), async (req: AuthRequest, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const result = await pool.query(
      `SELECT 
        id,
        type,
        message,
        status,
        admin_response,
        created_at,
        responded_at
      FROM feedback
      WHERE user_id = $1
      ORDER BY created_at DESC
      LIMIT 20`,
      [req.user.id]
    );
    
    res.json({
      feedback: result.rows,
      count: result.rows.length
    });
    
  } catch (error: any) {
    logger.error('Failed to fetch user feedback', { error: error.message });
    res.status(500).json({ error: 'Failed to retrieve feedback' });
  }
});

/**
 * GET /api/feedback/stats
 * Get feedback statistics (public)
 */
router.get('/stats', async (_req: Request, res: Response) => {
  try {
    const result = await pool.query(`
      SELECT 
        type,
        COUNT(*) as count,
        COUNT(DISTINCT user_id) as unique_users
      FROM feedback
      WHERE created_at > NOW() - INTERVAL '30 days'
      GROUP BY type
    `);
    
    const totalResult = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved,
        COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as in_progress
      FROM feedback
      WHERE created_at > NOW() - INTERVAL '30 days'
    `);
    
    res.json({
      byType: result.rows,
      totals: totalResult.rows[0] || { total: 0, resolved: 0, in_progress: 0 }
    });
    
  } catch (error: any) {
    logger.error('Failed to get feedback stats', { error: error.message });
    res.status(500).json({ error: 'Failed to retrieve statistics' });
  }
});

/**
 * GET /api/feedback/admin/all
 * Get all feedback (admin only)
 */
router.get('/admin/all', authenticateToken(true), async (req: AuthRequest, res: Response) => {
  try {
    // Check admin status
    if (!req.user?.isAdmin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    const { status = 'all', type = 'all', limit = 50 } = req.query;
    
    let query = `
      SELECT 
        f.id,
        f.user_id,
        f.type,
        f.message,
        f.page_url,
        f.user_agent,
        f.status,
        f.admin_response,
        f.created_at,
        f.responded_at,
        u.username,
        u.email
      FROM feedback f
      LEFT JOIN users u ON f.user_id = u.id
    `;
    
    const conditions = [];
    const params = [];
    
    if (status !== 'all') {
      conditions.push(`f.status = $${params.length + 1}`);
      params.push(status);
    }
    
    if (type !== 'all') {
      conditions.push(`f.type = $${params.length + 1}`);
      params.push(type);
    }
    
    if (conditions.length > 0) {
      query += ` WHERE ${conditions.join(' AND ')}`;
    }
    
    query += ` ORDER BY f.created_at DESC LIMIT $${params.length + 1}`;
    params.push(limit);
    
    const result = await pool.query(query, params);
    
    res.json({
      feedback: result.rows,
      count: result.rows.length
    });
    
  } catch (error: any) {
    logger.error('Failed to fetch admin feedback', { error: error.message });
    res.status(500).json({ error: 'Failed to retrieve feedback' });
  }
});

/**
 * PATCH /api/feedback/admin/:id
 * Update feedback status or add admin response
 */
router.patch('/admin/:id', authenticateToken(true), async (req: AuthRequest, res: Response) => {
  try {
    // Check admin status
    if (!req.user?.isAdmin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    const { id } = req.params;
    const { status, adminResponse } = req.body;
    
    const updates = [];
    const params = [];
    
    if (status) {
      updates.push(`status = $${params.length + 1}`);
      params.push(status);
    }
    
    if (adminResponse !== undefined) {
      updates.push(`admin_response = $${params.length + 1}`);
      params.push(adminResponse);
      updates.push(`responded_at = NOW()`);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: 'No updates provided' });
    }
    
    params.push(id);
    
    const result = await pool.query(
      `UPDATE feedback 
       SET ${updates.join(', ')}
       WHERE id = $${params.length}
       RETURNING *`,
      params
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Feedback not found' });
    }
    
    logger.info('Feedback updated by admin', { 
      feedbackId: id, 
      adminId: req.user.id,
      status,
      hasResponse: !!adminResponse
    });
    
    res.json({
      success: true,
      feedback: result.rows[0]
    });
    
  } catch (error: any) {
    logger.error('Failed to update feedback', { error: error.message });
    res.status(500).json({ error: 'Failed to update feedback' });
  }
});

export default router;
