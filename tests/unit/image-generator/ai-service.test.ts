import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock environment variables
const mockEnv = {
  OPENAI_API_KEY: 'test-openai-key',
  GOOGLE_GENAI_API_KEY: 'test-gemini-key',
  ANTHROPIC_API_KEY: 'test-anthropic-key'
};

// Mock AI providers
const mockOpenAI = {
  chat: {
    completions: {
      create: vi.fn()
    }
  }
};

const mockGemini = {
  generateContent: vi.fn()
};

const mockAnthropic = {
  messages: {
    create: vi.fn()
    }
};

// Mock logger
const mockLogger = {
  info: vi.fn(),
  error: vi.fn(),
  warn: vi.fn()
};

vi.mock('openai', () => ({ default: vi.fn(() => mockOpenAI) }));
vi.mock('@google/genai', () => ({ GoogleGenAI: vi.fn(() => mockGemini) }));
vi.mock('@anthropic-ai/sdk', () => ({ default: vi.fn(() => mockAnthropic) }));
vi.mock('../../../server/lib/logger-utils.js', () => ({ safeLog: mockLogger.info }));

// Import after mocking
import { generateWithMultiProvider } from '../../../server/services/multi-ai-provider';

describe('AI Service Unit Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Reset environment variables
    Object.keys(mockEnv).forEach(key => {
      process.env[key] = mockEnv[key];
    });
  });

  afterEach(() => {
    // Clean up environment variables
    Object.keys(mockEnv).forEach(key => {
      delete process.env[key];
    });
  });

  describe('Environment Variable Handling', () => {
    it('should handle missing OPENAI_API_KEY gracefully', async () => {
      delete process.env.OPENAI_API_KEY;
      
      // Should still try other providers (Gemini, Claude)
      mockGemini.generateContent.mockResolvedValueOnce({
        response: {
          text: () => JSON.stringify({
            titles: ['Generated with Gemini'],
            content: 'Gemini-generated content',
            photoInstructions: {
              lighting: 'natural',
              cameraAngle: 'straight',
              composition: 'centered',
              styling: 'casual',
              mood: 'happy',
              technicalSettings: 'auto'
            }
          })
        }
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'playful' } },
        platform: 'instagram',
        allowsPromotion: 'no'
      });

      expect(result).toBeDefined();
      expect(result.titles).toEqual(['Generated with Gemini']);
      expect(result.provider).toBe('gemini-flash');
    });

    it('should handle missing GOOGLE_GENAI_API_KEY gracefully', async () => {
      delete process.env.GOOGLE_GENAI_API_KEY;
      
      // Should fall back to OpenAI
      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['Generated with OpenAI'],
              content: 'OpenAI-generated content',
              photoInstructions: {
                lighting: 'studio',
                cameraAngle: 'portrait',
                composition: 'rule of thirds',
                styling: 'professional',
                mood: 'confident',
                technicalSettings: 'manual'
              }
            })
          }
        }]
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'professional' } },
        platform: 'twitter',
        allowsPromotion: 'yes'
      });

      expect(result).toBeDefined();
      expect(result.titles).toEqual(['Generated with OpenAI']);
      expect(result.provider).toBe('openai-gpt4o');
    });

    it('should handle all API keys missing', async () => {
      delete process.env.OPENAI_API_KEY;
      delete process.env.GOOGLE_GENAI_API_KEY;
      delete process.env.ANTHROPIC_API_KEY;

      await expect(generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'playful' } },
        platform: 'instagram',
        allowsPromotion: 'no'
      })).rejects.toThrow();
    });
  });

  describe('AI Provider Fallback Logic', () => {
    it('should fallback from Gemini to OpenAI on quota error', async () => {
      // Mock Gemini quota error
      mockGemini.generateContent.mockRejectedValueOnce(
        new Error('Quota exceeded for this API')
      );

      // Mock successful OpenAI response
      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['Fallback from OpenAI'],
              content: 'Content generated by OpenAI fallback',
              photoInstructions: {
                lighting: 'ambient',
                cameraAngle: 'low',
                composition: 'dynamic',
                styling: 'trendy',
                mood: 'energetic',
                technicalSettings: 'balanced'
              }
            })
          }
        }]
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'bold' } },
        platform: 'tiktok',
        allowsPromotion: 'no'
      });

      expect(result).toBeDefined();
      expect(result.titles).toEqual(['Fallback from OpenAI']);
      expect(result.provider).toBe('openai-gpt4o');
      expect(mockGemini.generateContent).toHaveBeenCalled();
      expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    });

    it('should fallback through all providers on consecutive failures', async () => {
      // Mock failures for all providers
      mockGemini.generateContent.mockRejectedValueOnce(
        new Error('Gemini service unavailable')
      );
      
      mockAnthropic.messages.create.mockRejectedValueOnce(
        new Error('Claude rate limit exceeded')
      );
      
      mockOpenAI.chat.completions.create.mockRejectedValueOnce(
        new Error('OpenAI API error')
      );

      await expect(generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'mysterious' } },
        platform: 'reddit',
        allowsPromotion: 'yes'
      })).rejects.toThrow();

      expect(mockGemini.generateContent).toHaveBeenCalled();
      expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    });
  });

  describe('Error Handling Edge Cases', () => {
    it('should handle malformed JSON responses', async () => {
      mockGemini.generateContent.mockResolvedValueOnce({
        response: {
          text: () => 'This is not valid JSON'
        }
      });

      // Should fallback to next provider
      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['Recovered from JSON error'],
              content: 'Valid content after JSON parsing error',
              photoInstructions: {
                lighting: 'natural',
                cameraAngle: 'eye-level',
                composition: 'centered',
                styling: 'casual',
                mood: 'relaxed',
                technicalSettings: 'auto'
              }
            })
          }
        }]
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'authentic' } },
        platform: 'instagram',
        allowsPromotion: 'no'
      });

      expect(result).toBeDefined();
      expect(result.titles).toEqual(['Recovered from JSON error']);
    });

    it('should handle network timeout errors', async () => {
      mockGemini.generateContent.mockRejectedValueOnce(
        new Error('Network timeout after 30000ms')
      );

      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['Network recovery success'],
              content: 'Generated after network timeout',
              photoInstructions: {
                lighting: 'soft',
                cameraAngle: 'profile',
                composition: 'minimalist',
                styling: 'elegant',
                mood: 'serene',
                technicalSettings: 'manual'
              }
            })
          }
        }]
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'elegant' } },
        platform: 'onlyfans',
        allowsPromotion: 'yes'
      });

      expect(result).toBeDefined();
      expect(result.provider).toBe('openai-gpt4o');
    });

    it('should handle rate limit errors with exponential backoff simulation', async () => {
      // Mock rate limit error
      mockGemini.generateContent.mockRejectedValueOnce(
        new Error('Rate limit exceeded. Please try again in 60 seconds.')
      );

      // Should move to next provider instead of retrying
      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['Rate limit bypass'],
              content: 'Successfully bypassed rate limit with provider switching',
              photoInstructions: {
                lighting: 'dramatic',
                cameraAngle: 'high',
                composition: 'rule of thirds',
                styling: 'sophisticated',
                mood: 'powerful',
                technicalSettings: 'professional'
              }
            })
          }
        }]
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'confident' } },
        platform: 'twitter',
        allowsPromotion: 'yes'
      });

      expect(result).toBeDefined();
      expect(result.provider).toBe('openai-gpt4o');
    });
  });

  describe('Cost Optimization', () => {
    it('should prioritize cheapest provider (Gemini) when available', async () => {
      mockGemini.generateContent.mockResolvedValueOnce({
        response: {
          text: () => JSON.stringify({
            titles: ['Gemini - cheapest option'],
            content: 'Cost-optimized content generation',
            photoInstructions: {
              lighting: 'budget-friendly natural',
              cameraAngle: 'smartphone-friendly',
              composition: 'simple',
              styling: 'accessible',
              mood: 'authentic',
              technicalSettings: 'basic'
            }
          })
        }
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'casual' } },
        platform: 'reddit',
        allowsPromotion: 'no'
      });

      expect(result).toBeDefined();
      expect(result.provider).toBe('gemini-flash');
      expect(result.estimatedCost).toBeLessThan(1); // Should be very low cost
      
      // Verify OpenAI wasn't called (more expensive)
      expect(mockOpenAI.chat.completions.create).not.toHaveBeenCalled();
    });

    it('should track and report estimated costs accurately', async () => {
      mockOpenAI.chat.completions.create.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              titles: ['OpenAI premium generation'],
              content: 'High-quality but expensive content',
              photoInstructions: {
                lighting: 'professional studio',
                cameraAngle: 'cinematic',
                composition: 'advanced',
                styling: 'premium',
                mood: 'luxurious',
                technicalSettings: 'expert'
              }
            })
          }
        }],
        usage: {
          prompt_tokens: 1000,
          completion_tokens: 500,
          total_tokens: 1500
        }
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'professional' } },
        platform: 'onlyfans',
        allowsPromotion: 'yes'
      });

      expect(result).toBeDefined();
      expect(result.provider).toBe('openai-gpt4o');
      expect(result.estimatedCost).toBeGreaterThan(0);
      expect(typeof result.estimatedCost).toBe('number');
    });
  });

  describe('Platform-Specific Optimizations', () => {
    it('should generate Instagram-optimized content', async () => {
      mockGemini.generateContent.mockResolvedValueOnce({
        response: {
          text: () => JSON.stringify({
            titles: [],
            content: 'Visual storytelling content for Instagram with relevant hashtags',
            photoInstructions: {
              lighting: 'Instagram-friendly bright',
              cameraAngle: 'aesthetic',
              composition: 'grid-ready',
              styling: 'trendy',
              mood: 'aspirational',
              technicalSettings: 'mobile-optimized'
            },
            hashtags: ['#content', '#creator', '#lifestyle']
          })
        }
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'sassy' } },
        platform: 'instagram',
        allowsPromotion: 'yes'
      });

      expect(result).toBeDefined();
      expect(result.content).toContain('hashtags');
      expect(result.photoInstructions.composition).toBe('grid-ready');
    });

    it('should generate Reddit-appropriate content without hashtags', async () => {
      mockGemini.generateContent.mockResolvedValueOnce({
        response: {
          text: () => JSON.stringify({
            titles: ['Reddit community discussion starter'],
            content: 'Authentic discussion content without hashtags, perfect for Reddit communities',
            photoInstructions: {
              lighting: 'natural reddit-friendly',
              cameraAngle: 'genuine',
              composition: 'story-focused',
              styling: 'relatable',
              mood: 'conversational',
              technicalSettings: 'authentic'
            }
          })
        }
      });

      const result = await generateWithMultiProvider({
        user: { personalityProfile: { toneOfVoice: 'authentic' } },
        platform: 'reddit',
        subreddit: 'selfie',
        allowsPromotion: 'no'
      });

      expect(result).toBeDefined();
      expect(result.content).not.toContain('#');
      expect(result.titles[0]).toContain('Reddit');
    });
  });
});