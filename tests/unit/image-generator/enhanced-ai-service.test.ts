import { describe, test, expect, vi, beforeEach } from 'vitest';

// Mock environment variables and dependencies
const mockEnv = {
  OPENAI_API_KEY: '',
  ANTHROPIC_API_KEY: '',
  GOOGLE_GENAI_API_KEY: '',
  GEMINI_API_KEY: '',
};

const mockMultiProvider = {
  generateContent: vi.fn(),
  generateWithMultiProvider: vi.fn(),
};

const mockLogger = vi.hoisted(() => ({ log: vi.fn(), error: vi.fn(), warn: vi.fn() }));

// Mock the dependencies before importing the service  
vi.mock('../../../server/services/multi-ai-provider.ts', () => ({
  generateWithMultiProvider: vi.fn(),
}));
vi.mock('../../../server/lib/logger-utils.js', () => ({ safeLog: vi.fn() }));
vi.mock('../../../server/content-templates.ts', () => ({
  preGeneratedTemplates: [
    {
      id: 'test_001',
      style: 'playful',
      category: 'engagement',
      title: 'Test playful title',
      content: 'Test playful content',
      tags: ['test'],
      photoInstructions: 'Natural lighting'
    }
  ]
}));

// Mock process.env
Object.defineProperty(process, 'env', {
  value: mockEnv,
  writable: true,
});

// Import after mocking
import { enhancedAIGenerator } from '../../../server/services/enhanced-ai-service';
import { generateWithMultiProvider } from '../../../server/services/multi-ai-provider';

describe('Enhanced AI Service - Failure Scenarios', () => {
  let service: typeof enhancedAIGenerator;

  beforeEach(() => {
    vi.clearAllMocks();
    service = enhancedAIGenerator;
    
    // Reset environment variables
    mockEnv.OPENAI_API_KEY = '';
    mockEnv.ANTHROPIC_API_KEY = '';
    mockEnv.GOOGLE_GENAI_API_KEY = '';
    mockEnv.GEMINI_API_KEY = '';
  });

  describe('Environment Variable Validation', () => {
    test('should handle missing all API keys gracefully', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'playful' as const,
        prompt: 'Test prompt',
      };

      vi.mocked(generateWithMultiProvider).mockRejectedValue(
        new Error('No AI providers available')
      );

      const result = await service.generate(request);
      
      // Should fallback to template system
      expect(result).toBeDefined();
      expect(result.titles).toBeDefined();
      expect(result.content).toBeDefined();
    });

    test('should log warning when API keys are missing', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'authentic' as const,
      };

      vi.mocked(generateWithMultiProvider).mockRejectedValue(
        new Error('API key not configured')
      );

      await service.generate(request);
      
      expect(generateWithMultiProvider).toHaveBeenCalled();
    });
  });

  describe('AI Provider Failure Handling', () => {
    test('should handle quota exceeded errors', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'confident' as const,
      };

      vi.mocked(generateWithMultiProvider).mockRejectedValue(
        new Error('Quota exceeded for current billing period')
      );

      const result = await service.generate(request);
      
      // Should return template fallback
      expect(result).toBeDefined();
      expect(['gemini-flash', 'templates', 'template-fallback', 'fallback']).toContain(result.metadata?.provider);
    });

    test('should handle network timeout errors', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'bold' as const,
      };

      vi.mocked(generateWithMultiProvider).mockRejectedValue(
        new Error('Network timeout after 30s')
      );

      const result = await service.generate(request);
      
      expect(result).toBeDefined();
      expect(result.titles.length).toBeGreaterThan(0);
    });

    test('should handle malformed JSON responses', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'elegant' as const,
      };

      vi.mocked(generateWithMultiProvider).mockRejectedValue(
        new Error('Invalid JSON in AI response')
      );

      const result = await service.generate(request);
      
      expect(result).toBeDefined();
      expect(result.content).toBeTruthy();
    });
  });

  describe('Success Path Validation', () => {
    test('should handle successful AI generation', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'sassy' as const,
      };

      const mockResponse = {
        titles: ['Test Title 1', 'Test Title 2'],
        content: 'Test content generated by AI',
        photoInstructions: {
          lighting: 'Natural light',
          cameraAngle: 'Eye level',
          composition: 'Rule of thirds',
          styling: 'Casual',
          mood: 'Confident',
          technicalSettings: 'Auto focus',
        },
        provider: 'gemini-flash',
        estimatedCost: 0.02,
      };

      vi.mocked(generateWithMultiProvider).mockResolvedValue(mockResponse);

      const result = await service.generate(request);
      
      // Should return enhanced response with all fields
      expect(result).toBeDefined();
      expect(result.titles).toEqual(['Test Title 1', 'Test Title 2']);
      expect(result.content).toBe('Test content generated by AI');
      expect(result.metadata?.provider).toBe('multi-ai');
    });

    test('should validate required environment variables on startup', () => {
      // Set one API key
      mockEnv.GOOGLE_GENAI_API_KEY = 'test-key';
      
      const newService = enhancedAIGenerator;
      expect(newService).toBeDefined();
      
      // Should not throw even with missing keys due to graceful degradation
    });
  });

  describe('Error Recovery Strategies', () => {
    test('should retry with different providers on failure', async () => {
      const request = {
        mode: 'image' as const,
        platform: 'instagram' as const,
        style: 'mysterious' as const,
        imageBase64: 'data:image/jpeg;base64,test',
      };

      // First call fails, second succeeds
      vi.mocked(generateWithMultiProvider)
        .mockRejectedValueOnce(new Error('Provider 1 failed'))
        .mockResolvedValueOnce({
          titles: ['Fallback Title'],
          content: 'Fallback content',
          photoInstructions: {
            lighting: 'Studio lighting',
            cameraAngle: 'Close-up',
            composition: 'Center frame',
            styling: 'Professional',
            mood: 'Mysterious',
            technicalSettings: 'Manual focus',
          },
          provider: 'template-fallback',
          estimatedCost: 0,
        });

      const result = await service.generate(request);
      
      expect(result).toBeDefined();
      // Template fallback should use the mocked template
      expect(result.titles).toContain('Test playful title');
    });
  });
});