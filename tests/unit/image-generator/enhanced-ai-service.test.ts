import { describe, test, expect, vi, beforeEach } from 'vitest';

// Mock environment variables and dependencies
const mockEnv = {
  OPENAI_API_KEY: '',
  ANTHROPIC_API_KEY: '',
  GOOGLE_GENAI_API_KEY: '',
  GEMINI_API_KEY: '',
};

const mockMultiProvider = {
  generateContent: vi.fn(),
  generateWithMultiProvider: vi.fn(),
};

// Mock logger
const mockLogger = { info: vi.fn(), error: vi.fn() };

// Mock the dependencies before importing the service
vi.mock('../../../server/services/multi-ai-provider.ts', () => ({
  MultiAIProvider: vi.fn(() => mockMultiProvider)
}));
vi.mock('../../../server/lib/logger-utils.js', () => ({ safeLog: mockLogger }));

// Mock process.env
Object.defineProperty(process, 'env', {
  value: mockEnv,
  writable: true,
});

// Import after mocking
import { EnhancedAIService } from '../../../server/services/enhanced-ai-service';

describe('Enhanced AI Service - Failure Scenarios', () => {
  let service: EnhancedAIService;

  beforeEach(() => {
    vi.clearAllMocks();
    service = new EnhancedAIService();
    
    // Reset environment variables
    mockEnv.OPENAI_API_KEY = '';
    mockEnv.ANTHROPIC_API_KEY = '';
    mockEnv.GOOGLE_GENAI_API_KEY = '';
    mockEnv.GEMINI_API_KEY = '';
  });

  describe('Environment Variable Validation', () => {
    test('should handle missing all API keys gracefully', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'playful' as const,
        prompt: 'Test prompt',
      };

      mockMultiProvider.generateWithMultiProvider.mockRejectedValue(
        new Error('No AI providers available')
      );

      const result = await service.generateContent(request);
      
      // Should fallback to template system
      expect(result).toBeDefined();
      expect(result.titles).toBeDefined();
      expect(result.content).toBeDefined();
    });

    test('should log warning when API keys are missing', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'authentic' as const,
      };

      mockMultiProvider.generateWithMultiProvider.mockRejectedValue(
        new Error('API key not configured')
      );

      await service.generateContent(request);
      
      expect(mockMultiProvider.generateWithMultiProvider).toHaveBeenCalled();
    });
  });

  describe('AI Provider Failure Handling', () => {
    test('should handle quota exceeded errors', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'confident' as const,
      };

      mockMultiProvider.generateWithMultiProvider.mockRejectedValue(
        new Error('Quota exceeded for current billing period')
      );

      const result = await service.generateContent(request);
      
      // Should return template fallback
      expect(result).toBeDefined();
      expect(['gemini-flash', 'template', 'template-fallback']).toContain(result.provider);
    });

    test('should handle network timeout errors', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'bold' as const,
      };

      mockMultiProvider.generateWithMultiProvider.mockRejectedValue(
        new Error('Network timeout after 30s')
      );

      const result = await service.generateContent(request);
      
      expect(result).toBeDefined();
      expect(result.titles.length).toBeGreaterThan(0);
    });

    test('should handle malformed JSON responses', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'elegant' as const,
      };

      mockMultiProvider.generateWithMultiProvider.mockRejectedValue(
        new Error('Invalid JSON in AI response')
      );

      const result = await service.generateContent(request);
      
      expect(result).toBeDefined();
      expect(result.content).toBeTruthy();
    });
  });

  describe('Success Path Validation', () => {
    test('should handle successful AI generation', async () => {
      const request = {
        mode: 'text' as const,
        platform: 'reddit' as const,
        style: 'sassy' as const,
      };

      const mockResponse = {
        titles: ['Test Title 1', 'Test Title 2'],
        content: 'Test content generated by AI',
        photoInstructions: {
          lighting: 'Natural light',
          cameraAngle: 'Eye level',
          composition: 'Rule of thirds',
          styling: 'Casual',
          mood: 'Confident',
          technicalSettings: 'Auto focus',
        },
        provider: 'gemini-flash',
        estimatedCost: 0.02,
      };

      mockMultiProvider.generateWithMultiProvider.mockResolvedValue(mockResponse);

      const result = await service.generateContent(request);
      
      expect(result).toEqual({
        ...mockResponse,
        success: true,
      });
    });

    test('should validate required environment variables on startup', () => {
      // Set one API key
      mockEnv.GOOGLE_GENAI_API_KEY = 'test-key';
      
      const newService = new EnhancedAIService();
      expect(newService).toBeDefined();
      
      // Should not throw even with missing keys due to graceful degradation
    });
  });

  describe('Error Recovery Strategies', () => {
    test('should retry with different providers on failure', async () => {
      const request = {
        mode: 'image' as const,
        platform: 'instagram' as const,
        style: 'mysterious' as const,
        imageBase64: 'data:image/jpeg;base64,test',
      };

      // First call fails, second succeeds
      mockMultiProvider.generateWithMultiProvider
        .mockRejectedValueOnce(new Error('Provider 1 failed'))
        .mockResolvedValueOnce({
          titles: ['Fallback Title'],
          content: 'Fallback content',
          photoInstructions: {
            lighting: 'Studio lighting',
            cameraAngle: 'Close-up',
            composition: 'Center frame',
            styling: 'Professional',
            mood: 'Mysterious',
            technicalSettings: 'Manual focus',
          },
          provider: 'template-fallback',
          estimatedCost: 0,
        });

      const result = await service.generateContent(request);
      
      expect(result).toBeDefined();
      expect(result.titles).toContain('Fallback Title');
    });
  });
});