import { createApiRequestContext, expect, test } from '@playwright/test';
import { getE2EEnvironment } from '../support/env';

interface SignupResponseBody {
  message: string;
  user: {
    id: number;
    username: string | null;
    email: string | null;
    tier?: string | null;
  };
}

interface LoginResponseBody {
  user: {
    id: number;
    username: string | null;
    email: string | null;
    tier?: string | null;
  };
}

interface GenerationResponseBody {
  titles: string[];
  content: string;
  photoInstructions: Record<string, unknown>;
}

interface ScheduleResponseBody {
  success: boolean;
  postJobId: number;
  scheduledAt: string;
}

interface ScheduledPost {
  id: number;
  subreddit: string;
  titleFinal: string;
  bodyFinal: string;
  scheduledAt: string;
}

interface BillingResponseBody {
  paymentUrl: string;
  formData?: {
    plan?: string;
  };
}

interface AdminUserSummary {
  id: number;
  email: string | null;
  username: string | null;
  tier?: string | null;
}

interface AdminStats {
  totalUsers: number;
  freeUsers?: number;
  proUsers?: number;
  revenue?: number;
}

interface ModerationResponse {
  message: string;
  flagId?: number;
}

const env = getE2EEnvironment();

test.describe('Creator full journey', () => {
  test('registers, onboards, schedules content, and passes admin checks', async ({ request }) => {
    const timestamp = Date.now();
    const email = `e2e-${timestamp}@example.com`;
    const password = `P@ssw0rd!${timestamp}`;
    const username = `e2e_user_${timestamp}`;

    await test.step('sign up new account', async () => {
      const response = await request.post('/api/auth/signup', {
        data: { email, password, username },
      });
      expect(response.status()).toBe(201);
      const body = await response.json<SignupResponseBody>();
      expect(body.message).toBeDefined();
      expect(body.user.email).toBe(email);
    });

    await test.step('log in with newly created credentials', async () => {
      const response = await request.post('/api/auth/login', {
        data: { email, password },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<LoginResponseBody>();
      expect(body.user.email).toBe(email);
    });

    await test.step('complete onboarding preferences', async () => {
      const response = await request.put('/api/user/profile', {
        data: {
          toneOfVoice: 'confident',
          contentStyle: 'playful',
          personalBrand: 'automation-e2e',
          contentLength: 'medium',
          includeEmojis: true,
          promotionLevel: 'subtle',
        },
      });
      expect(response.status()).toBe(200);
    });

    let generatedTitle = 'Automated content';

    await test.step('generate AI content', async () => {
      const response = await request.post('/api/generate-content', {
        data: {
          platform: 'reddit',
          style: 'playful',
          theme: 'lingerie',
          allowsPromotion: 'yes',
        },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<GenerationResponseBody>();
      expect(Array.isArray(body.titles)).toBe(true);
      if (body.titles.length > 0) {
        generatedTitle = body.titles[0] ?? generatedTitle;
      }
    });

    let scheduledJobId = 0;

    await test.step('schedule generated content', async () => {
      const scheduleResponse = await request.post('/api/posts/schedule', {
        data: {
          subreddit: 'r/e2e-automation',
          title: generatedTitle,
          body: 'Automated test post generated by E2E suite.',
          scheduledAt: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
        },
      });
      expect(scheduleResponse.status()).toBe(200);
      const body = await scheduleResponse.json<ScheduleResponseBody>();
      expect(body.success).toBe(true);
      scheduledJobId = body.postJobId;
    });

    await test.step('confirm scheduled post appears in queue', async () => {
      const response = await request.get('/api/posts/scheduled');
      expect(response.status()).toBe(200);
      const data = await response.json<ScheduledPost[]>();
      const match = data.find(post => post.id === scheduledJobId);
      expect(match).toBeDefined();
    });

    await test.step('request billing upgrade link', async () => {
      const response = await request.post('/api/billing/payment-link', {
        data: { plan: env.billingPlan },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<BillingResponseBody>();
      expect(body.paymentUrl).toMatch(/^https?:\/\//u);
    });

    await test.step('verify data from admin portal perspective', async () => {
      const adminContext = createApiRequestContext({
        baseURL: env.baseURL,
        defaultHeaders: { 'x-e2e-suite': 'full-journey-admin' },
      });

      try {
        const loginResponse = await adminContext.post('/api/auth/login', {
          data: { email: env.adminEmail, password: env.adminPassword },
        });
        expect(loginResponse.status()).toBe(200);

        const usersResponse = await adminContext.get('/api/admin/users');
        expect(usersResponse.status()).toBe(200);
        const users = await usersResponse.json<AdminUserSummary[]>();
        const createdUser = users.find(user => user.email === email);
        expect(createdUser).toBeDefined();

        const statsResponse = await adminContext.get('/api/admin/stats');
        expect(statsResponse.status()).toBe(200);
        const stats = await statsResponse.json<AdminStats>();
        expect(stats.totalUsers).toBeGreaterThan(0);

        const moderationResponse = await adminContext.post('/api/admin/moderate-content', {
          data: {
            flagId: scheduledJobId,
            action: 'approve',
            reason: 'E2E verification flow',
          },
        });
        expect(moderationResponse.status()).toBe(200);
        const moderationBody = await moderationResponse.json<ModerationResponse>();
        expect(moderationBody.message).toBeDefined();
      } finally {
        await adminContext.dispose();
      }
    });
  });
});