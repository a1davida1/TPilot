server/caption/dedupeVariants.ts
+18-10
@@ -96,55 +96,63 @@ export function dedupeVariantsForRanking(
  }

  // Get contextual fallback data for padding if needed
  const fallbackData = context?.platform
    ? inferFallbackFromFacts({
        platform: context.platform,
        facts: context.facts,
        theme: context.theme,
        context: context.context,
      })
    : null;
  const platform = context?.platform;
  const minHashtags = minimumHashtagCount(platform);
  const inferredHashtags = sanitizeHashtagList(fallbackData?.hashtags, minHashtags);
  const fallbackTags = inferredHashtags.length >= minHashtags
    ? inferredHashtags
    : resolveFallbackHashtags(platform);
  const fallbackAlt =
    typeof fallbackData?.alt === "string" && fallbackData.alt.trim().length >= 20
      ? fallbackData.alt.trim()
      : SAFE_DEFAULT_ALT;
  const fallbackCta =
    typeof fallbackData?.cta === "string" && fallbackData.cta.trim().length >= 2
      ? fallbackData.cta.trim()
      : HUMAN_CTA;
  const base = uniques[0] ?? duplicates[0] ?? {
    caption: SAFE_DEFAULT_CAPTION,
    alt: fallbackAlt,
    hashtags: [...fallbackTags],
    cta: fallbackCta,
    mood: "engaging",
    style: "authentic",
    safety_level: "normal",
    nsfw: false,
  } as CaptionVariant;
  const baseSource = uniques[0] ?? duplicates[0];
  const base: CaptionVariant = baseSource
    ? {
        ...baseSource,
        alt: fallbackAlt,
        hashtags: [...fallbackTags],
        cta: fallbackCta,
      }
    : {
        caption: SAFE_DEFAULT_CAPTION,
        alt: fallbackAlt,
        hashtags: [...fallbackTags],
        cta: fallbackCta,
        mood: "engaging",
        style: "authentic",
        safety_level: "normal",
        nsfw: false,
      };

  while (uniques.length < targetLength) {
    const source = duplicates.shift() ?? base;
    const index = uniques.length + 1;
    const freshCaption = buildFreshCaption(source.caption, index);
    uniques.push({
      ...source,
      caption: freshCaption,
      hashtags: [...fallbackTags],
      cta: fallbackCta,
      alt: fallbackAlt,
    });
  }

  if (uniques.length > targetLength) {
    uniques.length = targetLength;
  }

  return uniques;
}
server/caption/geminiPipeline.ts
+12-11
@@ -37,54 +37,53 @@ interface CaptionResult {
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

// Text model interfaces for type safety
interface TextModelFunction {
  (prompt: Array<{ text: string }>): Promise<unknown>;
}

interface TextModelObject {
  generateContent(prompt: Array<{ text: string }>): Promise<unknown>;
}

interface GeminiResponse {
  response?: {
    text(): string;
  };
}

const MAX_VARIANT_ATTEMPTS = 4;
const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 4;
const CAPTION_KEY_LENGTH = 80;

const safeFallbackCaption = "Check out this amazing content!";
const safeFallbackCaption = "Sharing something I'm proud of today.";
const safeFallbackAlt = "Detailed alt text describing the scene.";
const safeFallbackHashtags = ["#content", "#creative", "#amazing"];
const safeFallbackCta = "Check it out";
const safeFallbackCta = HUMAN_CTA;

function captionKey(caption: string): string {
  return caption.trim().slice(0, 80).toLowerCase();
}

function hintSnippet(caption: string): string {
  const normalized = caption.trim().replace(/\s+/g, " ");
  return normalized.length > 60 ? `${normalized.slice(0, 57)}…` : normalized;
}

function uniqueCaptionKey(caption: string): string {
  return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
}

function truncateForHint(caption: string): string {
  const trimmed = caption.trim();
  if (trimmed.length <= 60) {
    return trimmed;
  }
  return `${trimmed.slice(0, 57)}...`;
}

function buildRetryHint(
  baseHint: string | undefined,
  duplicates: string[],
@@ -389,74 +388,75 @@ type GeminiVariantParams = {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};

export async function generateVariants(params: GeminiVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
      : "Sharing something I'm proud of today.";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
      : "authentic";
    variant.cta = typeof variant.cta === "string" && variant.cta.trim().length >= 2
      ? variant.cta
      : "Check it out";
      : HUMAN_CTA;

    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
      : "Engaging description that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];
    const fallbackTags = fallbackHashtags(params.platform);
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : [...fallbackTags];

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);

    lines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
        `Avoid repeating or lightly editing these captions: ${existingCaptions.join(" | ")}.`
@@ -503,54 +503,54 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Engaging social media content",
      caption: "Sharing a highlight from today",
      alt: "Detailed alt text describing the scene",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      hashtags: fallbackHashtags(params.platform),
      cta: HUMAN_CTA,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
  }

  return CaptionArray.parse(uniqueVariants);
}

function normalizeGeminiFinal(
  final: Record<string, unknown>,
  platform?: string,
  facts?: Record<string, unknown>
){
  final.safety_level = normalizeSafetyLevel(
@@ -631,55 +631,56 @@ function truncateReason(reason: string, maxLength = 100): string {
async function requestGeminiRanking(
  variantsInput: z.infer<typeof CaptionArray>,
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string,
  facts?: Record<string, unknown>
): Promise<unknown> {
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res = await invokeTextModel([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Gemini textModel invocation failed:', error);
    throw error;
  }
  let json = stripToJSON(
    (res as GeminiResponse)?.response?.text
      ? (res as GeminiResponse).response.text()
      : typeof res === 'string'
        ? res
        : JSON.stringify(res)
  ) as unknown;


  const defaultHashtags = fallbackHashtags(platform);
  const defaultVariant = variantsInput[0] ??
    CaptionItem.parse({
      caption: safeFallbackCaption,
      alt: safeFallbackAlt,
      hashtags: [...safeFallbackHashtags],
      hashtags: [...defaultHashtags],
      cta: safeFallbackCta,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false,
    });
  const defaultScores = [5, 4, 3, 2, 1];

  if(Array.isArray(json)) {
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [...defaultScores],
      reason: "Selected based on engagement potential",
      final: winner ?? { ...defaultVariant }
    };
  }


  if (json && typeof json === "object" && !Array.isArray(json)) {
    const container = json as Record<string, unknown>;

    const rawWinner = container.winner_index;
    const normalizedWinner =
      typeof rawWinner === "number" && Number.isFinite(rawWinner)
server/caption/textOnlyPipeline.ts
+8-7
@@ -181,74 +181,75 @@ type TextOnlyVariantParams = {
  voice:string;
  theme:string;
  context?:string;
  hint?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

export async function generateVariantsTextOnly(params: TextOnlyVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants_textonly.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
      : "Sharing something I'm proud of today.";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
      : "authentic";
    variant.cta = typeof variant.cta === "string" && variant.cta.trim().length >= 2
      ? variant.cta
      : "Check it out";
      : HUMAN_CTA;

    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
      : "Engaging description that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];
    const fallbackTags = fallbackHashtags(params.platform);
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : [...fallbackTags];

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      `THEME: ${serializePromptField(params.theme)}`,
      `CONTEXT: ${serializePromptField(params.context || "")}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);

    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
@@ -295,54 +296,54 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Text-only social media content",
      caption: "Sharing a highlight from today",
      alt: "Detailed alt text describing the theme",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      hashtags: fallbackHashtags(params.platform),
      cta: HUMAN_CTA,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
  }

  return CaptionArray.parse(uniqueVariants);
}

async function requestTextOnlyRanking(
  variantsInput: unknown[],
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
tests/routes/caption-generation.test.ts
+76-88
import { describe, it, expect, beforeEach, vi, type Mock } from 'vitest';
import { pipeline } from '../../server/caption/geminiPipeline.js';
import { fallbackHashtags } from '../../server/caption/rankGuards.js';
import { BANNED_WORDS_HINT } from '../../server/caption/bannedWords.js';
import { pipelineRewrite, extractKeyEntities } from '../../server/caption/rewritePipeline.js';
import { pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';

// Mock dependencies
vi.mock('../../server/lib/gemini.js', () => ({
  textModel: {
    generateContent: vi.fn(),
  },
  visionModel: {
    generateContent: vi.fn(),
  },
}));

import { CaptionItem } from '../../server/caption/schema.js';

vi.mock('../../server/caption/openaiFallback.js', () => ({
  openAICaptionFallback: vi.fn().mockResolvedValue({
    caption: 'Fallback caption',
    hashtags: ['#fallback1', '#fallback2', '#fallback3'],
    safety_level: 'normal',
    alt: 'Fallback alt text that is sufficiently long',
    mood: 'neutral',
    style: 'informative',
    cta: 'Check this out',
    nsfw: false,
@@ -135,50 +137,56 @@ describe('Caption Generation', () => {
          safety_level: 'spicy_safe',
          mood: 'confident',
          style: 'dramatic',
          cta: 'Drop your favorite night-out emoji',
          alt: 'Alt text describing a model in velvet attire with playful lighting.',
          nsfw: false,
        },
        {
          caption: 'Neon-lit nights and satin strides',
          hashtags: ['#neon', '#satin', '#nightout'],
          safety_level: 'normal',
          mood: 'energized',
          style: 'modern',
          cta: 'Tell me your go-to city soundtrack',
          alt: 'Alt text highlighting neon reflections on satin fabrics downtown.',
          nsfw: false,
        },
      ];

      const mockVariantsResponse = {
        response: {
          text: () => JSON.stringify(variantPayload),
        },
      };

      const emptyVariantResponse = {
        response: {
          text: () => JSON.stringify([]),
        },
      };

      const mockRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected based on engagement potential',
              final: variantPayload[0],
            }),
        },
      };

      const retryVariantPayload = variantPayload.map((variant, index) => ({
        ...variant,
        caption: `${variant.caption} (retry ${index + 1})`,
        alt: `${variant.alt} Retry sequence ${index + 1}.`,
      }));

      const retryVariantsResponse = {
        response: {
          text: () => JSON.stringify(retryVariantPayload),
        },
      };

      const retryRankResponse = {
@@ -233,184 +241,164 @@ describe('Caption Generation', () => {
        if (responseQueue.length === 0) {
          responseQueue.push(finalVariantsResponse, finalRankResponse);
        }
        const next = responseQueue.shift();
        if (!next) {
          throw new Error('Gemini variants unavailable');
        }
        return Promise.resolve(next as Awaited<ReturnType<(typeof textModel)['generateContent']>>);
      });

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');

      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(result.final).toMatchObject({
        caption: expect.any(String) as string,
        safety_level: expect.stringMatching(/safe|low|spicy_safe|normal/),
      });
    });

    it('should fallback to safe defaults when Gemini returns variants with missing hashtags', async () => {
    it('pads variants missing hashtags with safe fallbacks', async () => {
      const mockImageUrl =
        'data:image/jpeg;base64,' +
        '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAAAAAAAAAAAAAAAAAACP/EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAD8Af//Z';
      const mockPlatform = 'instagram';
      const mockVoice = 'flirty_playful';
      const expectedHashtags = fallbackHashtags(mockPlatform);
      const minimumHashtags = 3;

      // Mock successful facts response
      const mockFactsResponse = {
        response: {
          text: () => JSON.stringify({
            objects: ['lingerie'],
            setting: 'bedroom',
            mood: 'confident',
            objects: ['camera'],
            setting: 'studio',
          }),
        },
      };

      // Mock variants response with missing hashtags (empty array)
      const variantPayload = [
        {
          caption: 'Camera ready confidence in the studio lights.',
          hashtags: [],
          safety_level: 'normal',
          mood: 'confident',
          style: 'authentic',
          cta: '',
          alt: 'Alt text describing a camera-ready pose under studio lighting with polished styling.',
          nsfw: false,
        },
        {
          caption: 'Studio glow with the lens focused on every detail.',
          safety_level: 'normal',
          mood: 'confident',
          style: 'authentic',
          cta: 'Join the moment',
          alt: 'Alt text capturing a confident pose beside the studio camera setup and lighting.',
          nsfw: false,
        },
        {
          caption: 'Lens flare and quiet focus before the shutter clicks.',
          hashtags: [],
          safety_level: 'normal',
          mood: 'calm',
          style: 'authentic',
          cta: 'Share your take',
          alt: 'Alt text describing a calm studio moment with the camera focused on the subject.',
          nsfw: false,
        },
      ];

      const mockVariantsResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Feeling gorgeous tonight ✨',
              hashtags: [], // Empty hashtags should trigger fallback
              safety_level: 'spicy_safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'What do you think?',
              alt: 'A glamorous example alt text to satisfy schema',
              nsfw: false,
            },
            {
              caption: 'Another amazing look',
              hashtags: [], // Empty hashtags should trigger fallback
              safety_level: 'safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'Love this look!',
              alt: 'Another example alt text that meets requirements',
              nsfw: false,
            },
            {
              caption: 'Third variant caption',
              // hashtags field completely missing
              safety_level: 'safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'Check it out',
              alt: 'Third alt text example that is long enough',
              nsfw: false,
            },
            {
              caption: 'Fourth variant here',
              hashtags: [], // Empty again
              safety_level: 'safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'See more',
              alt: 'Fourth alt text example with sufficient length',
              nsfw: false,
            },
            {
              caption: 'Fifth and final variant',
              hashtags: [], // Empty again
              safety_level: 'safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'Discover more',
              alt: 'Fifth alt text example that meets all criteria',
              nsfw: false,
            },
          ]),
          text: () => JSON.stringify(variantPayload),
        },
      };

      const emptyVariantResponse = {
        response: {
          text: () => JSON.stringify([]),
        },
      };

      const mockRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected variant with safe fallback hashtags',
              reason: 'Initial selection',
              final: {
                caption: 'Feeling gorgeous tonight ✨',
                hashtags: ['#thoughts'], // Should be populated by fallback
                safety_level: 'spicy_safe',
                caption: variantPayload[0].caption,
                hashtags: [],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'What do you think?',
                alt: 'A glamorous example alt text to satisfy schema',
                cta: '',
                alt: variantPayload[0].alt,
                nsfw: false,
              },
            }),
        },
      };

      const { textModel, visionModel } = await import('../../server/lib/gemini.js');
      const visionGenerateMock = asMock(visionModel.generateContent);
      visionGenerateMock.mockResolvedValueOnce(mockFactsResponse);
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock.mockRejectedValueOnce(new Error('Gemini variants unavailable'));
      textGenerateMock
        .mockResolvedValueOnce(mockVariantsResponse)
        .mockResolvedValueOnce(emptyVariantResponse)
        .mockResolvedValueOnce(mockRankResponse);

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');

      // When Gemini returns variants with missing or empty hashtags, 
      // the pipeline should fall back to OpenAI which provides safe defaults
      expect(openAICaptionFallback).toHaveBeenCalledWith({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });
      
      // Verify the result has the expected structure from OpenAI fallback
      expect(result.final).toMatchObject({
        caption: 'Fallback caption',
        hashtags: ['#fallback1', '#fallback2', '#fallback3'],
        safety_level: 'normal',
        alt: 'Fallback alt text that is sufficiently long',
        mood: 'neutral',
        style: 'informative',
        cta: 'Check this out',
        nsfw: false,
      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(result.variants).toHaveLength(5);
      expect(result.ranked?.reason).toBeDefined();
      expect(result.ranked?.reason ?? '').not.toContain(BANNED_WORDS_HINT);

      result.variants.forEach((variant) => {
        expect(Array.isArray(variant.hashtags)).toBe(true);
        expect(variant.hashtags.length).toBeGreaterThanOrEqual(minimumHashtags);
        variant.hashtags.forEach((tag) => {
          expect(tag.toLowerCase()).not.toContain('content');
        });
      });
      
      // Verify the fallback hashtags don't contain banned words
      const fallbackHashtags = ['#fallback1', '#fallback2', '#fallback3'];
      fallbackHashtags.forEach((tag) => {

      expect(result.final.hashtags.length).toBeGreaterThanOrEqual(minimumHashtags);
      result.final.hashtags.forEach((tag) => {
        expect(tag.toLowerCase()).not.toContain('content');
      });
    });

    it('should handle safety level normalization', async () => {
      const variantPayload = [
        {
          caption: 'Test caption',
          hashtags: ['#test'],
          safety_level: 'spicy_safe', // Should be normalized to spicy_safe
          mood: 'confident',
          style: 'authentic',
          cta: 'Check it out',
          alt: 'Alt text showcasing a confident pose with bold styling elements.',
          nsfw: false,
        },
        {
          caption: 'Second caption for safety checks',
          hashtags: ['#second', '#safety'],
          safety_level: 'normal',
          mood: 'relaxed',
          style: 'casual',
          cta: 'Share your vibe',
          alt: 'Alt text outlining a relaxed scene with casual fashion notes.',
          nsfw: false,
