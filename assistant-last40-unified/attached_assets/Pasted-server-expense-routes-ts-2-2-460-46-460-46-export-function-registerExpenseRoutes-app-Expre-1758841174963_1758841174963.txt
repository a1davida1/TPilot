server/expense-routes.ts
+2-2
@@ -460,46 +460,46 @@ export function registerExpenseRoutes(app: Express) {
        // Apply ImageShield protection to receipt
        logger.info(
          `Applying ImageShield protection (${protectionLevel}) to receipt for user ${req.user.id}, tier: ${userTier}`
        );
        receiptBuffer = await applyReceiptImageShieldProtection(
          req.file.buffer,
          protectionLevel as 'light' | 'standard' | 'heavy',
          addWatermark
        );
        desiredFileName = `protected_${safeOriginalName}`;
      }

      let receiptUrl: string;
      let receiptFileName = desiredFileName;

      if (process.env.S3_BUCKET_MEDIA) {
        const asset = await MediaManager.uploadFile(receiptBuffer, {
          userId: req.user.id,
          filename: desiredFileName,
        });
        receiptUrl = asset.downloadUrl || asset.signedUrl || asset.key;
        receiptFileName = asset.filename;
      } else {
        const uploadDir = path.join(process.cwd(), 'uploads', 'receipts');
        await fs.mkdir(uploadDir, { recursive: true });
        const timestampedFileName = `protected_${Date.now()}-${safeOriginalName}`;
        const fileName = timestampedFileName;
        const uniqueSuffix = crypto.randomUUID();
        const fileName = `protected_${uniqueSuffix}-${safeOriginalName}`;
        await fs.writeFile(path.join(uploadDir, fileName), receiptBuffer);
        receiptUrl = `/uploads/receipts/${fileName}`;
        receiptFileName = fileName;
      }

      const expense = await storage.updateExpense(expenseId, req.user.id, {
        receiptUrl,
        receiptFileName,
      });

      const uploadDescriptor = isPdf ? 'PDF receipt stored' : 'Protected receipt uploaded';
      logger.info(`${uploadDescriptor}: ${receiptFileName} for expense ${expenseId}`);
      res.json(expense);
    } catch (error) {
      console.error('Error uploading receipt:', error);
      res.status(500).json({ message: 'Failed to upload receipt' });
    }
  });
}
tests/unit/expenses/receipt-upload.test.ts
+24-15
/* eslint-env node, jest */
import { describe, test, expect, vi, beforeEach, type MockInstance, type Mock } from 'vitest';
import { describe, test, expect, vi, beforeEach, type Mock } from 'vitest';
import request from 'supertest';
import express from 'express';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

// Mock dependencies
const mockStorage = vi.hoisted(() => ({
  getExpense: vi.fn(),
  getExpenseCategory: vi.fn(),
  updateExpense: vi.fn(),
}));

const mockMediaManager = vi.hoisted(() => ({
  uploadFile: vi.fn(),
}));

const mockAuthenticateToken = vi.hoisted(() => vi.fn());

vi.mock('../../../server/storage.ts', () => ({ storage: mockStorage }));
vi.mock('../../../server/lib/media.js', () => ({ MediaManager: mockMediaManager }));
vi.mock('../../../server/middleware/auth.js', () => ({ authenticateToken: mockAuthenticateToken }));
vi.mock('fs/promises', () => ({
  default: {
    mkdir: vi.fn(),
    writeFile: vi.fn(),
  },
  mkdir: vi.fn(),
  writeFile: vi.fn(),
}))
@@ -183,119 +185,126 @@ describe('Receipt Upload with ImageShield Protection', () => {

  describe('PDF receipt handling', () => {
    test('should accept PDF receipts without applying protection', async () => {
      delete process.env.S3_BUCKET_MEDIA;

      const updateCalls: Array<{ receiptUrl: string; receiptFileName: string }> = [];
      mockStorage.updateExpense.mockImplementation(async (_expenseId, _userId, update) => {
        const receiptUrl = update.receiptUrl ?? '';
        const receiptFileName = update.receiptFileName ?? '';
        updateCalls.push({ receiptUrl, receiptFileName });
        return {
          id: 4,
          receiptUrl,
          receiptFileName,
        };
      });

      const pdfBuffer = Buffer.from('%PDF-1.4\n1 0 obj\n<< /Type /Catalog >>\nendobj\ntrailer\n<< /Root 1 0 R >>\n%%EOF');

      const response = await request(app)
        .post('/api/expenses/4/receipt')
        .attach('receipt', pdfBuffer, { filename: 'invoice.pdf', contentType: 'application/pdf' })
        .expect(200);

      expect(mockMediaManager.uploadFile).not.toHaveBeenCalled();
      const protectedPdfPattern = /\/uploads\/receipts\/protected_[0-9a-f-]+-invoice\.pdf$/u;
      const protectedPdfFilePattern = /^protected_[0-9a-f-]+-invoice\.pdf$/u;

      expect(mockStorage.updateExpense).toHaveBeenCalledWith(
        4,
        1,
        expect.objectContaining({
          receiptUrl: expect.stringMatching(/\/uploads\/receipts\/protected_\d+-invoice\.pdf$/u),
          receiptFileName: expect.stringMatching(/^protected_\d+-invoice\.pdf$/u),
          receiptUrl: expect.stringMatching(protectedPdfPattern),
          receiptFileName: expect.stringMatching(protectedPdfFilePattern),
        })
      );

      expect(response.body.receiptFileName).toMatch(/^protected_\d+-invoice\.pdf$/u);
      expect(response.body.receiptUrl).toMatch(/\/uploads\/receipts\/protected_\d+-invoice\.pdf$/u);
      expect(response.body.receiptFileName).toMatch(protectedPdfFilePattern);
      expect(response.body.receiptUrl).toMatch(protectedPdfPattern);

      const firstUpdate = updateCalls[0];
      expect(firstUpdate).toBeDefined();
      if (!firstUpdate) {
        throw new Error('Expected updateExpense to be called with receipt metadata.');
      }

      expect(firstUpdate.receiptFileName).toMatch(/^protected_\d+-invoice\.pdf$/u);
      expect(firstUpdate.receiptUrl).toMatch(/\/uploads\/receipts\/protected_\d+-invoice\.pdf$/u);
      expect(firstUpdate.receiptFileName).toMatch(protectedPdfFilePattern);
      expect(firstUpdate.receiptUrl).toMatch(protectedPdfPattern);

      const writeMock = fs.writeFile as unknown as Mock;
      expect(writeMock).toHaveBeenCalledWith(expect.stringMatching(/protected_\d+-invoice\.pdf$/u), expect.any(Buffer) as Buffer);
      expect(writeMock).toHaveBeenCalledWith(
        expect.stringMatching(/protected_[0-9a-f-]+-invoice\.pdf$/u),
        expect.any(Buffer) as Buffer,
      );
      const firstCall = writeMock.mock.calls[0];
      expect(firstCall).toBeDefined();
      const [writtenPath, storedBuffer] = firstCall;
      expect(typeof writtenPath).toBe('string');
      expect(writtenPath).toMatch(/protected_\d+-invoice\.pdf$/u);
      expect(path.basename(writtenPath)).toMatch(protectedPdfFilePattern);
      expect(Buffer.isBuffer(storedBuffer)).toBe(true);
      expect(storedBuffer.equals(pdfBuffer)).toBe(true);
    });

    test('should generate unique filenames for successive local PDF uploads', async () => {
      delete process.env.S3_BUCKET_MEDIA;

      const pdfBuffer = Buffer.from('%PDF-1.4\n1 0 obj\n<< /Type /Catalog >>\nendobj\ntrailer\n<< /Root 1 0 R >>\n%%EOF');

      const storedFileNames: string[] = [];
      mockStorage.updateExpense.mockImplementation(async (_expenseId, _userId, update) => {
        const receiptFileName = update.receiptFileName ?? '';
        storedFileNames.push(receiptFileName);
        return {
          id: storedFileNames.length,
          receiptUrl: update.receiptUrl ?? '',
          receiptFileName,
        };
      });

      const nowSpy = vi.spyOn(Date, 'now');
      let callIndex = 0;
      nowSpy.mockImplementation(() => 1700000000000 + callIndex++ * 1000);
      const uuidSpy = vi.spyOn(crypto, 'randomUUID');
      uuidSpy
        .mockImplementationOnce(() => '11111111-1111-1111-1111-111111111111')
        .mockImplementationOnce(() => '22222222-2222-2222-2222-222222222222');

      try {
        await request(app)
          .post('/api/expenses/6/receipt')
          .attach('receipt', pdfBuffer, { filename: 'invoice.pdf', contentType: 'application/pdf' })
          .expect(200);

        await request(app)
          .post('/api/expenses/7/receipt')
          .attach('receipt', pdfBuffer, { filename: 'invoice.pdf', contentType: 'application/pdf' })
          .expect(200);
      } finally {
        nowSpy.mockRestore();
        uuidSpy.mockRestore();
      }

      expect(storedFileNames).toHaveLength(2);
      expect(storedFileNames[0]).toMatch(/^protected_\d+-invoice\.pdf$/u);
      expect(storedFileNames[1]).toMatch(/^protected_\d+-invoice\.pdf$/u);
      expect(storedFileNames[0]).toBe('protected_11111111-1111-1111-1111-111111111111-invoice.pdf');
      expect(storedFileNames[1]).toBe('protected_22222222-2222-2222-2222-222222222222-invoice.pdf');
      expect(new Set(storedFileNames).size).toBe(2);

      const writeMock = fs.writeFile as unknown as Mock;
      expect(writeMock).toHaveBeenCalledTimes(2);
      const firstPath = writeMock.mock.calls[0]?.[0];
      const secondPath = writeMock.mock.calls[1]?.[0];
      expect(typeof firstPath).toBe('string');
      expect(typeof secondPath).toBe('string');
      expect(firstPath).toContain(storedFileNames[0]);
      expect(secondPath).toContain(storedFileNames[1]);
      expect(firstPath).not.toBe(secondPath);
    });

    test('should retain original filename when uploading to S3', async () => {
      process.env.S3_BUCKET_MEDIA = 'test-bucket';

      const mockAsset = {
        downloadUrl: 'https://s3.amazonaws.com/test-bucket/invoice.pdf',
        filename: 'invoice.pdf',
        key: 'receipts/invoice.pdf',
      };

      mockMediaManager.uploadFile.mockResolvedValue(mockAsset);
      mockStorage.updateExpense.mockResolvedValue({
        id: 5,
