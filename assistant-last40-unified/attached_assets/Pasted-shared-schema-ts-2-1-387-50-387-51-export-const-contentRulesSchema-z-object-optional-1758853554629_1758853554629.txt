shared/schema.ts
+2-1
@@ -387,50 +387,51 @@ export const contentRulesSchema = z.object({
}).optional();

export const postingRulesSchema = z.object({
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional(),
}).optional();

// New structured rule schema
export const redditCommunityRuleSetSchema = z.object({
  eligibility: eligibilityRulesSchema,
  content: contentRulesSchema,
  posting: postingRulesSchema,
  notes: z.string().nullable().optional(),
}).optional();

// Legacy schema for backwards compatibility
export const legacyRedditCommunityRuleSetSchema = z.object({
  minKarma: z.number().nullable().optional(),
  minAccountAge: z.number().nullable().optional(), // in days (legacy)
  minAccountAgeDays: z.number().nullable().optional(), // in days (new)
  watermarksAllowed: z.boolean().nullable().optional(),
  sellingAllowed: redditCommunitySellingPolicySchema.optional(),
  promotionalLinksAllowed: ruleAllowanceSchema.optional(),
  titleRules: z.array(z.string()).optional().default([]),
  contentRules: z.array(z.string()).optional().default([]),
  linkRestrictions: z.array(z.string()).optional().default([]),
  bannedContent: z.array(z.string()).optional().default([]),
  formattingRequirements: z.array(z.string()).optional().default([]),
  notes: z.string().optional(),
  verificationRequired: z.boolean().optional(),
  requiresApproval: z.boolean().optional(),
  requiresOriginalContent: z.boolean().optional(),
  nsfwRequired: z.boolean().optional(),
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional()
}).optional();

export type RedditCommunityRuleSet = z.infer<typeof redditCommunityRuleSetSchema>;
export type EligibilityRules = z.infer<typeof eligibilityRulesSchema>;
export type ContentRules = z.infer<typeof contentRulesSchema>;
export type PostingRules = z.infer<typeof postingRulesSchema>;
export type LegacyRedditCommunityRuleSet = z.infer<typeof legacyRedditCommunityRuleSetSchema>;

// Posting limits schema
export const postingLimitsSchema = z.object({
  perDay: z.number().nullable().optional(),
  perWeek: z.number().nullable().optional(),
  daily: z.number().nullable().optional(), // legacy support
  weekly: z.number().nullable().optional(), // legacy support
  cooldownHours: z.number().nullable().optional()
}).nullable().optional();
@@ -535,51 +536,51 @@ export const redditCommunities = pgTable("reddit_communities", {
  competitionLevel: varchar("competition_level", { length: 20 })
});
export type RedditCommunity = typeof redditCommunities.$inferSelect;
export type InsertRedditCommunity = typeof redditCommunities.$inferInsert;
export const insertRedditCommunitySchema = createInsertSchema(redditCommunities);

// Helper function to normalize legacy rules to structured rules
export const normalizeRulesToStructured = (legacyRules: LegacyRedditCommunityRuleSet | null | undefined): RedditCommunityRuleSet | null => {
  if (!legacyRules) return null;

  return {
    eligibility: {
      minKarma: legacyRules.minKarma ?? null,
      minAccountAgeDays: legacyRules.minAccountAgeDays ?? legacyRules.minAccountAge ?? null,
      verificationRequired: legacyRules.verificationRequired ?? false,
      requiresApproval: legacyRules.requiresApproval ?? false,
    },
    content: {
      sellingPolicy: legacyRules.sellingAllowed,
      watermarksAllowed: legacyRules.watermarksAllowed ?? null,
      promotionalLinks: legacyRules.promotionalLinksAllowed ?? null,
      requiresOriginalContent: legacyRules.requiresOriginalContent ?? false,
      nsfwRequired: legacyRules.nsfwRequired ?? false,
      titleGuidelines: legacyRules.titleRules ?? [],
      contentGuidelines: legacyRules.contentRules ?? [],
      linkRestrictions: [],
      linkRestrictions: legacyRules.linkRestrictions ?? [],
      bannedContent: legacyRules.bannedContent ?? [],
      formattingRequirements: legacyRules.formattingRequirements ?? [],
    },
    posting: {
      maxPostsPerDay: legacyRules.maxPostsPerDay ?? null,
      cooldownHours: legacyRules.cooldownHours ?? null,
    },
    notes: legacyRules.notes ?? null,
  };
};

// Helper function to infer selling policy from rules
export const inferSellingPolicyFromRules = (rules: RedditCommunityRuleSet | null): RedditCommunitySellingPolicy => {
  if (!rules?.content?.sellingPolicy) return 'unknown';
  return rules.content.sellingPolicy;
};

export const subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).unique().notNull(),
  status: varchar("status", { length: 20 }).notNull(), // "active" | "past_due" | "canceled"
  plan: varchar("plan", { length: 20 }).notNull(), // "free" | "pro"
  priceCents: integer("price_cents").notNull(),
  processor: varchar("processor", { length: 20 }).notNull(), // "ccbill" | "segpay" | "epoch" | "crypto"
  processorSubId: varchar("processor_sub_id", { length: 255 }),
tests/unit/normalize-rules.test.ts
New
+17-0
import { describe, it, expect } from 'vitest';
import { normalizeRulesToStructured, type LegacyRedditCommunityRuleSet } from '@shared/schema';

describe('normalizeRulesToStructured', () => {
  it('preserves legacy link restrictions when present', () => {
    const legacyRules: NonNullable<LegacyRedditCommunityRuleSet> = {
      linkRestrictions: ['no shortened urls', 'no affiliate links']
    };

    const normalized = normalizeRulesToStructured(legacyRules);

    expect(normalized?.content.linkRestrictions).toEqual([
      'no shortened urls',
      'no affiliate links'
    ]);
  });
});
