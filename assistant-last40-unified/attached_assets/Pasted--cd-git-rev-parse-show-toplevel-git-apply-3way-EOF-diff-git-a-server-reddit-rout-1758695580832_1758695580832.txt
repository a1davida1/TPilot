 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/reddit-routes.ts b/server/reddit-routes.ts
index 874a606285d2e0dbd7e45af739bd67109ef2dd16..79c5f5df622c3983071d7150366c976dd71785a7 100644
--- a/server/reddit-routes.ts
+++ b/server/reddit-routes.ts
@@ -1,45 +1,45 @@
 import type { Express } from 'express';
 import crypto from 'crypto';
-import { RedditManager, getRedditAuthUrl, exchangeRedditCode } from './lib/reddit.js';
+import { RedditManager, getRedditAuthUrl, exchangeRedditCode, type RedditPostResult } from './lib/reddit.js';
 import { SafetyManager } from './lib/safety-systems.js';
 import { db } from './db.js';
 import { creatorAccounts, type ShadowbanCheckApiResponse } from '@shared/schema';
 import { eq, and } from 'drizzle-orm';
 import { authenticateToken, type AuthRequest } from './middleware/auth.js';
 import { stateStore, encrypt, decrypt, rateLimit } from './services/state-store.js';
 import {
   listCommunities,
   searchCommunities,
   getCommunityInsights,
   createCommunity,
   updateCommunity,
   deleteCommunity
 } from './reddit-communities.js';
 import { getUserRedditCommunityEligibility } from './lib/reddit.js';
 import { logger } from './bootstrap/logger.js';
-import { summarizeRemovalReasons } from './compliance/ruleViolationTracker.js';
+import { recordPostOutcome, summarizeRemovalReasons } from './compliance/ruleViolationTracker.js';
 
 interface RedditProfile {
   username: string;
   karma?: number;
   verified?: boolean;
 }
 
 export function registerRedditRoutes(app: Express) {
   
   // Start Reddit OAuth flow - SECURE VERSION
   app.get('/api/reddit/connect', rateLimit, authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!process.env.REDDIT_CLIENT_ID) {
         return res.status(503).json({ 
           error: 'Reddit integration not configured. Please set REDDIT_CLIENT_ID and other Reddit environment variables.' 
         });
       }
 
       const userId = req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }
 
       // Generate cryptographically secure state
       const state = crypto.randomBytes(32).toString('hex');
diff --git a/server/reddit-routes.ts b/server/reddit-routes.ts
index 874a606285d2e0dbd7e45af739bd67109ef2dd16..79c5f5df622c3983071d7150366c976dd71785a7 100644
--- a/server/reddit-routes.ts
+++ b/server/reddit-routes.ts
@@ -397,81 +397,83 @@ export function registerRedditRoutes(app: Express) {
         }
         
         res.json({ 
           connected: true, 
           profile: {
             username: profile?.username,
             karma: profile?.karma,
             verified: profile?.verified
           }
         });
       } else {
         res.json({
           connected: false,
           profile: null
         });
       }
 
     } catch (error) {
       console.error('Reddit test error:', error);
       res.status(500).json({ error: 'Failed to test Reddit connection' });
     }
   });
 
   // Enhanced submit endpoint with image support
   app.post('/api/reddit/submit', authenticateToken, async (req: AuthRequest, res) => {
+    const userId = req.user?.id;
+    const subreddit = typeof req.body?.subreddit === 'string' ? req.body.subreddit : undefined;
+
     try {
-      const userId = req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }
-      
-      const { subreddit, title, body, url, nsfw, spoiler, postType, imageData } = req.body;
+
+      const { title, body, url, nsfw, spoiler, postType, imageData } = req.body;
 
       if (!subreddit || !title) {
         return res.status(400).json({ error: 'Subreddit and title are required' });
       }
 
       // Get Reddit manager
       const reddit = await RedditManager.forUser(userId);
       if (!reddit) {
         return res.status(404).json({ 
           error: 'No active Reddit account found. Please connect your Reddit account first.' 
         });
       }
 
-      let result;
-      
+      let result: RedditPostResult;
+
       // Handle different post types
       switch (postType || 'text') {
         case 'image':
           // Single image post
           if (!imageData && !url) {
             return res.status(400).json({ error: 'Image data or URL required for image post' });
           }
-          
-          let imageBuffer;
+
+          let imageBuffer: Buffer | undefined;
           if (imageData) {
             // Convert base64 to buffer if needed
             const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
             imageBuffer = Buffer.from(base64Data, 'base64');
           }
           
           result = await reddit.submitImagePost({
             subreddit,
             title,
             imageBuffer,
             imageUrl: url,
             nsfw: nsfw || false,
             spoiler: spoiler || false
           });
           break;
           
         case 'gallery':
           // Multiple images
           if (!req.body.images || !Array.isArray(req.body.images)) {
             return res.status(400).json({ error: 'Images array required for gallery post' });
           }
           
           const typedImages =
             req.body.images as Array<{ url: string; caption?: string }>;
           const images = typedImages.map(img => ({
diff --git a/server/reddit-routes.ts b/server/reddit-routes.ts
index 874a606285d2e0dbd7e45af739bd67109ef2dd16..79c5f5df622c3983071d7150366c976dd71785a7 100644
--- a/server/reddit-routes.ts
+++ b/server/reddit-routes.ts
@@ -494,100 +496,120 @@ export function registerRedditRoutes(app: Express) {
           }
           
           result = await reddit.submitPost({
             subreddit,
             title,
             url,
             nsfw: nsfw || false,
             spoiler: spoiler || false
           });
           break;
           
         case 'text':
         default:
           // Text post
           result = await reddit.submitPost({
             subreddit,
             title,
             body: body || '',
             nsfw: nsfw || false,
             spoiler: spoiler || false
           });
           break;
       }
 
       if (result.success) {
+        recordPostOutcome(userId, subreddit, { status: 'posted' });
         console.log('Reddit post successful:', {
           userId,
           subreddit,
           postType,
           url: result.url
         });
 
         // Record post for rate limiting and duplicate detection
         try {
           await SafetyManager.recordPost(userId.toString(), subreddit);
           await SafetyManager.recordPostForDuplicateDetection(
             userId.toString(), 
             subreddit, 
             title, 
             body || url || ''
           );
           console.log(`Recorded safety signals for user ${userId} in r/${subreddit}`);
         } catch (safetyError) {
           console.error('Failed to record safety signals:', safetyError);
           // Don't fail the request if safety recording fails
         }
         
         res.json({
           success: true,
           postId: result.postId,
           url: result.url,
           message: `Post submitted successfully to r/${subreddit}`,
           warnings: result.decision?.warnings || []
         });
       } else {
+        const decisionReasons = Array.isArray(result.decision?.reasons) ? result.decision?.reasons.filter((value): value is string => typeof value === 'string' && value.trim().length > 0) : [];
+        const removalReason = result.error
+          ?? (typeof result.decision?.reason === 'string' ? result.decision.reason : undefined)
+          ?? decisionReasons[0]
+          ?? 'Reddit posting failed';
+
+        recordPostOutcome(userId, subreddit, {
+          status: 'removed',
+          reason: removalReason,
+        });
         res.status(400).json({
           success: false,
           error: result.error || 'Failed to submit post',
           reason: result.decision?.reason,
           reasons: result.decision?.reasons || [],
           warnings: result.decision?.warnings || [],
           nextAllowedPost: result.decision?.nextAllowedPost,
           rateLimit: {
             postsInLast24h: result.decision?.postsInLast24h || 0,
             maxPostsPer24h: result.decision?.maxPostsPer24h || 3
           }
         });
       }
 
     } catch (error: unknown) {
+      const failureMessage = error instanceof Error
+        ? error.message
+        : 'Failed to submit post to Reddit';
+
+      if (userId && subreddit) {
+        recordPostOutcome(userId, subreddit, {
+          status: 'removed',
+          reason: failureMessage,
+        });
+      }
+
       console.error('Reddit submit error:', error);
       res.status(500).json({
-        error: error instanceof Error
-          ? (error as Error).message
-          : 'Failed to submit post to Reddit'
+        error: failureMessage
       });
     }
   });
 
   // Add new endpoint to check subreddit capabilities
   app.get('/api/reddit/subreddit/:name/capabilities', authenticateToken, async (req: AuthRequest, res) => {
     try {
       const userId = req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       
       const reddit = await RedditManager.forUser(userId);
       if (!reddit) {
         return res.status(404).json({ error: 'No Reddit account connected' });
       }
       
       const capabilities = await reddit.checkSubredditCapabilities(req.params.name);
       res.json(capabilities);
       
     } catch (error) {
       console.error('Error checking subreddit:', error);
       res.status(500).json({ error: 'Failed to check subreddit' });
     }
   });
 
EOF
)