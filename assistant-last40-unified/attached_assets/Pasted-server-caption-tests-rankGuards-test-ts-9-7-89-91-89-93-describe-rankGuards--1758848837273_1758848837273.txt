server/caption/__tests__/rankGuards.test.ts
+9-7
@@ -89,91 +89,93 @@ describe('rankGuards', () => {
      expect(violations).toHaveLength(0);
    });

    it('should detect multiple violation types', () => {
      const caption = createTestCaption({
        caption: "Check out this amazing content! ✨",
        alt: "A photo",
        hashtags: ["#content", "#amazing"],
        cta: "Link in bio!"
      });
      
      const violations = detectVariantViolations(caption);
      expect(violations).toHaveLength(3); // banned_phrase, generic_hashtag, canned_cta
    });
  });

  describe('sanitizeFinalVariant', () => {
    it('should sanitize caption with fallback content', () => {
      const caption = createTestCaption({
        caption: "✨ Amazing content! Check it out! ✨",
        alt: "A photo",
        hashtags: ["#content", "#creative"],
        cta: "Link in bio!"
      });
      
      const sanitized = sanitizeFinalVariant(caption, 'instagram');
      
      const sanitized = sanitizeFinalVariant(caption, { platform: 'instagram' });

      expect(sanitized.caption).not.toContain('✨');
      expect(sanitized.caption).not.toContain('Amazing content');
      expect(sanitized.cta).toBe(HUMAN_CTA);
      expect(sanitized.hashtags).toEqual(fallbackHashtags('instagram'));
      expect(sanitized.cta).not.toBe(HUMAN_CTA);
      expect(sanitized.cta.toLowerCase()).toContain('tap');
      expect(sanitized.hashtags.length).toBeGreaterThan(0);
      expect(sanitized.hashtags.every(tag => typeof tag === 'string' && !tag.toLowerCase().includes('content'))).toBe(true);
    });

    it('should preserve good content unchanged', () => {
      const caption = createTestCaption({
        caption: "Enjoying the peaceful morning in my garden",
        alt: "Person tending to flowers in a sunlit garden",
        hashtags: ["#gardening", "#morninglight"],
        cta: "What's your favorite flower?"
      });
      
      const sanitized = sanitizeFinalVariant(caption, 'instagram');
      const sanitized = sanitizeFinalVariant(caption, { platform: 'instagram' });
      expect(sanitized).toEqual(caption);
    });

    it('should apply platform-specific hashtag limits', () => {
      const caption = createTestCaption({
        caption: "Beautiful day",
        alt: "A photo",
        hashtags: Array(10).fill("#test"), // Too many for X platform
        cta: "Nice!"
      });
      
      const sanitized = sanitizeFinalVariant(caption, 'x');
      const sanitized = sanitizeFinalVariant(caption, { platform: 'x' });
      expect(sanitized.hashtags).toHaveLength(2); // X platform limit
    });

    it('should provide empty hashtags for Reddit', () => {
      const caption = createTestCaption({
        caption: "Beautiful day",
        alt: "A photo", 
        hashtags: ["#test"],
        cta: "Nice!"
      });
      
      const sanitized = sanitizeFinalVariant(caption, 'reddit');
      const sanitized = sanitizeFinalVariant(caption, { platform: 'reddit' });
      expect(sanitized.hashtags).toEqual([]);
    });
  });

  describe('buildRerankHint', () => {
    it('should build rerank hint from violations', () => {
      const violations = [
        { type: 'banned_phrase' as const, field: 'caption' as const, content: '✨ Amazing content!' },
        { type: 'generic_hashtag' as const, field: 'hashtags' as const, content: '#content' }
      ];
      
      const hint = buildRerankHint(violations);
      expect(hint).toContain('sparkle emojis');
      expect(hint).toContain('generic hashtags');
      expect(hint).toContain('specific, engaging');
    });

    it('should return empty string for no violations', () => {
      const hint = buildRerankHint([]);
      expect(hint).toBe('');
    });
  });

  describe('formatViolationSummary', () => {
    it('should format violation summary', () => {
server/caption/geminiPipeline.ts
+51-21
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";
import { extractToneOptions, ToneOptions } from "./toneOptions";
import { buildVoiceGuideBlock } from "./stylePack";
import { serializePromptField } from "./promptUtils";
import { formatVoiceContext } from "./voiceTraits";
import { ensureFactCoverage } from "./ensureFactCoverage";
import { inferFallbackFromFacts, ensureFallbackCompliance } from "./inferFallbackFromFacts";
import type { Platform } from "./inferFallbackFromFacts";
import { dedupeVariantsForRanking } from "./dedupeVariants";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
@@ -398,65 +399,73 @@ type GeminiVariantParams = {
export async function generateVariants(params: GeminiVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
      : "authentic";
    variant.cta = typeof variant.cta === "string" && variant.cta.trim().length >= 2
      ? variant.cta
      : "Check it out";

    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
    const normalizedHashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];
      : undefined;

    const fallback = ensureFallbackCompliance(
      {
        caption,
        hashtags: normalizedHashtags,
        cta: typeof variant.cta === "string" ? variant.cta : undefined,
        alt: typeof variant.alt === "string" ? variant.alt : undefined,
      },
      {
        platform: params.platform,
        facts: params.facts,
        existingCaption: caption,
      }
    );

    variant.cta = fallback.cta;
    variant.alt = fallback.alt;
    variant.hashtags = fallback.hashtags.slice(0, 10);

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);

    lines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
        `Avoid repeating or lightly editing these captions: ${existingCaptions.join(" | ")}.`
@@ -501,56 +510,62 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
        })();

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  const paddingFallback = inferFallbackFromFacts({
    platform: params.platform,
    facts: params.facts,
    existingCaption: uniqueVariants[0]?.caption,
  });

  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Engaging social media content",
      alt: "Detailed alt text describing the scene",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      caption: safeFallbackCaption,
      alt: paddingFallback.alt,
      hashtags: paddingFallback.hashtags,
      cta: paddingFallback.cta,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
  }

  return CaptionArray.parse(uniqueVariants);
}

function normalizeGeminiFinal(
  final: Record<string, unknown>,
  platform?: string,
  facts?: Record<string, unknown>
){
  final.safety_level = normalizeSafetyLevel(
@@ -631,56 +646,68 @@ function truncateReason(reason: string, maxLength = 100): string {
async function requestGeminiRanking(
  variantsInput: z.infer<typeof CaptionArray>,
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string,
  facts?: Record<string, unknown>
): Promise<unknown> {
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res = await invokeTextModel([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Gemini textModel invocation failed:', error);
    throw error;
  }
  let json = stripToJSON(
    (res as GeminiResponse)?.response?.text
      ? (res as GeminiResponse).response.text()
      : typeof res === 'string'
        ? res
        : JSON.stringify(res)
  ) as unknown;


  const defaultVariant = variantsInput[0] ??
  const firstVariant = variantsInput[0];
  const platformForFallback = platform === "instagram" || platform === "x" || platform === "reddit" || platform === "tiktok"
    ? platform
    : undefined;
  const fallbackContext = platformForFallback
    ? inferFallbackFromFacts({
        platform: platformForFallback,
        facts,
        existingCaption: typeof firstVariant?.caption === "string" ? firstVariant.caption : undefined,
      })
    : undefined;

  const defaultVariant = firstVariant ??
    CaptionItem.parse({
      caption: safeFallbackCaption,
      alt: safeFallbackAlt,
      hashtags: [...safeFallbackHashtags],
      cta: safeFallbackCta,
      alt: fallbackContext?.alt ?? safeFallbackAlt,
      hashtags: fallbackContext?.hashtags ?? [...safeFallbackHashtags],
      cta: fallbackContext?.cta ?? safeFallbackCta,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false,
    });
  const defaultScores = [5, 4, 3, 2, 1];

  if(Array.isArray(json)) {
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [...defaultScores],
      reason: "Selected based on engagement potential",
      final: winner ?? { ...defaultVariant }
    };
  }


  if (json && typeof json === "object" && !Array.isArray(json)) {
    const container = json as Record<string, unknown>;

    const rawWinner = container.winner_index;
    const normalizedWinner =
      typeof rawWinner === "number" && Number.isFinite(rawWinner)
        ? Math.min(Math.max(Math.trunc(rawWinner), 0), defaultScores.length - 1)
@@ -728,51 +755,54 @@ export async function rankAndSelect(
  const serializedVariants = JSON.stringify(variants);

  const first = await requestGeminiRanking(variants, serializedVariants, promptBlock, params?.platform, undefined, params?.facts);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);

  if (violations.length === 0) {
    return parsed;
  }

  const rerank = await requestGeminiRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations),
    params?.facts
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const sanitizedFinal = sanitizeFinalVariant(parsed.final, {
    platform: params?.platform as Platform | undefined,
    facts: params?.facts,
  });
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type GeminiPipelineArgs = {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};

/**
 * Primary image captioning pipeline backed by Gemini vision + text models.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
server/caption/inferFallbackFromFacts.ts
+1-1
import { z } from "zod";

type Platform = "instagram" | "x" | "reddit" | "tiktok";
export type Platform = "instagram" | "x" | "reddit" | "tiktok";

export interface FallbackInferenceInput {
  platform: Platform;
  facts?: Record<string, unknown>;
  existingCaption?: string;
  theme?: string;
  context?: string;
}

export interface FallbackInferenceResult {
  hashtags: string[];
  cta: string;
  alt: string;
}

const PLATFORM_HASHTAG_RULES: Record<Platform, { min: number; max: number; prefix: "#" | ""; filler: string[] }> = {
  instagram: { min: 3, max: 8, prefix: "#", filler: ["creatorspotlight", "dailyvibes", "socialstory", "behindthescenes"] },
  x: { min: 1, max: 3, prefix: "#", filler: ["trendwatch", "nowplaying", "dailyupdate"] },
  reddit: { min: 1, max: 3, prefix: "", filler: ["community insights", "open discussion", "deep dive"] },
  tiktok: { min: 2, max: 5, prefix: "#", filler: ["fypfinds", "mustwatch", "trendalert", "creatorlife"] }
};

const STOPWORDS = new Set([
  "the", "and", "for", "with", "from", "this", "that", "have", "your", "about", "into", "will", "would", "their",
  "there", "been", "were", "just", "like", "over", "make", "made", "after", "before", "while", "where", "which",
server/caption/rankGuards.ts
+69-13
// Ranking guards utilities for detecting and sanitizing sparkle-filler content
import { variantContainsBannedWord, replaceBannedWords, containsBannedWord } from "./bannedWords";
import { CaptionArray } from "./schema";
import { ensureFallbackCompliance } from "./inferFallbackFromFacts";
import type { Platform } from "./inferFallbackFromFacts";
import type { z } from "zod";

type CaptionVariant = z.infer<typeof CaptionArray>[number];

export const HUMAN_CTA = "What do you think?";

const CTA_EDGE_PUNCTUATION = /^[\s\p{P}\p{S}]+|[\s\p{P}\p{S}]+$/gu;

function normalizeCTA(value: string): string {
  return value
    .trim()
    .replace(CTA_EDGE_PUNCTUATION, "")
    .replace(/\s+/g, " ")
    .toLowerCase();
}

// Banned sparkle-filler phrases that should be detected and replaced
const BANNED_PHRASES = [
  /Check out this amazing content/i,
  /✨ Enhanced/i,
  /Amazing content/i,
  /Check it out/i,
  /Click the link/i,
  /Don't miss out/i,
  /You won't believe/i,
@@ -198,105 +200,159 @@ export function buildRerankHint(violations: Violation[]): string {
export function formatViolationSummary(violations: Violation[]): string {
  if (violations.length === 0) return "";

  const summaries: string[] = [];

  for (const violation of violations) {
    switch (violation.type) {
      case "banned_phrase":
        summaries.push("sanitized sparkle emojis and filler caption");
        break;
      case "banned_word":
        summaries.push("removed banned words");
        break;
      case "generic_hashtag":
        summaries.push("replaced generic hashtags");
        break;
      case "canned_cta":
        summaries.push("upgraded canned CTA");
        break;
    }
  }

  return `Sanitized: ${summaries.join(", ")}`;
}

export function sanitizeFinalVariant(variant: CaptionVariant, platform?: string): CaptionVariant {
type SanitizeOptions = {
  platform?: Platform;
  facts?: Record<string, unknown>;
  theme?: string;
  context?: string;
  existingCaption?: string;
};

export function sanitizeFinalVariant(variant: CaptionVariant, options?: SanitizeOptions): CaptionVariant {
  const sanitized = { ...variant };
  const platform = options?.platform;

  // Sanitize caption for banned words first
  if (typeof sanitized.caption === "string") {
    if (containsBannedWord(sanitized.caption)) {
      sanitized.caption = replaceBannedWords(sanitized.caption);
      if (!sanitized.caption || sanitized.caption.trim().length === 0) {
        sanitized.caption = "Sharing something I'm genuinely proud of.";
      }
    }
  }

  // Sanitize caption if it contains banned phrases  
  // Sanitize caption if it contains banned phrases
  if (typeof sanitized.caption === "string") {
    for (const regex of BANNED_PHRASES) {
      if (regex.test(sanitized.caption)) {
        sanitized.caption = "Sharing something I'm genuinely proud of.";
        break;
      }
    }
  }

  // Sanitize CTA - check if it's canned after normalization
  if (isCannedCTA(sanitized.cta)) {
    sanitized.cta = HUMAN_CTA;
  }

  // Sanitize CTA for banned words
  if (typeof sanitized.cta === "string") {
    if (containsBannedWord(sanitized.cta)) {
      sanitized.cta = replaceBannedWords(sanitized.cta);
      if (!sanitized.cta || sanitized.cta.trim().length === 0) {
        sanitized.cta = HUMAN_CTA;
      }
    }
  }

  // Sanitize alt text for banned words and ensure it's always present
  if (typeof sanitized.alt === "string") {
    if (containsBannedWord(sanitized.alt)) {
      sanitized.alt = replaceBannedWords(sanitized.alt);
      if (!sanitized.alt || sanitized.alt.trim().length < 20) {
        sanitized.alt = "Descriptive photo for the post";
  // Sanitize alt text for banned words
  if (typeof sanitized.alt === "string" && containsBannedWord(sanitized.alt)) {
    sanitized.alt = replaceBannedWords(sanitized.alt);
  }

  if (platform) {
    const fallback = ensureFallbackCompliance(
      {
        caption: typeof sanitized.caption === "string" ? sanitized.caption : undefined,
        hashtags: Array.isArray(sanitized.hashtags)
          ? sanitized.hashtags.filter((tag): tag is string => typeof tag === "string")
          : undefined,
        cta: typeof sanitized.cta === "string" ? sanitized.cta : undefined,
        alt: typeof sanitized.alt === "string" ? sanitized.alt : undefined,
      },
      {
        platform,
        facts: options?.facts,
        theme: options?.theme,
        context: options?.context,
        existingCaption: typeof sanitized.caption === "string" ? sanitized.caption : options?.existingCaption,
      }
    }
  } else if (!sanitized.alt) {
    );

    sanitized.hashtags = fallback.hashtags;
    sanitized.cta = fallback.cta;
    sanitized.alt = fallback.alt;
  } else if (!sanitized.alt || typeof sanitized.alt !== "string" || sanitized.alt.trim().length < 20) {
    // Ensure alt is always present, even if not originally provided
    sanitized.alt = "Descriptive photo for the post";
  }

  // Enhanced hashtag sanitization with platform-specific rules
  if (Array.isArray(sanitized.hashtags)) {
    let cleanedHashtags: string[] = sanitized.hashtags
      .filter((tag): tag is string => typeof tag === "string")
      .filter((tag) => !containsBannedWord(tag))
      .filter((tag) => !GENERIC_HASHTAGS.has(tag.toLowerCase()));

    if (platform === "reddit") {
      cleanedHashtags = cleanedHashtags
        .map((tag) => (tag.startsWith("#") ? tag.substring(1) : tag))
        .filter((tag) => tag.length > 0);
    }

    const limit = platform === "x" ? 2 : platform === "reddit" ? 0 : undefined;
    if (typeof limit === "number") {
      cleanedHashtags = limit === 0 ? [] : cleanedHashtags.slice(0, limit);
    }

    if (cleanedHashtags.length === 0) {
      sanitized.hashtags = fallbackHashtags(platform);
    } else {
      sanitized.hashtags = cleanedHashtags;
      if (platform) {
        const refreshed = ensureFallbackCompliance(
          {
            caption: typeof sanitized.caption === "string" ? sanitized.caption : undefined,
            hashtags: [],
            cta: typeof sanitized.cta === "string" ? sanitized.cta : undefined,
            alt: typeof sanitized.alt === "string" ? sanitized.alt : undefined,
          },
          {
            platform,
            facts: options?.facts,
            theme: options?.theme,
            context: options?.context,
            existingCaption: typeof sanitized.caption === "string" ? sanitized.caption : options?.existingCaption,
          }
        ).hashtags;

        cleanedHashtags = platform === "reddit"
          ? refreshed.map((tag) => (tag.startsWith("#") ? tag.substring(1) : tag)).filter((tag) => tag.length > 0)
          : refreshed;

        if (typeof limit === "number") {
          cleanedHashtags = limit === 0 ? [] : cleanedHashtags.slice(0, limit);
        }
      } else {
        cleanedHashtags = fallbackHashtags(platform);
      }
    }

    sanitized.hashtags = cleanedHashtags;
  } else {
    sanitized.hashtags = fallbackHashtags(platform);
  }

  return sanitized;
}
server/caption/textOnlyPipeline.ts
+89-24
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { z } from "zod";
import { textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { extractToneOptions, ToneOptions } from "./toneOptions";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";
import { buildVoiceGuideBlock } from "./stylePack";
import { formatVoiceContext } from "./voiceTraits";
import { serializePromptField } from "./promptUtils";
import { inferFallbackFromFacts, ensureFallbackCompliance } from "./inferFallbackFromFacts";
import type { Platform } from "./inferFallbackFromFacts";
import { dedupeVariantsForRanking } from "./dedupeVariants";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

const MAX_VARIANT_ATTEMPTS = 4;
const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 4;
const CAPTION_KEY_LENGTH = 80;
const safeFallbackCaption = "Text-only social media content";
const safeFallbackAlt = "Detailed alt text describing the theme.";
const safeFallbackHashtags = ["#content", "#creative", "#amazing"] as const;
const safeFallbackCta = "Check it out";

function captionKey(caption: string): string {
  return caption.trim().slice(0, 80).toLowerCase();
}

function hintSnippet(caption: string): string {
  const normalized = caption.trim().replace(/\s+/g, " ");
  return normalized.length > 60 ? `${normalized.slice(0, 57)}…` : normalized;
}

function uniqueCaptionKey(caption: string): string {
  return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
}

function truncateForHint(caption: string): string {
  const trimmed = caption.trim();
  if (trimmed.length <= 60) {
    return trimmed;
  }
  return `${trimmed.slice(0, 57)}...`;
}

function buildRetryHint(
  baseHint: string | undefined,
  duplicates: string[],
@@ -190,65 +195,74 @@ type TextOnlyVariantParams = {
export async function generateVariantsTextOnly(params: TextOnlyVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants_textonly.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
      : "authentic";
    variant.cta = typeof variant.cta === "string" && variant.cta.trim().length >= 2
      ? variant.cta
      : "Check it out";

    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
    const normalizedHashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];
      : undefined;

    const fallback = ensureFallbackCompliance(
      {
        caption,
        hashtags: normalizedHashtags,
        cta: typeof variant.cta === "string" ? variant.cta : undefined,
        alt: typeof variant.alt === "string" ? variant.alt : undefined,
      },
      {
        platform: params.platform,
        theme: params.theme,
        context: params.context,
        existingCaption: caption,
      }
    );

    variant.cta = fallback.cta;
    variant.alt = fallback.alt;
    variant.hashtags = fallback.hashtags.slice(0, 10);

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      `THEME: ${serializePromptField(params.theme)}`,
      `CONTEXT: ${serializePromptField(params.context || "")}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);

    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
@@ -293,141 +307,192 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
        })();

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  const paddingFallback = inferFallbackFromFacts({
    platform: params.platform,
    theme: params.theme,
    context: params.context,
    existingCaption: uniqueVariants[0]?.caption,
  });

  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Text-only social media content",
      alt: "Detailed alt text describing the theme",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      caption: safeFallbackCaption,
      alt: paddingFallback.alt,
      hashtags: paddingFallback.hashtags,
      cta: paddingFallback.cta,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
  }

  return CaptionArray.parse(uniqueVariants);
}

async function requestTextOnlyRanking(
  variantsInput: unknown[],
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
  extraHint?: string,
  theme?: string,
  context?: string
): Promise<unknown> {
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res = await textModel.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Text-only textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  

  const platformForFallback = platform === "instagram" || platform === "x" || platform === "reddit" || platform === "tiktok"
    ? platform
    : undefined;
  const firstVariant = Array.isArray(variantsInput) && variantsInput.length > 0 && typeof variantsInput[0] === "object" && variantsInput[0] !== null
    ? variantsInput[0] as Record<string, unknown>
    : undefined;
  const fallbackContext = platformForFallback
    ? inferFallbackFromFacts({
        platform: platformForFallback,
        theme,
        context,
        existingCaption: typeof firstVariant?.caption === "string" ? firstVariant.caption : undefined,
      })
    : undefined;

  if(Array.isArray(json)) {
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner ?? variantsInput[0]
      final: winner ?? firstVariant ?? {
        caption: safeFallbackCaption,
        alt: fallbackContext?.alt ?? safeFallbackAlt,
        hashtags: fallbackContext?.hashtags ?? [...safeFallbackHashtags],
        cta: fallbackContext?.cta ?? safeFallbackCta,
        mood: "engaging",
        style: "authentic",
        safety_level: "normal",
        nsfw: false,
      }
    };
  }
  

  return json;
}

export async function rankAndSelect(
  variants: unknown[],
  params?: { platform?: string; theme?: string; context?: string }
): Promise<z.infer<typeof RankResult>> {
  const sys = await load("system.txt"), guard = await load("guard.txt"), prompt = await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestTextOnlyRanking(variants, serializedVariants, promptBlock, params?.platform);
  const first = await requestTextOnlyRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    undefined,
    params?.theme,
    params?.context
  );
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  
  if (violations.length === 0) {
    // Always sanitize final variant to ensure required fields like alt are present
    const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
    const sanitizedFinal = sanitizeFinalVariant(parsed.final, {
      platform: params?.platform as Platform | undefined,
      theme: params?.theme,
      context: params?.context,
    });
    return RankResult.parse({
      ...parsed,
      final: sanitizedFinal
    });
  }

  const rerank = await requestTextOnlyRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
    buildRerankHint(violations),
    params?.theme,
    params?.context
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const sanitizedFinal = sanitizeFinalVariant(parsed.final, {
    platform: params?.platform as Platform | undefined,
    theme: params?.theme,
    context: params?.context,
  });
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type TextOnlyPipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  theme:string;
  context?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

/**
 * Text-only caption pipeline for brainstorming without an image upload.
 *
 * @remarks
 * Persona settings (`style`, `mood`, etc.) are forwarded to every Gemini retry so the
 * voice remains consistent even when a platform validation retry is required.
 */
