 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/caption/rewritePipeline.ts b/server/caption/rewritePipeline.ts
index f39f36cbc13b180f6d48ce7dc7b607dda9a8921d..f70d8a6f56d4936991b7f62006cd2bd893509219 100644
--- a/server/caption/rewritePipeline.ts
+++ b/server/caption/rewritePipeline.ts
@@ -154,125 +154,133 @@ export async function extractFacts(imageUrl:string){
 type RewriteVariantsParams = {
   platform:"instagram"|"x"|"reddit"|"tiktok";
   voice:string;
   existingCaption:string;
   facts?:Record<string, unknown>;
   hint?:string;
   nsfw?:boolean;
   doNotDrop?: string[];
 } & ToneOptions;
 
 const VARIANT_TARGET = 5;
 const VARIANT_RETRY_LIMIT = 3;
 
 export async function variantsRewrite(params: RewriteVariantsParams) {
   const [sys, guard, prompt] = await Promise.all([
     load("system.txt"),
     load("guard.txt"),
     load("rewrite.txt")
   ]);
 
   let attempts = 0;
   let currentHint = params.hint;
   const mandatoryTokens = params.doNotDrop && params.doNotDrop.length > 0
     ? `MANDATORY TOKENS: ${params.doNotDrop.join(" | ")}`
     : "";
-  const variants: { caption: string; hashtags: string[]; cta?: string; alt?: string }[] = [];
+  const variants: Array<z.infer<typeof CaptionItem>> = [];
 
   while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
     attempts += 1;
 
     const voiceContext = formatVoiceContext(params.voice);
     const user = [
       `PLATFORM: ${params.platform}`,
       `VOICE: ${params.voice}`,
       voiceContext,
       params.style ? `STYLE: ${params.style}` : "",
       params.mood ? `MOOD: ${params.mood}` : "",
       `EXISTING_CAPTION: ${serializePromptField(params.existingCaption)}`,
       params.facts ? `IMAGE_FACTS: ${JSON.stringify(params.facts)}` : "",
       `NSFW: ${params.nsfw || false}`,
       mandatoryTokens,
       currentHint ? `HINT:${serializePromptField(currentHint, { block: true })}` : "",
     ].filter((line): line is string => Boolean(line)).join("\n");
 
     const voiceGuide = buildVoiceGuideBlock(params.voice);
     const promptSections = [sys, guard, prompt, user];
     if (voiceGuide) promptSections.push(voiceGuide);
 
     let res;
     try {
       res = await textModel.generateContent([{ text: promptSections.join("\n") }]);
     } catch (error) {
       console.error('Gemini textModel.generateContent failed:', error);
       throw error;
     }
 
     const json = stripToJSON(res.response.text()) as unknown;
     let hasBannedWords = false;
 
     if (Array.isArray(json)) {
       json.forEach((item) => {
         const variant = item as Record<string, unknown>;
 
-        // Normalize variant fields first
-        variant.safety_level = normalizeSafetyLevel(
+        const normalizedSafetyLevel = normalizeSafetyLevel(
           typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
         );
-        if (typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
-        if (typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
+        const mood = typeof variant.mood === 'string' && variant.mood.length >= 2 ? variant.mood : "engaging";
+        const style = typeof variant.style === 'string' && variant.style.length >= 2 ? variant.style : "authentic";
 
-        // Use helper for contextual fallbacks
         const fallback = ensureFallbackCompliance(
           {
             caption: typeof variant.caption === 'string' ? variant.caption : undefined,
-            hashtags: Array.isArray(variant.hashtags) ? variant.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
+            hashtags: Array.isArray(variant.hashtags)
+              ? variant.hashtags.filter((tag): tag is string => typeof tag === 'string')
+              : undefined,
             cta: typeof variant.cta === 'string' ? variant.cta : undefined,
             alt: typeof variant.alt === 'string' ? variant.alt : undefined,
           },
           {
             platform: params.platform,
             facts: params.facts,
             existingCaption: params.existingCaption,
           }
         );
 
-        variant.hashtags = fallback.hashtags;
-        variant.cta = fallback.cta;
-        variant.alt = fallback.alt;
-
-        if (typeof variant.caption !== 'string' || variant.caption.length < 1) {
-          variant.caption = params.existingCaption || "Here's something I'm proud of today.";
-        }
-
-        // Check for banned words after normalization
-        if (variantContainsBannedWord(variant)) {
+        const caption =
+          typeof variant.caption === 'string' && variant.caption.length > 0
+            ? variant.caption
+            : params.existingCaption || "Here's something I'm proud of today.";
+
+        const sanitizedVariant = {
+          caption,
+          hashtags: fallback.hashtags,
+          cta: fallback.cta,
+          alt: fallback.alt,
+          mood,
+          style,
+          safety_level: normalizedSafetyLevel,
+          nsfw: typeof variant.nsfw === 'boolean' ? variant.nsfw : false,
+        } satisfies z.input<typeof CaptionItem>;
+
+        if (variantContainsBannedWord(sanitizedVariant)) {
           hasBannedWords = true;
-          return; // Skip this variant
+          return;
         }
 
-        variants.push(variant);
+        const parsedVariant = CaptionItem.parse(sanitizedVariant);
+        variants.push(parsedVariant);
       });
     }
 
     // If we don't have enough variants, build retry hint
     if (variants.length < VARIANT_TARGET) {
       const needed = VARIANT_TARGET - variants.length;
       let retryHint = `Generate ${needed} more unique, distinct variants.`;
 
       // Add banned words hint if detected
       if (hasBannedWords) {
         retryHint = retryHint ? `${retryHint} ${BANNED_WORDS_HINT}` : BANNED_WORDS_HINT;
       }
 
       currentHint = retryHint;
     }
   }
 
   // Ensure exactly 5 variants by padding with variations if needed
   while (variants.length < VARIANT_TARGET) {
     const fallbackContent = inferFallbackFromFacts({
       platform: params.platform,
       facts: params.facts,
       existingCaption: params.existingCaption,
     });
 
 
EOF
)