client/src/components/admin/admin-communities-panel.tsx
+129
-26

@@ -13,51 +13,55 @@ import {
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import {
  type AdminCommunity,
  type CommunityPayload,
  type PromotionPolicy,
  type GrowthTrend,
  type ActivityLevel,
  type CompetitionLevel,
  useAdminCommunities,
  useCreateCommunity,
  useUpdateCommunity,
  useDeleteCommunity,
  GROWTH_TRENDS,
  GROWTH_TREND_LABELS,
} from '@/hooks/use-admin-communities';
import type { RedditCommunitySellingPolicy } from '@shared/schema';
import type {
  LegacyRedditCommunityRuleSet,
  RedditCommunityRuleSet,
  RedditCommunitySellingPolicy,
} from '@shared/schema';
import { cn } from '@/lib/utils';
import { CheckCircle, Edit2, Loader2, PlusCircle, ShieldAlert, Trash2 } from 'lucide-react';

interface AdminCommunitiesPanelProps {
  canManage: boolean;
}

type SellingRuleOption = 'unspecified' | RedditCommunitySellingPolicy;
type TriState = 'unspecified' | 'allowed' | 'disallowed';

interface CommunityFormState {
  id: string;
  name: string;
  displayName: string;
  category: string;
  members: string;
  engagementRate: string;
  verificationRequired: boolean;
  promotionAllowed: PromotionPolicy;
  postingLimitsPerDay: string;
  postingLimitsPerWeek: string;
  postingLimitsCooldownHours: string;
  rulesMinKarma: string;
  rulesMinAccountAge: string;
  rulesWatermarksAllowed: TriState;
@@ -82,94 +86,186 @@ const defaultFormState: CommunityFormState = {
  category: '',
  members: '',
  engagementRate: '',
  verificationRequired: false,
  promotionAllowed: 'limited',
  postingLimitsPerDay: '',
  postingLimitsPerWeek: '',
  postingLimitsCooldownHours: '',
  rulesMinKarma: '',
  rulesMinAccountAge: '',
  rulesWatermarksAllowed: 'unspecified',
  rulesSellingAllowed: 'unspecified',
  rulesTitleRules: '',
  rulesContentRules: '',
  rulesLinkRestrictions: '',
  bestPostingTimes: '',
  averageUpvotes: '',
  successProbability: '',
  growthTrend: 'stable',
  modActivity: 'medium',
  description: '',
  tags: '',
  competitionLevel: 'medium',
};

type StructuredRules = RedditCommunityRuleSet | null | undefined;
type LegacyRules = LegacyRedditCommunityRuleSet | null | undefined;

type StructuredEligibility = NonNullable<RedditCommunityRuleSet['eligibility']>;
type StructuredContent = NonNullable<RedditCommunityRuleSet['content']>;
type StructuredPosting = NonNullable<RedditCommunityRuleSet['posting']>;

interface RuleContext {
  structured: RedditCommunityRuleSet | null;
  legacy: LegacyRedditCommunityRuleSet | null;
  eligibility: StructuredEligibility | null;
  content: StructuredContent | null;
  posting: StructuredPosting | null;
}

function ensureArray<T>(value: readonly T[] | null | undefined): T[] {
  return value ? [...value] : [];
}

function toLegacyRuleSet(structured: StructuredRules, legacy: LegacyRules): LegacyRedditCommunityRuleSet | null {
  if (legacy) {
    return {
      ...legacy,
      titleRules: ensureArray(legacy.titleRules),
      contentRules: ensureArray(legacy.contentRules),
      linkRestrictions: ensureArray(legacy.linkRestrictions),
      bannedContent: ensureArray(legacy.bannedContent),
      formattingRequirements: ensureArray(legacy.formattingRequirements),
    };
  }

  if (!structured) {
    return null;
  }

  const eligibility = structured.eligibility ?? {};
  const content = structured.content ?? {};
  const posting = structured.posting ?? {};

  return {
    minKarma: eligibility.minKarma ?? null,
    minAccountAge: eligibility.minAccountAgeDays ?? null,
    minAccountAgeDays: eligibility.minAccountAgeDays ?? null,
    verificationRequired: eligibility.verificationRequired ?? false,
    requiresApproval: eligibility.requiresApproval ?? false,
    watermarksAllowed: content.watermarksAllowed ?? null,
    sellingAllowed: content.sellingPolicy ?? undefined,
    promotionalLinksAllowed: content.promotionalLinks ?? undefined,
    requiresOriginalContent: content.requiresOriginalContent ?? false,
    nsfwRequired: content.nsfwRequired ?? false,
    titleRules: ensureArray(content.titleGuidelines),
    contentRules: ensureArray(content.contentGuidelines),
    linkRestrictions: ensureArray(content.linkRestrictions),
    bannedContent: ensureArray(content.bannedContent),
    formattingRequirements: ensureArray(content.formattingRequirements),
    maxPostsPerDay: posting?.maxPostsPerDay ?? null,
    cooldownHours: posting?.cooldownHours ?? null,
    notes: structured.notes ?? undefined,
  };
}

function getRuleContext(community: AdminCommunity): RuleContext {
  const structured = community.rules ?? null;
  const legacy = toLegacyRuleSet(structured, community.legacyRules ?? null);

  return {
    structured,
    legacy,
    eligibility: structured?.eligibility ?? null,
    content: structured?.content ?? null,
    posting: structured?.posting ?? null,
  };
}

function toStringValue(value: number | null | undefined): string {
  return value === null || value === undefined ? '' : String(value);
}

function parseNumber(value: string): number | undefined {
  const trimmed = value.trim();
  if (trimmed === '') return undefined;
  const parsed = Number(trimmed);
  return Number.isNaN(parsed) ? undefined : parsed;
}

function parseList(value: string): string[] | undefined {
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  const items = trimmed
    .split(/\n|,/)
    .map(item => item.trim())
    .filter(Boolean);
  return items.length ? items : undefined;
}

function communityToForm(community: AdminCommunity): CommunityFormState {
  const { eligibility, content, posting, legacy } = getRuleContext(community);
  const postingLimits = community.postingLimits ?? null;
  const titleGuidelines = content?.titleGuidelines ?? legacy?.titleRules ?? [];
  const contentGuidelines = content?.contentGuidelines ?? legacy?.contentRules ?? [];
  const linkRestrictions = content?.linkRestrictions ?? legacy?.linkRestrictions ?? [];
  const watermarksAllowed = content?.watermarksAllowed ?? legacy?.watermarksAllowed ?? null;
  const sellingPolicy = content?.sellingPolicy ?? legacy?.sellingAllowed ?? undefined;
  const minKarma = eligibility?.minKarma ?? legacy?.minKarma ?? null;
  const minAccountAge =
    eligibility?.minAccountAgeDays ?? legacy?.minAccountAge ?? legacy?.minAccountAgeDays ?? null;
  const maxPostsPerDay =
    postingLimits?.perDay ?? posting?.maxPostsPerDay ?? legacy?.maxPostsPerDay ?? null;
  const maxPostsPerWeek = postingLimits?.perWeek ?? null;
  const cooldownHours =
    postingLimits?.cooldownHours ?? posting?.cooldownHours ?? legacy?.cooldownHours ?? null;

  return {
    id: community.id,
    name: community.name,
    displayName: community.displayName,
    category: community.category,
    members: String(community.members ?? ''),
    engagementRate: String(community.engagementRate ?? ''),
    verificationRequired: community.verificationRequired,
    promotionAllowed: community.promotionAllowed,
    postingLimitsPerDay: community.postingLimits?.perDay ? String(community.postingLimits.perDay) : '',
    postingLimitsPerWeek: community.postingLimits?.perWeek ? String(community.postingLimits.perWeek) : '',
    postingLimitsCooldownHours: community.postingLimits?.cooldownHours
      ? String(community.postingLimits.cooldownHours)
      : '',
    rulesMinKarma: community.rules?.eligibility?.minKarma !== undefined ? String(community.rules.eligibility.minKarma) : '',
    rulesMinAccountAge: community.rules?.eligibility?.minAccountAgeDays !== undefined ? String(community.rules.eligibility.minAccountAgeDays) : '',
    postingLimitsPerDay: toStringValue(maxPostsPerDay),
    postingLimitsPerWeek: toStringValue(maxPostsPerWeek),
    postingLimitsCooldownHours: toStringValue(cooldownHours),
    rulesMinKarma: toStringValue(minKarma),
    rulesMinAccountAge: toStringValue(minAccountAge),
    rulesWatermarksAllowed:
      community.rules?.content?.watermarksAllowed === true
      watermarksAllowed === true
        ? 'allowed'
        : community.rules?.content?.watermarksAllowed === false
        : watermarksAllowed === false
          ? 'disallowed'
          : 'unspecified',
    rulesSellingAllowed: community.rules?.content?.sellingPolicy ?? 'unspecified',
    rulesTitleRules: (community.rules?.content?.titleGuidelines ?? []).join('\n'),
    rulesContentRules: (community.rules?.content?.contentGuidelines ?? []).join('\n'),
    rulesLinkRestrictions: (community.rules?.content?.linkRestrictions ?? []).join('\n'),
    rulesSellingAllowed: sellingPolicy ?? 'unspecified',
    rulesTitleRules: titleGuidelines.join('\n'),
    rulesContentRules: contentGuidelines.join('\n'),
    rulesLinkRestrictions: linkRestrictions.join('\n'),
    bestPostingTimes: (community.bestPostingTimes ?? []).join(', '),
    averageUpvotes: community.averageUpvotes !== null && community.averageUpvotes !== undefined
      ? String(community.averageUpvotes)
      : '',
    successProbability: community.successProbability !== null && community.successProbability !== undefined
      ? String(community.successProbability)
      : '',
    growthTrend: community.growthTrend ?? 'stable',
    modActivity: community.modActivity ?? 'medium',
    description: community.description ?? '',
    tags: (community.tags ?? []).join(', '),
    competitionLevel: community.competitionLevel ?? 'medium',
  };
}

function formToPayload(form: CommunityFormState): CommunityPayload {
  const members = parseNumber(form.members);
  const engagementRate = parseNumber(form.engagementRate);
  if (members === undefined) {
    throw new Error('Member count is required and must be a number.');
  }
  if (engagementRate === undefined) {
    throw new Error('Engagement rate is required and must be a number.');
  }

@@ -218,80 +314,87 @@ function formToPayload(form: CommunityFormState): CommunityPayload {
  const normalizedRules = Object.keys(rules).length ? rules : null;

  return {
    id: form.id.trim() || undefined,
    name: form.name.trim(),
    displayName: form.displayName.trim(),
    category: form.category.trim(),
    members,
    engagementRate,
    verificationRequired: form.verificationRequired,
    promotionAllowed: form.promotionAllowed,
    postingLimits: normalizedPostingLimits,
    rules: normalizedRules,
    bestPostingTimes: bestPostingTimes ?? null,
    averageUpvotes: averageUpvotes ?? null,
    successProbability: successProbability ?? null,
    growthTrend: form.growthTrend,
    modActivity: form.modActivity,
    description: form.description.trim() || null,
    tags: tags ?? null,
    competitionLevel: form.competitionLevel,
  };
}

function RuleSummary({ community }: { community: AdminCommunity }) {
  const { eligibility, content, legacy } = getRuleContext(community);
  const ruleItems: string[] = [];
  if (community.rules?.eligibility?.minKarma !== undefined) {
    ruleItems.push(`Min Karma ${community.rules.eligibility.minKarma}`);
  const minKarma = eligibility?.minKarma ?? legacy?.minKarma;
  if (typeof minKarma === 'number') {
    ruleItems.push(`Min Karma ${minKarma}`);
  }
  if (community.rules?.eligibility?.minAccountAgeDays !== undefined) {
    ruleItems.push(`Account ${community.rules.eligibility.minAccountAgeDays}d`);
  const minAccountAge = eligibility?.minAccountAgeDays ?? legacy?.minAccountAge ?? legacy?.minAccountAgeDays;
  if (typeof minAccountAge === 'number') {
    ruleItems.push(`Account ${minAccountAge}d`);
  }
  if (community.rules?.content?.watermarksAllowed === true) {
  const watermarksAllowed = content?.watermarksAllowed ?? legacy?.watermarksAllowed ?? null;
  if (watermarksAllowed === true) {
    ruleItems.push('Watermarks allowed');
  }
  if (community.rules?.content?.watermarksAllowed === false) {
  if (watermarksAllowed === false) {
    ruleItems.push('No watermarks');
  }
  const sellingPolicy = community.rules?.content?.sellingPolicy;
  const sellingPolicy = content?.sellingPolicy ?? legacy?.sellingAllowed;
  if (sellingPolicy === 'allowed') {
    ruleItems.push('Selling allowed');
  } else if (sellingPolicy === 'limited') {
    ruleItems.push('Limited selling');
  } else if (sellingPolicy === 'not_allowed') {
    ruleItems.push('No selling');
  } else if (sellingPolicy === 'unknown') {
    ruleItems.push('Selling policy unknown');
  }
  if ((community.rules?.content?.titleGuidelines?.length ?? 0) > 0) {
    ruleItems.push(`${community.rules?.content?.titleGuidelines?.length ?? 0} title rules`);
  const titleGuidelines = content?.titleGuidelines ?? legacy?.titleRules ?? [];
  if (titleGuidelines.length > 0) {
    ruleItems.push(`${titleGuidelines.length} title rules`);
  }
  if ((community.rules?.content?.contentGuidelines?.length ?? 0) > 0) {
    ruleItems.push(`${community.rules?.content?.contentGuidelines?.length ?? 0} content rules`);
  const contentGuidelines = content?.contentGuidelines ?? legacy?.contentRules ?? [];
  if (contentGuidelines.length > 0) {
    ruleItems.push(`${contentGuidelines.length} content rules`);
  }
  if ((community.rules?.content?.linkRestrictions?.length ?? 0) > 0) {
  const linkRestrictions = content?.linkRestrictions ?? legacy?.linkRestrictions ?? [];
  if (linkRestrictions.length > 0) {
    ruleItems.push('Link restrictions');
  }
  return (
    <div className="flex flex-wrap gap-1">
      {ruleItems.length ? (
        ruleItems.map(item => (
          <Badge key={item} variant="secondary" className="bg-purple-50 text-purple-700">
            {item}
          </Badge>
        ))
      ) : (
        <span className="text-sm text-muted-foreground">No structured rules</span>
      )}
    </div>
  );
}

export function AdminCommunitiesPanel({ canManage }: AdminCommunitiesPanelProps) {
  const { toast } = useToast();
  const [searchTerm, setSearchTerm] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [promotionFilter, setPromotionFilter] = useState<'all' | PromotionPolicy>('all');
  const [verificationFilter, setVerificationFilter] = useState<'all' | 'required' | 'not-required'>('all');
  const [formState, setFormState] = useState<CommunityFormState>(defaultFormState);
  const [isCreateOpen, setIsCreateOpen] = useState(false);
client/src/components/compliance/ComplianceStatusDashboard.tsx
+0
-288

@@ -259,313 +259,25 @@ export function ComplianceStatusDashboard() {
                      <TableHead className="text-xs uppercase tracking-wide text-gray-500">Reason</TableHead>
                      <TableHead className="text-xs uppercase tracking-wide text-gray-500">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {subreddit.recentRemovals.map((removal) => (
                      <TableRow key={removal.id} className="border-gray-100">
                        <TableCell className="font-mono text-xs text-gray-600">{removal.id}</TableCell>
                        <TableCell className="text-sm text-gray-700">{formatDateTime(removal.removedAt)}</TableCell>
                        <TableCell className="text-sm text-gray-700">{removal.reason}</TableCell>
                        <TableCell className="text-sm text-gray-500">
                          {removal.actionTaken || '—'}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { AlertTriangle, CheckCircle, Clock, Shield } from 'lucide-react';

export interface SubredditRemoval {
  id: string;
  removedAt: string;
  reason: string;
  actionTaken?: string;
}

/**
 * Shape of the subreddit level compliance metrics expected from the backend.
 * The dashboard currently renders an array of these objects while backend
 * integration is pending.
 * - `name`: Subreddit name without the leading `r/`.
 * - `shadowbanned`: Flag indicating if automation detected a shadowban.
 * - `verificationStatus`: Either `pending`, `review`, or `verified`.
 * - `nextPostTime`: ISO timestamp representing the next compliant posting window.
 * - `recentRemovals`: Chronological list of the latest moderation removals.
 */
export interface SubredditComplianceStatus {
  name: string;
  shadowbanned: boolean;
  verificationStatus: 'pending' | 'review' | 'verified';
  nextPostTime: string;
  recentRemovals: SubredditRemoval[];
}

/**
 * Temporary mocked data. Replace this structure with live compliance results
 * once the moderation ingestion pipeline is wired up.
 *
 * Backend teams can refer to `docs/compliance-dashboard-data.md` for the
 * contract powering this dashboard. When the API is ready, swap this array
 * with the fetched response typed as `SubredditComplianceStatus[]` to unlock
 * live telemetry without updating the UI layer.
 */
const dummyComplianceData: SubredditComplianceStatus[] = [
  {
    name: 'CreatorSupport',
    shadowbanned: false,
    verificationStatus: 'verified',
    nextPostTime: '2024-03-09T18:30:00Z',
    recentRemovals: [
      {
        id: 'CS-2051',
        removedAt: '2024-03-07T21:15:00Z',
        reason: 'Automod: Affiliate link outside allowed domains',
        actionTaken: 'Auto-removed'
      },
      {
        id: 'CS-2049',
        removedAt: '2024-03-06T16:03:00Z',
        reason: 'Manual: Low-effort promotion',
        actionTaken: 'Warning issued'
      },
      {
        id: 'CS-2045',
        removedAt: '2024-03-05T09:47:00Z',
        reason: 'Automod: Missing flair'
      },
      {
        id: 'CS-2043',
        removedAt: '2024-03-04T14:22:00Z',
        reason: 'Manual: Rule violation - excessive self-promotion',
        actionTaken: 'Temporary ban'
      },
      {
        id: 'CS-2041',
        removedAt: '2024-03-03T11:30:00Z',
        reason: 'Automod: Title format violation'
      }
    ]
  },
  {
    name: 'OnlyFansPromotion',
    shadowbanned: true,
    verificationStatus: 'review',
    nextPostTime: '2024-03-10T12:00:00Z',
    recentRemovals: [
      {
        id: 'OF-1823',
        removedAt: '2024-03-08T09:15:00Z',
        reason: 'Shadowban detected - posts not visible',
        actionTaken: 'Account review initiated'
      },
      {
        id: 'OF-1821',
        removedAt: '2024-03-07T16:45:00Z',
        reason: 'Automod: Watermark policy violation',
        actionTaken: 'Auto-removed'
      },
      {
        id: 'OF-1819',
        removedAt: '2024-03-06T13:20:00Z',
        reason: 'Manual: Spam filter triggered',
        actionTaken: 'Manual review'
      }
    ]
  },
  {
    name: 'AdultCreators',
    shadowbanned: false,
    verificationStatus: 'pending',
    nextPostTime: '2024-03-09T20:45:00Z',
    recentRemovals: [
      {
        id: 'AC-3456',
        removedAt: '2024-03-08T14:30:00Z',
        reason: 'Manual: Content quality standards',
        actionTaken: 'Feedback provided'
      },
      {
        id: 'AC-3454',
        removedAt: '2024-03-07T10:15:00Z',
        reason: 'Automod: Account age requirement',
        actionTaken: 'Auto-removed'
      }
    ]
  },
  {
    name: 'ContentCreatorHub',
    shadowbanned: false,
    verificationStatus: 'verified',
    nextPostTime: '2024-03-09T15:20:00Z',
    recentRemovals: []
  }
];

const getVerificationStatusBadge = (status: SubredditComplianceStatus['verificationStatus']) => {
  switch (status) {
    case 'verified':
      return (
        <Badge variant="default" className="bg-green-100 text-green-700 border-green-200">
          <CheckCircle className="h-3 w-3 mr-1" />
          Verified
        </Badge>
      );
    case 'review':
      return (
        <Badge variant="secondary" className="bg-yellow-100 text-yellow-700 border-yellow-200">
          <Clock className="h-3 w-3 mr-1" />
          Under Review
        </Badge>
      );
    case 'pending':
      return (
        <Badge variant="outline" className="bg-gray-100 text-gray-700 border-gray-200">
          <Clock className="h-3 w-3 mr-1" />
          Pending
        </Badge>
      );
    default:
      return null;
  }
};

const getShadowbanBadge = (shadowbanned: boolean) => {
  if (shadowbanned) {
    return (
      <Badge variant="destructive" className="bg-red-100 text-red-700 border-red-200">
        <AlertTriangle className="h-3 w-3 mr-1" />
        Shadowbanned
      </Badge>
    );
  }
  return (
    <Badge variant="default" className="bg-green-100 text-green-700 border-green-200">
      <Shield className="h-3 w-3 mr-1" />
      Active
    </Badge>
  );
};

const formatDateTime = (isoString: string) => {
  return new Intl.DateTimeFormat('en-US', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short'
  }).format(new Date(isoString));
};

const formatNextPostTime = (isoString: string) => {
  const now = new Date();
  const postTime = new Date(isoString);
  const diffMs = postTime.getTime() - now.getTime();
  
  if (diffMs <= 0) {
    return 'Available now';
  }
  
  const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
  if (diffHours < 24) {
    return `${diffHours}h remaining`;
  }
  
  const diffDays = Math.ceil(diffHours / 24);
  return `${diffDays}d remaining`;
};

export function ComplianceStatusDashboard() {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight text-gray-900">
            Compliance Dashboard
          </h2>
          <p className="text-gray-600 mt-1">
            Monitor subreddit compliance status and moderation activity
          </p>
        </div>
        <Badge variant="outline" className="text-xs">
          Live Data Coming Soon
        </Badge>
      </div>

      {dummyComplianceData.map((subreddit) => {
        const hasRemovals = subreddit.recentRemovals.length > 0;
        
        return (
          <Card key={subreddit.name} className="bg-white/80 backdrop-blur-sm border-0 shadow-xl">
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-3">
                  <span className="text-lg font-semibold text-gray-900">
                    r/{subreddit.name}
                  </span>
                  {getShadowbanBadge(subreddit.shadowbanned)}
                  {getVerificationStatusBadge(subreddit.verificationStatus)}
                </CardTitle>
                <div className="text-sm text-gray-500">
                  Next post: {formatNextPostTime(subreddit.nextPostTime)}
                </div>
              </div>
            </CardHeader>
            
            <CardContent>
              {!hasRemovals ? (
                <div className="text-center py-8">
                  <CheckCircle className="h-12 w-12 text-green-400 mx-auto mb-3" />
                  <p className="text-gray-500 font-medium">No recent removals</p>
                  <p className="text-sm text-gray-400 mt-1">
                    This subreddit has a clean moderation record
                  </p>
                </div>
              ) : (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-3 flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4" />
                    Recent Removals ({subreddit.recentRemovals.length})
                  </h4>
                  <Table>
                    <TableHeader>
                      <TableRow className="border-gray-200">
                        <TableHead className="text-xs uppercase tracking-wide text-gray-500">ID</TableHead>
                        <TableHead className="text-xs uppercase tracking-wide text-gray-500">Removed At</TableHead>
                        <TableHead className="text-xs uppercase tracking-wide text-gray-500">Reason</TableHead>
                        <TableHead className="text-xs uppercase tracking-wide text-gray-500">Action</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {subreddit.recentRemovals.map((removal) => (
                        <TableRow key={removal.id} className="border-gray-100">
                          <TableCell className="font-mono text-xs text-gray-600">{removal.id}</TableCell>
                          <TableCell className="text-sm text-gray-700">{formatDateTime(removal.removedAt)}</TableCell>
                          <TableCell className="text-sm text-gray-700">{removal.reason}</TableCell>
                          <TableCell className="text-sm text-gray-500">
                            {removal.actionTaken || '—'}
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
client/src/hooks/use-admin-communities.ts
+20
-4

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import type { RedditCommunitySellingPolicy, RedditCommunityRuleSet } from '@shared/schema';
import type {
  RedditCommunitySellingPolicy,
  RedditCommunityRuleSet,
  LegacyRedditCommunityRuleSet,
} from '@shared/schema';
import { 
  type GrowthTrend,
  GROWTH_TRENDS,
  GROWTH_TREND_LABELS,
  getGrowthTrendLabel
} from '@shared/growth-trends';

export type { GrowthTrend } from '@shared/growth-trends';

export type PromotionPolicy = 'yes' | 'no' | 'limited' | 'subtle' | 'strict' | 'unknown';
// GrowthTrend type imported from @shared/growth-trends - uses canonical values: 'up' | 'stable' | 'down'
export type ActivityLevel = 'low' | 'medium' | 'high' | 'unknown';
export type CompetitionLevel = 'low' | 'medium' | 'high' | 'unknown';

// Re-export growth trend constants and labels for use by components
export { GROWTH_TRENDS, GROWTH_TREND_LABELS, getGrowthTrendLabel };

// Use the structured rule schema from shared/schema
export type CommunityRules = RedditCommunityRuleSet;

export interface PostingLimits {
  perDay?: number;
  perWeek?: number;
  cooldownHours?: number;
}

export interface AdminCommunity {
  id: string;
  name: string;
  displayName: string;
  category: string;
  members: number;
  engagementRate: number;
  verificationRequired: boolean;
  promotionAllowed: PromotionPolicy;
  postingLimits?: PostingLimits | null;
  rules?: CommunityRules | null;
  legacyRules?: LegacyRedditCommunityRuleSet | null;
  bestPostingTimes?: string[] | null;
  averageUpvotes?: number | null;
  successProbability?: number | null;
  growthTrend?: GrowthTrend | null;
  modActivity?: ActivityLevel | null;
  description?: string | null;
  tags?: string[] | null;
  competitionLevel?: CompetitionLevel | null;
}

export interface CommunityPayload {
  id?: string;
  name: string;
  displayName: string;
  category: string;
  members: number;
  engagementRate: number;
  verificationRequired: boolean;
  promotionAllowed: PromotionPolicy;
  postingLimits?: PostingLimits | null;
  rules?: Partial<CommunityRules> | null;
  bestPostingTimes?: string[] | null;
  averageUpvotes?: number | null;
  successProbability?: number | null;
  growthTrend?: GrowthTrend;
@@ -75,54 +80,65 @@ export interface CommunityFilters {
  promotionAllowed?: PromotionPolicy | 'all';
  verificationRequired?: 'all' | 'required' | 'not-required';
}

export function useAdminCommunities(filters?: CommunityFilters) {
  const queryParams = new URLSearchParams();

  if (filters?.search) {
    queryParams.set('search', filters.search);
  }
  if (filters?.category && filters.category !== 'all') {
    queryParams.set('category', filters.category);
  }
  if (filters?.promotionAllowed && filters.promotionAllowed !== 'all') {
    queryParams.set('promotionAllowed', filters.promotionAllowed);
  }
  if (filters?.verificationRequired && filters.verificationRequired !== 'all') {
    queryParams.set('verificationRequired', filters.verificationRequired === 'required' ? 'true' : 'false');
  }

  const queryString = queryParams.toString();
  const url = `/api/admin/communities${queryString ? `?${queryString}` : ''}`;

  return useQuery<AdminCommunity[]>({
    queryKey: ['admin-communities', filters],
    queryFn: () => fetch(url).then(res => {
    queryFn: async () => {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch communities');
      return res.json();
    }),
      const payload = await res.json();

      if (Array.isArray(payload)) {
        return payload as AdminCommunity[];
      }

      if (payload && Array.isArray((payload as { data?: unknown }).data)) {
        return (payload as { data: AdminCommunity[] }).data;
      }

      throw new Error('Unexpected response format when loading communities');
    },
  });
}

export function useCreateCommunity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CommunityPayload) => 
      apiRequest('POST', '/api/admin/communities', payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
  });
}

export function useUpdateCommunity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: CommunityPayload }) => 
      apiRequest('PUT', `/api/admin/communities/${id}`, payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
  });
server/advanced-content-generator.ts
+24
-8

@@ -2,50 +2,52 @@ import fs from 'fs/promises';
import path from 'path';

import {
  applyConversationalTone,
  buildConversationalToneConfig,
  type ConversationalToneConfig
} from './conversational-tone.js';
import {
  getCommunityVoicePack,
  sampleCommunityReference,
  type CommunityVoicePack
} from './community-voice-packs.js';
import {
  applyStoryPersonaSegments,
  getStoryPersona,
  type PersonaTone
} from './story-persona.js';
import { scoreAuthenticity, type AuthenticityScore } from './authenticity-metrics.js';
import {
  assignExperimentVariant,
  getExperimentDefinition,
  isTreatmentVariant,
  type ExperimentAssignment
} from './engagement-experiments.js';

type Mutable<T> = { -readonly [P in keyof T]: T[P] };

export interface HumanizationConfig {
  maxQuirks?: number;
  random?: () => number;
}

export interface ContentParameters {
  photoType: 'casual' | 'workout' | 'shower' | 'showing-skin' | 'spicy' | 'very-spicy' | 'all-xs' | 'needs_review';
  textTone: 'confident' | 'playful' | 'mysterious' | 'authentic' | 'sassy';
  style: string;
  includePromotion: boolean;
  selectedHashtags: string[];
  customPrompt?: string;
  platform: string;
  humanization?: HumanizationConfig;
  targetCommunity?: string;
  conversationalOverrides?: Partial<ConversationalToneConfig>;
  experiment?: ExperimentRequest;
  narrativePersonaOverride?: PersonaTone;
}

export interface PhotoInstructions {
  lighting: string;
  angles: string;
  composition: string;
  styling: string;
@@ -186,61 +188,75 @@ function resolveExperimentAssignment(
  random: () => number
): ExperimentAssignment | undefined {
  if (!request) {
    return undefined;
  }

  if (request.variant) {
    const definition = getExperimentDefinition(request.id);
    const controlVariant = definition?.controlVariant ?? 'control';
    return {
      id: request.id,
      variant: request.variant,
      isControl: request.variant === controlVariant
    };
  }

  return assignExperimentVariant(request.id, random);
}

function createConversationalToneConfig(
  params: ContentParameters,
  communityPack: CommunityVoicePack,
  experimentAssignment: ExperimentAssignment | undefined,
  random: () => number
): ConversationalToneConfig {
  const overrides: Partial<ConversationalToneConfig> = {
  type ToneOverrides = Partial<Mutable<ConversationalToneConfig>>;

  const baseOverrides: ToneOverrides = {
    ...params.conversationalOverrides
  };

  let overrides: ToneOverrides = baseOverrides;

  if (experimentAssignment) {
    const experimentalOverrides: ToneOverrides = { ...baseOverrides };

    if (isTreatmentVariant(experimentAssignment)) {
      overrides.voiceMarkerProbability = Math.max(overrides.voiceMarkerProbability ?? 0.6, 0.75);
      overrides.contractionProbability = Math.max(overrides.contractionProbability ?? 0.55, 0.65);
    } else if (overrides.voiceMarkerProbability === undefined) {
      overrides.voiceMarkerProbability = 0.45;
      experimentalOverrides.voiceMarkerProbability = Math.max(
        experimentalOverrides.voiceMarkerProbability ?? 0.6,
        0.75
      );
      experimentalOverrides.contractionProbability = Math.max(
        experimentalOverrides.contractionProbability ?? 0.55,
        0.65
      );
    } else if (experimentalOverrides.voiceMarkerProbability === undefined) {
      experimentalOverrides.voiceMarkerProbability = 0.45;
    }

    overrides = experimentalOverrides;
  }

  return buildConversationalToneConfig(communityPack, overrides, random, params.platform);
}

interface HumanizationOptions {
  maxQuirks?: number;
  random?: RandomGenerator;
}

interface HumanizationContext {
  random: RandomGenerator;
  toneStyle: ToneStyle;
}

interface HumanizationQuirk {
  chance: number;
  apply: (text: string, context: HumanizationContext) => string;
}

const LOWERCASE_INTERJECTIONS: readonly string[] = ['hmm', 'haha', 'um', 'oh'];

const SPELLING_VARIATIONS: Array<{ pattern: RegExp; replacement: string }> = [
  { pattern: /\bkind of\b/i, replacement: 'kinda' },
  { pattern: /\bsort of\b/i, replacement: 'sorta' },
@@ -1596,51 +1612,51 @@ async function loadPresetVariations(): Promise<Record<string, PresetVariation[]>
  }
}

let presetVariationsCache: Record<string, PresetVariation[]> | null = null;

async function getPresetVariations(): Promise<Record<string, PresetVariation[]>> {
  if (!presetVariationsCache) {
    presetVariationsCache = await loadPresetVariations();
  }
  return presetVariationsCache;
}

function getRandomPresetVariation(presetId: string): PresetVariation | null {
  // This is a synchronous version that returns null for non-preset requests
  // The async loading is handled elsewhere
  return null;
}

function generateTitles(
  params: ContentParameters,
  photoConfig: PhotoConfig,
  toneStyle: ToneStyle,
  profiles: Record<string, PlatformProfile>
): string[] {
  const profile = profiles[params.platform] ?? profiles.default;
  const maxSentenceLength = pickRandom(profile.maxSentenceLength);
  const maxSentenceLengths = profile.maxSentenceLength;
  const emojiCount = pickRandom(profile.emojiDensity);
  const callToAction = pickRandom(profile.callToActions);
  const context: PlatformPostProcessContext = {
    emojiPool: toneStyle.emojis,
    emojiCount
  };

  const desiredTitleCount = Math.floor(Math.random() * (MAX_TITLES - MIN_TITLES + 1)) + MIN_TITLES;
  const themes = photoConfig.themes;
  const starters = toneStyle.starters;
  const emojis = toneStyle.emojis;

  const connectorPool = (toneStyle.connectors ?? []).filter(connector => connector.trim().length > 0);
  const connectors = connectorPool.length > 0 ? connectorPool : fallbackConnectors;
  const basePatterns = toneStyle.titlePatterns && toneStyle.titlePatterns.length > 0 ? toneStyle.titlePatterns : fallbackTitlePatterns;
  const specialPatterns: TitlePatternDefinition[] = [];
  const readablePhotoType = params.photoType.replace(/-/g, ' ');

  if (params.photoType === 'all-xs') {
    specialPatterns.push(
      { template: 'Warning: {theme} content ahead - not for everyone{punct}{emoji}', type: 'statement', emojiProbability: 0.5 },
      { template: '{starter} the limits are gone tonight{punct}{emoji}', type: 'statement', emojiProbability: 0.6 }
    );
  } else if (params.photoType === 'very-spicy') {
    specialPatterns.push(
@@ -1699,53 +1715,53 @@ function generateTitles(
      const fallbackTheme = randomFromArray(themes);
      const fallbackPattern = fallbackTitlePatterns[generatedTitles.size % fallbackTitlePatterns.length];
      const fallbackContext: TitlePatternContext = {
        starter: fallbackStarter,
        theme: fallbackTheme,
        altTheme: pickAlternateTheme(themes, fallbackTheme),
        connector: randomFromArray(connectors),
        emoji: selectEmoji(emojis, DEFAULT_EMOJI_PROBABILITY),
        punctuation: choosePunctuation(fallbackPattern.type),
        hedge: fallbackPattern.template.includes('{hedge}') ? randomFromArray(hedgeOptions) : '',
        photoType: readablePhotoType
      };

      generatedTitles.add(renderTitleFromPattern(fallbackPattern, fallbackContext));
    }
  }

  const titles = shuffleArray(Array.from(generatedTitles));

  if (titles.length > 0) {
    titles[0] = `${titles[0]} ${callToAction}`.trim();
  }

  const processedTitles = titles
    .map(title => applyEmojiDensity(title, emojis, emojiCount))
    .map(title => clampSentenceLength(title, maxSentenceLength))
    .map(title => clampSentenceLength(title, maxSentenceLengths))
    .map(title => (profile.postProcessTitle ? profile.postProcessTitle(title, context) : title))
    .map(title => clampSentenceLength(title, maxSentenceLength));
    .map(title => clampSentenceLength(title, maxSentenceLengths));

  return processedTitles.slice(0, desiredTitleCount);
}

function generateMainContent(
  params: ContentParameters,
  photoConfig: PhotoConfig,
  toneStyle: ToneStyle,
  experimentAssignment: ExperimentAssignment | undefined
): MainContentBuildResult {
  const themes = photoConfig.themes;
  const settings = photoConfig.settings;
  const descriptors = toneStyle.descriptors;
  const endings = toneStyle.endings;
  const emojis = toneStyle.emojis;
  const personalTone = personalToneConfigs[params.textTone];
  const profile = platformProfiles[params.platform] ?? platformProfiles.default;
  const random = params.humanization?.random ?? Math.random;
  const communityPack = getCommunityVoicePack(params.targetCommunity, params.platform);
  const persona = getStoryPersona(resolvePersonaTone(params));

  const segments: string[] = [];
  const starter = pickRandom(toneStyle.starters);
  const opener = pickRandom(personalTone.openers);
  const descriptor = pickRandom(descriptors);
shared/schema.ts
+3
-1

@@ -324,50 +324,51 @@ export const contentRulesSchema = z.object({
}).optional();

export const postingRulesSchema = z.object({
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional(),
}).optional();

// New structured rule schema
export const redditCommunityRuleSetSchema = z.object({
  eligibility: eligibilityRulesSchema,
  content: contentRulesSchema,
  posting: postingRulesSchema,
  notes: z.string().nullable().optional(),
}).optional();

// Legacy schema for backwards compatibility
export const legacyRedditCommunityRuleSetSchema = z.object({
  minKarma: z.number().nullable().optional(),
  minAccountAge: z.number().nullable().optional(), // in days (legacy)
  minAccountAgeDays: z.number().nullable().optional(), // in days (new)
  watermarksAllowed: z.boolean().nullable().optional(),
  sellingAllowed: redditCommunitySellingPolicySchema.optional(),
  promotionalLinksAllowed: ruleAllowanceSchema.optional(),
  titleRules: z.array(z.string()).optional().default([]),
  contentRules: z.array(z.string()).optional().default([]),
  linkRestrictions: z.array(z.string()).optional().default([]),
  bannedContent: z.array(z.string()).optional().default([]),
  formattingRequirements: z.array(z.string()).optional().default([]),
  notes: z.string().optional(),
  verificationRequired: z.boolean().optional(),
  requiresApproval: z.boolean().optional(),
  requiresOriginalContent: z.boolean().optional(),
  nsfwRequired: z.boolean().optional(),
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional()
}).optional();

export type RedditCommunityRuleSet = z.infer<typeof redditCommunityRuleSetSchema>;
export type EligibilityRules = z.infer<typeof eligibilityRulesSchema>;
export type ContentRules = z.infer<typeof contentRulesSchema>;
export type PostingRules = z.infer<typeof postingRulesSchema>;
export type LegacyRedditCommunityRuleSet = z.infer<typeof legacyRedditCommunityRuleSetSchema>;

// Posting limits schema
export const postingLimitsSchema = z.object({
  perDay: z.number().nullable().optional(),
  perWeek: z.number().nullable().optional(),
  daily: z.number().nullable().optional(), // legacy support
  weekly: z.number().nullable().optional(), // legacy support
  cooldownHours: z.number().nullable().optional()
}).nullable().optional();
@@ -418,50 +419,51 @@ export const createDefaultRules = (): RedditCommunityRuleSet => ({
    requiresOriginalContent: false,
    nsfwRequired: false,
    titleGuidelines: [],
    contentGuidelines: [],
    linkRestrictions: [],
    bannedContent: [],
    formattingRequirements: [],
  },
  posting: {
    maxPostsPerDay: null,
    cooldownHours: null,
  },
  notes: null,
});

// Legacy default rule factory for backwards compatibility
export const createDefaultLegacyRules = (): LegacyRedditCommunityRuleSet => ({
  minKarma: null,
  minAccountAge: null,
  minAccountAgeDays: null,
  watermarksAllowed: null,
  sellingAllowed: undefined,
  promotionalLinksAllowed: undefined,
  titleRules: [],
  contentRules: [],
  linkRestrictions: [],
  bannedContent: [],
  formattingRequirements: [],
  notes: undefined,
  verificationRequired: false,
  requiresApproval: false,
  requiresOriginalContent: false,
  nsfwRequired: false,
  maxPostsPerDay: null,
  cooldownHours: null
});

export const redditCommunities = pgTable("reddit_communities", {
  id: varchar("id", { length: 100 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  displayName: varchar("display_name", { length: 255 }).notNull(),
  members: integer("members").notNull(),
  engagementRate: integer("engagement_rate").notNull(),
  category: varchar("category", { length: 50 }).notNull(),
  verificationRequired: boolean("verification_required").default(false).notNull(),
  promotionAllowed: varchar("promotion_allowed", { length: 20 }).default("no").notNull(),
  postingLimits: jsonb("posting_limits"),
  rules: jsonb("rules").$type<RedditCommunityRuleSet>(),
  bestPostingTimes: jsonb("best_posting_times").$type<string[]>(),
  averageUpvotes: integer("average_upvotes"),
  successProbability: integer("success_probability"),
@@ -472,51 +474,51 @@ export const redditCommunities = pgTable("reddit_communities", {
  competitionLevel: varchar("competition_level", { length: 20 })
});
export type RedditCommunity = typeof redditCommunities.$inferSelect;
export type InsertRedditCommunity = typeof redditCommunities.$inferInsert;
export const insertRedditCommunitySchema = createInsertSchema(redditCommunities);

// Helper function to normalize legacy rules to structured rules
export const normalizeRulesToStructured = (legacyRules: LegacyRedditCommunityRuleSet | null | undefined): RedditCommunityRuleSet | null => {
  if (!legacyRules) return null;
  
  return {
    eligibility: {
      minKarma: legacyRules.minKarma ?? null,
      minAccountAgeDays: legacyRules.minAccountAgeDays ?? legacyRules.minAccountAge ?? null,
      verificationRequired: legacyRules.verificationRequired ?? false,
      requiresApproval: legacyRules.requiresApproval ?? false,
    },
    content: {
      sellingPolicy: legacyRules.sellingAllowed,
      watermarksAllowed: legacyRules.watermarksAllowed ?? null,
      promotionalLinks: legacyRules.promotionalLinksAllowed ?? null,
      requiresOriginalContent: legacyRules.requiresOriginalContent ?? false,
      nsfwRequired: legacyRules.nsfwRequired ?? false,
      titleGuidelines: legacyRules.titleRules ?? [],
      contentGuidelines: legacyRules.contentRules ?? [],
      linkRestrictions: [],
      linkRestrictions: legacyRules.linkRestrictions ?? [],
      bannedContent: legacyRules.bannedContent ?? [],
      formattingRequirements: legacyRules.formattingRequirements ?? [],
    },
    posting: {
      maxPostsPerDay: legacyRules.maxPostsPerDay ?? null,
      cooldownHours: legacyRules.cooldownHours ?? null,
    },
    notes: legacyRules.notes ?? null,
  };
};

// Helper function to infer selling policy from rules
export const inferSellingPolicyFromRules = (rules: RedditCommunityRuleSet | null): RedditCommunitySellingPolicy => {
  if (!rules?.content?.sellingPolicy) return 'unknown';
  return rules.content.sellingPolicy;
};

export const subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).unique().notNull(),
  status: varchar("status", { length: 20 }).notNull(), // "active" | "past_due" | "canceled"
  plan: varchar("plan", { length: 20 }).notNull(), // "free" | "pro"
  priceCents: integer("price_cents").notNull(),
  processor: varchar("processor", { length: 20 }).notNull(), // "ccbill" | "segpay" | "epoch" | "crypto"
  processorSubId: varchar("processor_sub_id", { length: 255 }),
tsconfig.json
+1
-2

{
  "include": [
    "server/**/*.ts",
    "shared/**/*.ts", 
    "client/**/*.ts",
    "client/**/*.tsx",
    "client/vite-env.d.ts"
  ],
  "exclude": ["node_modules", "dist"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "incremental": false,
    "noEmit": false,
    "module": "ESNext",
    "target": "ES2022",
    "strict": false,
    "skipLibCheck": true,
    "noImplicitAny": false,
    "strictNullChecks": false,
    "strictFunctionTypes": false,
    "strictBindCallApply": false,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "downlevelIteration": true,
    "baseUrl": ".",
    "rootDir": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@shared/*": ["shared/*"],
      "@server/*": ["server/*"],
      "@/*": ["client/src/*"]
    },
    "preserveSymlinks": true,
    "outDir": "dist"