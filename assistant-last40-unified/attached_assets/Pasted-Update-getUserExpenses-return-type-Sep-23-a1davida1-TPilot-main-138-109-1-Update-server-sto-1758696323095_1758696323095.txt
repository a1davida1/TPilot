Update getUserExpenses return type
Sep 23 · a1davida1/TPilot · main ·
+138-109
1. Update `server/storage.ts` so `getUserExpenses` returns `Promise<Array<Expense & { category: ExpenseCategory | null }>>` at both the interface signature and the `DatabaseStorage` implementation (adjust the `async` method signature and keep the existing mapping logic). A patch template:

   ```diff
   diff --git a/server/storage.ts b/server/storage.ts
   @@
   -  getUserExpenses(userId: number, taxYear?: number): Promise<Expense[]>;
   +  getUserExpenses(
   +    userId: number,
   +    taxYear?: number
   +  ): Promise<Array<Expense & { category: ExpenseCategory | null }>>;
   @@
   -  async getUserExpenses(userId: number, taxYear?: number): Promise<Expense[]> {
   +  async getUserExpenses(
   +    userId: number,
   +    taxYear?: number
   +  ): Promise<Array<Expense & { category: ExpenseCategory | null }>> {
   ```

2. Leave `tests/_helpers/buildStorageMock.ts` untouched—the mapped type will now compile cleanly once the interface’s return type matches the implementation.

3. Rewrite the `getUserExpenses` expectations in `tests/unit/expenses/expense-operations.test.ts` to assert the flattened object shape (spread `expense` fields and nested `category`) instead of `{ expense, category }` tuples; update any helper fixtures used by other suites to match.

4. Run `npm run typecheck`, `npm run lint`, and `npm test` to confirm the stronger typing and adjusted fixtures hold across the suite before merging.

Summary

    In DatabaseStorage.getUserExpenses, captured the joined query results in a typed flattenedResults array so the method now naturally returns expenses merged with their optional categories, aligning with the strengthened storage interface signature and removing the old type assertion.

Reworked the expense operations unit tests to build explicit Expense and ExpenseCategory fixtures, compose flattened expectations with category data, and assert on the merged object shape to reflect the updated contract.

Testing

    ❌ npm run typecheck *(fails on pre-existing Reddit community schema and referral manager typing issues)*

✅ npm run lint *(completes with existing repository warnings about any usage and unused symbols)*

❌ npm test *(wide suite reports numerous prior failures across admin community, referral, upload, and integration specs; run terminated after confirming our updated unit suite passes)*


server/storage.ts
+7-4
@@ -800,54 +800,57 @@ export class DatabaseStorage implements IStorage {
      return result;
    } catch (error) {
      console.error('Error creating expense:', { error: (error as Error).message });
      throw error;
    }
  }

  async getUserExpenses(
    userId: number,
    taxYear?: number
  ): Promise<Array<Expense & { category: ExpenseCategory | null }>> {
    try {
      const query = db.select({
        expense: expenses,
        category: expenseCategories
      })
      .from(expenses)
      .leftJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id))
      .where(
        taxYear 
          ? and(eq(expenses.userId, userId), eq(expenses.taxYear, taxYear))
          : eq(expenses.userId, userId)
      );

      const results = await query.orderBy(desc(expenses.expenseDate));
      return results.map(r => ({
        ...r.expense,
        category: r.category
      })) as (Expense & { category: ExpenseCategory | null })[];
      const flattenedResults: Array<Expense & { category: ExpenseCategory | null }> =
        results.map(({ expense, category }) => ({
          ...expense,
          category,
        }));

      return flattenedResults;
    } catch (error) {
      console.error('Error getting user expenses:', { error: (error as Error).message });
      return [];
    }
  }

  async getExpense(id: number, userId: number): Promise<Expense | undefined> {
    try {
      const [result] = await db.select().from(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
      return result;
    } catch (error) {
      console.error('Error getting expense:', { error: (error as Error).message });
      return undefined;
    }
  }

  async updateExpense(id: number, userId: number, updates: Partial<Expense>): Promise<Expense> {
    try {
      let updatesToApply: Partial<Expense> = { ...updates };
      const businessPurposeValue = updates.businessPurpose;
      const hasEmptyBusinessPurpose =
        typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0;

      if (hasEmptyBusinessPurpose) {
tests/unit/expenses/expense-operations.test.ts
+131-105
@@ -269,156 +269,182 @@ describe('Expense Operations Unit Tests', () => {
        ...updates,
        updatedAt: new Date()
      };

      mockStorage.updateExpense.mockResolvedValueOnce(updatedExpense);

      const result = await storage.updateExpense(expenseId, userId, updates);

      expect(result.amount).toBe(12000);
      expect(result.description).toBe('Updated description');
      expect(mockStorage.updateExpense).toHaveBeenCalledWith(expenseId, userId, updates);
    });

    test('should handle update error', async () => {
      const expenseId = 4;
      const updates = { amount: 15000 };

      mockStorage.updateExpense.mockRejectedValueOnce(new Error('Update failed'));

      await expect(storage.updateExpense(expenseId, userId, updates)).rejects.toThrow('Update failed');
    });
  });

  describe('getUserExpenses', () => {
    test('should fetch user expenses with category information', async () => {
      const mockExpensesWithCategories = [
      const expense = {
        id: 1,
        userId,
        categoryId: 1,
        amount: 75000,
        description: 'Camera lens',
        vendor: null,
        expenseDate: new Date('2024-01-15'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 100,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2024,
        notes: null,
        createdAt: new Date('2024-01-20'),
        updatedAt: new Date('2024-01-20')
      } satisfies Expense;

      const category = {
        id: 1,
        name: 'Technology',
        description: 'Equipment and technology purchases',
        legalExplanation: 'Equipment deduction',
        deductionPercentage: 100,
        itsDeductionCode: null,
        examples: [],
        icon: 'tech',
        color: '#000000',
        isActive: true,
        sortOrder: 1,
        defaultBusinessPurpose: null,
        createdAt: new Date('2024-01-01')
      } satisfies ExpenseCategory;

      const expensesWithCategories: Array<Expense & { category: ExpenseCategory | null }> = [
        {
          id: 1,
          userId,
          categoryId: 1,
          amount: 75000,
          description: 'Camera lens',
          vendor: null,
          expenseDate: new Date('2024-01-15'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 100,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2024,
          notes: null,
          createdAt: new Date('2024-01-20'),
          updatedAt: new Date('2024-01-20'),
          category: {
            id: 1,
            name: 'Technology',
            description: 'Equipment and technology purchases',
            legalExplanation: 'Equipment deduction',
            deductionPercentage: 100,
            itsDeductionCode: null,
            examples: [],
            icon: 'tech',
            color: '#000000',
            isActive: true,
            sortOrder: 1,
            defaultBusinessPurpose: null,
            createdAt: new Date('2024-01-01')
          }
          ...expense,
          category
        }
      ] satisfies Array<Expense & { category: ExpenseCategory | null }>;
      ];

      mockStorage.getUserExpenses.mockResolvedValueOnce(mockExpensesWithCategories);
      mockStorage.getUserExpenses.mockResolvedValueOnce(expensesWithCategories);

      const result = await storage.getUserExpenses(userId, 2024);

      expect(result).toEqual(mockExpensesWithCategories);
      expect(result).toEqual(expensesWithCategories);
      expect(result[0]).toMatchObject({
        ...expense,
        category
      });
      expect(result[0]?.category?.name).toBe('Technology');
      expect(mockStorage.getUserExpenses).toHaveBeenCalledWith(userId, 2024);
    });

    test('should fetch expenses without tax year filter', async () => {
      const mockAllExpenses = [
      const firstExpense = {
        id: 1,
        userId,
        categoryId: 2,
        amount: 12000,
        description: 'Expense 1',
        vendor: null,
        expenseDate: new Date('2023-03-10'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 80,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2023,
        notes: null,
        createdAt: new Date('2023-03-11'),
        updatedAt: new Date('2023-03-11')
      } satisfies Expense;

      const firstCategory = {
        id: 2,
        name: 'Education',
        description: 'Courses and learning materials',
        legalExplanation: 'Education deduction',
        deductionPercentage: 80,
        itsDeductionCode: null,
        examples: ['Online courses'],
        icon: 'book',
        color: '#FFAA00',
        isActive: true,
        sortOrder: 2,
        defaultBusinessPurpose: null,
        createdAt: new Date('2023-01-01')
      } satisfies ExpenseCategory;

      const secondExpense = {
        id: 2,
        userId,
        categoryId: 3,
        amount: 8500,
        description: 'Expense 2',
        vendor: null,
        expenseDate: new Date('2024-02-05'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 100,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2024,
        notes: null,
        createdAt: new Date('2024-02-06'),
        updatedAt: new Date('2024-02-06')
      } satisfies Expense;

      const secondCategory = {
        id: 3,
        name: 'Travel',
        description: 'Business travel expenses',
        legalExplanation: 'Travel deduction',
        deductionPercentage: 100,
        itsDeductionCode: null,
        examples: ['Flights', 'Hotels'],
        icon: 'plane',
        color: '#3366FF',
        isActive: true,
        sortOrder: 3,
        defaultBusinessPurpose: null,
        createdAt: new Date('2024-01-05')
      } satisfies ExpenseCategory;

      const mockAllExpenses: Array<Expense & { category: ExpenseCategory | null }> = [
        {
          id: 1,
          userId,
          categoryId: 2,
          amount: 12000,
          description: 'Expense 1',
          vendor: null,
          expenseDate: new Date('2023-03-10'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 80,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2023,
          notes: null,
          createdAt: new Date('2023-03-11'),
          updatedAt: new Date('2023-03-11'),
          category: {
            id: 2,
            name: 'Education',
            description: 'Courses and learning materials',
            legalExplanation: 'Education deduction',
            deductionPercentage: 80,
            itsDeductionCode: null,
            examples: ['Online courses'],
            icon: 'book',
            color: '#FFAA00',
            isActive: true,
            sortOrder: 2,
            defaultBusinessPurpose: null,
            createdAt: new Date('2023-01-01')
          }
          ...firstExpense,
          category: firstCategory
        },
        {
          id: 2,
          userId,
          categoryId: 3,
          amount: 8500,
          description: 'Expense 2',
          vendor: null,
          expenseDate: new Date('2024-02-05'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 100,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2024,
          notes: null,
          createdAt: new Date('2024-02-06'),
          updatedAt: new Date('2024-02-06'),
          category: {
            id: 3,
            name: 'Travel',
            description: 'Business travel expenses',
            legalExplanation: 'Travel deduction',
            deductionPercentage: 100,
            itsDeductionCode: null,
            examples: ['Flights', 'Hotels'],
            icon: 'plane',
            color: '#3366FF',
            isActive: true,
            sortOrder: 3,
            defaultBusinessPurpose: null,
            createdAt: new Date('2024-01-05')
          }
          ...secondExpense,
          category: secondCategory
        }
      ] satisfies Array<Expense & { category: ExpenseCategory | null }>;
      ];

      mockStorage.getUserExpenses.mockResolvedValueOnce(mockAllExpenses);

      const result = await storage.getUserExpenses(userId);

      expect(result).toEqual(mockAllExpenses);
      expect(result[0]).toMatchObject({
        ...firstExpense,
        category: firstCategory
      });
      expect(result).toHaveLength(2);
      expect(mockStorage.getUserExpenses).toHaveBeenCalledWith(userId);
    });
  });
});
