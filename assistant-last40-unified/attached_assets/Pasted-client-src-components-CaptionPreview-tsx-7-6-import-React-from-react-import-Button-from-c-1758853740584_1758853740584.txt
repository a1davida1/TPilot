client/src/components/CaptionPreview.tsx
+7-6
import React from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Copy, Check, AlertCircle } from "lucide-react";
import { useState } from "react";
import type { CaptionObject, RankedResult, CaptionPreviewData } from '@shared/types/caption';

// Re-export types from shared module for backward compatibility
export type { CaptionObject, RankedResult, CaptionPreviewData } from '@shared/types/caption';

export function CaptionPreview({ data }: { data: CaptionPreviewData | null | undefined }) {
  const [copiedCaption, setCopiedCaption] = useState(false);
  const [copiedJSON, setCopiedJSON] = useState(false);


  if (!data) return null;
  
  const { final = '', ranked = [] } = data || {};
  if (!final) return null;
  

  // Handle different data formats - final could be a string or object with caption property
  const captionText = typeof final === 'string' ? final : final.caption;
  const charCount = captionText ? captionText.length : 0;
  
  const captionText = typeof final === 'string' ? final : final.caption ?? '';
  if (!captionText) return null;

  const normalizedCaption = String(captionText);
  const charCount = normalizedCaption.length;

  const handleCopyCaption = async () => {
    await navigator.clipboard.writeText(captionText);
    await navigator.clipboard.writeText(normalizedCaption);
    setCopiedCaption(true);
    setTimeout(() => setCopiedCaption(false), 2000);
  };

  const handleCopyJSON = async () => {
    await navigator.clipboard.writeText(JSON.stringify(final, null, 2));
    setCopiedJSON(true);
    setTimeout(() => setCopiedJSON(false), 2000);
  };

  return (
    <Card className="rounded-2xl bg-white/60 dark:bg-gray-900/60 backdrop-blur-sm">
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="text-lg font-semibold">Caption Preview</CardTitle>
          <Badge variant="outline" className="font-mono">
            {charCount} chars
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Main Caption */}
        <div className="p-4 bg-gradient-to-r from-pink-50 to-purple-50 dark:from-pink-950/20 dark:to-purple-950/20 rounded-lg">
          <p className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap leading-relaxed">
            {captionText}
            {normalizedCaption}
          </p>
        </div>

        {/* ALT Text */}
        {typeof final === 'object' && final.alt && (
          <div className="space-y-1">
            <p className="text-xs font-medium text-gray-500 dark:text-gray-400">ALT Text</p>
            <p className="text-xs text-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-gray-800 p-2 rounded">
              {final.alt}
            </p>
          </div>
        )}

        {/* Hashtags */}
        {typeof final === 'object' && final.hashtags && final.hashtags.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {final.hashtags.map((h: string, index: number) => (
              <Badge 
                key={`${h}-${index}`} 
                variant="secondary" 
                className="text-xs bg-gradient-to-r from-pink-100 to-purple-100 dark:from-pink-900/30 dark:to-purple-900/30"
              >
                {h}
              </Badge>
            ))}
client/src/components/__tests__/sample-upload.test.tsx
+1-1
@@ -163,51 +163,51 @@ async function findByTestId(testId: string): Promise<HTMLElement> {
    const element = queryByTestId(testId);
    if (!element) {
      throw new Error("Test id not found");
    }
    return element;
  });
}

function getButtonByText(matcher: string | RegExp): HTMLButtonElement {
  const button = Array.from(document.body.querySelectorAll("button") as NodeListOf<HTMLButtonElement>).find((element) =>
    textMatches(element.textContent?.trim() ?? "", matcher),
  );
  if (!button) {
    throw new Error(`Button with text ${String(matcher)} not found`);
  }
  return button;
}

function click(element: HTMLElement) {
  act(() => {
    element.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true }));
  });
}

const clipboardDescriptor = Object.getOwnPropertyDescriptor(navigator, "clipboard");
const clipboardWriteMock = vi.fn<[], Promise<void>>();
const clipboardWriteMock = vi.fn<() => Promise<void>>();

describe("SampleUpload", () => {
  beforeEach(() => {
    cleanup();
    mockUseQuery.mockReset();
    mockUseMutation.mockReset();
    toastMock.mockReset();
    invalidateQueriesMock.mockReset();
    apiRequestMock.mockReset();
    clipboardWriteMock.mockReset();

    mockUseMutation.mockImplementation(() => ({ mutate: vi.fn(), isPending: false }));

    Object.defineProperty(navigator, "clipboard", {
      configurable: true,
      value: {
        writeText: clipboardWriteMock,
      },
    });
  });

  afterEach(() => {
    cleanup();
  });

client/src/components/admin-portal.tsx
+4-4
@@ -130,53 +130,53 @@ interface TrialRequest {
  duration: number;
  tier: 'starter' | 'pro';
}

interface AdminActionRequest {
  userId: number;
  action: 'ban' | 'suspend' | 'unban' | 'reset-password' | 'force-logout';
  reason?: string;
  duration?: string;
  hours?: number;
}

interface PasswordResetResponse {
  tempPassword: string;
}

export function AdminPortal() {
  const [trialForm, setTrialForm] = useState<TrialRequest>({
    email: '',
    username: '',
    duration: 30,
    tier: 'starter'
  });
  const [selectedUser, setSelectedUser] = useState<UserData | null>(null);
  const [actionType, setActionType] = useState<string | null>(null);
  const [_duration, _setDuration] = useState<string>('24');
  const [_tempPassword, _setTempPassword] = useState<string>('');
  const [_reason, _setReason] = useState<string>('');
  const [duration, setDuration] = useState<string>('24');
  const [tempPassword, setTempPassword] = useState<string>('');
  const [reason, setReason] = useState<string>('');
  const { toast } = useToast();
  const { user: currentUser } = useAuth();
  
  // Authenticated API request with cookie-based auth
  const authenticatedRequest = async (url: string, method: string = 'GET', data?: unknown) => {
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include', // Include cookies for session-based auth
      body: data ? JSON.stringify(data) : undefined
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.message || errorText;
      } catch {
        errorMessage = errorText || response.statusText;
      }
      throw new Error(errorMessage);
    }
@@ -270,51 +270,51 @@ export function AdminPortal() {
  };

  const getTierColor = (tier: string) => {
    switch (tier) {
      case 'admin': return 'bg-gradient-to-r from-red-600 to-orange-600 text-white';
      case 'pro': return 'bg-gradient-to-r from-purple-600 to-pink-600 text-white';
      case 'starter': return 'bg-gradient-to-r from-blue-600 to-cyan-600 text-white';
      case 'free': return 'bg-gray-100 text-gray-800 border border-gray-300';
      default: return 'bg-gray-100 text-gray-800 border border-gray-300';
    }
  };

  const _handleAction = () => {
    if (!selectedUser || !actionType) return;
    
    const userWithId = selectedUser as { id: number };
    if (actionType === 'reset-password') {
      actionMutation.mutate({ 
        userId: userWithId.id, 
        action: actionType 
      });
    } else {
      actionMutation.mutate({ 
        userId: userWithId.id, 
        action: actionType, 
        duration: actionType === 'suspend' ? _duration : undefined 
        duration: actionType === 'suspend' ? duration : undefined
      });
    }
  };

  return (
    <div className="w-full max-w-7xl mx-auto space-y-6 p-4">
      {/* Header */}
      <Card className="bg-gradient-to-r from-purple-600/10 via-pink-600/10 to-blue-600/10 border-purple-500/20">
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-3xl flex items-center gap-3">
                <Shield className="h-8 w-8 text-purple-600" />
                Admin Control Center
              </CardTitle>
              <CardDescription className="text-base mt-2">
                Manage users, create trials, and monitor platform performance
              </CardDescription>
            </div>
            <Badge className="bg-gradient-to-r from-purple-600 to-pink-600 text-white px-4 py-2">
              <Crown className="h-4 w-4 mr-2" />
              ADMIN ACCESS
            </Badge>
          </div>
        </CardHeader>
client/src/components/admin/admin-communities-panel.tsx
+1-1
@@ -181,51 +181,51 @@ function formToPayload(formState: CommunityFormState): CommunityPayload {
    name: formState.name,
    displayName: formState.displayName,
    category: formState.category,
    members: parseNumber(formState.members) || 0,
    engagementRate: parseNumber(formState.engagementRate) || 0,
    verificationRequired: formState.verificationRequired,
    promotionAllowed: formState.promotionAllowed,
    postingLimits: Object.values(postingLimits).some(v => v !== undefined) ? postingLimits : null,
    rules: Object.values(rules).some(section => section && Object.values(section).some(v => v !== undefined && v !== null)) ? rules : null,
    bestPostingTimes: parseList(formState.bestPostingTimes),
    averageUpvotes: parseNumber(formState.averageUpvotes),
    successProbability: parseNumber(formState.successProbability),
    growthTrend: formState.growthTrend,
    modActivity: formState.modActivity,
    description: formState.description || null,
    tags: parseList(formState.tags),
    competitionLevel: formState.competitionLevel,
  };
}

function communityToForm(community: AdminCommunity): CommunityFormState {
  const { eligibility, content, posting, legacy } = getRuleContext(community);
  const postingLimits = community.postingLimits ?? null;
  const titleGuidelines = content?.titleGuidelines ?? legacy?.titleRules ?? [];
  const contentGuidelines = content?.contentGuidelines ?? legacy?.contentRules ?? [];
  const linkRestrictions = content?.linkRestrictions ?? [] as string[];
  const linkRestrictions = content?.linkRestrictions ?? legacy?.linkRestrictions ?? [];
  const watermarksAllowed = content?.watermarksAllowed ?? legacy?.watermarksAllowed ?? null;
  const sellingPolicy = content?.sellingPolicy ?? legacy?.sellingAllowed ?? undefined;
  const minKarma = eligibility?.minKarma ?? legacy?.minKarma ?? null;
  const minAccountAge =
    eligibility?.minAccountAgeDays ?? legacy?.minAccountAge ?? legacy?.minAccountAgeDays ?? null;
  const maxPostsPerDay =
    postingLimits?.perDay ?? posting?.maxPostsPerDay ?? legacy?.maxPostsPerDay ?? null;
  const maxPostsPerWeek = postingLimits?.perWeek ?? null;
  const cooldownHours =
    postingLimits?.cooldownHours ?? posting?.cooldownHours ?? legacy?.cooldownHours ?? null;

  return {
    id: community.id,
    name: community.name,
    displayName: community.displayName,
    category: community.category,
    members: String(community.members ?? ''),
    engagementRate: String(community.engagementRate ?? ''),
    verificationRequired: community.verificationRequired,
    promotionAllowed: community.promotionAllowed,
    postingLimitsPerDay: toStringValue(maxPostsPerDay),
    postingLimitsPerWeek: toStringValue(maxPostsPerWeek),
    postingLimitsCooldownHours: toStringValue(cooldownHours),
    rulesMinKarma: toStringValue(minKarma),
    rulesMinAccountAge: toStringValue(minAccountAge),
server/advanced-content-generator.ts
+2-0
@@ -2,50 +2,52 @@ import fs from 'fs/promises';
import path from 'path';

import {
  applyConversationalTone,
  buildConversationalToneConfig,
  type ConversationalToneConfig
} from './conversational-tone.js';
import {
  getCommunityVoicePack,
  sampleCommunityReference,
  type CommunityVoicePack
} from './community-voice-packs.js';
import {
  applyStoryPersonaSegments,
  getStoryPersona,
  type PersonaTone
} from './story-persona.js';
import { scoreAuthenticity, type AuthenticityScore } from './authenticity-metrics.js';
import {
  assignExperimentVariant,
  getExperimentDefinition,
  isTreatmentVariant,
  type ExperimentAssignment
} from './engagement-experiments.js';

type Mutable<T> = { -readonly [K in keyof T]: T[K] };

export interface HumanizationConfig {
  maxQuirks?: number;
  random?: () => number;
}

export interface ContentParameters {
  photoType: 'casual' | 'workout' | 'shower' | 'showing-skin' | 'spicy' | 'very-spicy' | 'all-xs' | 'needs_review';
  textTone: 'confident' | 'playful' | 'mysterious' | 'authentic' | 'sassy';
  style: string;
  includePromotion: boolean;
  selectedHashtags: string[];
  customPrompt?: string;
  platform: string;
  humanization?: HumanizationConfig;
  targetCommunity?: string;
  conversationalOverrides?: Partial<ConversationalToneConfig>;
  experiment?: ExperimentRequest;
  narrativePersonaOverride?: PersonaTone;
}

export interface PhotoInstructions {
  lighting: string;
  angles: string;
  composition: string;
  styling: string;
shared/schema.ts
+3-1
@@ -387,50 +387,51 @@ export const contentRulesSchema = z.object({
}).optional();

export const postingRulesSchema = z.object({
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional(),
}).optional();

// New structured rule schema
export const redditCommunityRuleSetSchema = z.object({
  eligibility: eligibilityRulesSchema,
  content: contentRulesSchema,
  posting: postingRulesSchema,
  notes: z.string().nullable().optional(),
}).optional();

// Legacy schema for backwards compatibility
export const legacyRedditCommunityRuleSetSchema = z.object({
  minKarma: z.number().nullable().optional(),
  minAccountAge: z.number().nullable().optional(), // in days (legacy)
  minAccountAgeDays: z.number().nullable().optional(), // in days (new)
  watermarksAllowed: z.boolean().nullable().optional(),
  sellingAllowed: redditCommunitySellingPolicySchema.optional(),
  promotionalLinksAllowed: ruleAllowanceSchema.optional(),
  titleRules: z.array(z.string()).optional().default([]),
  contentRules: z.array(z.string()).optional().default([]),
  linkRestrictions: z.array(z.string()).optional().default([]),
  bannedContent: z.array(z.string()).optional().default([]),
  formattingRequirements: z.array(z.string()).optional().default([]),
  notes: z.string().optional(),
  verificationRequired: z.boolean().optional(),
  requiresApproval: z.boolean().optional(),
  requiresOriginalContent: z.boolean().optional(),
  nsfwRequired: z.boolean().optional(),
  maxPostsPerDay: z.number().nullable().optional(),
  cooldownHours: z.number().nullable().optional()
}).optional();

export type RedditCommunityRuleSet = z.infer<typeof redditCommunityRuleSetSchema>;
export type EligibilityRules = z.infer<typeof eligibilityRulesSchema>;
export type ContentRules = z.infer<typeof contentRulesSchema>;
export type PostingRules = z.infer<typeof postingRulesSchema>;
export type LegacyRedditCommunityRuleSet = z.infer<typeof legacyRedditCommunityRuleSetSchema>;

// Posting limits schema
export const postingLimitsSchema = z.object({
  perDay: z.number().nullable().optional(),
  perWeek: z.number().nullable().optional(),
  daily: z.number().nullable().optional(), // legacy support
  weekly: z.number().nullable().optional(), // legacy support
  cooldownHours: z.number().nullable().optional()
}).nullable().optional();
@@ -481,50 +482,51 @@ export const createDefaultRules = (): RedditCommunityRuleSet => ({
    requiresOriginalContent: false,
    nsfwRequired: false,
    titleGuidelines: [],
    contentGuidelines: [],
    linkRestrictions: [],
    bannedContent: [],
    formattingRequirements: [],
  },
  posting: {
    maxPostsPerDay: null,
    cooldownHours: null,
  },
  notes: null,
});

// Legacy default rule factory for backwards compatibility
export const createDefaultLegacyRules = (): LegacyRedditCommunityRuleSet => ({
  minKarma: null,
  minAccountAge: null,
  minAccountAgeDays: null,
  watermarksAllowed: null,
  sellingAllowed: undefined,
  promotionalLinksAllowed: undefined,
  titleRules: [],
  contentRules: [],
  linkRestrictions: [],
  bannedContent: [],
  formattingRequirements: [],
  notes: undefined,
  verificationRequired: false,
  requiresApproval: false,
  requiresOriginalContent: false,
  nsfwRequired: false,
  maxPostsPerDay: null,
  cooldownHours: null
});

export const redditCommunities = pgTable("reddit_communities", {
  id: varchar("id", { length: 100 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  displayName: varchar("display_name", { length: 255 }).notNull(),
  members: integer("members").notNull(),
  engagementRate: integer("engagement_rate").notNull(),
  category: varchar("category", { length: 50 }).notNull(),
  verificationRequired: boolean("verification_required").default(false).notNull(),
  promotionAllowed: varchar("promotion_allowed", { length: 20 }).default("no").notNull(),
  postingLimits: jsonb("posting_limits"),
  rules: jsonb("rules").$type<RedditCommunityRuleSet>(),
  bestPostingTimes: jsonb("best_posting_times").$type<string[]>(),
  averageUpvotes: integer("average_upvotes"),
  successProbability: integer("success_probability"),
@@ -535,51 +537,51 @@ export const redditCommunities = pgTable("reddit_communities", {
  competitionLevel: varchar("competition_level", { length: 20 })
});
export type RedditCommunity = typeof redditCommunities.$inferSelect;
export type InsertRedditCommunity = typeof redditCommunities.$inferInsert;
export const insertRedditCommunitySchema = createInsertSchema(redditCommunities);

// Helper function to normalize legacy rules to structured rules
export const normalizeRulesToStructured = (legacyRules: LegacyRedditCommunityRuleSet | null | undefined): RedditCommunityRuleSet | null => {
  if (!legacyRules) return null;

  return {
    eligibility: {
      minKarma: legacyRules.minKarma ?? null,
      minAccountAgeDays: legacyRules.minAccountAgeDays ?? legacyRules.minAccountAge ?? null,
      verificationRequired: legacyRules.verificationRequired ?? false,
      requiresApproval: legacyRules.requiresApproval ?? false,
    },
    content: {
      sellingPolicy: legacyRules.sellingAllowed,
      watermarksAllowed: legacyRules.watermarksAllowed ?? null,
      promotionalLinks: legacyRules.promotionalLinksAllowed ?? null,
      requiresOriginalContent: legacyRules.requiresOriginalContent ?? false,
      nsfwRequired: legacyRules.nsfwRequired ?? false,
      titleGuidelines: legacyRules.titleRules ?? [],
      contentGuidelines: legacyRules.contentRules ?? [],
      linkRestrictions: [],
      linkRestrictions: legacyRules.linkRestrictions ?? [],
      bannedContent: legacyRules.bannedContent ?? [],
      formattingRequirements: legacyRules.formattingRequirements ?? [],
    },
    posting: {
      maxPostsPerDay: legacyRules.maxPostsPerDay ?? null,
      cooldownHours: legacyRules.cooldownHours ?? null,
    },
    notes: legacyRules.notes ?? null,
  };
};

// Helper function to infer selling policy from rules
export const inferSellingPolicyFromRules = (rules: RedditCommunityRuleSet | null): RedditCommunitySellingPolicy => {
  if (!rules?.content?.sellingPolicy) return 'unknown';
  return rules.content.sellingPolicy;
};

export const subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).unique().notNull(),
  status: varchar("status", { length: 20 }).notNull(), // "active" | "past_due" | "canceled"
  plan: varchar("plan", { length: 20 }).notNull(), // "free" | "pro"
  priceCents: integer("price_cents").notNull(),
  processor: varchar("processor", { length: 20 }).notNull(), // "ccbill" | "segpay" | "epoch" | "crypto"
  processorSubId: varchar("processor_sub_id", { length: 255 }),
