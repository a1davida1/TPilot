server/caption/geminiPipeline.ts
+42-10
@@ -371,50 +371,51 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
          setting: 'digital',
          wardrobe: ['various'],
          angles: ['dynamic'],
          mood: 'playful',
          style: 'animated'
        };
      }

      throw error;
    }
  } catch (error) {
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

type GeminiVariantParams = {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
  toneExtras?: Record<string, string>;
};

export async function generateVariants(params: GeminiVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
@@ -427,50 +428,55 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i
    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);
    if (params.toneExtras) {
      for (const [key, value] of Object.entries(params.toneExtras)) {
        lines.push(`${key.toUpperCase()}: ${value}`);
      }
    }

    lines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
        `Avoid repeating or lightly editing these captions: ${existingCaptions.join(" | ")}.`
      );
    }
    hintParts.push("Provide five options that vary tone, structure, and specific imagery.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    const serializedHint = serializePromptField(combinedHint, { block: true });
    lines.push(`HINT:${serializedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
@@ -737,88 +743,114 @@ export async function rankAndSelect(

  const rerank = await requestGeminiRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations),
    params?.facts
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type GeminiToneArgs = {
  style?: string;
  mood?: string;
} & Record<string, unknown>;

type GeminiPipelineArgs = {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};
} & GeminiToneArgs;

/**
 * Primary image captioning pipeline backed by Gemini vision + text models.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
export async function pipeline({ imageUrl, platform, voice = "flirty_playful", nsfw = false, style, mood, ...toneRest }: GeminiPipelineArgs): Promise<CaptionResult> {
export async function pipeline(args: GeminiPipelineArgs): Promise<CaptionResult> {
  const imageUrl = args.imageUrl;
  const platform = args.platform;
  const voice = typeof args.voice === "string" && args.voice.length > 0 ? args.voice : "flirty_playful";
  const nsfw = typeof args.nsfw === "boolean" ? args.nsfw : false;
  const tone: ToneOptions = extractToneOptions(args);

  try {
    const tone = extractToneOptions(toneRest);
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, facts, nsfw, ...tone });
    let variants = await generateVariants({
      platform,
      voice,
      facts,
      nsfw,
      style: tone.style,
      mood: tone.mood,
      toneExtras: tone.extras
    });
    variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
    let ranked = await rankAndSelect(variants, { platform, facts });
    let out = ranked.final;

    const enforceCoverage = async () => {
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        variants = await generateVariants({ platform, voice, facts, hint: coverage.hint, nsfw, ...tone });
        variants = await generateVariants({
          platform,
          voice,
          facts,
          hint: coverage.hint,
          nsfw,
          style: tone.style,
          mood: tone.mood,
          toneExtras: tone.extras
        });
        variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
        ranked = await rankAndSelect(variants, { platform, facts });
        out = ranked.final;
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    await enforceCoverage();

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({
        platform,
        voice,
        style,
        mood,
        style: tone.style,
        mood: tone.mood,
        facts,
        hint: `Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`,
        nsfw
        nsfw,
        toneExtras: tone.extras
      });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/rewritePipeline.ts
+32-7
@@ -138,80 +138,86 @@ export function extractKeyEntities(existingCaption: string): string[] {

  return result;
}

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

type RewriteVariantsParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  existingCaption:string;
  facts?:Record<string, unknown>;
  hint?:string;
  nsfw?:boolean;
  doNotDrop?: string[];
  style?: string;
  mood?: string
  mood?: string;
  toneExtras?: Record<string, string>;
};

const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 3;

export async function variantsRewrite(params: RewriteVariantsParams) {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rewrite.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  const mandatoryTokens = params.doNotDrop && params.doNotDrop.length > 0
    ? `MANDATORY TOKENS: ${params.doNotDrop.join(" | ")}`
    : "";
  const variants: { caption: string; hashtags: string[]; cta?: string; alt?: string }[] = [];

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;

    const voiceContext = formatVoiceContext(params.voice);
    const toneLines = params.toneExtras
      ? Object.entries(params.toneExtras).map(([key, value]) => `${key.toUpperCase()}: ${value}`)
      : [];

    const user = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      voiceContext,
      params.style ? `STYLE: ${params.style}` : "",
      params.mood ? `MOOD: ${params.mood}` : "",
      ...toneLines,
      `EXISTING_CAPTION: ${serializePromptField(params.existingCaption)}`,
      params.facts ? `IMAGE_FACTS: ${JSON.stringify(params.facts)}` : "",
      `NSFW: ${params.nsfw || false}`,
      mandatoryTokens,
      currentHint ? `HINT:${serializePromptField(currentHint, { block: true })}` : "",
    ].filter((line): line is string => Boolean(line)).join("\n");

    const voiceGuide = buildVoiceGuideBlock(params.voice);
    const promptSections = [sys, guard, prompt, user];
    if (voiceGuide) promptSections.push(voiceGuide);

    let res;
    try {
      res = await textModel.generateContent([{ text: promptSections.join("\n") }]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    const json = stripToJSON(res.response.text()) as unknown;
    let hasBannedWords = false;

    if (Array.isArray(json)) {
      json.forEach((item) => {
        const variant = item as Record<string, unknown>;
@@ -349,88 +355,107 @@ export async function rankAndSelect(
  }

  const rerank = await requestRewriteRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    "Previous attempt had violations. Try again with better compliance."
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectRankingViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = parsed.final;
  const summary = formatViolations(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type RewriteToneArgs = {
  style?: string;
  mood?: string;
} & Record<string, unknown>;

type RewritePipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  existingCaption:string;
  imageUrl?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};
} & RewriteToneArgs;

/**
 * Caption rewriting pipeline that enhances existing captions while preserving tone.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
type CaptionItemType = z.infer<typeof CaptionItem>;
type CaptionArrayResult = z.infer<typeof CaptionArray>;
type RankResultType = z.infer<typeof RankResult>;

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
export async function pipelineRewrite(args:RewritePipelineArgs){
  const platform = args.platform;
  const voice = typeof args.voice === 'string' && args.voice.length > 0 ? args.voice : 'flirty_playful';
  const existingCaption = args.existingCaption;
  const imageUrl = args.imageUrl;
  const nsfw = typeof args.nsfw === 'boolean' ? args.nsfw : false;
  const tone: ToneOptions = extractToneOptions(args);

  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;

    const doNotDrop = extractKeyEntities(existingCaption);

    const attemptHints: (string | undefined)[] = [
      undefined,
      "Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clich√©s.",
      facts
        ? "Make it 25% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 25% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
    ];

    const baseParams = { platform, voice, style, mood, existingCaption, facts, nsfw, doNotDrop } as const;
    const baseParams = {
      platform,
      voice,
      style: tone.style,
      mood: tone.mood,
      toneExtras: tone.extras,
      existingCaption,
      facts,
      nsfw,
      doNotDrop
    } as const;

    type AttemptResult = { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType };

    const performAttempt = async (hint?: string): Promise<AttemptResult> => {
      const attemptVariants = await variantsRewrite({ ...baseParams, hint });
      const attemptRanked = await rankAndSelect(attemptVariants);
      return { variants: attemptVariants, ranked: attemptRanked, final: attemptRanked.final };
    };

    const enforceMandatoryTokens = async (
      attempt: AttemptResult,
      priorHint?: string
    ): Promise<AttemptResult> => {
      if (doNotDrop.length === 0) {
        return attempt;
      }
      const missing = doNotDrop.filter((token) => !attempt.final.caption.includes(token));
      if (missing.length === 0) {
        return attempt;
      }
      const messageParts = [
        priorHint,
        `ABSOLUTE RULE: Keep these tokens verbatim in the caption: ${doNotDrop.join(", ")}`,
        `Previous attempt removed: ${missing.join(", ")}`
      ].filter((part): part is string => Boolean(part && part.trim()));
server/caption/textOnlyPipeline.ts
+40-7
@@ -163,50 +163,51 @@ function captionsAreSimilar(a: string, b: string): boolean {
  const distance = levenshtein(normalizedA, normalizedB);
  const maxLen = Math.max(normalizedA.length, normalizedB.length);
  if (maxLen === 0) return true;

  const similarityScore = 1 - distance / maxLen;
  if (similarityScore > 0.9) return true;

  const tokensA = new Set(normalizedA.split(" ").filter(Boolean));
  const tokensB = new Set(normalizedB.split(" ").filter(Boolean));
  const intersectionSize = [...tokensA].filter(token => tokensB.has(token)).length;
  const unionSize = new Set([...tokensA, ...tokensB]).size || 1;
  const jaccard = intersectionSize / unionSize;

  return jaccard > 0.82;
}

type TextOnlyVariantParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  theme:string;
  context?:string;
  hint?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
  toneExtras?: Record<string, string>;
};

export async function generateVariantsTextOnly(params: TextOnlyVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants_textonly.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
@@ -221,50 +222,55 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P
      : "Engaging social media content that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      `THEME: ${serializePromptField(params.theme)}`,
      `CONTEXT: ${serializePromptField(params.context || "")}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);
    if (params.toneExtras) {
      for (const [key, value] of Object.entries(params.toneExtras)) {
        lines.push(`${key.toUpperCase()}: ${value}`);
      }
    }

    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
        `Avoid repeating or lightly editing these captions: ${existingCaptions.join(" | ")}.`
      );
    }
    hintParts.push("Provide five options that vary tone, structure, and specific content themes.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    lines.push(`HINT: ${combinedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
@@ -392,59 +398,86 @@ export async function rankAndSelect(
  }

  const rerank = await requestTextOnlyRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type TextOnlyToneArgs = {
  style?: string;
  mood?: string;
} & Record<string, unknown>;

type TextOnlyPipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  theme:string;
  context?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};
} & TextOnlyToneArgs;

/**
 * Text-only caption pipeline for brainstorming without an image upload.
 *
 * @remarks
 * Persona settings (`style`, `mood`, etc.) are forwarded to every Gemini retry so the
 * voice remains consistent even when a platform validation retry is required.
 */
export async function pipelineTextOnly({ platform, voice="flirty_playful", theme, context, nsfw=false, ...toneRest }:TextOnlyPipelineArgs){
  const tone = extractToneOptions(toneRest);
  let variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone });
export async function pipelineTextOnly(args:TextOnlyPipelineArgs){
  const platform = args.platform;
  const voice = typeof args.voice === 'string' && args.voice.length > 0 ? args.voice : 'flirty_playful';
  const theme = args.theme;
  const context = args.context;
  const nsfw = typeof args.nsfw === 'boolean' ? args.nsfw : false;
  const tone: ToneOptions = extractToneOptions(args);
  let variants = await generateVariantsTextOnly({
    platform,
    voice,
    theme,
    context,
    nsfw,
    style: tone.style,
    mood: tone.mood,
    toneExtras: tone.extras
  });
  variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
  let ranked = await rankAndSelect(variants, { platform, theme, context });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone, hint:`Fix: ${err}. Be specific and engaging.` });
    variants = await generateVariantsTextOnly({
      platform,
      voice,
      theme,
      context,
      nsfw,
      style: tone.style,
      mood: tone.mood,
      toneExtras: tone.extras,
      hint:`Fix: ${err}. Be specific and engaging.`
    });
    variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
    ranked = await rankAndSelect(variants, { platform, theme, context });
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
server/caption/toneOptions.ts
+47-5

export type ToneOptions = {
  style?: string;
  mood?: string;
} & Partial<Record<string, string>>;
  extras: Record<string, string>;
};

const RESERVED_KEYS = new Set([
  'style',
  'mood',
  'platform',
  'voice',
  'imageUrl',
  'existingCaption',
  'theme',
  'context',
  'hint',
  'nsfw',
  'facts',
  'doNotDrop',
  'caption',
  'alt',
  'hashtags',
  'cta',
  'safety_level',
  'provider',
  'ranked',
  'final'
]);

export function extractToneOptions(input: Record<string, unknown>): ToneOptions {
  const tone: Record<string, string> = {};
  let style: string | undefined;
  let mood: string | undefined;
  const extras: Record<string, string> = {};

  for (const [key, value] of Object.entries(input)) {
    if (typeof value === 'string') {
      tone[key] = value;
    if (typeof value !== 'string') {
      continue;
    }

    if (key === 'style') {
      style = value;
      continue;
    }

    if (key === 'mood') {
      mood = value;
      continue;
    }

    if (RESERVED_KEYS.has(key)) {
      continue;
    }

    extras[key] = value;
  }

  return tone as ToneOptions;
  return { style, mood, extras };
}
server/routes/caption.ts
+42-6
import { Router, type Request, type Response } from 'express';
import { pipeline, InvalidImageError } from '../caption/geminiPipeline';
import { pipelineTextOnly } from '../caption/textOnlyPipeline';
import { pipelineRewrite } from '../caption/rewritePipeline';
import { extractToneOptions } from '../caption/toneOptions';
import { storage } from '../storage';
import { authenticateToken, type AuthRequest } from '../middleware/auth';
import { insertContentGenerationSchema } from '@shared/schema';
import { type CaptionObject } from '@shared/types/caption';
import { z } from 'zod';
import { logger } from '../bootstrap/logger';

// Local validation schema to prevent import issues
const captionObjectSchema = z.object({
  caption: z.string(),
  alt: z.string().optional(),
  hashtags: z.array(z.string()).optional(),
  mood: z.string().optional(),
  style: z.string().optional(),
  cta: z.string().optional(),
  safety_level: z.enum(['normal', 'spicy_safe', 'unsafe']).optional(),
});

const rankedResultSchema = z.object({
  reason: z.string().optional(),
}).catchall(z.unknown());

const generationResponseSchema = z.object({
  final: z.union([z.string(), captionObjectSchema]),
  ranked: z.union([z.array(z.string()), rankedResultSchema]),
@@ -43,150 +44,185 @@ const generateSchema = z.object({
});

const generateTextSchema = z.object({
  platform: z.enum(['instagram', 'x', 'reddit', 'tiktok']),
  voice: z.string().optional(),
  style: z.string().optional(),
  mood: z.string().optional(),
  theme: z.string(),
  context: z.string().optional(),
  nsfw: z.boolean().optional()
});

const rewriteSchema = z.object({
  platform: z.enum(['instagram', 'x', 'reddit', 'tiktok']),
  voice: z.string().optional(),
  style: z.string().optional(),
  mood: z.string().optional(),
  existingCaption: z.string(),
  imageUrl: z.string().optional(),
  nsfw: z.boolean().optional()
});

router.post('/generate', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { imageUrl, platform, voice, style, mood, nsfw } = generateSchema.parse(req.body ?? {});
    
    const result = await pipeline({ imageUrl, platform, voice, style, mood, nsfw: nsfw || false });
    const tone = extractToneOptions(req.body ?? {});
    const normalizedStyle = tone.style ?? style;
    const normalizedMood = tone.mood ?? mood;

    const result = await pipeline({
      imageUrl,
      platform,
      voice,
      nsfw: nsfw || false,
      style: normalizedStyle,
      mood: normalizedMood,
      ...tone.extras
    });
    
    // Validate response payload matches expected schema
    const validatedResult = generationResponseSchema.parse(result);
    
    // Save generation to database
    if (req.user?.id && result.final) {
      try {
        await storage.createGeneration({
          userId: req.user.id,
          platform,
          style: style || voice || 'default',
          theme: 'image_based',
          titles: [result.final.caption || 'Generated content'],
          content: result.final.caption || '',
          photoInstructions: {
            lighting: 'Natural lighting',
            cameraAngle: 'Eye level',
            composition: 'Center composition',
            styling: 'Authentic styling',
            mood: 'Confident and natural',
            technicalSettings: 'Auto settings'
          },
          prompt: `Image-based generation for ${platform}`,
          generationType: 'ai',
          allowsPromotion: nsfw || false
        });
      } catch (dbError) {
        logger.error('Failed to save generation to database', { error: dbError });
        // Don't fail the request if database save fails
      }
    }
    
    return res.status(200).json(validatedResult);
    
  } catch (e: unknown) {
    const message = e instanceof Error ? e.message : "generation failed";
    logger.error('Caption generation error', { error: message });
    if (e instanceof InvalidImageError) {
      return res.status(422).json({ error: message });
    }
    return res.status(500).json({ error: message });
  }
});

router.post('/generate-text', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { platform, voice, style, mood, theme, context, nsfw } = generateTextSchema.parse(req.body ?? {});
    
    const result = await pipelineTextOnly({ platform, voice, style, mood, theme, context, nsfw: nsfw || false });
    const tone = extractToneOptions(req.body ?? {});
    const normalizedStyle = tone.style ?? style;
    const normalizedMood = tone.mood ?? mood;

    const result = await pipelineTextOnly({
      platform,
      voice,
      theme,
      context,
      nsfw: nsfw || false,
      style: normalizedStyle,
      mood: normalizedMood,
      ...tone.extras
    });
    
    // Validate response payload matches expected schema
    const validatedResult = generationResponseSchema.parse(result);
    
    // Save generation to database
    if (req.user?.id && result.final) {
      try {
        await storage.createGeneration({
          userId: req.user.id,
          platform,
          style: style || voice || 'default',
          theme: theme || 'lifestyle',
          titles: [result.final.caption || 'Generated content'],
          content: result.final.caption || '',
          photoInstructions: {
            lighting: 'Natural lighting',
            cameraAngle: 'Eye level',
            composition: 'Center composition',
            styling: 'Authentic styling',
            mood: 'Confident and natural',
            technicalSettings: 'Auto settings'
          },
          prompt: `Text-based generation: ${theme} for ${platform}${context ? ` - ${context}` : ''}`,
          generationType: 'ai',
          allowsPromotion: nsfw || false
        });
      } catch (dbError) {
        logger.error('Failed to save generation to database', { error: dbError });
        // Don't fail the request if database save fails
      }
    }
    
    return res.status(200).json(validatedResult);
    
  } catch (e: unknown) {
    const message = e instanceof Error ? e.message : "generation failed";
    logger.error('Text caption generation error', { error: message });
    if (e instanceof InvalidImageError) {
      return res.status(422).json({ error: message });
    }
    return res.status(500).json({ error: message });
  }
});

router.post('/rewrite', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { platform, voice, style, mood, existingCaption, imageUrl, nsfw } = rewriteSchema.parse(req.body ?? {});
    
    const result = await pipelineRewrite({ platform, voice, style, mood, existingCaption, imageUrl, nsfw: nsfw || false });
    const tone = extractToneOptions(req.body ?? {});
    const normalizedStyle = tone.style ?? style;
    const normalizedMood = tone.mood ?? mood;

    const result = await pipelineRewrite({
      platform,
      voice,
      existingCaption,
      imageUrl,
      nsfw: nsfw || false,
      style: normalizedStyle,
      mood: normalizedMood,
      ...tone.extras
    });
    
    // Validate response payload matches expected schema
    const validatedResult = generationResponseSchema.parse(result);
    
    // Save generation to database
    if (req.user?.id && result.final) {
      const finalResult = result.final as CaptionObject;
      try {
        await storage.createGeneration({
          userId: req.user.id,
          platform,
          style: style || voice || 'default',
          theme: 'rewrite',
          titles: [finalResult.caption || 'Generated content'],
          content: finalResult.caption || '',
          photoInstructions: {
            lighting: 'Natural lighting',
            cameraAngle: 'Eye level',
            composition: 'Center composition',
            styling: 'Authentic styling',
            mood: 'Confident and natural',
            technicalSettings: 'Auto settings'
          },
          prompt: `Rewrite existing content for ${platform}: "${existingCaption.substring(0, 100)}..."`,
          generationType: 'ai',
tests/unit/caption/tone-options.test.ts
+36-23
@@ -3,148 +3,157 @@
 * 
 * This test file verifies the tone parameter extraction and forwarding functionality
 * without complex mocking scenarios.
 */

import { describe, it, expect } from 'vitest';
import { extractToneOptions, ToneOptions } from '../../../server/caption/toneOptions';

describe('ToneOptions Helper', () => {
  describe('extractToneOptions', () => {
    it('should extract style and mood parameters', () => {
      const params = {
        style: 'modern',
        mood: 'confident',
        platform: 'instagram',
        voice: 'professional',
        nsfw: false,
        facts: { objects: ['test'] },
        otherParam: 'value'
      };

      const result = extractToneOptions(params);

      expect(result).toEqual({
        style: 'modern',
        mood: 'confident'
        mood: 'confident',
        extras: {
          otherParam: 'value'
        }
      });
      expect(result.extras).not.toHaveProperty('platform');
      expect(result.extras).not.toHaveProperty('voice');
    });

    it('should handle missing tone parameters', () => {
      const params = {
        platform: 'instagram',
        voice: 'professional',
        nsfw: false
      };

      const result = extractToneOptions(params);

      expect(result).toEqual({});
      expect(result).toEqual({ style: undefined, mood: undefined, extras: {} });
    });

    it('should handle empty parameters', () => {
      const result = extractToneOptions({});
      expect(result).toEqual({});
      expect(result).toEqual({ style: undefined, mood: undefined, extras: {} });
    });

    it('should ignore non-string tone values', () => {
      const params = {
        style: 'modern',
        mood: 123, // Should be ignored as it's not a string
        platform: 'x'
      };

      const result = extractToneOptions(params);

      expect(result).toEqual({
        style: 'modern'
        style: 'modern',
        mood: undefined,
        extras: {}
      });
    });

    it('should only extract known tone parameters', () => {
    it('should forward additional tone strings while ignoring reserved keys', () => {
      const params = {
        style: 'elegant',
        mood: 'playful',
        platform: 'tiktok',
        voice: 'energetic',
        nsfw: false,
        facts: { objects: ['test'] },
        hint: 'some hint',
        imageUrl: 'http://example.com/image.jpg',
        existingCaption: 'caption',
        theme: 'fitness',
        context: 'workout',
        someRandomParam: 'should not be included'
        persona: 'witty'
      };

      const result = extractToneOptions(params);

      // Should only extract style and mood
      expect(result).toEqual({
        style: 'elegant',
        mood: 'playful'
        mood: 'playful',
        extras: {
          persona: 'witty'
        }
      });

      // Should not include non-tone parameters
      expect(result).not.toHaveProperty('platform');
      expect(result).not.toHaveProperty('voice');
      expect(result).not.toHaveProperty('nsfw');
      expect(result).not.toHaveProperty('facts');
      expect(result).not.toHaveProperty('hint');
      expect(result).not.toHaveProperty('someRandomParam');
      expect(result.extras).not.toHaveProperty('platform');
      expect(result.extras).not.toHaveProperty('voice');
      expect(result.extras).not.toHaveProperty('theme');
      expect(result.extras).not.toHaveProperty('context');
    });
  });

  describe('ToneOptions type', () => {
    it('should accept valid tone options', () => {
      const validOptions: ToneOptions = {
        style: 'modern',
        mood: 'confident'
        mood: 'confident',
        extras: {}
      };

      expect(validOptions.style).toBe('modern');
      expect(validOptions.mood).toBe('confident');
    });

    it('should accept partial tone options', () => {
      const styleOnly: ToneOptions = {
        style: 'minimal'
        style: 'minimal',
        extras: {}
      };

      const moodOnly: ToneOptions = {
        mood: 'exciting'
        mood: 'exciting',
        extras: {}
      };

      expect(styleOnly.style).toBe('minimal');
      expect(styleOnly.mood).toBeUndefined();
      expect(moodOnly.style).toBeUndefined();
      expect(moodOnly.mood).toBe('exciting');
    });

    it('should accept empty tone options', () => {
      const empty: ToneOptions = {};
      expect(Object.keys(empty)).toHaveLength(0);
      const empty: ToneOptions = { extras: {} };
      expect(empty.extras).toEqual({});
    });
  });
});

/**
 * Integration test to verify tone parameters are used in prompts
 * This is a more focused test that checks the actual function behavior
 */
describe('Tone Parameter Integration', () => {
  it('should include tone parameters in generated prompts', async () => {
    // Test the core logic that builds prompts with tone parameters
    const platform = 'instagram';
    const voice = 'professional';
    const style = 'minimalist';
    const mood = 'confident';
    const facts = { objects: ['test'], colors: ['blue'] };
    
    // Simulate the prompt building logic that would happen in the pipelines
    const promptParts = [
      `PLATFORM: ${platform}`,
      `VOICE: ${voice}`,
      style ? `STYLE: ${style}` : '',
      mood ? `MOOD: ${mood}` : '',
      `IMAGE_FACTS: ${JSON.stringify(facts)}`,
      'NSFW: false'
@@ -165,46 +174,50 @@ describe('Tone Parameter Integration', () => {
    const platform = 'x';
    const voice = 'casual';
    const facts = { objects: ['photo'] };
    
    const promptParts = [
      `PLATFORM: ${platform}`,
      `VOICE: ${voice}`,
      `IMAGE_FACTS: ${JSON.stringify(facts)}`,
      'NSFW: false'
    ];
    
    const prompt = promptParts.join('\n');
    
    expect(prompt).toContain('PLATFORM: x');
    expect(prompt).toContain('VOICE: casual');
    expect(prompt).not.toContain('STYLE:');
    expect(prompt).not.toContain('MOOD:');
  });

  it('should preserve tone parameters when adding hints', async () => {
    const originalParams = {
      platform: 'reddit',
      voice: 'witty',
      style: 'sarcastic',
      mood: 'playful',
      facts: { objects: ['meme'] }
      facts: { objects: ['meme'] },
      persona: 'snarky'
    };
    
    const hint = 'Fix: Platform validation failed. Be more specific.';
    
    // Simulate what happens during retry with hint
    const toneOptions = extractToneOptions(originalParams);
    const retryParams = {
      ...originalParams,
      ...toneOptions,
      style: toneOptions.style ?? originalParams.style,
      mood: toneOptions.mood ?? originalParams.mood,
      ...toneOptions.extras,
      hint
    };
    

    // Verify tone parameters are preserved
    expect(retryParams.style).toBe('sarcastic');
    expect(retryParams.mood).toBe('playful');
    expect(retryParams.persona).toBe('snarky');
    expect(retryParams.hint).toBe(hint);
    expect(retryParams.platform).toBe('reddit');
    expect(retryParams.voice).toBe('witty');
  });
});
