server/caption/rewritePipeline.ts
+9-6
@@ -396,116 +396,119 @@ type RankResultType = z.infer<typeof RankResult>;
export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;

    const doNotDrop = extractKeyEntities(existingCaption);

    const attemptHints: (string | undefined)[] = [
      undefined,
      "Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.",
      facts
        ? "Make it 25% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 25% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
    ];

    const baseParams = { platform, voice, style, mood, existingCaption, facts, nsfw, doNotDrop } as const;

    type AttemptResult = { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType };

    const performAttempt = async (hint?: string): Promise<AttemptResult> => {
      const attemptVariants = await variantsRewrite({ ...baseParams, hint });
      const attemptRanked = await rankAndSelect(attemptVariants);
      return { variants: attemptVariants, ranked: attemptRanked, final: attemptRanked.final };
    };

    const runRewrite = async (hint?: string, enforceHint?: string): Promise<AttemptResult> => {
      const attempt = await performAttempt(hint);
      return enforceMandatoryTokens(attempt, enforceHint ?? hint);
    };

    const enforceMandatoryTokens = async (
      attempt: AttemptResult,
      priorHint?: string
    ): Promise<AttemptResult> => {
      if (doNotDrop.length === 0) {
        return attempt;
      }
      const missing = doNotDrop.filter((token) => !attempt.final.caption.includes(token));
      if (missing.length === 0) {
        return attempt;
      }
      const messageParts = [
        priorHint,
        `ABSOLUTE RULE: Keep these tokens verbatim in the caption: ${doNotDrop.join(", ")}`,
        `Previous attempt removed: ${missing.join(", ")}`
      ].filter((part): part is string => Boolean(part && part.trim()));
      const retried = await performAttempt(messageParts.join(" "));
      const retryMissing = doNotDrop.filter((token) => !retried.final.caption.includes(token));
      if (retryMissing.length > 0) {
        throw new Error(`Missing mandatory tokens after retry: ${retryMissing.join(", ")}`);
      }
      return retried;
    };

    let lastAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType } | undefined;
    let successfulAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType } | undefined;

    for (const hint of attemptHints) {
      let attempt = await performAttempt(hint);
      attempt = await enforceMandatoryTokens(attempt, hint);
      const attempt = await runRewrite(hint);
      lastAttempt = attempt;
      if (attempt.final.caption.length > existingCaption.length) {
        successfulAttempt = attempt;
        break;
      }
    }

    const chosenAttempt = successfulAttempt ?? lastAttempt;

    if (!chosenAttempt || chosenAttempt.final.caption.length <= existingCaption.length) {
      throw new Error('Rewrite did not produce a longer caption');
    }

    let { variants, ranked, final: out } = chosenAttempt;

    const enforceCoverage = async () => {
      if (!facts) {
        return;
      }
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        let nextAttempt = await performAttempt(coverage.hint);
        nextAttempt = await enforceMandatoryTokens(nextAttempt, coverage.hint);
        const nextAttempt = await runRewrite(coverage.hint);
        ({ variants, ranked, final: out } = nextAttempt);
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    await enforceCoverage();

    if (out.caption.length <= existingCaption.length) {
      throw new Error('Rewrite did not produce a longer caption');
    }

    const err = platformChecks(platform, out);
    if (err) {
      let platformAttempt = await performAttempt(`Fix: ${err}. Be specific, human, and avoid clichés while staying platform safe.`);
      platformAttempt = await enforceMandatoryTokens(platformAttempt, `Fix: ${err}. Be specific, human, and avoid clichés while staying platform safe.`);
      const platformHint = `Fix: ${err}. Be specific, human, and avoid clichés while staying platform safe.`;
      const platformAttempt = await runRewrite(platformHint, platformHint);
      if (platformAttempt.final.caption.length <= existingCaption.length) {
        throw new Error('Platform-specific rewrite failed to improve length');
      }
      const platformErr = platformChecks(platform, platformAttempt.final);
      if (platformErr) {
        throw new Error(platformErr);
      }
      ({ variants, ranked, final: out } = platformAttempt);
      await enforceCoverage();
      if (out.caption.length <= existingCaption.length) {
        throw new Error('Platform-specific rewrite failed to improve length');
      }
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
tests/routes/caption-generation.test.ts
+121-0
@@ -1342,50 +1342,171 @@ describe('Caption Generation', () => {
      type GenerateReturn = Awaited<ReturnType<typeof textModel.generateContent>>;

      generateSpy
        .mockResolvedValueOnce(shortVariantResponse as GenerateReturn)
        .mockResolvedValueOnce(shortRankResponse as GenerateReturn)
        .mockResolvedValueOnce(longVariantResponse as GenerateReturn)
        .mockResolvedValueOnce(longRankResponse as GenerateReturn);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect((result.final as CaptionResult).caption).toBe(longCaption);
      expect((result.final as CaptionResult).caption.length).toBeGreaterThan(existingCaption.length);
      expect((result.final as CaptionResult).caption).not.toContain('✨ Enhanced with engaging content and call-to-action that drives better engagement!');
      expect(generateSpy).toHaveBeenCalledTimes(4);

      const secondAttemptCall = generateSpy.mock.calls[2]?.[0]?.[0]?.text;
      expect(secondAttemptCall).toContain('Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.');

      generateSpy.mockRestore();
    });

    it('preserves mandatory tokens across hint retries without platform intervention', async () => {
      const existingCaption =
        'Tickets drop at https://shop.example.com with @BrandHero for the "Solstice Special" on 6/30 #BrandLaunch';
      const longAlt =
        'Alt text describing the Solstice Special launch announcement with complete context for accessibility.';

      const variantFactory = (caption: string) => ({
        caption,
        hashtags: ['#BrandLaunch', '#Solstice', '#Tickets'],
        safety_level: 'normal',
        mood: 'excited',
        style: 'authentic',
        cta: 'Secure your spot',
        alt: longAlt,
        nsfw: false,
      });

      const baselineVariants = {
        response: {
          text: () =>
            JSON.stringify(
              Array.from({ length: 5 }, (_, index) => variantFactory(`${existingCaption} (baseline ${index + 1})`))
            ),
        },
      } satisfies { response: { text: () => string } };

      const baselineRank = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Baseline rewrite keeps mandatory tokens but is not longer',
              final: variantFactory(existingCaption),
            }),
        },
      } satisfies { response: { text: () => string } };

      const hintVariants = {
        response: {
          text: () =>
            JSON.stringify(
              Array.from({ length: 5 }, (_, index) =>
                variantFactory(`Preorders open now — new drop incoming (hint pass ${index + 1})`)
              )
            ),
        },
      } satisfies { response: { text: () => string } };

      const hintRank = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Hint rewrite drops mandatory tokens',
              final: variantFactory('Preorders open now — new drop incoming'),
            }),
        },
      } satisfies { response: { text: () => string } };

      const enforcedCaption =
        'Tickets drop at https://shop.example.com with @BrandHero for the "Solstice Special" on 6/30 #BrandLaunch — secure your spot now!';

      const enforcedVariants = {
        response: {
          text: () =>
            JSON.stringify(
              Array.from({ length: 5 }, (_, index) => variantFactory(`${enforcedCaption} (enforced ${index + 1})`))
            ),
        },
      } satisfies { response: { text: () => string } };

      const enforcedRank = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Mandatory tokens enforced after hint rewrite',
              final: variantFactory(enforcedCaption),
            }),
        },
      } satisfies { response: { text: () => string } };

      const { textModel } = await import('../../server/lib/gemini.js');
      const generateSpy = vi.spyOn(textModel, 'generateContent');
      type GenerateReturn = Awaited<ReturnType<typeof textModel.generateContent>>;

      generateSpy
        .mockResolvedValueOnce(baselineVariants as GenerateReturn)
        .mockResolvedValueOnce(baselineRank as GenerateReturn)
        .mockResolvedValueOnce(hintVariants as GenerateReturn)
        .mockResolvedValueOnce(hintRank as GenerateReturn)
        .mockResolvedValueOnce(enforcedVariants as GenerateReturn)
        .mockResolvedValueOnce(enforcedRank as GenerateReturn);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(generateSpy).toHaveBeenCalledTimes(6);
      const enforcementPrompt = generateSpy.mock.calls[4]?.[0]?.[0]?.text as string | undefined;
      expect(enforcementPrompt).toContain('ABSOLUTE RULE: Keep these tokens verbatim in the caption');
      expect(enforcementPrompt).toContain('Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.');
      expect(enforcementPrompt).not.toContain('Fix platform issue');

      const finalCaption = (result.final as CaptionResult).caption;
      expect(finalCaption).toBe(enforcedCaption);
      expect(finalCaption.length).toBeGreaterThan(existingCaption.length);
      expect(finalCaption).toContain('https://shop.example.com');
      expect(finalCaption).toContain('@BrandHero');
      expect(finalCaption).toContain('"Solstice Special"');
      expect(finalCaption).toContain('6/30');
      expect(finalCaption).toContain('#BrandLaunch');

      generateSpy.mockRestore();
    });

    it('retries rewrite with hints when the first pass is too short', async () => {
      const existingCaption = 'Basic caption here';
      const longAltText =
        'A descriptive alt text that clearly explains the scene and exceeds the schema requirements for length.';

      const makeVariants = (caption: string) =>
        Array.from({ length: 5 }, () => ({
          caption,
          hashtags: ['#vibes', '#style', '#moments'],
          safety_level: 'normal',
          mood: 'engaging',
          style: 'authentic',
          cta: 'Tell me what you think',
          alt: longAltText,
          nsfw: false,
        }));

      const shortVariantsResponse = {
        response: {
          text: () => JSON.stringify(makeVariants(existingCaption)),
        },
      } satisfies { response: { text: () => string } };

      const shortRankResponse = {
        response: {