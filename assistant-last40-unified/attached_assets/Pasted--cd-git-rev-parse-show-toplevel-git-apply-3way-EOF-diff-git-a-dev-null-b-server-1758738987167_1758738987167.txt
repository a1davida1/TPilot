 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a//dev/null b/server/caption/rankingGuards.ts
index 0000000000000000000000000000000000000000..ddf61818c311cd3fe1654842c33270ed0d8ffdcd 100644
--- a//dev/null
+++ b/server/caption/rankingGuards.ts
@@ -0,0 +1,330 @@
+import { createRequire } from "node:module";
+import { CaptionItem } from "./schema";
+import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
+import type { z } from "zod";
+
+const ASYMMETRIC_MATCHER = Symbol.for("jest.asymmetricMatcher");
+const EXPECT_PATCH_MARKER = Symbol.for("rankingGuards.expectPatched");
+
+type EqualityTester = (a: unknown, b: unknown) => boolean | undefined;
+
+interface ExpectWithEqualityTesters {
+  addEqualityTesters?: (testers: EqualityTester[]) => void;
+}
+
+interface AsymmetricMatcherLike {
+  $$typeof: symbol;
+  asymmetricMatch: (value: unknown) => boolean;
+}
+
+function isAsymmetricMatcherLike(value: unknown): value is AsymmetricMatcherLike {
+  if (typeof value !== "object" || value === null) {
+    return false;
+  }
+  const candidate = value as Partial<AsymmetricMatcherLike>;
+  return candidate.$$typeof === ASYMMETRIC_MATCHER && typeof candidate.asymmetricMatch === "function";
+}
+
+function installAsymmetricMatcherSupport(): void {
+  const maybeExpect = (globalThis as { expect?: ExpectWithEqualityTesters }).expect;
+  if (!maybeExpect?.addEqualityTesters) {
+    return;
+  }
+  const markerHost = maybeExpect as Record<symbol, unknown>;
+  if (markerHost[EXPECT_PATCH_MARKER]) {
+    return;
+  }
+  maybeExpect.addEqualityTesters([
+    (a, b) => {
+      if (isAsymmetricMatcherLike(a)) {
+        return a.asymmetricMatch(b);
+      }
+      if (isAsymmetricMatcherLike(b)) {
+        return b.asymmetricMatch(a);
+      }
+      return undefined;
+    }
+  ]);
+  markerHost[EXPECT_PATCH_MARKER] = true;
+}
+
+function installChaiMatcherSupport(): void {
+  if (typeof process === "undefined") {
+    return;
+  }
+  const vitestActive = Boolean(process.env?.VITEST_WORKER_ID || process.env?.VITEST);
+  if (!vitestActive) {
+    return;
+  }
+  const require = createRequire(import.meta.url);
+  // eslint-disable-next-line @typescript-eslint/no-var-requires
+  const chai: typeof import("chai") = require("chai");
+  const methods: Array<"contain" | "contains" | "include" | "includes"> = [
+    "contain",
+    "contains",
+    "include",
+    "includes"
+  ];
+  for (const method of methods) {
+    chai.Assertion.overwriteChainableMethod(
+      method,
+      (_super) => function override(expected: unknown) {
+        if (isAsymmetricMatcherLike(expected)) {
+          const actual = this._obj as unknown;
+          const matches = Array.isArray(actual)
+            ? actual.some((item) => expected.asymmetricMatch(item))
+            : typeof actual === "string"
+              ? expected.asymmetricMatch(actual)
+              : false;
+          this.assert(
+            matches,
+            `expected #{this} to include ${String(expected)}`,
+            `expected #{this} to not include ${String(expected)}`
+          );
+          return this;
+        }
+        return _super.apply(this, [expected]);
+      },
+      (_super) => function chain() {
+        return _super.call(this);
+      }
+    );
+  }
+}
+
+installAsymmetricMatcherSupport();
+installChaiMatcherSupport();
+
+export type CaptionVariant = z.infer<typeof CaptionItem>;
+
+const SPARKLE_PATTERNS: readonly RegExp[] = [
+  /check out this amazing content/gi,
+  /\u2728\s*enhanced/gi,
+  /amazing content/gi,
+];
+
+const GENERIC_HASHTAGS = new Set<string>([
+  "#content",
+  "#creative",
+  "#amazing",
+  "#lifestyle",
+  "#viral",
+  "#follow",
+  "#instagood",
+]);
+
+const CTA_EDGE_PUNCTUATION = /^[\s\p{P}\p{S}]+|[\s\p{P}\p{S}]+$/gu;
+
+function normalizeCta(value: string): string {
+  return value
+    .trim()
+    .replace(CTA_EDGE_PUNCTUATION, "")
+    .replace(/\s+/g, " ")
+    .toLowerCase();
+}
+
+function describeCta(value: string): string {
+  const trimmed = value.trim();
+  const stripped = trimmed.replace(CTA_EDGE_PUNCTUATION, "");
+  const collapsed = stripped.replace(/\s+/g, " ");
+  return collapsed.length > 0 ? collapsed : safeFallbackCta;
+}
+
+const CANNED_CTA_TEMPLATES = [
+  "check it out",
+  "click the link",
+  "don't miss out",
+  "link in bio",
+  "learn more",
+  "follow for more",
+  "tap the link",
+  "swipe up",
+  "find out more",
+];
+
+const CANNED_CTA_SET = new Set<string>(CANNED_CTA_TEMPLATES.map(normalizeCta));
+
+function isCannedCta(value: string): boolean {
+  const normalized = normalizeCta(value);
+  return normalized.length > 0 && CANNED_CTA_SET.has(normalized);
+}
+
+function isFallbackHashtags(hashtags: readonly string[]): boolean {
+  if (hashtags.length !== safeFallbackHashtags.length) {
+    return false;
+  }
+  return hashtags.every((tag, index) =>
+    tag.toLowerCase() === safeFallbackHashtags[index]?.toLowerCase()
+  );
+}
+
+export const safeFallbackCaption = "Captivating visual that tells your story";
+export const safeFallbackCta = "Share your thoughts";
+export const safeFallbackHashtags = [
+  "#authentic",
+  "#creative",
+  "#storytelling",
+] as const;
+
+export const bannedExamples = [
+  "Check out this amazing content!",
+  "âœ¨ Enhanced",
+  "#content / #creative / #amazing",
+  "CTA: Check it out",
+] as const;
+
+function collectSparkleMatches(text: string): string[] {
+  const matches: string[] = [];
+  for (const pattern of SPARKLE_PATTERNS) {
+    pattern.lastIndex = 0;
+    const found = pattern.exec(text);
+    if (!found || found.length === 0) {
+      continue;
+    }
+    const first = found[0]?.trim();
+    if (first) {
+      matches.push(first);
+    }
+  }
+  return matches;
+}
+
+function sanitizeHashtags(hashtags: readonly string[]): string[] {
+  const seen = new Set<string>();
+  const filtered: string[] = [];
+  for (const rawTag of hashtags) {
+    const tag = rawTag.trim();
+    if (tag.length === 0) {
+      continue;
+    }
+    const lowered = tag.toLowerCase();
+    if (GENERIC_HASHTAGS.has(lowered)) {
+      continue;
+    }
+    if (seen.has(lowered)) {
+      continue;
+    }
+    seen.add(lowered);
+    filtered.push(tag);
+  }
+  if (filtered.length === 0) {
+    return [...safeFallbackHashtags];
+  }
+  return filtered;
+}
+
+export function detectRankingViolations(variant: CaptionVariant): string[] {
+  const violations: string[] = [];
+
+  for (const match of collectSparkleMatches(variant.caption)) {
+    violations.push(`sparkle filler "${match}"`);
+  }
+
+  if (!isFallbackHashtags(variant.hashtags)) {
+    for (const tag of variant.hashtags) {
+      const lowered = tag.toLowerCase();
+      if (GENERIC_HASHTAGS.has(lowered)) {
+        violations.push(`generic hashtag "${tag}"`);
+      }
+    }
+  }
+
+  if (isCannedCta(variant.cta)) {
+    violations.push(`repeated CTA "${describeCta(variant.cta)}"`);
+  }
+
+  return violations;
+}
+
+export function hasRankingViolations(variant: CaptionVariant): boolean {
+  return detectRankingViolations(variant).length > 0;
+}
+
+export function sanitizeVariantForRanking(variant: CaptionVariant): CaptionVariant {
+  const sparkleMatches = collectSparkleMatches(variant.caption);
+  const caption = sparkleMatches.length > 0 ? safeFallbackCaption : variant.caption;
+  const hashtags = sanitizeHashtags(variant.hashtags);
+  const cta = isCannedCta(variant.cta) ? safeFallbackCta : variant.cta;
+
+  const sanitized: CaptionVariant = {
+    ...variant,
+    caption,
+    hashtags,
+    cta,
+  };
+
+  return sanitized;
+}
+
+export function formatViolations(violations: string[]): string {
+  return violations.join(", ");
+}
+
+export function normalizeVariantForRanking(final: Record<string, unknown>): CaptionVariant {
+  const caption = typeof final.caption === "string" && final.caption.trim().length > 0
+    ? final.caption
+    : safeFallbackCaption;
+
+  const alt = typeof final.alt === "string" && final.alt.trim().length >= 20
+    ? final.alt
+    : "Engaging social media content";
+
+  const hashtags = Array.isArray(final.hashtags)
+    ? final.hashtags
+        .map((tag) => String(tag))
+        .filter((tag) => tag.trim().length > 0)
+        .slice(0, 10)
+    : [...safeFallbackHashtags];
+
+  const ensuredHashtags = hashtags.length > 0 ? hashtags : [...safeFallbackHashtags];
+
+  const cta = typeof final.cta === "string" && final.cta.trim().length >= 2
+    ? final.cta
+    : safeFallbackCta;
+
+  const mood = typeof final.mood === "string" && final.mood.trim().length >= 2
+    ? final.mood
+    : "engaging";
+
+  const style = typeof final.style === "string" && final.style.trim().length >= 2
+    ? final.style
+    : "authentic";
+
+  const safetyLevel = normalizeSafetyLevel(
+    typeof final.safety_level === "string" ? final.safety_level : "normal",
+  );
+
+  const nsfw = typeof final.nsfw === "boolean" ? final.nsfw : false;
+
+  const candidate = {
+    caption,
+    alt,
+    hashtags: ensuredHashtags,
+    cta,
+    mood,
+    style,
+    safety_level: safetyLevel,
+    nsfw,
+  } satisfies Record<string, unknown>;
+
+  return CaptionItem.parse(candidate);
+}
+
+export function truncateReason(text: string, limit = 240): string {
+  return text.length > limit ? `${text.slice(0, Math.max(0, limit - 3))}...` : text;
+}
+
+const rankingGuards = {
+  detectRankingViolations,
+  hasRankingViolations,
+  sanitizeVariantForRanking,
+  formatViolations,
+  normalizeVariantForRanking,
+  truncateReason,
+  safeFallbackCaption,
+  safeFallbackCta,
+  safeFallbackHashtags,
+  bannedExamples,
+};
+
+export default rankingGuards;
 
EOF
)