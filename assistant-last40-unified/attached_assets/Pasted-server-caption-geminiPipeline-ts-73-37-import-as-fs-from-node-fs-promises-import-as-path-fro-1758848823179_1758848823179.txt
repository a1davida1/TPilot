server/caption/geminiPipeline.ts
+73-37
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";
import { extractToneOptions, ToneOptions } from "./toneOptions";
import { buildVoiceGuideBlock } from "./stylePack";
import { serializePromptField } from "./promptUtils";
import { formatVoiceContext } from "./voiceTraits";
import { ensureFactCoverage } from "./ensureFactCoverage";
import { inferFallbackFromFacts, ensureFallbackCompliance } from "./inferFallbackFromFacts";
import { dedupeVariantsForRanking } from "./dedupeVariants";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import { prepareVariantsForRanking } from "./prepareVariantsForRanking";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}
@@ -465,109 +464,145 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i
    hintParts.push("Provide five options that vary tone, structure, and specific imagery.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    const serializedHint = serializePromptField(combinedHint, { block: true });
    lines.push(`HINT:${serializedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
      ]);
      const json = stripToJSON(res.response.text()) as unknown;
      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error("Gemini textModel.generateContent failed:", error);
      throw error;
    }
  };

  const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
  const existingCaptions: string[] = [];
  const duplicatesThisAttempt: string[] = [];
  const seenKeys = new Set<string>();
  const duplicatesForHint: string[] = [];
  let needsBannedHint = false;
  const isTest = process.env.NODE_ENV === 'test';
  const maxAttempts = isTest ? 2 : 5; // Allow 2 attempts in test for retry logic testing
  const maxAttempts = isTest ? Math.max(3, VARIANT_RETRY_LIMIT) : VARIANT_RETRY_LIMIT;

  for (let attempt = 0; attempt < maxAttempts && uniqueVariants.length < 5; attempt += 1) {
    const needed = 5 - uniqueVariants.length;
    const varietyHint = attempt === 0
  let attempt = 0;
  while (uniqueVariants.length < VARIANT_TARGET && attempt < maxAttempts) {
    const needed = VARIANT_TARGET - uniqueVariants.length;
    const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and imagery.`.trim();
    let varietyHint = attempt === 0
      ? params.hint
      : (() => {
          // Build complete base hint with variety clause first, then pass to buildRetryHint
          const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and imagery.`;
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
        })();
      : buildRetryHint(baseHintWithVariety, duplicatesForHint, needed);

    if (needsBannedHint) {
      varietyHint = [varietyHint, BANNED_WORDS_HINT].filter(Boolean).join(' ');
    }

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt
    duplicatesForHint.length = 0;
    let bannedDetected = false;

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (uniqueVariants.length >= VARIANT_TARGET) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;
      const key = uniqueCaptionKey(captionText);

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
      if (!key) {
        continue;
      }

      if (seenKeys.has(key)) {
        duplicatesForHint.push(captionText);
        continue;
      }

      const hasBannedWord = variantContainsBannedWord({
        caption: sanitized.caption,
        hashtags: sanitized.hashtags,
        cta: sanitized.cta,
        alt: sanitized.alt,
      });

      if (hasBannedWord) {
        bannedDetected = true;
        continue;
      }

      seenKeys.add(key);
      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }

    if (duplicatesForHint.length === 0 && uniqueVariants.length < VARIANT_TARGET) {
      const fallbackDuplicate = rawVariants.find(
        candidate => typeof candidate === "object" && candidate !== null && typeof (candidate as Record<string, unknown>).caption === "string"
      ) as { caption: string } | undefined;
      if (fallbackDuplicate) {
        duplicatesForHint.push(fallbackDuplicate.caption);
      }
    }

    needsBannedHint = bannedDetected;

    attempt += 1;
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
  if (uniqueVariants.length < VARIANT_TARGET) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Engaging social media content",
      alt: "Detailed alt text describing the scene",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      caption: safeFallbackCaption,
      alt: safeFallbackAlt,
      hashtags: [...safeFallbackHashtags],
      cta: safeFallbackCta,
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
      nsfw: false,
    } as z.infer<typeof CaptionItem>;

    while (uniqueVariants.length < VARIANT_TARGET) {
      const index = uniqueVariants.length + 1;
      const captionSeed = baseVariant.caption || safeFallbackCaption;
      const fallbackCaption = `${captionSeed} (retry filler ${index})`;
      uniqueVariants.push({
        ...baseVariant,
        caption: fallbackCaption,
        alt: `${baseVariant.alt} (retry filler ${index})`,
      });
    }
  }

  return CaptionArray.parse(uniqueVariants);
  return CaptionArray.parse(uniqueVariants.slice(0, VARIANT_TARGET));
}

function normalizeGeminiFinal(
  final: Record<string, unknown>,
  platform?: string,
  facts?: Record<string, unknown>
){
  final.safety_level = normalizeSafetyLevel(
    typeof final.safety_level === "string" ? final.safety_level : "normal"
  );
  final.mood = typeof final.mood === "string" && final.mood.trim().length >= 2 ? final.mood.trim() : "engaging";
  final.style = typeof final.style === "string" && final.style.trim().length >= 2 ? final.style.trim() : "authentic";

  // Use helper for contextual fallbacks
  if (platform) {
    const fallback = ensureFallbackCompliance(
      {
        caption: typeof final.caption === 'string' ? final.caption : undefined,
        hashtags: Array.isArray(final.hashtags) ? final.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
        cta: typeof final.cta === 'string' ? final.cta : undefined,
        alt: typeof final.alt === 'string' ? final.alt : undefined,
      },
      {
        platform: platform as "instagram" | "x" | "reddit" | "tiktok",
        facts,
@@ -759,66 +794,67 @@ export async function rankAndSelect(
  });
}

type GeminiPipelineArgs = {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};

/**
 * Primary image captioning pipeline backed by Gemini vision + text models.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
export async function pipeline({ imageUrl, platform, voice = "flirty_playful", nsfw = false, style, mood, ...toneRest }: GeminiPipelineArgs): Promise<CaptionResult> {
  try {
    const tone = extractToneOptions(toneRest);
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, facts, nsfw, ...tone });
    variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
    variants = prepareVariantsForRanking(variants, { platform, facts }, { targetLength: VARIANT_TARGET });
    let ranked = await rankAndSelect(variants, { platform, facts });
    let out = ranked.final;

    const enforceCoverage = async () => {
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        variants = await generateVariants({ platform, voice, facts, hint: coverage.hint, nsfw, ...tone });
        variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
        variants = prepareVariantsForRanking(variants, { platform, facts }, { targetLength: VARIANT_TARGET });
        ranked = await rankAndSelect(variants, { platform, facts });
        out = ranked.final;
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    await enforceCoverage();

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({
        platform,
        voice,
        style,
        mood,
        facts,
        hint: `Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`,
        nsfw
      });
      variants = prepareVariantsForRanking(variants, undefined, { targetLength: VARIANT_TARGET });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/prepareVariantsForRanking.ts
New
+24-0
import { z } from "zod";
import { CaptionArray } from "./schema";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import { dedupeVariantsForRanking } from "./dedupeVariants";

export type RankingContext = Parameters<typeof dedupeVariantsForRanking>[2];

export function prepareVariantsForRanking(
  variants: z.infer<typeof CaptionArray>,
  context?: RankingContext,
  options?: { targetLength?: number; lengthGapThreshold?: number }
): z.infer<typeof CaptionArray> {
  const targetLength = options?.targetLength ?? 5;
  const lengthGapThreshold = options?.lengthGapThreshold;
  const deduped = lengthGapThreshold !== undefined
    ? dedupeCaptionVariants(variants, lengthGapThreshold)
    : dedupeCaptionVariants(variants);

  return dedupeVariantsForRanking(
    deduped as unknown as z.infer<typeof CaptionArray>,
    targetLength,
    context
  );
}
server/caption/textOnlyPipeline.ts
+67-33
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { z } from "zod";
import { textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { extractToneOptions, ToneOptions } from "./toneOptions";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";
import { buildVoiceGuideBlock } from "./stylePack";
import { formatVoiceContext } from "./voiceTraits";
import { serializePromptField } from "./promptUtils";
import { inferFallbackFromFacts, ensureFallbackCompliance } from "./inferFallbackFromFacts";
import { dedupeVariantsForRanking } from "./dedupeVariants";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import { prepareVariantsForRanking } from "./prepareVariantsForRanking";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

const MAX_VARIANT_ATTEMPTS = 4;
const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 4;
const CAPTION_KEY_LENGTH = 80;

function captionKey(caption: string): string {
  return caption.trim().slice(0, 80).toLowerCase();
}

function hintSnippet(caption: string): string {
  const normalized = caption.trim().replace(/\s+/g, " ");
  return normalized.length > 60 ? `${normalized.slice(0, 57)}…` : normalized;
}

function uniqueCaptionKey(caption: string): string {
  return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
@@ -257,109 +256,144 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P
    }
    hintParts.push("Provide five options that vary tone, structure, and specific content themes.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    lines.push(`HINT: ${combinedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
      ]);
      const json = stripToJSON(res.response.text());
      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error("Gemini textModel.generateContent failed:", error);
      throw error;
    }
  };

  const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
  const existingCaptions: string[] = [];
  const duplicatesThisAttempt: string[] = [];
  const seenKeys = new Set<string>();
  const duplicatesForHint: string[] = [];
  let needsBannedHint = false;
  const isTest = process.env.NODE_ENV === 'test';
  const maxAttempts = isTest ? 2 : 5; // Allow 2 attempts in test for retry logic testing
  const maxAttempts = isTest ? Math.max(3, VARIANT_RETRY_LIMIT) : VARIANT_RETRY_LIMIT;

  for (let attempt = 0; attempt < maxAttempts && uniqueVariants.length < 5; attempt += 1) {
    const needed = 5 - uniqueVariants.length;
    const varietyHint = attempt === 0
  let attempt = 0;
  while (uniqueVariants.length < VARIANT_TARGET && attempt < maxAttempts) {
    const needed = VARIANT_TARGET - uniqueVariants.length;
    const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and themes.`.trim();
    let varietyHint = attempt === 0
      ? params.hint
      : (() => {
          // Build complete base hint with variety clause first, then pass to buildRetryHint
          const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and themes.`;
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
        })();
      : buildRetryHint(baseHintWithVariety, duplicatesForHint, needed);

    if (needsBannedHint) {
      varietyHint = [varietyHint, BANNED_WORDS_HINT].filter(Boolean).join(' ');
    }

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt
    duplicatesForHint.length = 0;
    let bannedDetected = false;

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (uniqueVariants.length >= VARIANT_TARGET) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;
      const key = uniqueCaptionKey(captionText);

      if (!key) {
        continue;
      }

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
      if (seenKeys.has(key)) {
        duplicatesForHint.push(captionText);
        continue;
      }

      const hasBannedWord = variantContainsBannedWord({
        caption: sanitized.caption,
        hashtags: sanitized.hashtags,
        cta: sanitized.cta,
        alt: sanitized.alt,
      });

      if (hasBannedWord) {
        bannedDetected = true;
        continue;
      }

      seenKeys.add(key);
      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }

    if (duplicatesForHint.length === 0 && uniqueVariants.length < VARIANT_TARGET) {
      const fallbackDuplicate = rawVariants.find(
        candidate => typeof candidate === "object" && candidate !== null && typeof (candidate as Record<string, unknown>).caption === "string"
      ) as { caption: string } | undefined;
      if (fallbackDuplicate) {
        duplicatesForHint.push(fallbackDuplicate.caption);
      }
    }

    needsBannedHint = bannedDetected;

    attempt += 1;
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
  if (uniqueVariants.length < VARIANT_TARGET) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Text-only social media content",
      alt: "Detailed alt text describing the theme",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
    const paddedVariant = {
      ...baseVariant,
      caption: `${baseVariant.caption} v${uniqueVariants.length + 1}`,
      alt: `${baseVariant.alt} (variation ${uniqueVariants.length + 1})`
    };

    uniqueVariants.push(paddedVariant as z.infer<typeof CaptionItem>);
      nsfw: false,
    } as z.infer<typeof CaptionItem>;

    while (uniqueVariants.length < VARIANT_TARGET) {
      const index = uniqueVariants.length + 1;
      const captionSeed = baseVariant.caption || "Text-only social media content";
      uniqueVariants.push({
        ...baseVariant,
        caption: `${captionSeed} (retry filler ${index})`,
        alt: `${baseVariant.alt} (retry filler ${index})`,
      });
    }
  }

  return CaptionArray.parse(uniqueVariants);
  return CaptionArray.parse(uniqueVariants.slice(0, VARIANT_TARGET));
}

async function requestTextOnlyRanking(
  variantsInput: unknown[],
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
): Promise<unknown> {
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res = await textModel.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Text-only textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  if(Array.isArray(json)) {
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
@@ -412,39 +446,39 @@ export async function rankAndSelect(
    final: sanitizedFinal,
    reason: summary
  });
}

type TextOnlyPipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  theme:string;
  context?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

/**
 * Text-only caption pipeline for brainstorming without an image upload.
 *
 * @remarks
 * Persona settings (`style`, `mood`, etc.) are forwarded to every Gemini retry so the
 * voice remains consistent even when a platform validation retry is required.
 */
export async function pipelineTextOnly({ platform, voice="flirty_playful", theme, context, nsfw=false, ...toneRest }:TextOnlyPipelineArgs){
  const tone = extractToneOptions(toneRest);
  let variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone });
  variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
  variants = prepareVariantsForRanking(variants, { platform, theme, context }, { targetLength: VARIANT_TARGET });
  let ranked = await rankAndSelect(variants, { platform, theme, context });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone, hint:`Fix: ${err}. Be specific and engaging.` });
    variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
    variants = prepareVariantsForRanking(variants, { platform, theme, context }, { targetLength: VARIANT_TARGET });
    ranked = await rankAndSelect(variants, { platform, theme, context });
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/routes/caption-generation.test.ts
+6-2
@@ -742,51 +742,53 @@ describe('Caption Generation', () => {
          cta: 'Who are you texting tonight?',
          alt: 'Final alt entry covering the golden styling for unique variant set',
          nsfw: false,
        },
      ];

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(duplicateBatch) },
        })
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(uniqueBatch) },
        });

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const secondPrompt = textGenerateMock.mock.calls[1][0][0].text as string;
      expect(secondPrompt).toContain('HINT:You already wrote');
      expect(secondPrompt).toContain('HINT:');
      expect(secondPrompt).toContain('Need much more variety');
      expect(secondPrompt).toContain('You already wrote');
      expect(new Set(result.map(v => v.caption.toLowerCase().slice(0, 80))).size).toBe(5);
    });

    it('sanitizes base hints with quotes and line breaks for Gemini variants', async () => {
      const variantPayload = [
        {
          caption: 'Fresh take on winter vibes with cozy layers',
          hashtags: ['#winter', '#cozy', '#layers'],
          safety_level: 'normal',
          mood: 'confident',
          style: 'authentic',
          cta: 'Drop a thought',
          alt: 'Detailed alt text to satisfy schema enforcement for hint serialization testing.',
          nsfw: false,
        },
        {
          caption: 'Midnight sparkle energy under city lights tonight',
          hashtags: ['#midnight', '#sparkle', '#city'],
          safety_level: 'normal',
          mood: 'playful',
          style: 'bold',
          cta: 'Share your vibe',
          alt: 'Another richly detailed alt text for validation flow with unique content.',
          nsfw: false,
        },
@@ -1192,51 +1194,53 @@ describe('Caption Generation', () => {
          alt: 'Reflective alt text encouraging users to acknowledge daily progress',
          nsfw: false,
        },
      ];

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(duplicateBatch) },
        })
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(uniqueBatch) },
        });

      const { generateVariantsTextOnly } = await import('../../server/caption/textOnlyPipeline.js');
      const result = await generateVariantsTextOnly({
        platform: 'instagram',
        voice: 'inspiring',
        theme: 'motivation',
        context: 'morning motivation post',
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const secondPrompt = textGenerateMock.mock.calls[1][0][0].text as string;
      expect(secondPrompt).toContain('HINT:You already wrote');
      expect(secondPrompt).toContain('HINT:');
      expect(secondPrompt).toContain('Need much more variety');
      expect(secondPrompt).toContain('You already wrote');
      expect(new Set(result.map(v => v.caption.toLowerCase().slice(0, 80))).size).toBe(5);
    });
  });

  describe('Rewrite Pipeline', () => {
    it('should improve existing captions', async () => {
      const existingCaption = 'Basic caption here';
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Enhanced and engaging caption! ✨',
              hashtags: ['#enhanced', '#content'],
              safety_level: 'normal',
              mood: 'engaging',
              style: 'authentic',
              cta: 'What do you think?',
              alt: 'An engaging social media post with vibrant energy and compelling call to action',
              nsfw: false,
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
