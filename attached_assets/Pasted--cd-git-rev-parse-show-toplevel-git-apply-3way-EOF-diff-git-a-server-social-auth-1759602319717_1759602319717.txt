 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/social-auth.ts b/server/social-auth.ts
index 71bf58381523ef9b08af793f9154bdfebc12c421..965c8fe168e3457dc47fbe27cba28a77113d35dd 100644
--- a/server/social-auth.ts
+++ b/server/social-auth.ts
@@ -1,80 +1,76 @@
 import passport from 'passport';
 import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
 import { Strategy as FacebookStrategy } from 'passport-facebook';
 import { Strategy as RedditStrategy } from 'passport-reddit';
 import type { CookieOptions, Express, NextFunction, Request, Response } from 'express';
 import type { AuthenticateOptions } from 'passport';
 import type { User } from '@shared/schema';
 import { storage } from './storage';
 import jwt from 'jsonwebtoken';
 import { blacklistToken } from './lib/tokenBlacklist';
 import { logger } from './bootstrap/logger';
 import { API_PREFIX, prefixApiPath } from './lib/api-prefix.js';
 import { createToken } from './middleware/auth.js';
 import { getSessionCookieConfig } from './bootstrap/session.js';
 
 type RedditAuthenticateOptions = AuthenticateOptions & {
   state?: string;
   duration?: 'temporary' | 'permanent';
 };
 
 const redditCallbackOptions: RedditAuthenticateOptions = {
   failureRedirect: '/login?error=reddit_failed'
   // Note: No successRedirect - we handle cookie + redirect in the callback handler
 };
 
-type SessionCookieConfig = {
-  name: string;
-  options: CookieOptions;
-};
-
-const getSessionCookieConfig = (): SessionCookieConfig => {
-  const cookieName = process.env.SESSION_COOKIE_NAME ?? 'tpilot.sid';
-  const isProduction = process.env.NODE_ENV === 'production';
-  const cookieDomain = process.env.SESSION_COOKIE_DOMAIN?.trim();
-
+const getAuthCookieOptions = (): CookieOptions => {
   const cookieOptions: CookieOptions = {
     httpOnly: true,
-    sameSite: 'lax',
-    secure: isProduction,
+    secure: true,
+    sameSite: 'none',
     path: '/',
   };
 
+  const cookieDomain = process.env.SESSION_COOKIE_DOMAIN?.trim();
   if (cookieDomain) {
     cookieOptions.domain = cookieDomain;
   }
 
-  return {
-    name: cookieName,
-    options: cookieOptions,
-  };
+  return cookieOptions;
+};
+
+const setAuthCookie = (res: Response, token: string): void => {
+  res.cookie('authToken', token, {
+    ...getAuthCookieOptions(),
+    maxAge: 86400_000,
+  });
 };
 
 const clearSessionCookie = (res: Response): void => {
-  const { name, options } = getSessionCookieConfig();
-  res.clearCookie(name, options);
+  const { name, cookie } = getSessionCookieConfig();
+  res.clearCookie(name, cookie);
 };
 
 export function setupSocialAuth(app: Express, apiPrefix: string = API_PREFIX) {
   // Note: passport.initialize() and passport.session() are now called from routes.ts
   // after session middleware is initialized
   // Serialization/deserialization is also handled in routes.ts
 
   // Google OAuth Strategy
   if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
     passport.use(new GoogleStrategy({
       clientID: process.env.GOOGLE_CLIENT_ID,
       clientSecret: process.env.GOOGLE_CLIENT_SECRET,
       callbackURL: prefixApiPath('/auth/google/callback', apiPrefix)
     }, async (accessToken, refreshToken, profile, done) => {
       try {
         const email = profile.emails?.[0]?.value || '';
         const username = profile.displayName || email || '';
         const avatar = profile.photos?.[0]?.value;
         
         // First, check by provider ID (most reliable for OAuth)
         let user = await storage.getUserByProviderId('google', profile.id);
         
         if (user) {
           // Update avatar and username if changed
           if (avatar && user.avatar !== avatar || user.username !== username) {
diff --git a/server/social-auth.ts b/server/social-auth.ts
index 71bf58381523ef9b08af793f9154bdfebc12c421..965c8fe168e3457dc47fbe27cba28a77113d35dd 100644
--- a/server/social-auth.ts
+++ b/server/social-auth.ts
@@ -228,216 +224,174 @@ export function setupSocialAuth(app: Express, apiPrefix: string = API_PREFIX) {
         
         return done(null, user);
       } catch (error) {
         return done(error as Error, false);
       }
     }));
   }
 
   // Auth routes
   setupAuthRoutes(app, apiPrefix);
 }
 
 function setupAuthRoutes(app: Express, apiPrefix: string) {
   const route = (path: string) => prefixApiPath(path, apiPrefix);
   // Google routes
   app.get(route('/auth/google'),
     passport.authenticate('google', { scope: ['profile', 'email'] })
   );
 
   app.get(route('/auth/google/callback'),
     passport.authenticate('google', { failureRedirect: '/login?error=google_failed' }),
     (req, res) => {
       // Set auth token cookie with SameSite=None for third-party OAuth redirect
       if (req.user) {
         const token = createToken(req.user as User);
-        res.cookie('authToken', token, {
-          httpOnly: true,
-          secure: true,
-          sameSite: 'none',
-          maxAge: 86400_000,
-          path: '/',
-        });
+        setAuthCookie(res, token);
       }
       res.redirect('/dashboard');
     }
   );
 
   // Facebook routes
   app.get(route('/auth/facebook'),
     passport.authenticate('facebook', { scope: ['email'] })
   );
 
   app.get(route('/auth/facebook/callback'),
     passport.authenticate('facebook', { failureRedirect: '/login?error=facebook_failed' }),
     (req, res) => {
       // Set auth token cookie with SameSite=None for third-party OAuth redirect
       if (req.user) {
         const token = createToken(req.user as User);
-        res.cookie('authToken', token, {
-          httpOnly: true,
-          secure: true,
-          sameSite: 'none',
-          maxAge: 86400_000,
-          path: '/',
-        });
+        setAuthCookie(res, token);
       }
       res.redirect('/dashboard');
     }
   );
 
   // Reddit routes
   app.get(route('/auth/reddit'), (req: Request, res: Response, next: NextFunction) => {
     const redditAuthOptions: RedditAuthenticateOptions = {
       state: Math.random().toString(36).substring(7)
     };
     return passport.authenticate('reddit', redditAuthOptions)(req, res, next);
   });
 
   app.get(route('/auth/reddit/callback'),
     passport.authenticate('reddit', redditCallbackOptions),
     (req, res) => {
       // Set auth token cookie with SameSite=None for third-party OAuth redirect
       if (req.user) {
         const token = createToken(req.user as User);
-        res.cookie('authToken', token, {
-          httpOnly: true,
-          secure: true, // Must be true for SameSite=None
-          sameSite: 'none', // Required for third-party redirect
-          maxAge: 86400_000,
-          path: '/',
-        });
+        setAuthCookie(res, token);
       }
       res.redirect('/dashboard?connected=reddit');
     }
   );
 
   // Logout with comprehensive error handling
   app.post(route('/auth/logout'), async (req: Request, res: Response) => {
     const r = req as Request & {
       session?: { destroy?: (cb: (err?: unknown) => void) => void };
       logout?: (cb: (err?: unknown) => void) => void;
     };
     try {
       // Check if session exists first
       if (!r.session) {
         // No session, just clear cookies and return success
         clearSessionCookie(res);
-        res.clearCookie('authToken', {
-          httpOnly: true,
-          secure: process.env.NODE_ENV === 'production',
-          sameSite: 'strict'
-        });
+        res.clearCookie('authToken', getAuthCookieOptions());
         const authHeader = req.headers['authorization'];
         const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
         if (token) {
           const decoded = jwt.decode(token) as { exp?: number } | null;
           const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
           await blacklistToken(token, ttl);
         }
         return res.json({ message: 'Logged out successfully' });
       }
 
       // If using Passport and session exists
       if (r.logout) {
         r.logout(async (err) => {
           if (err) {
             logger.error('Passport logout error', { error: err instanceof Error ? err.message : String(err) });
             // Continue with logout anyway
           }
           
           // Destroy session if it exists
           if (r.session && r.session.destroy) {
             r.session.destroy(async (destroyErr) => {
               if (destroyErr) {
                 logger.error('Session destroy error', { error: destroyErr instanceof Error ? destroyErr.message : String(destroyErr) });
               }
               // Clear cookies regardless
               clearSessionCookie(res);
-              res.clearCookie('authToken', {
-                httpOnly: true,
-                secure: process.env.NODE_ENV === 'production',
-                sameSite: 'strict'
-              });
+              res.clearCookie('authToken', getAuthCookieOptions());
               const authHeader = req.headers['authorization'];
               const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
               if (token) {
                 const decoded = jwt.decode(token) as { exp?: number } | null;
                 const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
                 await blacklistToken(token, ttl);
               }
               res.json({ message: 'Logged out successfully' });
             });
           } else {
             // No session.destroy, just clear cookies
             clearSessionCookie(res);
-            res.clearCookie('authToken', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
+            res.clearCookie('authToken', getAuthCookieOptions());
             const authHeader = req.headers['authorization'];
             const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
             if (token) {
               const decoded = jwt.decode(token) as { exp?: number } | null;
               const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
               await blacklistToken(token, ttl);
             }
             res.json({ message: 'Logged out successfully' });
           }
         });
       } else {
         // No passport logout, destroy session directly
         if (r.session && r.session.destroy) {
           r.session.destroy(async (err) => {
             if (err) {
               logger.error('Session destroy error', { error: err instanceof Error ? err.message : String(err) });
             }
             clearSessionCookie(res);
-            res.clearCookie('authToken', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
+            res.clearCookie('authToken', getAuthCookieOptions());
             const authHeader = req.headers['authorization'];
             const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
             if (token) {
               const decoded = jwt.decode(token) as { exp?: number } | null;
               const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
               await blacklistToken(token, ttl);
             }
             res.json({ message: 'Logged out successfully' });
           });
         } else {
           // Just clear cookies
           clearSessionCookie(res);
-          res.clearCookie('authToken', {
-            httpOnly: true,
-            secure: process.env.NODE_ENV === 'production',
-            sameSite: 'strict'
-          });
+          res.clearCookie('authToken', getAuthCookieOptions());
           const authHeader = req.headers['authorization'];
           const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
           if (token) {
             const decoded = jwt.decode(token) as { exp?: number } | null;
             const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
             await blacklistToken(token, ttl);
           }
           res.json({ message: 'Logged out successfully' });
         }
       }
     } catch (error) {
       logger.error('Logout error', { error: error instanceof Error ? (error as Error).message : String(error) });
       // Even on error, clear cookies to help user
       clearSessionCookie(res);
-      res.clearCookie('authToken', {
-        httpOnly: true,
-        secure: process.env.NODE_ENV === 'production',
-        sameSite: 'strict'
-      });
+      res.clearCookie('authToken', getAuthCookieOptions());
       res.json({ message: 'Logged out (with errors)' });
     }
   });
 
   // Get current user - REMOVED: Duplicate endpoint
   // The main /api/auth/user endpoint is handled in server/auth.ts with JWT support
 }
 
EOF
)