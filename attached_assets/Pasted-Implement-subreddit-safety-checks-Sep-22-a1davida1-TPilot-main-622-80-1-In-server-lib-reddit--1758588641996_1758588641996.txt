Implement subreddit safety checks
Sep 22 · a1davida1/TPilot · main
+622-80
1. In `server/lib/reddit.ts`, load the target community via `redditCommunities` and call `SafetyManager.performSafetyCheck` plus any subreddit-specific rule predicates before allowing a submission.
2. Return descriptive `reason` strings for failures (karma, verification, rate limit, duplicates, etc.) and bubble them through `/api/reddit/submit`.
3. When a post succeeds, invoke `SafetyManager.recordPost` and `SafetyManager.recordPostForDuplicateDetection` so rate-limit and duplicate tables stay accurate.
4. Add unit coverage around the new logic to confirm rule, rate-limit, and duplicate blocks all trigger correctly.

Summary

    Enriched RedditManager with subreddit-specific rule predicates, integrated SafetyManager.performSafetyCheck, enforced descriptive rejection reasons, and recorded rate-limit/duplicate metrics after successful submissions (including image and gallery flows).

    Updated Reddit posting workers to build full post context for permission checks before queueing or publishing content, ensuring SafetyManager uses accurate payloads.

    Surfaced safety failure metadata from the Reddit submit API and refreshed integration/unit coverage to validate rule, rate-limit, and duplicate blocking behavior.

Testing

    ✅ npm run lint

    ⚠️ npm test *(aborted after numerous pre-existing suite failures that require unavailable services; see log)*


server/lib/reddit.ts
+361-38
import snoowrap from 'snoowrap';
import { db } from '../db.js';
import { creatorAccounts } from '@shared/schema';
import { creatorAccounts, redditCommunities } from '@shared/schema';
import { eq, and } from 'drizzle-orm';
import { decrypt } from '../services/state-store.js';
import { SafetyManager } from './safety-systems.js';

function getEnvOrDefault(name: string, defaultValue?: string): string {
  const value = process.env[name];
  if (!value && !defaultValue) {
    console.warn(`Warning: Missing environment variable: ${name}`);
    return '';
  }
  return value || defaultValue || '';
}

// These will be validated when actually needed, not at startup
const REDDIT_CLIENT_ID = getEnvOrDefault('REDDIT_CLIENT_ID');
const REDDIT_CLIENT_SECRET = getEnvOrDefault('REDDIT_CLIENT_SECRET');
const REDDIT_USER_AGENT = getEnvOrDefault('REDDIT_USER_AGENT', 'ThottoPilot/1.0 (Content scheduling bot)');

export interface RedditPostOptions {
  subreddit: string;
  title: string;
  body?: string;
  url?: string;
  nsfw?: boolean;
  spoiler?: boolean;
}

export interface RedditPostResult {
  success: boolean;
  postId?: string;
  url?: string;
  error?: string;
  reason?: string;
  nextAllowedPost?: Date;
}

export interface PostingPermission {
  canPost: boolean;
  reason?: string;
  nextAllowedPost?: Date;
}

interface RedditSubmission {
  id: string;
  permalink: string;
}

type PostType = 'text' | 'link' | 'image' | 'gallery' | 'video';

interface PostCheckContext {
  title?: string;
  body?: string;
  url?: string;
  nsfw?: boolean;
  postType?: PostType;
}

interface AccountMetadata {
  karma?: number;
  verified?: boolean;
  [key: string]: unknown;
}

interface RulePredicateInput {
  subreddit: string;
  community?: {
    name: string;
    verificationRequired?: boolean;
    promotionAllowed?: string;
    postingLimits?: unknown;
    rules?: unknown;
  };
  accountMetadata: AccountMetadata;
  context: PostCheckContext;
}

interface RulePredicateResult {
  allowed: boolean;
  reason?: string;
}

type RulePredicate = (input: RulePredicateInput) => RulePredicateResult;

const BASE_RULE_PREDICATES: RulePredicate[] = [
  ({ community, accountMetadata }) => {
    if (!community?.verificationRequired) {
      return { allowed: true };
    }
    if (accountMetadata.verified) {
      return { allowed: true };
    }
    return {
      allowed: false,
      reason: `r/${community.name} requires a verified Reddit account before posting.`,
    };
  },
  ({ community, accountMetadata }) => {
    if (!community) {
      return { allowed: true };
    }
    const minKarma = extractMinKarma(community.postingLimits);
    if (typeof minKarma !== 'number') {
      return { allowed: true };
    }
    const currentKarma = typeof accountMetadata.karma === 'number' ? accountMetadata.karma : 0;
    if (currentKarma >= minKarma) {
      return { allowed: true };
    }
    return {
      allowed: false,
      reason: `You need at least ${minKarma} karma to post in r/${community.name}. Your account currently has ${currentKarma}.`,
    };
  },
  ({ community, context }) => {
    if (!community) {
      return { allowed: true };
    }
    if (community.promotionAllowed === 'no' && hasExternalLink(context)) {
      return {
        allowed: false,
        reason: `r/${community.name} does not allow promotional or external links in submissions.`,
      };
    }
    return { allowed: true };
  },
];

const SUBREDDIT_RULE_PREDICATES: Record<string, RulePredicate[]> = {
  gonewild: [
    ({ context, subreddit }) => {
      if (context.nsfw) {
        return { allowed: true };
      }
      return {
        allowed: false,
        reason: `r/${subreddit} requires posts to be marked as NSFW. Please enable the NSFW flag before posting.`
      };
    },
  ],
  realgirls: [
    ({ context, community }) => {
      if (!community) {
        return { allowed: true };
      }
      if (community.promotionAllowed === 'no' && hasExternalLink(context)) {
        return {
          allowed: false,
          reason: `r/${community.name} does not allow external links or self-promotion content.`
        };
      }
      return { allowed: true };
    },
  ],
};

function hasExternalLink(context: PostCheckContext): boolean {
  if (context.url && context.url.trim().length > 0) {
    return true;
  }
  const body = context.body ?? '';
  return /https?:\/\//i.test(body) || /www\./i.test(body);
}

function extractMinKarma(postingLimits: unknown): number | undefined {
  if (!postingLimits || typeof postingLimits !== 'object') {
    return undefined;
  }
  const limits = postingLimits as Record<string, unknown>;
  const candidates = [
    limits.minKarma,
    limits.minTotalKarma,
    limits.minimumKarma,
  ];
  for (const candidate of candidates) {
    if (typeof candidate === 'number' && Number.isFinite(candidate)) {
      return candidate;
    }
  }
  return undefined;
}

function combineContentSegments(...segments: Array<string | undefined>): string {
  return segments
    .map(segment => (typeof segment === 'string' ? segment.trim() : ''))
    .filter(segment => segment.length > 0)
    .join('\n');
}

function resolvePostType(context: PostCheckContext): PostType {
  if (context.postType) {
    return context.postType;
  }
  if (context.url && context.url.length > 0) {
    return 'link';
  }
  return 'text';
}

function evaluateRulePredicates(input: RulePredicateInput): RulePredicateResult | undefined {
  for (const predicate of BASE_RULE_PREDICATES) {
    const result = predicate(input);
    if (!result.allowed) {
      return result;
    }
  }

  const subredditPredicates = SUBREDDIT_RULE_PREDICATES[input.subreddit];
  if (subredditPredicates) {
    for (const predicate of subredditPredicates) {
      const result = predicate(input);
      if (!result.allowed) {
        return result;
      }
    }
  }

  return undefined;
}

export class RedditManager {
  private reddit: snoowrap;
  private userId: number;

  constructor(accessToken: string, refreshToken: string, userId: number) {
    this.userId = userId;
    this.reddit = new snoowrap({
      userAgent: REDDIT_USER_AGENT,
      clientId: REDDIT_CLIENT_ID,
      clientSecret: REDDIT_CLIENT_SECRET,
      accessToken,
      refreshToken,
    });
  }

  /**
   * Get Reddit manager for a specific user
   */
  static async forUser(userId: number): Promise<RedditManager | null> {
    try {
      const [account] = await db
        .select()
        .from(creatorAccounts)
        .where(
          and(
@@ -81,407 +256,555 @@ export class RedditManager {
      }

      // Decrypt tokens
      const accessToken = decrypt(account.oauthToken);
      const refreshToken = account.oauthRefresh ? decrypt(account.oauthRefresh) : '';
      
      if (!accessToken) {
        console.error('Failed to decrypt access token for user:', userId);
        return null;
      }

      return new RedditManager(accessToken, refreshToken, userId);
    } catch (error) {
      console.error('Failed to create Reddit manager for user:', error);
      return null;
    }
  }

  /**
   * Submit a post to Reddit
   */
  async submitPost(options: RedditPostOptions): Promise<RedditPostResult> {
    try {
      console.log(`Submitting post to r/${options.subreddit}: "${options.title}"`);

      // Check if we can post to this subreddit
      const permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit);
      // Check if we can post to this subreddit with full safety context
      const permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit, {
        title: options.title,
        body: options.body,
        url: options.url,
        nsfw: options.nsfw ?? false,
        postType: options.url ? 'link' : 'text',
      });
      if (!permission.canPost) {
        return {
          success: false,
          error: permission.reason || 'Cannot post to this subreddit'
          error: permission.reason || 'Cannot post to this subreddit',
          reason: permission.reason,
          nextAllowedPost: permission.nextAllowedPost,
        };
      }

      let submission: RedditSubmission;

      if (options.url) {
        // Link post
        const subreddit = (this.reddit as unknown as {
          getSubreddit(name: string): {
            submitLink(input: {
              subredditName: string;
              title: string;
              url: string;
              nsfw: boolean;
              spoiler: boolean;
            }): Promise<RedditSubmission>;
          };
        }).getSubreddit(options.subreddit);
        submission = await subreddit.submitLink({
          subredditName: options.subreddit,
          title: options.title,
          url: options.url,
          nsfw: options.nsfw ?? false,
          spoiler: options.spoiler ?? false,
        });
      } else {
        // Text post
        const subreddit = (this.reddit as unknown as {
          getSubreddit(name: string): {
            submitSelfpost(input: {
              subredditName: string;
              title: string;
              text: string;
              nsfw: boolean;
              spoiler: boolean;
            }): Promise<RedditSubmission>;
          };
        }).getSubreddit(options.subreddit);
        submission = await subreddit.submitSelfpost({
          subredditName: options.subreddit,
          title: options.title,
          text: options.body ?? '',
          nsfw: options.nsfw ?? false,
          spoiler: options.spoiler ?? false,
        });
      }

      // Update rate limiting
      await this.updateRateLimit(options.subreddit);
      const duplicateBody = combineContentSegments(options.body, options.url);
      await this.recordSafetySignals(options.subreddit, options.title, duplicateBody);

      console.log('Reddit submission succeeded:', {
        userId: this.userId,
        subreddit: options.subreddit,
        postId: submission.id,
      });

      return {
        success: true,
        postId: submission.id,
        url: `https://www.reddit.com${submission.permalink}`,
      };

    } catch (error: unknown) {
      console.error('Reddit submission failed:', {
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      let errorMessage = 'Failed to submit post';
      
      // Parse common Reddit API errors
      const errorObj = error as { message?: string };
      if (errorObj.message?.includes('RATELIMIT')) {
        errorMessage = 'Rate limited by Reddit. Please try again later.';
      } else if (errorObj.message?.includes('SUBREDDIT_NOTALLOWED')) {
        errorMessage = 'Not allowed to post in this subreddit';
      } else if (errorObj.message?.includes('NO_TEXT')) {
        errorMessage = 'Post content cannot be empty';
      } else if (errorObj.message?.includes('TOO_LONG')) {
        errorMessage = 'Post title or content is too long';
      }

      return {
        success: false,
        error: errorMessage
        error: errorMessage,
        reason: errorMessage,
      };
    }
  }

  /**
   * Submit image post with direct upload to Reddit
   */
  async submitImagePost(options: {
    subreddit: string;
    title: string;
    imageUrl?: string;
    imageBuffer?: Buffer;
    imagePath?: string;
    nsfw?: boolean;
    spoiler?: boolean;
  }): Promise<RedditPostResult> {
    try {
      const permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit, {
        title: options.title,
        nsfw: options.nsfw ?? false,
        url: options.imageUrl,
        postType: 'image',
      });
      if (!permission.canPost) {
        return {
          success: false,
          error: permission.reason || 'Cannot post to this subreddit',
          reason: permission.reason,
          nextAllowedPost: permission.nextAllowedPost,
        };
      }

      const reddit = await this.initReddit();
      
      // If we have a URL, download it to buffer
      if (options.imageUrl && !options.imageBuffer) {
        const response = await fetch(options.imageUrl);
        const arrayBuffer = await response.arrayBuffer();
        options.imageBuffer = Buffer.from(arrayBuffer);
      }

      // Direct image upload to Reddit
      if (options.imageBuffer || options.imagePath) {
        console.log('Uploading image directly to Reddit (i.redd.it)...');
        
        const subreddit = (reddit as unknown as {
          getSubreddit(name: string): {
            submitImage(input: {
              title: string;
              imageFile: Buffer | string;
              nsfw: boolean;
              spoiler: boolean;
              sendReplies: boolean;
            }): Promise<{ name?: string; id: string; permalink: string }>;
          };
        }).getSubreddit(options.subreddit);
        
        try {
          // Try direct image upload first
          const imageFile = options.imageBuffer ?? options.imagePath;
          if (!imageFile) {
            throw new Error('No image file or path provided');
          }
          
          const submission = await subreddit.submitImage({
            title: options.title,
            imageFile,
            nsfw: options.nsfw ?? false,
            spoiler: options.spoiler ?? false,
            sendReplies: true,
          });

          await this.recordSafetySignals(
            options.subreddit,
            options.title,
            combineContentSegments(options.imageUrl, options.imagePath ? `file:${options.imagePath}` : undefined)
          );

          return {
            success: true,
            postId: submission.name || submission.id,
            url: `https://www.reddit.com${submission.permalink}`,
          };
        } catch (imgError: unknown) {
          console.error('Direct image upload failed, falling back to link post:', (imgError as { message?: string }).message);
          // Fallback to link post if image upload fails
          if (options.imageUrl) {
            return this.submitPost({
              subreddit: options.subreddit,
              title: options.title,
              url: options.imageUrl,
              nsfw: options.nsfw,
              spoiler: options.spoiler
            });
          }
          throw imgError;
        }
      }

      // No image provided
      return {
        success: false,
        error: 'No image provided for upload'
      };

    } catch (error: unknown) {
      console.error('Image submission failed:', error);
      return {
        success: false,
        error: (error as { message?: string }).message ?? 'Failed to upload image'
      };
    }
  }

  /**
   * Submit gallery post with multiple images
   */
  async submitGalleryPost(options: {
    subreddit: string;
    title: string;
    images: Array<{
      url?: string;
      buffer?: Buffer;
      caption?: string;
    }>;
    nsfw?: boolean;
  }): Promise<RedditPostResult> {
    try {
      const firstImageUrl = options.images[0]?.url;
      const permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit, {
        title: options.title,
        nsfw: options.nsfw ?? false,
        url: firstImageUrl,
        postType: 'gallery',
      });
      if (!permission.canPost) {
        return {
          success: false,
          error: permission.reason || 'Cannot post to this subreddit',
          reason: permission.reason,
          nextAllowedPost: permission.nextAllowedPost,
        };
      }

      const reddit = await this.initReddit();
      const subreddit = (reddit as unknown as {
        getSubreddit(name: string): {
          submitGallery(input: {
            title: string;
            images: Array<{ imageFile: Buffer; caption: string }>;
            nsfw: boolean;
            sendReplies: boolean;
          }): Promise<{ name?: string; id: string; permalink: string }>;
        };
      }).getSubreddit(options.subreddit);
      
      // Prepare images for gallery
      const galleryImages = await Promise.all(
        options.images.slice(0, 20).map(async (img) => { // Max 20 images
          let imageBuffer = img.buffer;
          
          if (!imageBuffer && img.url) {
            const response = await fetch(img.url);
            const arrayBuffer = await response.arrayBuffer();
            imageBuffer = Buffer.from(arrayBuffer);
          }
          
          if (!imageBuffer) {
            throw new Error('No image buffer or URL provided for gallery image');
          }
          
          return {
            imageFile: imageBuffer,
            caption: img.caption ?? ''
          };
        })
      );

      // Submit gallery
      const submission = await subreddit.submitGallery({
        title: options.title,
        images: galleryImages,
        nsfw: options.nsfw || false,
        sendReplies: true
      });

      const galleryContent = combineContentSegments(
        ...options.images.map(image => image.url || undefined)
      );
      await this.recordSafetySignals(options.subreddit, options.title, galleryContent);

      return {
        success: true,
        postId: submission.name || submission.id,
        url: `https://www.reddit.com${submission.permalink}`
      };

    } catch (error: unknown) {
      // Not all subreddits support galleries
      const errorObj = error as { message?: string };
      if (errorObj.message?.includes('INVALID_OPTION') || errorObj.message?.includes('gallery')) {
        console.log('Gallery not supported, falling back to single image');
        return this.submitImagePost({
          subreddit: options.subreddit,
          title: options.title,
          imageBuffer: options.images[0]?.buffer,
          imageUrl: options.images[0]?.url,
          nsfw: options.nsfw
        });
      }
      
      return {
        success: false,
        error: (error as { message?: string }).message ?? 'Failed to submit gallery'
      };
    }
  }

  private async recordSafetySignals(subreddit: string, title: string, body: string): Promise<void> {
    const contentBody = body ?? '';
    if (contentBody.length === 0 && !title) {
      return;
    }

    try {
      await Promise.all([
        SafetyManager.recordPost(String(this.userId), subreddit),
        SafetyManager.recordPostForDuplicateDetection(String(this.userId), subreddit, title, contentBody),
      ]);
    } catch (error: unknown) {
      console.warn('Failed to record Reddit safety metrics:', {
        userId: this.userId,
        subreddit,
        message: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Check if subreddit allows image posts
   */
  async checkSubredditCapabilities(subredditName: string): Promise<{
    allowsImages: boolean;
    allowsGalleries: boolean;
    allowsVideos: boolean;
    isNsfw: boolean;
  }> {
    try {
      const reddit = await this.initReddit();
      const subreddit = await (reddit as unknown as {
        getSubreddit(name: string): {
          fetch(): Promise<{
            allow_images: boolean;
            allow_galleries: boolean;
            allow_videos: boolean;
            over18: boolean;
          }>;
        };
      }).getSubreddit(subredditName).fetch();
      
      return {
        allowsImages: subreddit.allow_images !== false,
        allowsGalleries: subreddit.allow_galleries === true,
        allowsVideos: subreddit.allow_videos !== false,
        isNsfw: subreddit.over18 ?? false
      };
    } catch (error) {
      console.error('Failed to check subreddit capabilities:', error);
      return {
        allowsImages: true,
        allowsGalleries: false,
        allowsVideos: false,
        isNsfw: false
      };
    }
  }

  /**
   * Initialize Reddit instance (helper for new methods)
   */
  private async initReddit(): Promise<unknown> {
    await this.refreshTokenIfNeeded();
    return this.reddit;
  }

  /**
   * Check if user can post to a specific subreddit (rate limiting)
   */
  static async canPostToSubreddit(userId: number, subreddit: string): Promise<PostingPermission> {
  static async canPostToSubreddit(
    userId: number,
    subreddit: string,
    context: PostCheckContext = {}
  ): Promise<PostingPermission> {
    try {
      // Check if user has exceeded posting limits for this subreddit
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      
      // In a real implementation, you'd check:
      // - Subreddit-specific post limits
      // - User's posting history
      // - Account age and karma requirements
      // - Subreddit ban status
      const trimmedSubreddit = subreddit.trim();
      const lookupSubreddit = trimmedSubreddit.toLowerCase();

      const [community, account] = await Promise.all([
        db.query.redditCommunities.findFirst({
          where: (communities, operators) =>
            operators.or(
              operators.eq(communities.id, lookupSubreddit),
              operators.eq(communities.name, lookupSubreddit)
            ),
        }),
        db.query.creatorAccounts.findFirst({
          where: (accounts, operators) =>
            operators.and(
              operators.eq(accounts.userId, userId),
              operators.eq(accounts.platform, 'reddit'),
              operators.eq(accounts.isActive, true)
            ),
        }),
      ]);

      if (!account) {
        return {
          canPost: false,
          reason: 'Active Reddit account connection not found. Please reconnect your Reddit account.',
        };
      }

      return {
        canPost: true
      };
      const accountMetadata = (account.metadata ?? {}) as AccountMetadata;
      const duplicateContext = combineContentSegments(context.body, context.url);
      const safetyResult = await SafetyManager.performSafetyCheck(
        String(userId),
        trimmedSubreddit,
        context.title ?? '',
        duplicateContext
      );

    } catch (error) {
      console.error('Error checking posting permission:', error);
      if (!safetyResult.canPost) {
        const issues: string[] = [];
        if (safetyResult.rateLimit.reason) {
          issues.push(safetyResult.rateLimit.reason);
        }
        if (safetyResult.duplicateCheck.reason) {
          issues.push(safetyResult.duplicateCheck.reason);
        }
        if (safetyResult.issues.length > 0) {
          issues.push(...safetyResult.issues);
        }
        const reason = issues.join('; ') || 'Safety checks for this subreddit failed.';
        return {
          canPost: false,
          reason,
          nextAllowedPost: safetyResult.rateLimit.nextAvailableTime,
        };
      }

      if (community && community.postingLimits && typeof community.postingLimits === 'object') {
        const postingLimits = community.postingLimits as Record<string, unknown>;
        const dailyLimit = postingLimits.daily;
        if (typeof dailyLimit === 'number' && dailyLimit > 0) {
          const postsInWindow = safetyResult.rateLimit.postsInWindow ?? 0;
          if (postsInWindow >= dailyLimit) {
            const limitReason = `r/${community.name} allows only ${dailyLimit} post${dailyLimit === 1 ? '' : 's'} every 24 hours. Please wait before posting again.`;
            return {
              canPost: false,
              reason: limitReason,
              nextAllowedPost: safetyResult.rateLimit.nextAvailableTime,
            };
          }
        }
      }

      const predicateResult = evaluateRulePredicates({
        subreddit: lookupSubreddit,
        community: community
          ? {
              name: community.name,
              verificationRequired: community.verificationRequired,
              promotionAllowed: community.promotionAllowed,
              postingLimits: community.postingLimits,
              rules: community.rules,
            }
          : undefined,
        accountMetadata,
        context: {
          ...context,
          postType: resolvePostType(context),
        },
      });

      if (predicateResult && !predicateResult.allowed) {
        return {
          canPost: false,
          reason: predicateResult.reason,
        };
      }

      return { canPost: true };
    } catch (error: unknown) {
      console.error('Error checking posting permission:', {
        userId,
        subreddit,
        message: error instanceof Error ? error.message : String(error),
      });
      return {
        canPost: false,
        reason: 'Unable to verify posting permissions'
        reason: 'Unable to verify posting permissions',
      };
    }
  }

  /**
   * Update rate limiting after successful post
   */
  private async updateRateLimit(subreddit: string): Promise<void> {
    try {
      // In production, update rate limiting tables
      console.log(`Updated rate limit for user ${this.userId} in r/${subreddit}`);
      
      // This would insert/update records in post_rate_limits table
      // await db.insert(postRateLimits).values({...})
      
    } catch (error) {
      console.error('Failed to update rate limit:', error);
    }
  }

  /**
   * Get user's Reddit profile info
   */
  async getProfile(): Promise<unknown> {
    try {
      const user = await (this.reddit as unknown as {
        getMe(): Promise<{
          name: string;
          link_karma: number;
          comment_karma: number;
          created_utc: number;
          verified: boolean;
          is_gold: boolean;
          has_mail: boolean;
        }>;
      }).getMe();
      return {
        username: user.name,
        karma: user.link_karma + user.comment_karma,
        created: user.created_utc,
        verified: user.verified,
        goldStatus: user.is_gold,
        hasMail: user.has_mail,
      };
    } catch (error) {
server/lib/workers/batch-posting-worker.ts
+28-25
@@ -30,102 +30,105 @@ export class BatchPostingWorker {
      titleTemplate, 
      bodyTemplate, 
      mediaKey, 
      delayBetweenPosts = 300000 // 5 minutes default
    } = jobData as BatchPostJobData;

    try {
      logger.info(`Processing batch posting campaign ${campaignId} for ${subreddits.length} subreddits`);

      // Get Reddit manager for user
      const reddit = await RedditManager.forUser(userId);
      if (!reddit) {
        throw new Error('No active Reddit account found for user');
      }

      const results: unknown[] = [];
      let successCount = 0;
      let failureCount = 0;

      for (let i = 0; i < subreddits.length; i++) {
        const subreddit = subreddits[i];
        
        try {
          logger.info(`Posting to r/${subreddit} (${i + 1}/${subreddits.length})`);

          // Check if we can post to this subreddit
          const canPost = await RedditManager.canPostToSubreddit(userId, subreddit);
          if (!canPost.canPost) {
            results.push({
              subreddit,
              success: false,
              error: canPost.reason,
              skipped: true,
            });
            continue;
          }

          // Customize content for this subreddit
          const customizedContent = await this.customizeContentForSubreddit(
            subreddit,
            titleTemplate,
            bodyTemplate
          );

          // Create individual post job for tracking
          const [postJob] = await db.insert(postJobs).values({
            userId,
            subreddit,
            titleFinal: customizedContent.title,
            bodyFinal: customizedContent.body,
            mediaKey,
            scheduledAt: new Date(),
            status: 'pending',
          }).returning();

          // Submit post
          const postOptions: RedditPostOptions = {
            subreddit,
            title: customizedContent.title,
            body: customizedContent.body,
            nsfw: true,
          };

          // Add media if provided
          if (mediaKey) {
            try {
              const mediaAsset = await this.getMediaAsset(mediaKey, userId);
              if (mediaAsset) {
                postOptions.url = mediaAsset.downloadUrl || mediaAsset.signedUrl;
              }
            } catch (error: unknown) {
              logger.warn('Failed to attach media, posting as text:', {
                error: error instanceof Error ? error.message : String(error)
              });
            }
          }

          const canPost = await RedditManager.canPostToSubreddit(userId, subreddit, {
            title: postOptions.title,
            body: postOptions.body,
            url: postOptions.url,
            nsfw: postOptions.nsfw,
            postType: postOptions.url ? 'link' : 'text',
          });
          if (!canPost.canPost) {
            results.push({
              subreddit,
              success: false,
              error: canPost.reason,
              skipped: true,
            });
            continue;
          }

          // Create individual post job for tracking
          const [postJob] = await db.insert(postJobs).values({
            userId,
            subreddit,
            titleFinal: customizedContent.title,
            bodyFinal: customizedContent.body,
            mediaKey,
            scheduledAt: new Date(),
            status: 'pending',
          }).returning();

          const result = await reddit.submitPost(postOptions);

          if (result.success) {
            // Update post job status
            await db
              .update(postJobs)
              .set({
                status: 'sent',
                resultJson: {
                  redditPostId: result.postId,
                  url: result.url,
                  completedAt: new Date().toISOString(),
                },
                updatedAt: new Date(),
              })
              .where(eq(postJobs.id, postJob.id));

            // Schedule metrics collection
            if (result.postId) {
              await this.scheduleMetricsCollection(postJob.id, result.postId);
            }

            results.push({
              subreddit,
              success: true,
server/lib/workers/post-worker.ts
+12-15
import { registerProcessor } from "../queue-factory.js";
import { QUEUE_NAMES, type PostJobData } from "../queue/index.js";
import { db } from "../../db.js";
import { postJobs, eventLogs } from "@shared/schema";
import { eq } from "drizzle-orm";
import { RedditManager } from "../reddit.js";
import { RedditManager, type RedditPostOptions } from "../reddit.js";
import { MediaManager } from "../media.js";
import { storage } from "../../storage.js";
import { socialMediaManager, type Platform, type PostContent } from "../../social-media/social-media-manager.js";
import { logger } from "../logger.js";

export class PostWorker {
  private initialized = false;

  async initialize() {
    if (this.initialized) return;
    
    await registerProcessor<PostJobData>(
      QUEUE_NAMES.POST,
      this.processJob.bind(this),
      { concurrency: 2 } // Process 2 posts at once max
    );
    
    this.initialized = true;
    logger.info('✅ Post worker initialized with queue abstraction');
  }

  private async processJob(jobData: unknown, jobId: string): Promise<void> {
    // Validate job data structure
    if (!jobData || typeof jobData !== 'object') {
      throw new Error('Invalid job data: expected object');
    }
    const data = jobData as PostJobData;
    if (data.platforms && data.content) {
      await this.processSocialMediaJob(data, jobId);
      return;
    }
    const { userId, postJobId, subreddit, titleFinal, bodyFinal, mediaKey } = data;

    try {
      logger.info(`Processing post job ${postJobId} for user ${userId}`);

      // Get Reddit manager for user
      const reddit = await RedditManager.forUser(userId);
      if (!reddit) {
        throw new Error('No active Reddit account found for user');
      }

      // Check if we can post to this subreddit
      if (!subreddit) {
        throw new Error('Subreddit is required for Reddit posting');
      }
      const canPost = await RedditManager.canPostToSubreddit(userId, subreddit);
      if (!canPost.canPost) {
        throw new Error(`Cannot post: ${canPost.reason}`);
      }

      // Prepare post options
      interface RedditPostOptions {
        subreddit: string;
        title: string;
        body: string;
        nsfw: boolean;
        url?: string;
      }
      
      const postOptions: RedditPostOptions = {
        subreddit,
        title: titleFinal || '',
        body: bodyFinal || '',
        nsfw: true, // Assume NSFW for adult content
      };

      // Add media if provided
      if (mediaKey) {
        try {
          // In production, this would get the signed URL or public URL
          const mediaAsset = await this.getMediaAsset(mediaKey, userId);
          if (mediaAsset) {
            postOptions.url = mediaAsset.downloadUrl || mediaAsset.signedUrl;
          }
        } catch (error: unknown) {
          logger.warn('Failed to attach media, posting as text:', {
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      const canPost = await RedditManager.canPostToSubreddit(userId, subreddit, {
        title: postOptions.title,
        body: postOptions.body,
        url: postOptions.url,
        nsfw: postOptions.nsfw,
        postType: postOptions.url ? 'link' : 'text',
      });
      if (!canPost.canPost) {
        throw new Error(`Cannot post: ${canPost.reason}`);
      }

      // Submit to Reddit
      const result = await reddit.submitPost(postOptions);

      // Update job status in database
      if (result.success) {
        if (!postJobId) {
          throw new Error('postJobId is required');
        }
        await this.updateJobStatus(postJobId, 'sent', {
          redditPostId: result.postId,
          url: result.url,
          completedAt: new Date().toISOString(),
        });

        // Log success event
        await this.logEvent(userId, 'job.completed', {
          postJobId,
          subreddit,
          result,
        });

        logger.info(`Post job ${postJobId} completed successfully`, { result });
      } else {
        throw new Error(result.error || 'Reddit posting failed');
      }
server/reddit-routes.ts
+4-2
@@ -445,61 +445,63 @@ export function registerRedditRoutes(app: Express) {
            nsfw: nsfw || false,
            spoiler: spoiler || false
          });
          break;
          
        case 'text':
        default:
          // Text post
          result = await reddit.submitPost({
            subreddit,
            title,
            body: body || '',
            nsfw: nsfw || false,
            spoiler: spoiler || false
          });
          break;
      }

      if (result.success) {
        console.log('Reddit post successful:', {
          userId,
          subreddit,
          postType,
          url: result.url
        });
        

        res.json({
          success: true,
          postId: result.postId,
          url: result.url,
          message: `Post submitted successfully to r/${subreddit}`
        });
      } else {
        res.status(400).json({
          success: false,
          error: result.error || 'Failed to submit post'
          error: result.error || 'Failed to submit post',
          reason: result.reason || result.error,
          nextAllowedPost: result.nextAllowedPost
        });
      }

    } catch (error: unknown) {
      console.error('Reddit submit error:', error);
      res.status(500).json({
        error: error instanceof Error
          ? (error as Error).message
          : 'Failed to submit post to Reddit'
      });
    }
  });

  // Add new endpoint to check subreddit capabilities
  app.get('/api/reddit/subreddit/:name/capabilities', authenticateToken, async (req: AuthRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      
      const reddit = await RedditManager.forUser(userId);
      if (!reddit) {
        return res.status(404).json({ error: 'No Reddit account connected' });
      }
tests/integration/reddit/posting-flow.test.ts
+66-0
@@ -2,69 +2,135 @@
import { describe, test, expect, vi, beforeEach } from 'vitest';
import { RedditManager } from '../../../server/lib/reddit';

// Mock snoowrap
vi.mock('snoowrap', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      getSubreddit: vi.fn().mockReturnValue({
        submitLink: vi.fn().mockResolvedValue({
          id: 'test_link_post_id',
          permalink: '/r/test/comments/test_link_post_id/test_title/',
        }),
        submitSelfpost: vi.fn().mockResolvedValue({
          id: 'test_text_post_id', 
          permalink: '/r/test/comments/test_text_post_id/test_title/',
        }),
      }),
      getMe: vi.fn().mockResolvedValue({
        name: 'test_user',
        id: 'test_user_id',
      }),
    })),
  };
});

const safetyMocks = vi.hoisted(() => ({
  performSafetyCheck: vi.fn(),
  recordPost: vi.fn(),
  recordPostForDuplicateDetection: vi.fn(),
}));

const mockDb = vi.hoisted(() => ({
  query: {
    redditCommunities: {
      findFirst: vi.fn(),
    },
    creatorAccounts: {
      findFirst: vi.fn(),
    },
  },
}));

vi.mock('../../../server/db.js', () => ({
  db: mockDb,
}));

vi.mock('../../../server/lib/safety-systems.js', () => ({
  SafetyManager: safetyMocks,
}));

describe('Reddit Integration', () => {
  let redditManager: RedditManager;

  beforeEach(() => {
    redditManager = new RedditManager('mock_access_token', 'mock_refresh_token', 1);
    vi.clearAllMocks();

    const now = new Date();
    mockDb.query.redditCommunities.findFirst.mockResolvedValue({
      id: 'test',
      name: 'test',
      displayName: 'Test',
      verificationRequired: false,
      promotionAllowed: 'yes',
      postingLimits: null,
      rules: null,
    });
    mockDb.query.creatorAccounts.findFirst.mockResolvedValue({
      metadata: { karma: 500, verified: true },
    });
    safetyMocks.performSafetyCheck.mockResolvedValue({
      canPost: true,
      issues: [],
      warnings: [],
      rateLimit: {
        canPost: true,
        reason: undefined,
        postsInWindow: 0,
        windowResetTime: now,
        nextAvailableTime: undefined,
      },
      duplicateCheck: {
        isDuplicate: false,
        reason: undefined,
      },
    });
    safetyMocks.recordPost.mockResolvedValue(undefined);
    safetyMocks.recordPostForDuplicateDetection.mockResolvedValue(undefined);
  });

  test('should submit a link post successfully', async () => {
    const result = await redditManager.submitPost({
      subreddit: 'test',
      title: 'Test Link Post',
      url: 'https://example.com',
      nsfw: false,
      spoiler: false,
    });

    expect(result.success).toBe(true);
    expect(result.postId).toBe('test_link_post_id');
    expect(result.url).toBe('https://www.reddit.com/r/test/comments/test_link_post_id/test_title/');
    expect(safetyMocks.performSafetyCheck).toHaveBeenCalled();
    expect(safetyMocks.recordPost).toHaveBeenCalledWith('1', 'test');
    expect(safetyMocks.recordPostForDuplicateDetection).toHaveBeenCalledWith(
      '1',
      'test',
      'Test Link Post',
      expect.any(String)
    );
  });

  test('should submit a text post successfully', async () => {
    const result = await redditManager.submitPost({
      subreddit: 'test',
      title: 'Test Text Post',
      body: 'This is a test text post content.',
      nsfw: false,
      spoiler: false,
    });

    expect(result.success).toBe(true);
    expect(result.postId).toBe('test_text_post_id');
    expect(result.url).toBe('https://www.reddit.com/r/test/comments/test_text_post_id/test_title/');
  });

  test('should handle submission errors gracefully', async () => {
    // Mock submission error by creating a new RedditManager with error-throwing reddit instance
    const errorRedditManager = {
      ...redditManager,
      submitPost: async (_options: Record<string, unknown>) => {
        try {
          throw new Error('RATELIMIT: Rate limit exceeded');
        } catch (error: unknown) {
          let errorMessage = 'Failed to submit post';
tests/unit/reddit/can-post-permissions.test.ts
New
+151-0
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { RedditManager } from '../../../server/lib/reddit';
import type { RedditCommunity, CreatorAccount } from '@shared/schema';
import type { SafetyCheckResult } from '../../../server/lib/safety-systems';

const safetyMocks = vi.hoisted(() => ({
  performSafetyCheck: vi.fn<[string, string, string, string], Promise<SafetyCheckResult>>(),
  recordPost: vi.fn<[string, string], Promise<void>>(),
  recordPostForDuplicateDetection: vi.fn<[string, string, string, string], Promise<void>>(),
}));

const mockDb = vi.hoisted(() => ({
  query: {
    redditCommunities: {
      findFirst: vi.fn<[], Promise<Partial<RedditCommunity> | undefined>>(),
    },
    creatorAccounts: {
      findFirst: vi.fn<[], Promise<Partial<CreatorAccount> | undefined>>(),
    },
  },
}));

vi.mock('../../../server/db.js', () => ({
  db: mockDb,
}));

vi.mock('../../../server/lib/safety-systems.js', () => ({
  SafetyManager: safetyMocks,
}));

describe('RedditManager.canPostToSubreddit', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    const now = new Date();
    mockDb.query.redditCommunities.findFirst.mockResolvedValue({
      id: 'gonewild',
      name: 'gonewild',
      displayName: 'GoneWild',
      verificationRequired: false,
      promotionAllowed: 'yes',
      postingLimits: null,
      rules: null,
    });
    mockDb.query.creatorAccounts.findFirst.mockResolvedValue({
      metadata: { karma: 500, verified: true },
    });
    safetyMocks.performSafetyCheck.mockResolvedValue({
      canPost: true,
      issues: [],
      warnings: [],
      rateLimit: {
        canPost: true,
        reason: undefined,
        postsInWindow: 0,
        windowResetTime: now,
        nextAvailableTime: undefined,
      },
      duplicateCheck: {
        isDuplicate: false,
        reason: undefined,
        lastPostedAt: undefined,
        subreddit: undefined,
      },
    });
  });

  it('blocks when subreddit requires verification and account is not verified', async () => {
    mockDb.query.redditCommunities.findFirst.mockResolvedValueOnce({
      id: 'gonewild',
      name: 'gonewild',
      displayName: 'GoneWild',
      verificationRequired: true,
      promotionAllowed: 'yes',
      postingLimits: null,
      rules: null,
    });
    mockDb.query.creatorAccounts.findFirst.mockResolvedValueOnce({
      metadata: { karma: 500, verified: false },
    });

    const permission = await RedditManager.canPostToSubreddit(1, 'gonewild', {
      title: 'Test',
      body: 'Example body',
      nsfw: false,
    });

    expect(permission.canPost).toBe(false);
    expect(permission.reason).toContain('verified');
  });

  it('blocks when rate limit exceeded', async () => {
    const now = new Date();
    safetyMocks.performSafetyCheck.mockResolvedValueOnce({
      canPost: false,
      issues: ['Rate limit exceeded'],
      warnings: [],
      rateLimit: {
        canPost: false,
        reason: 'Rate limit exceeded: 5/5 posts in 24h window',
        postsInWindow: 5,
        windowResetTime: now,
        nextAvailableTime: new Date(now.getTime() + 60_000),
      },
      duplicateCheck: {
        isDuplicate: false,
        reason: undefined,
        lastPostedAt: undefined,
        subreddit: undefined,
      },
    });

    const permission = await RedditManager.canPostToSubreddit(1, 'gonewild', {
      title: 'Test',
      body: 'Example body',
    });

    expect(permission.canPost).toBe(false);
    expect(permission.reason).toContain('Rate limit exceeded');
    expect(permission.nextAllowedPost).toBeInstanceOf(Date);
  });

  it('blocks when duplicate content detected', async () => {
    const now = new Date();
    safetyMocks.performSafetyCheck.mockResolvedValueOnce({
      canPost: false,
      issues: ['Duplicate content detected'],
      warnings: [],
      rateLimit: {
        canPost: true,
        reason: undefined,
        postsInWindow: 1,
        windowResetTime: now,
        nextAvailableTime: undefined,
      },
      duplicateCheck: {
        isDuplicate: true,
        reason: 'Identical content posted recently',
        lastPostedAt: now,
        subreddit: 'gonewild',
      },
    });

    const permission = await RedditManager.canPostToSubreddit(1, 'gonewild', {
      title: 'Test Title',
      body: 'Example body',
    });

    expect(permission.canPost).toBe(false);
    expect(permission.reason).toContain('Identical content');
  });
});
