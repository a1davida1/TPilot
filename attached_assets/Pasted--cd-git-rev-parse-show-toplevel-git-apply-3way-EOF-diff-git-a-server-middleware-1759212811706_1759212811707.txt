 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/middleware/auth.ts b/server/middleware/auth.ts
index 97ebc7cbbdb20db632c1951332aaa988d2847d67..131714d74adb456bc8030b7d1e7b41d499aadfca 100644
--- a/server/middleware/auth.ts
+++ b/server/middleware/auth.ts
@@ -129,155 +129,167 @@ if (!JWT_SECRET) {
 }
 
 // Get admin credentials from environment (required)
 const adminCredentials = getAdminCredentials();
 
 export const ADMIN_EMAIL = adminCredentials.email;
 export const ADMIN_PASSWORD_HASH = adminCredentials.passwordHash;
 
 if (!ADMIN_PASSWORD_HASH) {
   logger.warn('ADMIN_PASSWORD_HASH environment variable is not set. Admin login is disabled.');
 }
 
 if (!ADMIN_EMAIL) {
   logger.warn('ADMIN_EMAIL environment variable is not set. Admin login is disabled.');
 }
 
 // keep this (yours)
 const isProd = process.env.NODE_ENV === 'production';
 export const cookieOpts = {
   httpOnly: true,
   secure: isProd,
   sameSite: (isProd ? 'strict' : 'lax') as 'strict' | 'lax',
   path: '/',
 };
 
-// keep this (theirs), but import jwt, helpers, and use JWT_SECRET + cookieOpts above
-export const authenticateToken = async (req: AuthRequest, res: express.Response, next: express.NextFunction) => {
-  const rawAuthHeader = Array.isArray(req.headers['authorization'])
-    ? req.headers['authorization'][0]
-    : req.headers['authorization'];
-  const { token: headerToken, invalid: headerInvalid } = parseBearerToken(rawAuthHeader);
+type DecodedJwt = {
+  userId?: number;
+  id?: number;
+  email?: string;
+  isAdmin?: boolean;
+  username?: string;
+  role?: string;
+  tier?: string;
+  iat: number;
+  exp: number;
+};
 
-  if (headerInvalid) return respondWithStatus(res, 401, { error: 'Invalid token' });
+type AuthMiddleware = (
+  req: AuthRequest,
+  res: express.Response,
+  next: express.NextFunction
+) => Promise<void | express.Response>;
 
-  let token: string | null = headerToken;
-  if (!token) {
-    const { token: cookieToken, invalid: cookieInvalid } = normalizeTokenCandidate(req.cookies?.authToken);
-    if (cookieInvalid) return respondWithStatus(res, 401, { error: 'Invalid token' });
-    token = cookieToken;
-  }
+const createAuthenticateTokenMiddleware = (required: boolean): AuthMiddleware => {
+  return async (req, res, next) => {
+    const rawAuthHeader = Array.isArray(req.headers['authorization'])
+      ? req.headers['authorization'][0]
+      : req.headers['authorization'];
+    const { token: headerToken, invalid: headerInvalid } = parseBearerToken(rawAuthHeader);
 
-  if (token) {
-    if (!hasJwtStructure(token)) return respondWithStatus(res, 401, { error: 'Invalid token' });
-    if (await isTokenBlacklisted(token)) return res.status(401).json({ error: 'Token revoked' });
-    try {
-      const decoded = jwt.verify(token, JWT_SECRET) as DecodedJwt;
-      // â€¦ load user from DB, enforce admin, etc.
-      return next();
-    } catch {
-      // clear bad cookie with same options
-      res.clearCookie('authToken', cookieOpts);
+    if (headerInvalid) {
       return respondWithStatus(res, 401, { error: 'Invalid token' });
     }
-  }
 
-  return respondWithStatus(res, 401, { error: 'Access token required' });
-};
+    const cookieCandidate = normalizeTokenCandidate(req.signedCookies?.authToken ?? req.cookies?.authToken);
+
+    if (cookieCandidate.invalid) {
+      return respondWithStatus(res, 401, { error: 'Invalid token' });
+    }
+
+    const token = headerToken ?? cookieCandidate.token;
 
-export const authenticateToken = (required = true) => {
-  return async (req: AuthRequest, res: express.Response, next: express.NextFunction) => {
-    // Check for bearer token in Authorization header
-    const authHeader = req.get('authorization');
-    const bearer = authHeader?.startsWith('Bearer ') ? authHeader.slice(7) : undefined;
-    
-    // Check for token in signed or unsigned cookies
-    const cookieToken = req.signedCookies?.authToken || req.cookies?.authToken;
-    
-    // Use bearer token if available, otherwise fall back to cookie
-    const token = bearer || cookieToken;
-
-    // Try JWT token first
     if (token) {
+      if (!hasJwtStructure(token)) {
+        return respondWithStatus(res, 401, { error: 'Invalid token' });
+      }
+
       if (await isTokenBlacklisted(token)) {
-        // Clear poisoned cookie
         res.clearCookie('authToken', cookieOpts);
-        if (required) return res.status(401).json({ error: 'Token revoked' });
+        if (required) {
+          return res.status(401).json({ error: 'Token revoked' });
+        }
         return next();
       }
-      
-      try {
-        const decoded = jwt.verify(token, JWT_SECRET) as { userId?: number; id?: number; email?: string; isAdmin?: boolean; username?: string; role?: string; tier?: string; iat: number; exp: number };
-
-        // All users must exist in database - no hardcoded admin backdoors
-        // Admin status is verified from database isAdmin/role fields only
 
-        // For regular users, fetch from database
+      try {
+        const decoded = jwt.verify(token, JWT_SECRET) as DecodedJwt;
         const userId = decoded.userId || decoded.id;
+
         if (!userId) {
-          // Clear poisoned cookie
           res.clearCookie('authToken', cookieOpts);
-          if (required) return res.status(401).json({ error: 'Invalid token: missing user ID' });
+          if (required) {
+            return res.status(401).json({ error: 'Invalid token: missing user ID' });
+          }
           return next();
         }
 
         const [user] = await db.select().from(users).where(eq(users.id, userId));
 
         if (!user) {
-          // Clear poisoned cookie
           res.clearCookie('authToken', cookieOpts);
-          if (required) return res.status(401).json({ error: 'User not found' });
+          if (required) {
+            return res.status(401).json({ error: 'User not found' });
+          }
           return next();
         }
 
         if (!user.emailVerified) {
           return EMAIL_NOT_VERIFIED_RESPONSE(res, user.email || '');
         }
 
         const restrictionResponse = handleAccountRestrictions(user, res);
         if (restrictionResponse) {
           return restrictionResponse;
         }
 
         req.user = user;
         return next();
       } catch (error) {
         logger.error('Auth error:', error);
-        // Clear poisoned cookie so repeated requests don't keep failing
         res.clearCookie('authToken', cookieOpts);
-        if (required) return res.status(401).json({ error: 'Invalid or expired token' });
+        if (required) {
+          return res.status(401).json({ error: 'Invalid or expired token' });
+        }
         return next();
       }
     }
 
-    // Fallback to session-based auth
     if (req.session && (req.session as { user?: UserType }).user) {
       const sessionUser = (req.session as { user?: UserType }).user as UserType;
 
       if (!sessionUser.emailVerified) {
         return EMAIL_NOT_VERIFIED_RESPONSE(res, sessionUser.email || '');
       }
 
       const restrictionResponse = handleAccountRestrictions(sessionUser, res);
       if (restrictionResponse) {
         return restrictionResponse;
       }
 
       req.user = sessionUser;
       return next();
     }
 
     if (required) {
       return res.status(401).json({ error: 'Access token required' });
     }
-    
+
     return next();
   };
 };
 
+type AuthenticateToken = AuthMiddleware & ((required?: boolean) => AuthMiddleware);
+
+export const authenticateToken: AuthenticateToken = ((
+  reqOrRequired: boolean | AuthRequest,
+  res?: express.Response,
+  next?: express.NextFunction
+) => {
+  if (typeof reqOrRequired === 'boolean') {
+    return createAuthenticateTokenMiddleware(reqOrRequired);
+  }
+
+  if (!res || !next) {
+    throw new Error('authenticateToken middleware requires req, res, and next arguments');
+  }
+
+  return createAuthenticateTokenMiddleware(true)(reqOrRequired, res, next);
+}) as AuthenticateToken;
+
 export const createToken = (user: UserType): string => {
   return jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: '24h' });
 };
 
 export const verifyToken = (token: string): { userId: number; email: string; iat: number; exp: number } => {
   return jwt.verify(token, JWT_SECRET) as { userId: number; email: string; iat: number; exp: number };
 };
 
EOF
)