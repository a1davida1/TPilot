 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/scripts/sync-subreddit-rules.ts b/server/scripts/sync-subreddit-rules.ts
index 03fbfecd3bd4cae936a09a1b2f973f1b1f00d4be..afe930b220f187553616cfc71329dec23466c598 100644
--- a/server/scripts/sync-subreddit-rules.ts
+++ b/server/scripts/sync-subreddit-rules.ts
@@ -1,31 +1,32 @@
 #!/usr/bin/env tsx
 
 import { db } from '../db.js';
-import { subredditRules, redditCommunities } from '@shared/schema';
-import { eq, sql } from 'drizzle-orm';
+import { subredditRules, redditCommunities, createDefaultRules } from '@shared/schema';
+import { eq } from 'drizzle-orm';
 import type { RuleSpec, RuleSpecBase } from '../lib/policy-linter.js';
+import type { RedditCommunityRuleSet } from '@shared/schema';
 
 // Reddit API configuration
 const REDDIT_USER_AGENT = 'ThottoPilot/1.0 (Subreddit rules sync)';
 
 interface RedditRule {
   kind: string;
   short_name: string;
   description?: string;
   description_html?: string;
   priority?: number;
 }
 
 interface RedditAboutRulesResponse {
   rules?: RedditRule[];
   site_rules?: RedditRule[];
 }
 
 interface RedditWikiResponse {
   kind: string;
   data?: {
     content_md?: string;
     content_html?: string;
   };
 }
 
diff --git a/server/scripts/sync-subreddit-rules.ts b/server/scripts/sync-subreddit-rules.ts
index 03fbfecd3bd4cae936a09a1b2f973f1b1f00d4be..afe930b220f187553616cfc71329dec23466c598 100644
--- a/server/scripts/sync-subreddit-rules.ts
+++ b/server/scripts/sync-subreddit-rules.ts
@@ -236,108 +237,164 @@ async function applyExistingOverrides(subreddit: string, newSpec: RuleSpecBase):
       ...newSpec,
       source: {
         fetchedAt: new Date().toISOString(),
         aboutRulesUrl: `https://www.reddit.com/r/${subreddit}/about/rules`,
         wikiRulesUrl: `https://www.reddit.com/r/${subreddit}/wiki/rules`,
         automatedBase: newSpec,
       },
     };
   } catch (error) {
     console.error(`Error applying overrides for r/${subreddit}:`, error);
     return {
       ...newSpec,
       source: {
         fetchedAt: new Date().toISOString(),
         aboutRulesUrl: `https://www.reddit.com/r/${subreddit}/about/rules`,
         wikiRulesUrl: `https://www.reddit.com/r/${subreddit}/wiki/rules`,
         automatedBase: newSpec,
       },
     };
   }
 }
 
 /**
  * Sync rules for a single subreddit
  */
-async function syncSubredditRules(subreddit: string): Promise<void> {
+function mapRuleSpecToCommunityRules(spec: RuleSpec): RedditCommunityRuleSet {
+  const defaults = createDefaultRules();
+
+  const sellingPolicy = (() => {
+    if (spec.linkPolicy === 'no-link') return 'not_allowed';
+    if (spec.linkPolicy === 'one-link') return 'limited';
+    if (spec.linkPolicy === 'ok') return 'allowed';
+    return 'unknown';
+  })();
+
+  return {
+    eligibility: {
+      minKarma: spec.manualFlags?.minKarma ?? defaults.eligibility?.minKarma ?? null,
+      minAccountAgeDays: spec.manualFlags?.minAccountAgeDays ?? defaults.eligibility?.minAccountAgeDays ?? null,
+      verificationRequired: spec.manualFlags?.verificationRequired ?? defaults.eligibility?.verificationRequired ?? false,
+      requiresApproval: defaults.eligibility?.requiresApproval ?? false,
+    },
+    content: {
+      sellingPolicy,
+      watermarksAllowed: defaults.content?.watermarksAllowed ?? null,
+      promotionalLinks: defaults.content?.promotionalLinks ?? null,
+      requiresOriginalContent: spec.flairRequired ?? defaults.content?.requiresOriginalContent ?? false,
+      nsfwRequired: defaults.content?.nsfwRequired ?? false,
+      titleGuidelines: spec.titleRegexes?.map(regex => `Avoid pattern: ${regex}`) ?? defaults.content?.titleGuidelines ?? [],
+      contentGuidelines: spec.wikiNotes ?? defaults.content?.contentGuidelines ?? [],
+      linkRestrictions: spec.requiredTags ?? defaults.content?.linkRestrictions ?? [],
+      bannedContent: spec.bannedWords ?? defaults.content?.bannedContent ?? [],
+      formattingRequirements: defaults.content?.formattingRequirements ?? [],
+    },
+    posting: {
+      maxPostsPerDay: defaults.posting?.maxPostsPerDay ?? null,
+      cooldownHours: defaults.posting?.cooldownHours ?? null,
+    },
+    notes: (spec.manualFlags?.notes && spec.manualFlags.notes.length > 0)
+      ? spec.manualFlags.notes.join('\n')
+      : defaults.notes ?? null,
+  };
+}
+
+async function syncSubredditRules(subreddit: string): Promise<RuleSpec> {
   console.log(`Syncing rules for r/${subreddit}...`);
 
   try {
     // Fetch rules from Reddit
     const [aboutRules, wikiContent] = await Promise.all([
       fetchAboutRules(subreddit),
       fetchWikiRules(subreddit),
     ]);
 
     // Parse rules into structured format
     const parsedSpec = parseRulesToSpec(aboutRules, wikiContent);
 
     // Apply existing overrides
     const finalSpec = await applyExistingOverrides(subreddit, parsedSpec);
 
     // Upsert to database
     await db
       .insert(subredditRules)
       .values({
         subreddit: subreddit.toLowerCase(),
         rulesJson: finalSpec,
         updatedAt: new Date(),
       })
       .onConflictDoUpdate({
         target: subredditRules.subreddit,
         set: {
           rulesJson: finalSpec,
           updatedAt: new Date(),
         },
       });
 
+    const communityRuleSet = mapRuleSpecToCommunityRules(finalSpec);
+
+    await db
+      .update(redditCommunities)
+      .set({
+        rules: communityRuleSet,
+      })
+      .where(eq(redditCommunities.id, subreddit.toLowerCase()));
+
     console.log(`‚úÖ Successfully synced rules for r/${subreddit}`);
+    return finalSpec;
   } catch (error) {
     console.error(`‚ùå Failed to sync rules for r/${subreddit}:`, error);
+    throw error;
   }
 }
 
 /**
  * Sync rules for all known communities
  */
 async function syncAllCommunityRules(): Promise<void> {
   console.log('üîÑ Starting community rules sync...');
 
   try {
     // Get all communities from the database
     const communities = await db.select().from(redditCommunities);
     
     console.log(`Found ${communities.length} communities to sync`);
 
     // Process in batches to avoid rate limiting
     const batchSize = 5;
     for (let i = 0; i < communities.length; i += batchSize) {
       const batch = communities.slice(i, i + batchSize);
       
       // Process batch in parallel but with delay between batches
       await Promise.all(
-        batch.map(community => syncSubredditRules(community.name))
+        batch.map(async community => {
+          try {
+            await syncSubredditRules(community.name);
+          } catch (error) {
+            console.error(`‚ùå Failed to sync rules for r/${community.name} in batch:`, error);
+          }
+        })
       );
 
       // Delay between batches to respect Reddit's rate limits
       if (i + batchSize < communities.length) {
         console.log(`Processed ${i + batchSize}/${communities.length}, waiting...`);
         await new Promise(resolve => setTimeout(resolve, 2000));
       }
     }
 
     console.log('‚úÖ Community rules sync completed');
   } catch (error) {
     console.error('‚ùå Community rules sync failed:', error);
     process.exit(1);
   }
 }
 
 /**
  * Main function
  */
 async function main() {
   const args = process.argv.slice(2);
   
   if (args.length === 0) {
     // Sync all communities
     await syncAllCommunityRules();
 
EOF
)