
Implement shadowban detection feature
Sep 23
·
a1davida1/TPilot
·
main
·
+273
-129

Archive

Share

Create PR


3
1. Implement a `checkShadowbanStatus` helper on `RedditManager` that compares self-view vs. public listing of recent submissions to infer hidden posts.
2. Expose a protected endpoint (e.g., `GET /api/reddit/shadowban-status`) in `server/reddit-routes.ts` that returns the detection result.
3. Surface the status in the client dashboard/posting flow with clear remediation messaging.
4. Provide tests that stub Reddit API responses to cover visible vs. shadowbanned scenarios.
Copy
Summary

Added robust normalization helpers so RedditManager.checkShadowbanStatus compares private and public submissions, returns structured evidence, and handles API failures gracefully.

Introduced the protected GET /api/reddit/shadowban-status route that surfaces detection results (or a safe fallback) for authenticated creators.

Enhanced the Reddit posting dashboard card to cache hidden submissions, present remediation guidance, and deep-link to affected posts for rapid recovery.

Expanded unit coverage to stub Reddit API responses across clear, suspected, and error scenarios, exercising the new detection workflow end-to-end.

Testing

✅ npm run lint (passes with existing repository warnings).

⚠️ npm test (full suite hits numerous pre-existing failures; aborted after verifying scope).

✅ npm test -- tests/unit/server/reddit-shadowban.test.ts.


Files (4)

client/src/pages/reddit-posting.tsx
+49
-7

server/lib/reddit.ts
+164
-101

server/reddit-routes.ts
+41
-0

tests/unit/server/reddit-shadowban.test.ts
+19
-21



Ask

Code
Diff
Logs

client/src/pages/reddit-posting.tsx
+49
-7

@@ -31,54 +31,55 @@ import {
  Eye,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Link as LinkIcon,
  Globe,
  Settings,
  Clock,
  BarChart3,
  Users,
  TrendingUp,
  Zap,
  Shield,
  FileText,
  TestTube,
  ExternalLink,
  ImageIcon,
  Images,
  LogIn,
  UserCheck,
  ChevronsUpDown,
  RefreshCcw,
  Loader2
} from 'lucide-react';
import { MediaLibrarySelector } from '@/components/MediaLibrarySelector';
import type { 
  ShadowbanStatusType, 
import type {
  ShadowbanStatusType,
  ShadowbanCheckApiResponse,
  RedditCommunitySellingPolicy 
  ShadowbanSubmissionSummary,
  RedditCommunitySellingPolicy
} from '@shared/schema';

function isApiError(error: unknown): error is ApiError {
  return error instanceof Error && 'status' in error && typeof (error as { status?: unknown }).status === 'number';
}

interface RedditAccount {
  id: number;
  username: string;
  isActive: boolean;
  connectedAt: string;
  karma: number;
  verified: boolean;
  accountAgeDays?: number;
}

interface SubredditCommunity {
  id: string;
  name: string;
  displayName: string;
  members: number;
  engagementRate: number;
  category: string;
  promotionAllowed: string;
  bestPostingTimes: string[];
@@ -333,50 +334,59 @@ export default function RedditPostingPage() {
    ? 'border-red-200 bg-red-50'
    : shadowbanStatusLevel === 'clear'
      ? 'border-green-200 bg-green-50'
      : shadowbanStatusLevel === 'error'
        ? 'border-red-200 bg-red-50'
        : 'border-blue-200 bg-blue-50';

  const shadowbanIcon = shadowbanStatusLevel === 'clear'
    ? <CheckCircle className="h-4 w-4 text-green-600" />
    : shadowbanStatusLevel === 'suspected'
      ? <AlertTriangle className="h-4 w-4 text-red-600" />
      : shadowbanStatusLevel === 'error'
        ? <XCircle className="h-4 w-4 text-red-600" />
        : <Eye className="h-4 w-4 text-blue-600" />;

  const shadowbanButtonStyles = shadowbanStatusLevel === 'suspected' || shadowbanStatusLevel === 'error'
    ? 'border-red-200 text-red-700 hover:bg-red-50'
    : shadowbanStatusLevel === 'clear'
      ? 'border-green-200 text-green-700 hover:bg-green-50'
      : 'border-blue-200 text-blue-700 hover:bg-blue-50';

  const lastShadowbanCheck = shadowbanStatus?.evidence.checkedAt
    ? new Date(shadowbanStatus.evidence.checkedAt).toLocaleString()
    : undefined;

  const hiddenSubmissions = useMemo<ShadowbanSubmissionSummary[]>(() => {
    if (!shadowbanStatus) {
      return [];
    }

    const missingIds = new Set(shadowbanStatus.evidence.missingSubmissionIds);
    return shadowbanStatus.evidence.privateSubmissions.filter(submission => missingIds.has(submission.id));
  }, [shadowbanStatus]);

  const selectedAssets = mediaAssets.filter((asset) => selectedMediaIds.includes(asset.id));

  // Sort communities by eligibility and karma requirements
  const sortedCommunities = useMemo(() => {
    if (!communities || communities.length === 0) return [];

    const communitiesWithEligibility = communities.map((community) => 
      checkCommunityEligibility(community, activeAccount)
    );

    // Sort: eligible first, then by karma requirement (ascending)
    return communitiesWithEligibility.sort((a, b) => {
      if (a.isEligible !== b.isEligible) {
        return a.isEligible ? -1 : 1; // Eligible first
      }
      
      // Within same eligibility, sort by karma requirement
      const aKarma = a.community.rules?.minKarma || 0;
      const bKarma = b.community.rules?.minKarma || 0;
      return aKarma - bKarma;
    });
  }, [communities, activeAccount]);

  // Set default community to first eligible one (only if no selection made yet)
  useEffect(() => {
@@ -816,54 +826,86 @@ export default function RedditPostingPage() {
                            Recheck
                          </Button>
                        </div>
                        
                        {shadowbanStatus.reason && (
                          <p className="text-xs text-gray-600">{shadowbanStatus.reason}</p>
                        )}
                        
                        <div className="grid grid-cols-2 gap-2 text-xs">
                          <div className="bg-gray-50 p-2 rounded">
                            <p className="font-medium">Private submissions</p>
                            <p className="text-gray-600">{shadowbanStatus.evidence.privateCount}</p>
                          </div>
                          <div className="bg-gray-50 p-2 rounded">
                            <p className="font-medium">Public submissions</p>
                            <p className="text-gray-600">{shadowbanStatus.evidence.publicCount}</p>
                          </div>
                        </div>
                        
                        {lastShadowbanCheck && (
                          <p className="text-xs text-gray-500">Last checked: {lastShadowbanCheck}</p>
                        )}
                        
                        {shadowbanStatus.status === 'suspected' && (
                          <Alert className="border-red-200 bg-red-50">
                            <AlertTriangle className="h-4 w-4" />
                            <AlertDescription className="text-red-700 text-sm">
                              Some of your posts may not be visible to other users. Consider contacting Reddit support or waiting before posting again.
                            </AlertDescription>
                            <AlertTriangle className="h-4 w-4 text-red-600" />
                            <div className="space-y-2">
                              <AlertDescription className="text-red-700 text-sm">
                                Some of your recent submissions are hidden from public listings. Reduce posting activity until visibility recovers.
                              </AlertDescription>
                              <ul className="list-disc list-inside text-xs text-red-700 space-y-1">
                                <li>Pause scheduled Reddit posts for at least 24 hours to avoid additional visibility penalties.</li>
                                <li>Review subreddit guidelines and adjust queued content to ensure it aligns with community rules.</li>
                                <li>Reach out to subreddit moderators or Reddit Support if the issue persists for more than a day.</li>
                              </ul>
                              {hiddenSubmissions.length > 0 && (
                                <div className="rounded border border-red-200 bg-white/70 p-2">
                                  <p className="text-xs font-semibold text-red-700">Hidden submissions</p>
                                  <ul className="mt-1 space-y-1">
                                    {hiddenSubmissions.map((submission) => {
                                      const permalink = submission.permalink && submission.permalink.startsWith('http')
                                        ? submission.permalink
                                        : `https://www.reddit.com${submission.permalink ?? ''}`;
                                      return (
                                        <li key={submission.id}>
                                          <a
                                            href={permalink}
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className="flex items-center gap-1 text-xs text-red-600 underline"
                                          >
                                            <Eye className="h-3 w-3" />
                                            {submission.title ?? submission.id}
                                          </a>
                                        </li>
                                      );
                                    })}
                                  </ul>
                                </div>
                              )}
                            </div>
                          </Alert>
                        )}
                      </div>
                    ) : (
                      <div className="text-center text-sm text-gray-500">
                        Shadowban status checking is available for connected Reddit accounts
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Post Creation */}
            <Card className="bg-white/90 backdrop-blur-sm border-pink-200 shadow-lg">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <FileText className="h-5 w-5" />
                  Create Post
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                
                {/* Post Type Selection */}
                <div className="grid grid-cols-2 lg:grid-cols-4 gap-2">
server/lib/reddit.ts
+164
-101

@@ -86,50 +86,106 @@ function extractMinKarma(postingLimits: unknown): number | undefined {
  for (const candidate of candidates) {
    if (typeof candidate === 'number' && Number.isFinite(candidate)) {
      return candidate;
    }
  }
  return undefined;
}

function combineContentSegments(...segments: Array<string | undefined>): string {
  return segments
    .map(segment => (typeof segment === 'string' ? segment.trim() : ''))
    .filter(segment => segment.length > 0)
    .join('\n');
}

function resolvePostType(context: PostCheckContext): PostType {
  if (context.postType) {
    return context.postType;
  }
  if (context.url && context.url.length > 0) {
    return 'link';
  }
  return 'text';
}

function normalizePrivateSubmission(submission: SnoowrapLikeSubmission): ShadowbanSubmissionSummary | null {
  if (typeof submission !== 'object' || submission === null) {
    return null;
  }

  const id = typeof submission.id === 'string' ? submission.id : undefined;
  if (!id) {
    return null;
  }

  const createdUtcCandidate = typeof submission.created_utc === 'number'
    ? submission.created_utc
    : typeof submission.createdUtc === 'number'
      ? submission.createdUtc
      : null;

  const permalinkCandidate = typeof submission.permalink === 'string'
    ? submission.permalink
    : typeof submission.url === 'string'
      ? submission.url
      : '';

  const titleCandidate = typeof submission.title === 'string' ? submission.title : undefined;
  const subredditCandidate = submission.subreddit && typeof submission.subreddit.display_name === 'string'
    ? submission.subreddit.display_name
    : undefined;

  return {
    id,
    createdUtc: createdUtcCandidate ?? 0,
    permalink: permalinkCandidate,
    title: titleCandidate,
    subreddit: subredditCandidate,
  };
}

interface SnoowrapLikeSubmission {
  id?: unknown;
  created_utc?: unknown;
  createdUtc?: unknown;
  permalink?: unknown;
  url?: unknown;
  title?: unknown;
  subreddit?: {
    display_name?: unknown;
  };
}

interface SnoowrapUserWithSubmissions {
  getSubmissions(options: { limit: number }): Promise<Array<SnoowrapLikeSubmission>>;
}

interface SnoowrapClientWithMe {
  getMe(): Promise<SnoowrapUserWithSubmissions>;
}

/**
 * Securely fetch an image URL with comprehensive SSRF protection
 */
async function secureFetchImage(imageUrl: string): Promise<Buffer> {
  // Validate URL format
  let url: URL;
  try {
    url = new URL(imageUrl);
  } catch {
    throw new Error('Invalid URL format');
  }

  // Check protocol
  if (!['http:', 'https:'].includes(url.protocol)) {
    throw new Error('Invalid URL protocol - only HTTP and HTTPS allowed');
  }

  // Allowlist for trusted image hosting services
  const allowedHosts = [
    'i.redd.it',
    'i.imgur.com',
    'imgur.com',
    'i.postimg.cc',
    'postimg.cc',
    'image.shutterstock.com',
@@ -521,53 +577,53 @@ function extractVerifiedFromMetadata(metadata: unknown): boolean | undefined {
  return undefined;
}

function calculateAccountAgeDays(createdUtc: number | null | undefined): number | null {
  if (typeof createdUtc !== 'number' || !Number.isFinite(createdUtc) || createdUtc <= 0) {
    return null;
  }

  const createdMs = createdUtc * 1000;
  const now = Date.now();

  if (!Number.isFinite(createdMs) || createdMs <= 0 || createdMs > now) {
    return null;
  }

  const diffMs = now - createdMs;
  const age = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  return age >= 0 ? age : 0;
}

export class RedditManager {
  private reddit: snoowrap;
  private userId: number;

  constructor(accessToken: string, refreshToken: string, userId: number) {
  constructor(accessToken: string, refreshToken: string, userId: number, redditClient?: snoowrap) {
    this.userId = userId;
    this.reddit = new snoowrap({
    this.reddit = redditClient ?? new snoowrap({
      userAgent: REDDIT_USER_AGENT,
      clientId: REDDIT_CLIENT_ID,
      clientSecret: REDDIT_CLIENT_SECRET,
      accessToken,
      refreshToken,
    });
  }

  /**
   * Get Reddit manager for a specific user
   */
  static async forUser(userId: number): Promise<RedditManager | null> {
    try {
      const [account] = await db
        .select()
        .from(creatorAccounts)
        .where(
          and(
            eq(creatorAccounts.userId, userId),
            eq(creatorAccounts.platform, 'reddit'),
            eq(creatorAccounts.isActive, true)
          )
        );

      if (!account || !account.oauthToken) {
@@ -1411,223 +1467,230 @@ export class RedditManager {
      return true;
    } catch (error) {
      console.error('Reddit connection test failed:', error);
      return false;
    }
  }

  /**
   * Refresh access token if needed
   */
  async refreshTokenIfNeeded(): Promise<void> {
    try {
      // snoowrap handles token refresh automatically
      await (this.reddit as unknown as {
        getMe(): Promise<unknown>;
      }).getMe();
    } catch (error) {
      console.error('Token refresh failed:', error);
      throw error;
    }
  }

  /**
   * Get private submissions from authenticated Reddit API
   */
  private async getPrivateSubmissions(): Promise<ShadowbanSubmissionSummary[]> {
  private async getPrivateSubmissions(): Promise<{ submissions: ShadowbanSubmissionSummary[]; error?: string }> {
    try {
      const user = await (this.reddit as unknown as {
        getMe(): Promise<{
          getSubmissions(options: { limit: number }): Promise<Array<{
            id: string;
            created_utc: number;
            permalink: string;
            title: string;
            subreddit: { display_name: string };
          }>>;
        }>;
      }).getMe();
      const user = await (this.reddit as unknown as SnoowrapClientWithMe).getMe();

      const submissions = await user.getSubmissions({ limit: 25 });
      
      return submissions.map(submission => ({
        id: submission.id,
        createdUtc: submission.created_utc,
        permalink: submission.permalink,
        title: submission.title,
        subreddit: submission.subreddit.display_name
      }));

      const normalized = submissions
        .map(submission => normalizePrivateSubmission(submission))
        .filter((submission): submission is ShadowbanSubmissionSummary => submission !== null);

      return { submissions: normalized };

    } catch (error) {
      console.error('Failed to fetch private submissions:', error);
      return [];
      const errorMessage = error instanceof Error ? error.message : 'Unknown error fetching private submissions';
      return {
        submissions: [],
        error: errorMessage,
      };
    }
  }

  /**
   * Get public submissions from Reddit's public JSON API
   */
  private async getPublicSubmissions(username: string): Promise<ShadowbanSubmissionSummary[]> {
  private async getPublicSubmissions(username: string): Promise<{ submissions: ShadowbanSubmissionSummary[]; error?: string }> {
    try {
      const url = `https://www.reddit.com/user/${username}/submitted.json?limit=25`;
      

      const response = await fetch(url, {
        headers: {
          'User-Agent': REDDIT_USER_AGENT
        }
      });

      if (!response.ok) {
        throw new Error(`Reddit API returned ${response.status}: ${response.statusText}`);
        return {
          submissions: [],
          error: `Reddit API returned ${response.status}: ${response.statusText}`,
        };
      }

      const data = await response.json() as {
        data: {
          children: Array<{
            data: {
              id: string;
              created_utc: number;
              permalink: string;
              title: string;
              subreddit: string;
            };
          }>;
        };
      };

      return data.data.children.map(child => ({
      const submissions = data.data.children.map(child => ({
        id: child.data.id,
        createdUtc: child.data.created_utc,
        permalink: child.data.permalink,
        title: child.data.title,
        subreddit: child.data.subreddit
      }));

      return { submissions };

    } catch (error) {
      console.error('Failed to fetch public submissions:', error);
      return [];
      const errorMessage = error instanceof Error ? error.message : 'Unknown error fetching public submissions';
      return {
        submissions: [],
        error: errorMessage,
      };
    }
  }

  /**
   * Check shadowban status by comparing self-view vs public submissions
   */
  async checkShadowbanStatus(): Promise<{
    isShadowbanned: boolean;
    statusMessage: string;
    checkedAt: string;
    publicCount: number;
    totalSelfPosts: number;
    hiddenPosts: Array<{
      id: string;
      title: string;
      createdUtc: number;
    }>;
    error?: string;
  }> {
  async checkShadowbanStatus(): Promise<ShadowbanCheckApiResponse> {
    const checkedAt = new Date().toISOString();

    const buildEvidence = (
      username: string,
      privateSubmissions: ShadowbanSubmissionSummary[],
      publicSubmissions: ShadowbanSubmissionSummary[],
      missingSubmissionIds: string[],
    ): ShadowbanEvidenceResponse => ({
      username,
      checkedAt,
      privateCount: privateSubmissions.length,
      publicCount: publicSubmissions.length,
      privateSubmissions,
      publicSubmissions,
      missingSubmissionIds,
    });

    try {
      // Get user's profile to get username
      const profile = await this.getProfile();
      if (!profile) {

      if (!profile?.username) {
        return {
          isShadowbanned: false,
          statusMessage: 'Unable to fetch profile',
          checkedAt: new Date().toISOString(),
          publicCount: 0,
          totalSelfPosts: 0,
          hiddenPosts: [],
          error: 'Could not access Reddit profile'
          status: 'unknown',
          reason: 'Unable to fetch Reddit profile for shadowban check.',
          evidence: buildEvidence('unknown', [], [], []),
        };
      }

      // Get recent submissions from user's profile (authenticated view)
      const recentSubmissions = await this.reddit.getUser(profile.username).getSubmissions({ limit: 25 });
      
      if (!recentSubmissions || recentSubmissions.length === 0) {
      const { submissions: privateSubmissions, error: privateError } = await this.getPrivateSubmissions();

      if (privateError) {
        return {
          isShadowbanned: false,
          statusMessage: 'No recent submissions found',
          checkedAt: new Date().toISOString(),
          publicCount: 0,
          totalSelfPosts: 0,
          hiddenPosts: [],
          error: 'No submissions to analyze'
          status: 'unknown',
          reason: `Unable to fetch private submissions: ${privateError}`,
          evidence: buildEvidence(profile.username, [], [], []),
        };
      }

      // Get public submissions for comparison
      const publicSubmissions = await this.getPublicSubmissions(profile.username);
      
      // Create sets for easy comparison
      const selfPostIds = new Set(recentSubmissions.map((sub: any) => sub.id));
      const publicPostIds = new Set(publicSubmissions.map(sub => sub.id));
      
      // Find hidden posts (in self view but not in public view)
      const hiddenPosts = recentSubmissions
        .filter((sub: any) => !publicPostIds.has(sub.id))
        .map((sub: any) => ({
          id: sub.id,
          title: sub.title,
          createdUtc: sub.created_utc
        }));

      const totalSelfPosts = recentSubmissions.length;
      const publicCount = publicSubmissions.length;
      const hiddenCount = hiddenPosts.length;
      const isShadowbanned = hiddenCount > 0;

      let statusMessage = '';
      if (isShadowbanned) {
        const percentage = Math.round((hiddenCount / totalSelfPosts) * 100);
        statusMessage = `${percentage}% of recent posts are hidden from public view.`;
      const { submissions: publicSubmissions, error: publicError } = await this.getPublicSubmissions(profile.username);

      if (privateSubmissions.length === 0) {
        return {
          status: 'unknown',
          reason: 'No recent submissions found to analyze.',
          evidence: buildEvidence(profile.username, [], publicSubmissions, []),
        };
      }

      if (publicError) {
        return {
          status: 'unknown',
          reason: publicError,
          evidence: buildEvidence(profile.username, privateSubmissions, publicSubmissions, []),
        };
      }

      const publicIds = new Set(publicSubmissions.map(submission => submission.id));
      const missingSubmissionIds = privateSubmissions
        .filter(submission => !publicIds.has(submission.id))
        .map(submission => submission.id);

      const missingCount = missingSubmissionIds.length;
      const privateCount = privateSubmissions.length;
      let status: ShadowbanStatusType = 'clear';
      let reason: string;

      if (missingCount === 0) {
        status = 'clear';
        reason = 'All recent submissions are publicly visible.';
      } else if (missingCount === privateCount) {
        status = 'suspected';
        reason = 'All recent submissions are missing from public view.';
      } else {
        statusMessage = 'All recent posts are visible publicly.';
        const missingRatio = missingCount / privateCount;
        if (missingRatio >= 0.5) {
          status = 'suspected';
          reason = `${missingCount} of ${privateCount} recent submissions are missing from public view.`;
        } else {
          status = 'clear';
          reason = `Most submissions are publicly visible (${privateCount - missingCount}/${privateCount}).`;
        }
      }

      return {
        isShadowbanned,
        statusMessage,
        checkedAt: new Date().toISOString(),
        publicCount,
        totalSelfPosts,
        hiddenPosts: hiddenPosts.slice(0, 5), // Limit to first 5 for UI
        error: undefined
        status,
        reason,
        evidence: buildEvidence(profile.username, privateSubmissions, publicSubmissions, missingSubmissionIds),
      };

    } catch (error) {
      console.error('Shadowban check failed:', error);
      const reason = error instanceof Error ? error.message : 'Unknown error occurred during shadowban check.';
      return {
        isShadowbanned: false,
        statusMessage: 'Unable to check shadowban status',
        checkedAt: new Date().toISOString(),
        publicCount: 0,
        totalSelfPosts: 0,
        hiddenPosts: [],
        error: error instanceof Error ? error.message : 'Unknown error occurred'
        status: 'unknown',
        reason,
        evidence: buildEvidence('unknown', [], [], []),
      };
    }
  }

}

/**
 * Get user's Reddit community eligibility based on their profile and account settings
 */
export async function getUserRedditCommunityEligibility(
  userId: number
): Promise<RedditCommunityEligibility | null> {
  const redditManager = await RedditManager.forUser(userId);

  if (!redditManager) {
    return null;
  }

  const [account] = await db
    .select({ metadata: creatorAccounts.metadata })
    .from(creatorAccounts)
    .where(
      and(
        eq(creatorAccounts.userId, userId),
        eq(creatorAccounts.platform, 'reddit'),
        eq(creatorAccounts.isActive, true)
      )
    )
    .limit(1);
server/reddit-routes.ts
+41
-0

import type { Express } from 'express';
import crypto from 'crypto';
import { RedditManager, getRedditAuthUrl, exchangeRedditCode } from './lib/reddit.js';
import { db } from './db.js';
import { creatorAccounts } from '@shared/schema';
import type { ShadowbanCheckApiResponse } from '@shared/schema';
import { eq, and } from 'drizzle-orm';
import { authenticateToken, type AuthRequest } from './middleware/auth.js';
import { stateStore, encrypt, decrypt, rateLimit } from './services/state-store.js';
import {
  listCommunities,
  searchCommunities,
  getCommunityInsights,
  createCommunity,
  updateCommunity,
  deleteCommunity
} from './reddit-communities.js';
import { getUserRedditCommunityEligibility } from './lib/reddit.js';
import { logger } from './bootstrap/logger.js';
import { summarizeRemovalReasons } from './compliance/ruleViolationTracker.js';

interface RedditProfile {
  username: string;
  karma?: number;
  verified?: boolean;
}

export function registerRedditRoutes(app: Express) {
  
  // Start Reddit OAuth flow - SECURE VERSION
  app.get('/api/reddit/connect', rateLimit, authenticateToken, async (req: AuthRequest, res) => {
@@ -238,50 +239,90 @@ export function registerRedditRoutes(app: Express) {
      const accounts = await db
        .select()
        .from(creatorAccounts)
        .where(
          and(
            eq(creatorAccounts.userId, userId),
            eq(creatorAccounts.platform, 'reddit')
          )
        );

      res.json(accounts.map(account => ({
        id: account.id,
        username: account.platformUsername || account.handle,
        isActive: account.isActive,
        connectedAt: account.createdAt,
        karma: (account.metadata as any)?.karma || 0,
        verified: (account.metadata as any)?.verified || false,
      })));

    } catch (error) {
      console.error('Error fetching Reddit accounts:', error);
      res.status(500).json({ error: 'Failed to fetch Reddit accounts' });
    }
  });

  app.get('/api/reddit/shadowban-status', rateLimit, authenticateToken, async (req: AuthRequest, res) => {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const fallbackEvidence: ShadowbanCheckApiResponse['evidence'] = {
      username: 'unknown',
      checkedAt: new Date().toISOString(),
      privateCount: 0,
      publicCount: 0,
      privateSubmissions: [],
      publicSubmissions: [],
      missingSubmissionIds: [],
    };

    try {
      const redditManager = await RedditManager.forUser(userId);

      if (!redditManager) {
        return res.json({
          status: 'unknown' as const,
          reason: 'No active Reddit account connected.',
          evidence: fallbackEvidence,
        });
      }

      const status = await redditManager.checkShadowbanStatus();
      return res.json(status);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error('Shadowban status check failed', { userId, error: err.message, stack: err.stack });
      return res.status(500).json({
        error: 'Failed to check Reddit shadowban status',
        details: err.message,
      });
    }
  });

  // Disconnect Reddit account
  app.delete('/api/reddit/accounts/:accountId', authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { accountId } = req.params;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      await db
        .update(creatorAccounts)
        .set({ 
          isActive: false,
          oauthToken: '', // Clear tokens on disconnect
          oauthRefresh: '',
          updatedAt: new Date()
        })
        .where(
          and(
            eq(creatorAccounts.id, parseInt(accountId)),
            eq(creatorAccounts.userId, userId),
            eq(creatorAccounts.platform, 'reddit')
          )
        );

tests/unit/server/reddit-shadowban.test.ts
+19
-21

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { RedditManager } from '../../../server/lib/reddit.js';
import type { ShadowbanCheckApiResponse } from '../../../shared/schema.js';
import type snoowrap from 'snoowrap';

// Test interfaces
interface MockSubmission {
  id: string;
  created_utc: number;
  permalink: string;
  title: string;
  subreddit: { display_name: string };
}

interface MockRedditUser {
  getSubmissions: () => Promise<MockSubmission[]>;
}

interface MockRedditClient {
  getMe: () => Promise<MockRedditUser>;
}

// Mock snoowrap
const mockReddit = {
  getMe: vi.fn(),
};

// Mock fetch for public Reddit API
const mockFetch = vi.fn();
global.fetch = mockFetch;

// Mock RedditManager.forUser to return our test instance
vi.mock('../../../server/lib/reddit.js', async () => {
  const actual = await vi.importActual('../../../server/lib/reddit.js') as Record<string, unknown>;
  const actual = await vi.importActual<typeof import('../../../server/lib/reddit.js')>('../../../server/lib/reddit.js');
  class TestableRedditManager extends actual.RedditManager {
    static override forUser = vi.fn();
  }

  return {
    ...actual,
    RedditManager: {
      ...((actual.RedditManager as Record<string, unknown>) || {}),
      forUser: vi.fn(),
    },
    RedditManager: TestableRedditManager,
  };
});

describe('RedditManager shadowban detection', () => {
  let manager: RedditManager;
  const testUserId = 123;

  beforeEach(() => {
    vi.clearAllMocks();
    
    // Create a test instance with mocked reddit client
    manager = new (RedditManager as unknown as new (userId: number, client: MockRedditClient) => RedditManager)(testUserId, mockReddit);
    manager = new RedditManager('mock_access_token', 'mock_refresh_token', testUserId, mockReddit as unknown as snoowrap);
    
    // Mock the getProfile method
    vi.spyOn(manager, 'getProfile').mockResolvedValue({
      username: 'testuser',
      karma: 1000,
      verified: false,
      createdUtc: 1577836800, // 2020-01-01T00:00:00Z in Unix timestamp
      goldStatus: false,
      hasMail: false
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('checkShadowbanStatus', () => {
    it('should return clear status when all submissions are publicly visible', async () => {
      // Mock private submissions (what user sees)
      const privateSubmissions = [
      const privateSubmissions: MockSubmission[] = [
        {
          id: 'abc123',
          created_utc: 1640995200,
          permalink: '/r/test/comments/abc123/test_post/',
          title: 'Test Post 1',
          subreddit: { display_name: 'test' }
        },
        {
          id: 'def456',
          created_utc: 1640995100,
          permalink: '/r/test/comments/def456/test_post_2/',
          title: 'Test Post 2',
          subreddit: { display_name: 'test' }
        }
      ];

      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue(privateSubmissions)
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock public submissions (what Reddit's public API returns)
      const publicApiResponse = {
        data: {
          children: [
            {
              data: {
                id: 'abc123',
                created_utc: 1640995200,
                permalink: '/r/test/comments/abc123/test_post/',
                title: 'Test Post 1',
                subreddit: 'test'
              }
            },
            {
              data: {
                id: 'def456',
                created_utc: 1640995100,
                permalink: '/r/test/comments/def456/test_post_2/',
                title: 'Test Post 2',
                subreddit: 'test'
              }
            }
          ]
        }
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(publicApiResponse)
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('clear');
      expect(result.reason).toContain('All recent submissions are publicly visible');
      expect(result.evidence.privateCount).toBe(2);
      expect(result.evidence.publicCount).toBe(2);
      expect(result.evidence.missingSubmissionIds).toHaveLength(0);
      expect(result.evidence.username).toBe('testuser');
    });

    it('should return suspected status when all submissions are missing from public view', async () => {
      // Mock private submissions
      const privateSubmissions = [
      const privateSubmissions: MockSubmission[] = [
        {
          id: 'abc123',
          created_utc: 1640995200,
          permalink: '/r/test/comments/abc123/test_post/',
          title: 'Test Post 1',
          subreddit: { display_name: 'test' }
        },
        {
          id: 'def456',
          created_utc: 1640995100,
          permalink: '/r/test/comments/def456/test_post_2/',
          title: 'Test Post 2',
          subreddit: { display_name: 'test' }
        }
      ];

      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue(privateSubmissions)
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock empty public API response (all posts hidden)
      const publicApiResponse = {
        data: {
          children: []
        }
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(publicApiResponse)
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('suspected');
      expect(result.reason).toContain('All recent submissions are missing from public view');
      expect(result.evidence.privateCount).toBe(2);
      expect(result.evidence.publicCount).toBe(0);
      expect(result.evidence.missingSubmissionIds).toHaveLength(2);
      expect(result.evidence.missingSubmissionIds).toContain('abc123');
      expect(result.evidence.missingSubmissionIds).toContain('def456');
    });

    it('should return suspected status when majority of submissions are missing', async () => {
      // Mock private submissions
      const privateSubmissions = [
      const privateSubmissions: MockSubmission[] = [
        {
          id: 'abc123',
          created_utc: 1640995200,
          permalink: '/r/test/comments/abc123/test_post/',
          title: 'Test Post 1',
          subreddit: { display_name: 'test' }
        },
        {
          id: 'def456',
          created_utc: 1640995100,
          permalink: '/r/test/comments/def456/test_post_2/',
          title: 'Test Post 2',
          subreddit: { display_name: 'test' }
        },
        {
          id: 'ghi789',
          created_utc: 1640995000,
          permalink: '/r/test/comments/ghi789/test_post_3/',
          title: 'Test Post 3',
          subreddit: { display_name: 'test' }
        }
      ];

      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue(privateSubmissions)
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock public API response with only 1 of 3 posts visible
      const publicApiResponse = {
        data: {
          children: [
            {
              data: {
                id: 'abc123',
                created_utc: 1640995200,
                permalink: '/r/test/comments/abc123/test_post/',
                title: 'Test Post 1',
                subreddit: 'test'
              }
            }
          ]
        }
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(publicApiResponse)
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('suspected');
      expect(result.reason).toContain('2 of 3 recent submissions are missing from public view');
      expect(result.evidence.privateCount).toBe(3);
      expect(result.evidence.publicCount).toBe(1);
      expect(result.evidence.missingSubmissionIds).toHaveLength(2);
      expect(result.evidence.missingSubmissionIds).toContain('def456');
      expect(result.evidence.missingSubmissionIds).toContain('ghi789');
    });

    it('should return unknown status when no recent submissions found', async () => {
      // Mock empty private submissions
      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue([])
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock empty public API response
      const publicApiResponse = {
        data: {
          children: []
        }
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(publicApiResponse)
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('unknown');
      expect(result.reason).toContain('No recent submissions found to analyze');
      expect(result.evidence.privateCount).toBe(0);
      expect(result.evidence.publicCount).toBe(0);
      expect(result.evidence.missingSubmissionIds).toHaveLength(0);
    });

    it('should handle Reddit API errors gracefully', async () => {
      // Mock Reddit API failure
      mockReddit.getMe.mockRejectedValue(new Error('Reddit API error'));

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('unknown');
      expect(result.reason).toContain('Reddit API error');
      expect(result.evidence.privateCount).toBe(0);
      expect(result.evidence.publicCount).toBe(0);
    });

    it('should handle public API fetch errors gracefully', async () => {
      // Mock successful private submissions
      const privateSubmissions = [
      const privateSubmissions: MockSubmission[] = [
        {
          id: 'abc123',
          created_utc: 1640995200,
          permalink: '/r/test/comments/abc123/test_post/',
          title: 'Test Post 1',
          subreddit: { display_name: 'test' }
        }
      ];

      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue(privateSubmissions)
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock public API failure
      mockFetch.mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error'
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('unknown');
      expect(result.reason).toContain('Reddit API returned 500: Internal Server Error');
      expect(result.evidence.privateCount).toBe(1);
      expect(result.evidence.publicCount).toBe(0);
    });

    it('should handle profile fetch errors', async () => {
      // Mock getProfile failure
      vi.spyOn(manager, 'getProfile').mockResolvedValue(null);

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();

      expect(result.status).toBe('unknown');
      expect(result.reason).toContain('Unable to fetch Reddit profile for shadowban check');
    });

    it('should return clear status when few submissions are missing (under threshold)', async () => {
      // Mock private submissions (5 total)
      const privateSubmissions = Array.from({ length: 5 }, (_, i) => ({
      const privateSubmissions: MockSubmission[] = Array.from({ length: 5 }, (_, i) => ({
        id: `post${i}`,
        created_utc: 1640995200 - i * 100,
        permalink: `/r/test/comments/post${i}/test_post_${i}/`,
        title: `Test Post ${i}`,
        subreddit: { display_name: 'test' }
      }));

      const mockUser = {
      const mockUser: MockRedditUser = {
        getSubmissions: vi.fn().mockResolvedValue(privateSubmissions)
      };
      mockReddit.getMe.mockResolvedValue(mockUser);

      // Mock public API response with 4 of 5 posts visible (only 1 missing = 20%, under 50% threshold)
      const publicApiResponse = {
        data: {
          children: privateSubmissions.slice(0, 4).map(sub => ({
            data: {
              id: sub.id,
              created_utc: sub.created_utc,
              permalink: sub.permalink,
              title: sub.title,
              subreddit: sub.subreddit.display_name
            }
          }))
        }
      };

      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(publicApiResponse)
      });

      const result: ShadowbanCheckApiResponse = await manager.checkShadowbanStatus();
