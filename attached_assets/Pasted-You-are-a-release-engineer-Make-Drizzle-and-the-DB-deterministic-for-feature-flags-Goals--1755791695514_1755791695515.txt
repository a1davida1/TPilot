You are a release engineer. Make Drizzle and the DB deterministic for `feature_flags`.

Goals:
- Ensure our canonical fix SQL is where Drizzle expects it (./migrations).
- Ensure the Drizzle schema includes created_at -> createdAt mapping.
- Run our resolver, push schema, and verify.

Steps:

1) Ensure the canonical fix is in ./migrations
- If a file exists at migrations/sql/*feature_flags_fix.sql, copy it into ./migrations (keeping the original).
  Commands:
    mkdir -p migrations
    ls -1 migrations/sql/*feature_flags_fix.sql >/dev/null 2>&1 && cp migrations/sql/*feature_flags_fix.sql migrations/ || true
- Print: `ls -1 migrations | grep feature_flags_fix || true`

2) Confirm Drizzle config points to ./migrations
- Open drizzle.config.ts; ensure `out: "./migrations"`. If it's already that, do nothing. Print the line with `out:` so I can see it.

3) Patch Drizzle schema for created_at (idempotent)
- File: shared/schema.ts
- Ensure the import line includes `timestamp` from "drizzle-orm/pg-core".
- In the `featureFlags = pgTable("feature_flags", { ... })` object, ensure there is:
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  If missing, insert it after the `enabled` field. Keep commas correct. Do not create duplicates.
- Print the `featureFlags` block after edit.

4) Enforce DB state & push
- Run our deterministic resolver:
    node scripts/resolve-feature-flags.js
- Sync Drizzle (try both forms):
    npm run db:push || npx drizzle-kit push

5) Verify DB matches schema
- Run:
    psql "$DATABASE_URL" -Atc "\d+ public.feature_flags"
    psql "$DATABASE_URL" -Atc "SELECT count(*), min(created_at), max(created_at) FROM public.feature_flags;"
    psql "$DATABASE_URL" -Atc "SELECT to_regclass('public.saved_content');"
- Then print a short summary:
    - Where the fix SQL lives
    - Whether `created_at` appears in the schema and DB
    - Whether `saved_content` is gone (NULL) or ignored
