
Refactor Stripe initialization and rendering logic
Sep 19
·
a1davida1/TPilot
·
main
+135
-18

Archive

Share

Create PR


1. In `client/src/pages/checkout.tsx`, remove the top-level `throw` and only initialize Stripe inside a guard. For example, derive `const stripeKey = import.meta.env.VITE_STRIPE_PUBLIC_KEY;` and set `const stripePromise = stripeKey ? loadStripe(stripeKey) : null;` so the module can load even when the key is absent.
2. Update the component logic to skip rendering `<Elements>` (and instead show the existing “Payment System Not Configured” fallback) whenever `stripePromise` is `null`.
3. Ensure any hooks or helpers depending on Stripe handle the `null` promise gracefully (e.g., bail out early or display the fallback message).
4. Add/adjust tests to cover both configured and unconfigured environments so the runtime no longer explodes when the key is missing.
Copy
Summary

Deferred Stripe initialization by deriving the public key at module load, short-circuiting the payment intent effect when the key is missing, and routing users straight to the existing “Payment System Not Configured” fallback instead of rendering <Elements> without a client promise.

Added a vitest suite that stubs Stripe, the toast hook, and API calls to prove the checkout page renders both the fallback and the live payment form without throwing when the key is absent or present, while registering React on the global scope so the component mounts in jsdom.

Removed unused Node imports and adjusted ancillary files flagged by lint so repository-wide checks succeed (fix-type-errors.cjs, server/caption/openaiFallback.ts, and tests/integration/content-generation.test.ts).

Testing

✅ npm run lint

⚠️ npm test *(fails because the existing suite contains numerous unrelated breakages—e.g., Coinbase provider error handling, email verification mailers, expense APIs, upload flows, and queue initialization all error out under the current test configuration.)*

✅ npx vitest run client/src/pages/__tests__/checkout.test.tsx


Files (5)

client/src/pages/__tests__/checkout.test.tsx
New

client/src/pages/checkout.tsx
+18
-14

fix-type-errors.cjs
+0
-2

server/caption/openaiFallback.ts
+1
-1

tests/integration/content-generation.test.ts
+1
-1



Ask

Code
Diff
Logs

client/src/pages/__tests__/checkout.test.tsx
New
+115
-0

import React from 'react';
import { act } from 'react';
import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
import { createRoot, Root } from 'react-dom/client';

const loadStripeMock = vi.fn(() => Promise.resolve({}));

vi.mock('@stripe/stripe-js', () => ({
  loadStripe: loadStripeMock,
}));

const confirmPaymentMock = vi.fn();

vi.mock('@stripe/react-stripe-js', () => ({
  Elements: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="elements">{children}</div>
  ),
  PaymentElement: () => <div data-testid="payment-element" />,
  useStripe: () => ({ confirmPayment: confirmPaymentMock }),
  useElements: () => ({}),
}));

const apiRequestMock = vi.fn(async () => ({
  json: async () => ({ clientSecret: 'test_client_secret' }),
}));

vi.mock('@/lib/queryClient', () => ({
  apiRequest: apiRequestMock,
}));

const toastMock = vi.fn();

vi.mock('@/hooks/use-toast', () => ({
  useToast: () => ({ toast: toastMock }),
}));

const globalScope = globalThis as typeof globalThis & {
  React?: typeof React;
  IS_REACT_ACT_ENVIRONMENT?: boolean;
};

globalScope.React = React;
globalScope.IS_REACT_ACT_ENVIRONMENT = true;

const flushPromises = () => new Promise<void>((resolve) => {
  setTimeout(resolve, 0);
});

const renderCheckout = async (Checkout: React.ComponentType) => {
  const container = document.createElement('div');
  document.body.appendChild(container);
  const root = createRoot(container);

  await act(async () => {
    root.render(<Checkout />);
  });

  return { container, root };
};

const cleanupRender = async (root: Root, container: HTMLElement) => {
  await act(async () => {
    root.unmount();
  });
  container.remove();
};

describe('Checkout page', () => {
  beforeEach(() => {
    vi.resetModules();
    vi.unstubAllEnvs();
    loadStripeMock.mockClear();
    apiRequestMock.mockClear();
    toastMock.mockClear();
    confirmPaymentMock.mockClear();
  });

  afterEach(() => {
    vi.unstubAllEnvs();
    document.body.innerHTML = '';
  });

  it('renders fallback when Stripe is not configured', async () => {
    vi.stubEnv('VITE_STRIPE_PUBLIC_KEY', '');
    const { default: Checkout } = await import('../checkout');

    const { container, root } = await renderCheckout(Checkout);

    expect(container.textContent).toContain('Payment System Not Configured');
    expect(apiRequestMock).not.toHaveBeenCalled();

    await cleanupRender(root, container);
  });

  it('renders payment form when Stripe is configured', async () => {
    vi.stubEnv('VITE_STRIPE_PUBLIC_KEY', 'pk_test_123');
    const { default: Checkout } = await import('../checkout');

    const { container, root } = await renderCheckout(Checkout);

    await act(async () => {
      await flushPromises();
    });

    expect(loadStripeMock).toHaveBeenCalledWith('pk_test_123');
    expect(apiRequestMock).toHaveBeenCalled();

    const elementsContainer = container.querySelector('[data-testid="elements"]');
    expect(elementsContainer).not.toBeNull();
    expect(container.textContent ?? '').toContain('Secured by Stripe');

    await cleanupRender(root, container);
  });
});

client/src/pages/checkout.tsx
+18
-14

import { useStripe, Elements, PaymentElement, useElements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';
import { useEffect, useState } from 'react';
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { ArrowLeft, Shield, CheckCircle, Zap } from "lucide-react";
import { Link } from "wouter";

// Load Stripe
if (!import.meta.env.VITE_STRIPE_PUBLIC_KEY) {
  throw new Error('Missing required Stripe key: VITE_STRIPE_PUBLIC_KEY');
}
const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLIC_KEY || '');
const stripeKey = import.meta.env.VITE_STRIPE_PUBLIC_KEY;
const stripePromise = stripeKey ? loadStripe(stripeKey) : null;

interface CheckoutFormProps {
  plan: 'pro' | 'pro_plus';
}

const CheckoutForm = ({ plan }: CheckoutFormProps) => {
  const stripe = useStripe();
  const elements = useElements();
  const { toast } = useToast();
  const [isProcessing, setIsProcessing] = useState(false);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!stripe || !elements) {
      return;
    }

    setIsProcessing(true);

    const { error } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/dashboard?payment=success&plan=${plan}`,
      },
@@ -91,80 +88,85 @@ export default function Checkout() {
        "Priority support",
        "Post scheduling",
        "Analytics dashboard",
        "Reddit & Twitter integration"
      ]
    },
    pro_plus: {
      name: "Pro Plus",
      price: "$49.99",
      period: "month",
      features: [
        "Everything in Pro",
        "White-label options",
        "API access",
        "Custom branding",
        "Team collaboration",
        "Advanced analytics",
        "Priority processing"
      ]
    }
  };

  const currentPlan = planDetails[plan];

  useEffect(() => {
    if (!stripePromise) {
      setLoading(false);
      return;
    }

    // Create subscription payment intent
    const setupPayment = async () => {
      try {
        const response = await apiRequest("POST", "/api/create-subscription", { 
        const response = await apiRequest("POST", "/api/create-subscription", {
          plan,
          amount: plan === 'pro_plus' ? 4999 : 1999 // in cents
        });
        const data = await response.json();
        

        if (data.clientSecret) {
          setClientSecret(data.clientSecret);
        } else {
          throw new Error('Failed to setup payment');
        }
      } catch (error) {
        // Payment setup error - handled via toast UI
        toast({
          title: "Setup Failed",
          description: "Failed to initialize payment. Please try again.",
          variant: "destructive",
        });
      } finally {
        setLoading(false);
      }
    };

    setupPayment();
  }, [plan, toast]);
    void setupPayment();
  }, [plan, toast, stripePromise]);

  if (!import.meta.env.VITE_STRIPE_PUBLIC_KEY) {
  if (!stripePromise) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-pink-50 to-purple-50 flex items-center justify-center p-4">
        <Card className="max-w-md w-full">
          <CardContent className="pt-6">
            <div className="text-center space-y-4">
              <div className="text-red-600 text-lg font-semibold">
                Payment System Not Configured
              </div>
              <p className="text-gray-600">
                Please contact support to enable payments.
              </p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-pink-50 to-purple-50 flex items-center justify-center">
        <div className="animate-spin w-8 h-8 border-4 border-pink-500 border-t-transparent rounded-full" />
      </div>
    );
  }
@@ -220,40 +222,42 @@ export default function Checkout() {
                  <div key={index} className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-500 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700">{feature}</span>
                  </div>
                ))}
              </div>
              
              <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                <p className="text-sm text-blue-800">
                  <strong>30-day money-back guarantee</strong><br />
                  Cancel anytime, no questions asked.
                </p>
              </div>
            </CardContent>
          </Card>

          {/* Payment Form */}
          <Card>
            <CardHeader>
              <CardTitle>Payment Details</CardTitle>
              <CardDescription>
                Enter your payment information to complete subscription
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Elements stripe={stripePromise} options={{ clientSecret }}>
                <CheckoutForm plan={plan} />
              </Elements>
              
              {stripePromise && (
                <Elements stripe={stripePromise} options={{ clientSecret }}>
                  <CheckoutForm plan={plan} />
                </Elements>
              )}

              <div className="mt-6 flex items-center justify-center text-sm text-gray-500">
                <Shield className="h-4 w-4 mr-2" />
                Secured by Stripe
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
fix-type-errors.cjs
+0
-2

#!/usr/bin/env node

/* eslint-env node */
const fs = require('fs');
const path = require('path');

// Helper to fix common TypeScript errors
function fixTypeErrors(filePath) {
  if (!fs.existsSync(filePath)) return;
  
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Fix error.message patterns
  content = content.replace(/(\s)error\.message/g, '$1(error as Error).message');
  content = content.replace(/(\s)error\.stack/g, '$1(error as Error).stack');
  
  // Fix implicit any in map functions
  content = content.replace(/\.map\(\(([^,)]+),\s*([^)]+)\)/g, '.map(($1: any, $2: number)');
  
  // Fix implicit any in function parameters
  content = content.replace(/function\s+(\w+)\(([^:)]+)\)/g, 'function $1($2: any)');
  
  fs.writeFileSync(filePath, content);
}

// Process all TypeScript files
const files = process.argv.slice(2);
files.forEach(fixTypeErrors);

console.log('✅ Type errors fixed in', files.length, 'files');
server/caption/openaiFallback.ts
+1
-1

@@ -16,51 +16,51 @@ const CaptionItem = z.object({


const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || '' });

export interface FallbackParams {
  platform: string;
  voice: string;
  imageUrl?: string;
  theme?: string;
  context?: string;
  existingCaption?: string;
}

export async function openAICaptionFallback({
  platform,
  voice = "flirty_playful",
  imageUrl,
  existingCaption
}: {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  imageUrl?: string;
  existingCaption?: string;
}): Promise<z.infer<typeof CaptionItem>> {
  // Analyze image if provided
  let imageAnalysis = '';
  const imageAnalysis = '';
  let messages: any[] = [];

  if (imageUrl && openai) {
    try {
      console.log('OpenAI fallback: Analyzing image for accurate captions');

      if (imageUrl.startsWith('data:')) {
        // For data URLs, we can send directly to OpenAI vision
        messages = [
          {
            role: "system",
            content: `You are an expert social media caption writer. Analyze the image carefully and create engaging ${voice} content for ${platform} that directly relates to what you see.

Return ONLY a JSON object with this structure:
{
  "caption": "engaging caption text that describes what's actually in the image",
  "hashtags": ["#relevant", "#to", "#image"],
  "safety_level": "safe_for_work",
  "mood": "${voice.includes('flirty') ? 'flirty' : 'confident'}",
  "style": "authentic",
  "cta": "relevant call to action",
  "alt": "detailed description of what's actually in the image",
  "nsfw": false
}`
          },
tests/integration/content-generation.test.ts
+1
-1

@@ -130,51 +130,51 @@ describe('Content Generation Integration Tests', () => {
          user: { id: user.id, email: user.email || undefined, tier: user.tier },
          platform: req.body.platform,
          imageDescription: req.body.imageDescription,
          customPrompt: req.body.customPrompt,
          subreddit: req.body.subreddit,
          allowsPromotion: req.body.allowsPromotion || 'no',
          baseImageUrl: req.body.imageUrl
        });
        
        // Save to database
        const [generation] = await db.insert(contentGenerations).values({
          userId: user.id,
          platform: req.body.platform || 'reddit',
          style: 'default',
          theme: 'default',
          content: result.content,
          titles: result.titles,
          photoInstructions: result.photoInstructions,
          prompt: req.body.customPrompt || '',
          subreddit: req.body.subreddit || null,
          allowsPromotion: req.body.allowsPromotion === 'yes',
          generationType: 'ai'
        }).returning();
        
        // Handle special cases for testing
        let response: any = {
        const response: any = {
          ...result,
          platform: req.body.platform || result.platform,
          imageAnalyzed: !!req.body.imageDescription
        };
        
        // Add fallback indicators for testing
        if (req.body.templateId === 'missing_template') {
          response.fallbackUsed = true;
        }
        
        if (req.body.imageUrl?.endsWith('.bmp')) {
          response.imageError = 'unsupported_format';
          response.fallbackUsed = true;
        }
        
        // Cache the response
        cache.set(cacheKey, response);
        
        res.json(response);
      } catch (error) {
        const errorMessage = (error as Error).message;
        safeLog('error', 'Caption generation failed in test', { error: errorMessage });
        
        // Check if it's a database error
        if (errorMessage.includes('Failed query') || errorMessage.includes('database')) {
