diff --git a/server/admin-routes.ts b/server/admin-routes.ts
index cf2cda76b82d11442567728cd3043a76a19fedef..92974016e00bfa96d697fb99ee7025c4a6d6bf1b 100644
--- a/server/admin-routes.ts
+++ b/server/admin-routes.ts
@@ -1,40 +1,44 @@
 import { Express } from 'express';
 import express from 'express';
 import bcrypt from 'bcrypt';
 import jwt from 'jsonwebtoken';
 import crypto from 'crypto';
 import { storage } from './storage';
 import { emailService } from './services/email-service';
 
 const JWT_SECRET = process.env.JWT_SECRET;
 if (!JWT_SECRET) {
   throw new Error('JWT_SECRET environment variable is required for secure token operations');
 }
 // Type assertion after validation
 const JWT_SECRET_VALIDATED: string = JWT_SECRET;
 
+interface AdminRequest extends express.Request {
+  user: { id: number; username?: string | null; isAdmin?: boolean | null };
+}
+
 export function setupAdminRoutes(app: Express) {
   // Admin middleware to check if user is admin
   const requireAdmin = (req: express.Request & { user?: { id: number; username?: string | null; isAdmin?: boolean | null }; isAuthenticated?: () => boolean }, res: express.Response, next: express.NextFunction) => {
     // Check if user is authenticated via session OR JWT
     let user: unknown = null;
     let token: string | null = null;
     
     // Try cookie-based authentication first (preferred)
     if (req.cookies && req.cookies.authToken) {
       token = req.cookies.authToken;
     }
     // Fallback to Bearer token authentication  
     else if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
       token = req.headers.authorization.substring(7);
     }
     // Also try session-based authentication
     else if (req.isAuthenticated && req.isAuthenticated()) {
       user = req.user;
     }
     
     // If we have a token, verify it
     if (token) {
       try {
         const decoded = jwt.verify(token, JWT_SECRET_VALIDATED) as { id: number; username?: string; isAdmin?: boolean; iat: number; exp: number };
         user = decoded;
diff --git a/server/admin-routes.ts b/server/admin-routes.ts
index cf2cda76b82d11442567728cd3043a76a19fedef..92974016e00bfa96d697fb99ee7025c4a6d6bf1b 100644
--- a/server/admin-routes.ts
+++ b/server/admin-routes.ts
@@ -578,151 +582,151 @@ export function setupAdminRoutes(app: Express) {
     } catch (error) {
       console.error('Error fetching system metrics:', error);
       res.status(500).json({ message: 'Error fetching system metrics' });
     }
   });
 
   app.get('/api/admin/system-logs', requireAdmin, async (req, res) => {
     try {
       const level = req.query.level || 'all';
       const limit = parseInt(req.query.limit as string) || 50;
 
       // Return empty logs array since we don't have system_logs table yet
       const logs = [];
 
       res.json(logs);
     } catch (error) {
       console.error('Error fetching system logs:', error);
       res.status(500).json({ message: 'Error fetching system logs' });
     }
   });
 
   // FEATURE 3: Advanced User Management Actions
   app.post('/api/admin/ban-user', requireAdmin, async (req, res) => {
     try {
       const { userId, reason, duration, banIp = false } = req.body;
-      const adminId = (req.user as any).id;
+      const adminId = (req as AdminRequest).user.id;
 
       // Update user status and log action
       await storage.updateUser(userId, { 
         tier: 'banned',
         bannedAt: new Date(),
         banReason: reason
       });
 
       // Log admin action
       const auditLogData = {
         adminId,
         action: 'ban_user',
         targetType: 'user',
         targetId: userId,
         description: `Banned user for: ${reason}`,
         ipAddress: req.ip,
         metadata: { duration, banIp, reason }
       };
 
       res.json({ 
         message: 'User banned successfully',
         action: auditLogData
       });
     } catch (error) {
       console.error('Error banning user:', error);
       res.status(500).json({ message: 'Error banning user' });
     }
   });
 
   app.post('/api/admin/unban-user', requireAdmin, async (req, res) => {
     try {
       const { userId } = req.body;
-      const adminId = (req.user as any).id;
+      const adminId = (req as AdminRequest).user.id;
 
       await storage.updateUser(userId, { 
         tier: 'free',
         bannedAt: null,
         banReason: null
       });
 
       res.json({ message: 'User unbanned successfully' });
     } catch (error) {
       console.error('Error unbanning user:', error);
       res.status(500).json({ message: 'Error unbanning user' });
     }
   });
 
   app.post('/api/admin/suspend-user', requireAdmin, async (req, res) => {
     try {
       const { userId, hours, reason } = req.body;
-      const adminId = (req.user as any).id;
+      const adminId = (req as AdminRequest).user.id;
 
       const suspendedUntil = new Date(Date.now() + hours * 60 * 60 * 1000);
       
       await storage.updateUser(userId, { 
         suspendedUntil,
         suspensionReason: reason
       });
 
       res.json({ 
         message: `User suspended for ${hours} hours`,
         suspendedUntil
       });
     } catch (error) {
       console.error('Error suspending user:', error);
       res.status(500).json({ message: 'Error suspending user' });
     }
   });
 
   app.post('/api/admin/force-logout', requireAdmin, async (req, res) => {
     try {
       const { userId } = req.body;
       
       // This would normally invalidate all user sessions
       res.json({ message: 'User sessions terminated' });
     } catch (error) {
       console.error('Error forcing logout:', error);
       res.status(500).json({ message: 'Error forcing logout' });
     }
   });
 
   // FEATURE 4: Content Moderation Tools
   app.get('/api/admin/flagged-content', requireAdmin, async (req, res) => {
     try {
       const status = req.query.status || 'pending';
       
       // Return empty flags array since we don't have content_flags table data yet
       const flags = [];
 
       res.json(flags);
     } catch (error) {
       console.error('Error fetching flagged content:', error);
       res.status(500).json({ message: 'Error fetching flagged content' });
     }
   });
 
   app.post('/api/admin/moderate-content', requireAdmin, async (req, res) => {
     try {
       const { flagId, action, reason } = req.body; // approve, remove, warn_user
-      const adminId = (req.user as any).id;
+      const adminId = (req as AdminRequest).user.id;
 
       // Would update the content flag status when content_flags table exists
       res.json({ 
         message: `Content ${action}d successfully`,
         flagId,
         moderatedBy: adminId,
         moderatedAt: new Date(),
         reason
       });
     } catch (error) {
       console.error('Error moderating content:', error);
       res.status(500).json({ message: 'Error moderating content' });
     }
   });
 
   // FEATURE 5: Live Admin Dashboard - Real-time Metrics
   app.get('/api/admin/live-dashboard', requireAdmin, async (req, res) => {
     try {
       const users = await storage.getAllUsers();
       
       // Content generations will be tracked when implemented
       const totalGenerations = 0;
       
       const liveMetrics = {
         realTime: {
diff --git a/server/admin-routes.ts b/server/admin-routes.ts
index cf2cda76b82d11442567728cd3043a76a19fedef..92974016e00bfa96d697fb99ee7025c4a6d6bf1b 100644
--- a/server/admin-routes.ts
+++ b/server/admin-routes.ts
@@ -735,33 +739,33 @@ export function setupAdminRoutes(app: Express) {
         recentActivity: [], // Would come from audit logs when implemented
         systemHealth: {
           database: 'healthy',
           ai: process.env.GOOGLE_GENAI_API_KEY ? 'healthy' : 'degraded',
           storage: 'healthy',
           api: 'healthy'
         }
       };
 
       res.json(liveMetrics);
     } catch (error) {
       console.error('Error fetching live dashboard data:', error);
       res.status(500).json({ message: 'Error fetching live dashboard data' });
     }
   });
 
   app.post('/api/admin/acknowledge-alert', requireAdmin, async (req, res) => {
     try {
       const { alertId } = req.body;
       
       // This would mark the alert as acknowledged
       res.json({ 
         message: 'Alert acknowledged',
         alertId,
         acknowledgedAt: new Date(),
-        acknowledgedBy: (req.user as any).id
+        acknowledgedBy: (req as AdminRequest).user.id
       });
     } catch (error) {
       console.error('Error acknowledging alert:', error);
       res.status(500).json({ message: 'Error acknowledging alert' });
     }
   });
 }
