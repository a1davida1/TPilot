ThottoPilot - Production Launch Readiness & Polish Phase
Current Status: Core functionality is working - OAuth fixed, database schema updated, TypeScript errors resolved, AI providers configured. Now we need to polish everything for real users and prepare for launch.
Mission: Transform ThottoPilot from a working prototype into a polished, production-ready SaaS that can handle real users, provide excellent UX, and scale effectively.

🎨 PART 1: User Experience Polish
A. Onboarding Flow Enhancement
Create a smooth first-user experience:

Create Welcome Flow (client/src/components/onboarding-wizard.tsx):

typescript// Implement a 4-step wizard:
// Step 1: Welcome & choose content type (SFW/NSFW)
// Step 2: Connect social accounts (Reddit, Twitter, etc.)
// Step 3: Set up AI preferences (tone, style)
// Step 4: First content generation tutorial

interface OnboardingStep {
  title: string;
  description: string;
  action: () => void;
  isComplete: boolean;
}

Add Progress Indicators everywhere:


Upload progress bars with percentages
AI generation progress (Analyzing... Generating... Polishing...)
Save states with success confirmations
Form submission states


Implement Tooltips for complex features:

typescript// Add helpful tooltips to:
- Protection levels (explain what each does)
- AI styles (show example outputs)
- Posting best times (explain why)
- Platform requirements (character limits, etc.)

Create Interactive Demo Mode:


Let users try features without signing up
Pre-populated sample data
"Try it free" buttons throughout landing page
Clear upgrade prompts after demo

B. Error Handling & Recovery

User-Friendly Error Messages:

typescript// Replace all generic errors with helpful messages:
Instead of: "Error 500: Internal Server Error"
Show: "Oops! Our AI is taking a coffee break. Try again in a moment, or use a different style."

// Create error message map:
const errorMessages = {
  'quota_exceeded': "You've reached your daily limit. Upgrade to Pro for unlimited generations!",
  'reddit_not_connected': "Connect your Reddit account first to post",
  'image_too_large': "Image is too large (max 10MB). Try compressing it first.",
  'nsfw_not_allowed': "This subreddit doesn't allow NSFW content",
  // ... etc
}

Retry Mechanisms:

typescript// Add automatic retry with exponential backoff:
async function retryWithBackoff(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
    }
  }
}

Offline Mode Support:


Cache generated content locally
Queue posts for when connection returns
Show offline indicator
Sync when back online

C. Loading States & Skeletons
Replace ALL loading spinners with context-aware states:
typescript// Create skeleton components for each section:
// ContentSkeleton.tsx
export const ContentSkeleton = () => (
  <div className="animate-pulse">
    <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
    <div className="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
    <div className="h-20 bg-gray-200 rounded"></div>
  </div>
);

// Use throughout app:
{isLoading ? <ContentSkeleton /> : <ActualContent />}
D. Mobile Optimization

Touch Gestures:


Swipe to delete/archive
Pull to refresh
Long press for options
Pinch to zoom images


Mobile-First Components:

typescript// Create mobile drawer for navigation
// Bottom sheets for actions
// Floating action button for quick create
// Thumb-friendly button placement

Responsive Images:

typescript// Implement responsive image loading:
<picture>
  <source media="(max-width: 640px)" srcSet={mobileSrc} />
  <source media="(max-width: 1024px)" srcSet={tabletSrc} />
  <img src={desktopSrc} loading="lazy" />
</picture>

📊 PART 2: Analytics & Monitoring Implementation
A. User Analytics System
Create server/services/analytics-service.ts:
typescriptinterface AnalyticsEvent {
  userId: string;
  event: string;
  properties: Record<string, any>;
  timestamp: Date;
  sessionId: string;
  deviceInfo: {
    browser: string;
    os: string;
    device: string;
  };
}

class AnalyticsService {
  // Track these key events:
  trackSignup(userId: string, source: string) {}
  trackLogin(userId: string, method: string) {}
  trackContentGenerated(userId: string, platform: string, style: string) {}
  trackPostCreated(userId: string, platform: string, success: boolean) {}
  trackSubscription(userId: string, plan: string, revenue: number) {}
  trackFeatureUsage(userId: string, feature: string) {}
  trackError(userId: string, error: string, context: any) {}
  
  // Generate reports:
  getDailyActiveUsers(): number {}
  getConversionFunnel(): FunnelData {}
  getRetentionCohort(): CohortData {}
  getFeatureAdoption(): AdoptionData {}
  getRevenueMetrics(): RevenueData {}
}
B. Performance Monitoring
Create server/middleware/performance.ts:
typescript// Track response times
app.use((req, res, next) => {
  const start = process.hrtime();
  
  res.on('finish', () => {
    const [seconds, nanoseconds] = process.hrtime(start);
    const duration = seconds * 1000 + nanoseconds / 1000000;
    
    // Log slow requests
    if (duration > 1000) {
      logger.warn('Slow request', {
        path: req.path,
        method: req.method,
        duration,
        query: req.query
      });
    }
    
    // Send to metrics service
    metrics.histogram('http_request_duration', duration, {
      path: req.path,
      method: req.method,
      status: res.statusCode
    });
  });
  
  next();
});
C. Error Tracking
Implement comprehensive error tracking:
typescript// client/src/utils/error-boundary.tsx
class ErrorBoundary extends React.Component {
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to service
    errorTracking.logError(error, {
      component: errorInfo.componentStack,
      userId: getCurrentUserId(),
      url: window.location.href,
      timestamp: new Date().toISOString()
    });
    
    // Show user-friendly error
    this.setState({ hasError: true });
  }
}

// Wrap entire app
<ErrorBoundary>
  <App />
</ErrorBoundary>

🔐 PART 3: Security Hardening
A. Implement Content Security Policy
typescript// server/middleware/security.ts
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://js.stripe.com"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      imgSrc: ["'self'", "data:", "https:", "blob:"],
      connectSrc: ["'self'", "https://api.stripe.com", "https://api.openai.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
B. Add Request Signing
typescript// For sensitive operations, add request signing:
function signRequest(payload: any, secret: string): string {
  return crypto
    .createHmac('sha256', secret)
    .update(JSON.stringify(payload))
    .digest('hex');
}

// Verify on server:
function verifySignature(payload: any, signature: string, secret: string): boolean {
  const expected = signRequest(payload, secret);
  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected));
}
C. Implement Rate Limiting by Tier
typescript// server/middleware/tiered-rate-limit.ts
const rateLimits = {
  free: { windowMs: 60000, max: 10 },
  starter: { windowMs: 60000, max: 50 },
  pro: { windowMs: 60000, max: 200 },
  premium: { windowMs: 60000, max: 1000 }
};

export const tieredRateLimit = async (req, res, next) => {
  const user = await getUserFromRequest(req);
  const tier = user?.tier || 'free';
  const limit = rateLimits[tier];
  
  // Apply appropriate limit
  return rateLimit(limit)(req, res, next);
};

💰 PART 4: Monetization & Growth Features
A. Implement Referral System
Create server/services/referral-service.ts:
typescriptinterface ReferralSystem {
  generateReferralCode(userId: string): string;
  trackReferral(code: string, newUserId: string): void;
  calculateRewards(userId: string): ReferralRewards;
  processRewardPayout(userId: string): void;
}

// Database schema:
CREATE TABLE referrals (
  id SERIAL PRIMARY KEY,
  referrer_id INTEGER REFERENCES users(id),
  referred_id INTEGER REFERENCES users(id),
  code VARCHAR(20) UNIQUE,
  status VARCHAR(50), -- pending, completed, paid
  reward_amount DECIMAL(10,2),
  created_at TIMESTAMP DEFAULT NOW()
);
B. Usage-Based Billing
typescript// Track usage for billing:
interface UsageTracking {
  userId: string;
  metric: 'ai_generation' | 'image_protection' | 'posts_scheduled';
  quantity: number;
  timestamp: Date;
}

// Bill based on usage:
async function calculateMonthlyBill(userId: string): Promise<number> {
  const usage = await getMonthlyUsage(userId);
  const rates = {
    ai_generation: 0.02,      // $0.02 per generation
    image_protection: 0.01,    // $0.01 per image
    posts_scheduled: 0.005     // $0.005 per post
  };
  
  return Object.entries(usage).reduce((total, [metric, quantity]) => {
    return total + (rates[metric] * quantity);
  }, 0);
}
C. A/B Testing Framework
typescript// client/src/utils/ab-testing.ts
class ABTestingService {
  getVariant(testName: string, userId: string): string {
    // Consistent variant assignment
    const hash = hashCode(userId + testName);
    const variants = this.tests[testName].variants;
    const index = Math.abs(hash) % variants.length;
    return variants[index];
  }
  
  trackConversion(testName: string, userId: string, value?: number) {
    analytics.track('ab_test_conversion', {
      test: testName,
      variant: this.getVariant(testName, userId),
      userId,
      value
    });
  }
}

// Usage:
const variant = abTest.getVariant('pricing_page', userId);
if (variant === 'new_design') {
  return <NewPricingPage />;
} else {
  return <OldPricingPage />;
}

🎯 PART 5: Content Optimization Engine
A. Smart Content Scheduling
typescript// server/services/scheduling-optimizer.ts
class SchedulingOptimizer {
  async getBestPostTime(userId: string, platform: string): Promise<Date> {
    // Analyze user's historical performance
    const history = await getPostHistory(userId, platform);
    
    // Find patterns in successful posts
    const successfulPosts = history.filter(p => p.engagement > avgEngagement);
    const hourCounts = new Map<number, number>();
    
    successfulPosts.forEach(post => {
      const hour = new Date(post.postedAt).getHours();
      hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
    });
    
    // Return optimal time
    const bestHour = [...hourCounts.entries()]
      .sort((a, b) => b[1] - a[1])[0][0];
    
    return getNextTimeAtHour(bestHour);
  }
  
  async suggestContentBasedOnTrends(): Promise<ContentSuggestion[]> {
    // Analyze trending topics
    const trends = await getTrendingTopics();
    
    // Match with user's niche
    const userNiche = await getUserNiche(userId);
    
    // Generate suggestions
    return trends
      .filter(t => matchesNiche(t, userNiche))
      .map(t => ({
        topic: t.topic,
        platform: t.platform,
        estimatedEngagement: t.score,
        suggestedStyle: t.bestStyle
      }));
  }
}
B. Content Performance Predictor
typescript// Use ML-lite approach for engagement prediction:
class EngagementPredictor {
  async predictEngagement(content: Content): Promise<number> {
    const features = {
      titleLength: content.title.length,
      hasEmojis: /\p{Emoji}/u.test(content.title),
      hasQuestion: content.title.includes('?'),
      postTime: new Date(content.scheduledFor).getHours(),
      dayOfWeek: new Date(content.scheduledFor).getDay(),
      contentLength: content.body.length,
      imageCount: content.images?.length || 0,
      hashtagCount: content.hashtags?.length || 0
    };
    
    // Simple scoring based on historical data
    let score = 50; // Base score
    
    if (features.titleLength > 40 && features.titleLength < 80) score += 10;
    if (features.hasEmojis) score += 15;
    if (features.hasQuestion) score += 20;
    if (features.postTime >= 19 && features.postTime <= 23) score += 15;
    if (features.dayOfWeek === 5 || features.dayOfWeek === 6) score += 10;
    if (features.imageCount > 0) score += 25;
    if (features.hashtagCount >= 3 && features.hashtagCount <= 7) score += 10;
    
    return Math.min(100, score);
  }
}

🔧 PART 6: Database Optimization
A. Add Indexes for Performance
sql-- Critical indexes for performance:
CREATE INDEX CONCURRENTLY idx_users_email_verified ON users(email_verified) WHERE email_verified = true;
CREATE INDEX CONCURRENTLY idx_content_generations_user_created ON content_generations(user_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_posts_platform_status ON social_media_posts(platform, status);
CREATE INDEX CONCURRENTLY idx_sessions_expires ON sessions(expires) WHERE expires > NOW();

-- Composite indexes for common queries:
CREATE INDEX CONCURRENTLY idx_users_tier_status ON users(tier, subscription_status);
CREATE INDEX CONCURRENTLY idx_analytics_user_event_time ON analytics_events(user_id, event, timestamp DESC);

-- Full text search indexes:
CREATE INDEX CONCURRENTLY idx_posts_content_search ON social_media_posts USING gin(to_tsvector('english', content));
B. Implement Soft Deletes
sql-- Add soft delete columns:
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP DEFAULT NULL;
ALTER TABLE social_media_posts ADD COLUMN deleted_at TIMESTAMP DEFAULT NULL;
ALTER TABLE user_images ADD COLUMN deleted_at TIMESTAMP DEFAULT NULL;

-- Create views for active records:
CREATE VIEW active_users AS 
  SELECT * FROM users WHERE deleted_at IS NULL;

CREATE VIEW active_posts AS 
  SELECT * FROM social_media_posts WHERE deleted_at IS NULL;

-- Update queries to use views or add WHERE deleted_at IS NULL
C. Data Archival Strategy
typescript// server/jobs/archive-old-data.ts
async function archiveOldData() {
  const ARCHIVE_AFTER_DAYS = 90;
  
  // Move old analytics to archive table
  await db.query(`
    INSERT INTO analytics_events_archive 
    SELECT * FROM analytics_events 
    WHERE timestamp < NOW() - INTERVAL '${ARCHIVE_AFTER_DAYS} days'
  `);
  
  // Delete from main table
  await db.query(`
    DELETE FROM analytics_events 
    WHERE timestamp < NOW() - INTERVAL '${ARCHIVE_AFTER_DAYS} days'
  `);
  
  // Vacuum to reclaim space
  await db.query('VACUUM ANALYZE analytics_events');
}

// Run daily at 3 AM
cron.schedule('0 3 * * *', archiveOldData);

📱 PART 7: Progressive Web App (PWA)
A. Create Service Worker
Create client/public/service-worker.js:
javascriptconst CACHE_NAME = 'thottopilot-v1';
const urlsToCache = [
  '/',
  '/dashboard',
  '/static/css/main.css',
  '/static/js/main.js',
  '/logo.png'
];

// Install event
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// Fetch event with network-first strategy
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Cache successful responses
        if (response && response.status === 200) {
          const responseToCache = response.clone();
          caches.open(CACHE_NAME)
            .then(cache => cache.put(event.request, responseToCache));
        }
        return response;
      })
      .catch(() => caches.match(event.request))
  );
});
B. Add Web App Manifest
Create client/public/manifest.json:
json{
  "name": "ThottoPilot - Content Creation Platform",
  "short_name": "ThottoPilot",
  "description": "AI-powered content creation for social media creators",
  "start_url": "/dashboard",
  "display": "standalone",
  "theme_color": "#8B5CF6",
  "background_color": "#FEF3F2",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "shortcuts": [
    {
      "name": "Generate Content",
      "url": "/generate",
      "icons": [{ "src": "/icon-generate.png", "sizes": "96x96" }]
    },
    {
      "name": "Reddit Post",
      "url": "/reddit",
      "icons": [{ "src": "/icon-reddit.png", "sizes": "96x96" }]
    }
  ]
}
C. Push Notifications
typescript// client/src/services/push-notifications.ts
class PushNotificationService {
  async requestPermission() {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      await this.subscribeUser();
    }
  }
  
  async subscribeUser() {
    const registration = await navigator.serviceWorker.ready;
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: process.env.REACT_APP_VAPID_PUBLIC_KEY
    });
    
    // Send subscription to server
    await fetch('/api/push/subscribe', {
      method: 'POST',
      body: JSON.stringify(subscription),
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  async sendNotification(title: string, body: string, icon?: string) {
    const registration = await navigator.serviceWorker.ready;
    registration.showNotification(title, {
      body,
      icon: icon || '/logo.png',
      badge: '/badge.png',
      vibrate: [200, 100, 200],
      actions: [
        { action: 'view', title: 'View' },
        { action: 'dismiss', title: 'Dismiss' }
      ]
    });
  }
}

🏃 PART 8: Performance Optimization
A. Implement Code Splitting
typescript// client/src/App.tsx
import { lazy, Suspense } from 'react';

// Lazy load heavy components
const Dashboard = lazy(() => import('./pages/dashboard'));
const ContentGenerator = lazy(() => import('./pages/content-generator'));
const RedditPosting = lazy(() => import('./pages/reddit-posting'));
const ImageProtection = lazy(() => import('./pages/image-protection'));

// Use with Suspense
<Suspense fallback={<LoadingScreen />}>
  <Routes>
    <Route path="/dashboard" element={<Dashboard />} />
    <Route path="/generate" element={<ContentGenerator />} />
    <Route path="/reddit" element={<RedditPosting />} />
    <Route path="/protect" element={<ImageProtection />} />
  </Routes>
</Suspense>
B. Optimize Bundle Size
javascript// webpack.config.js or vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui': ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu'],
          'charts': ['recharts'],
          'editor': ['@tiptap/react', '@tiptap/starter-kit'],
          'ai': ['openai', '@anthropic-ai/sdk']
        }
      }
    },
    // Enable compression
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  }
};
C. Image Optimization Pipeline
typescript// server/services/image-optimizer.ts
import sharp from 'sharp';

class ImageOptimizer {
  async optimizeForWeb(buffer: Buffer): Promise<OptimizedImages> {
    const pipeline = sharp(buffer);
    
    // Generate multiple sizes
    const sizes = {
      thumbnail: { width: 150, height: 150 },
      mobile: { width: 640 },
      tablet: { width: 1024 },
      desktop: { width: 1920 }
    };
    
    const optimized = {};
    
    for (const [name, size] of Object.entries(sizes)) {
      // WebP for modern browsers
      optimized[`${name}_webp`] = await pipeline
        .resize(size.width, size.height, { fit: 'inside' })
        .webp({ quality: 85 })
        .toBuffer();
      
      // JPEG fallback
      optimized[`${name}_jpg`] = await pipeline
        .resize(size.width, size.height, { fit: 'inside' })
        .jpeg({ quality: 85, progressive: true })
        .toBuffer();
    }
    
    return optimized;
  }
  
  async generateBlurPlaceholder(buffer: Buffer): Promise<string> {
    const placeholder = await sharp(buffer)
      .resize(20, 20, { fit: 'inside' })
      .blur(10)
      .toBuffer();
    
    return `data:image/jpeg;base64,${placeholder.toString('base64')}`;
  }
}

📝 PART 9: Documentation & Help System
A. In-App Help System
Create client/src/components/help-system.tsx:
typescriptinterface HelpArticle {
  id: string;
  title: string;
  category: string;
  content: string;
  videoUrl?: string;
  relatedArticles?: string[];
}

const HelpSystem = () => {
  const articles: HelpArticle[] = [
    {
      id: 'getting-started',
      title: 'Getting Started with ThottoPilot',
      category: 'basics',
      content: '...',
      videoUrl: 'https://youtube.com/...'
    },
    // ... more articles
  ];
  
  return (
    <CommandDialog>
      <CommandInput placeholder="Search help articles..." />
      <CommandList>
        {articles.map(article => (
          <CommandItem key={article.id}>
            {article.title}
          </CommandItem>
        ))}
      </CommandList>
    </CommandDialog>
  );
};

// Activate with Cmd+K or Ctrl+K
B. Interactive Tutorials
typescript// client/src/components/interactive-tutorial.tsx
import { driver } from 'driver.js';

const tutorials = {
  firstPost: [
    {
      element: '#generate-button',
      popover: {
        title: 'Generate Content',
        description: 'Click here to create your first AI-powered post'
      }
    },
    {
      element: '#style-selector',
      popover: {
        title: 'Choose Your Style',
        description: 'Select a tone that matches your brand'
      }
    },
    // ... more steps
  ]
};

export function startTutorial(name: string) {
  const driverObj = driver({
    showProgress: true,
    steps: tutorials[name]
  });
  
  driverObj.drive();
}

🎊 PART 10: Launch Preparation
A. Pre-Launch Checklist
typescript// server/scripts/pre-launch-check.ts
async function preLaunchCheck() {
  const checks = [
    { name: 'Database connection', fn: checkDatabase },
    { name: 'Redis connection', fn: checkRedis },
    { name: 'Email service', fn: checkEmail },
    { name: 'Payment processing', fn: checkStripe },
    { name: 'AI providers', fn: checkAIProviders },
    { name: 'File uploads', fn: checkFileUploads },
    { name: 'Rate limiting', fn: checkRateLimiting },
    { name: 'SSL certificate', fn: checkSSL },
    { name: 'Backup system', fn: checkBackups },
    { name: 'Monitoring', fn: checkMonitoring }
  ];
  
  for (const check of checks) {
    try {
      await check.fn();
      console.log(`✅ ${check.name}`);
    } catch (error) {
      console.error(`❌ ${check.name}: ${error.message}`);
    }
  }
}
B. Launch Day Monitoring
typescript// server/monitoring/launch-dashboard.ts
class LaunchDashboard {
  metrics = {
    signups: 0,
    activeUsers: 0,
    contentGenerated: 0,
    errors: [],
    revenue: 0,
    serverLoad: 0
  };
  
  startMonitoring() {
    // Update metrics every 30 seconds
    setInterval(() => this.updateMetrics(), 30000);
    
    // Alert on anomalies
    this.watchForAnomalies();
  }
  
  async updateMetrics() {
    this.metrics.signups = await getSignupCount();
    this.metrics.activeUsers = await getActiveUsers();
    this.metrics.contentGenerated = await getContentCount();
    this.metrics.errors = await getRecentErrors();
    this.metrics.revenue = await getRevenue();
    this.metrics.serverLoad = await getServerLoad();
    
    // Send to dashboard
    io.emit('metrics-update', this.metrics);
  }
  
  watchForAnomalies() {
    // Alert if error rate > 5%
    if (this.metrics.errors.length / this.metrics.activeUsers > 0.05) {
      this.sendAlert('High error rate detected!');
    }
    
    // Alert if server load > 80%
    if (this.metrics.serverLoad > 80) {
      this.sendAlert('High server load!');
    }
  }
}

✅ Final Verification Steps
After implementing all improvements:

Run Full Test Suite:

bashnpm run test:unit
npm run test:integration
npm run test:e2e
npm run lighthouse

Check Performance Metrics:


First Contentful Paint < 1.5s
Time to Interactive < 3.5s
Bundle size < 500KB gzipped
API response time < 200ms p50


Security Audit:

bashnpm audit
npm run security-check

User Testing Checklist:


 New user can complete onboarding in < 2 minutes
 Content generation works on first try
 Reddit posting succeeds
 Payment flow completes
 Mobile experience is smooth
 Error messages are helpful


Production Readiness:


 All environment variables documented
 Backup strategy implemented
 Monitoring dashboards configured
 Support system ready
 Terms of Service and Privacy Policy updated