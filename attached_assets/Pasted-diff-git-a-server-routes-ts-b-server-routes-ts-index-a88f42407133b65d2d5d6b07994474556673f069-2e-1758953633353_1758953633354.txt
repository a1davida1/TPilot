diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -11,204 +11,207 @@ import passport from 'passport';
 
 // Security and middleware
 import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
 import { AppError, CircuitBreaker } from "./lib/errors.js";
 import { authenticateToken } from "./middleware/auth.js";
 import { createSessionMiddleware } from "./bootstrap/session.js";
 
 // Route modules
 // import { authRoutes } from "./routes/auth.js"; // Removed - using server/auth.ts instead
 import { uploadRoutes, applyImageShieldProtection, protectionPresets } from "./routes/upload.js";
 import { mediaRoutes } from "./routes/media.js";
 import { analyticsRouter } from "./routes/analytics.js";
 import { referralRouter } from "./routes/referrals.js";
 import { registerExpenseRoutes } from "./expense-routes.js";
 import { adminCommunitiesRouter } from "./routes/admin-communities.js";
 import { createCancelSubscriptionHandler } from "./routes/subscription-management.js";
 
 // Core imports
 import { storage } from "./storage.js";
 import { setupAuth } from "./auth.js";
 import { setupAdminRoutes } from "./admin-routes.js";
 import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
 import { visitorAnalytics } from "./visitor-analytics.js";
 import { makePaxum, makeCoinbase, makeStripe } from "./payments/payment-providers.js";
 import { deriveStripeConfig } from "./payments/stripe-config.js";
-<<<<<<< ours
-
-export const csrfProtectedRoutes = [
-  '/api/auth/verify-email',
-  '/api/auth/change-password',
-  '/api/auth/forgot-password',
-  '/api/auth/reset-password',
-  '/api/upload/image',
-  '/api/generate-content',
-  '/api/reddit/connect',
-  '/api/reddit/submit',
-  '/api/admin/*', // All admin routes
-  '/api/billing/*', // All billing operations
-  '/api/auth/delete-account',
-  '/api/user/settings'
-];
-=======
 import { buildUploadUrl } from "./lib/uploads.js";
->>>>>>> theirs
+import { API_PREFIX, prefixApiPath } from "./lib/api-prefix.js";
+
+export function buildCsrfProtectedRoutes(apiPrefix: string = API_PREFIX): string[] {
+  return [
+    prefixApiPath('/auth/verify-email', apiPrefix),
+    prefixApiPath('/auth/change-password', apiPrefix),
+    prefixApiPath('/auth/forgot-password', apiPrefix),
+    prefixApiPath('/auth/reset-password', apiPrefix),
+    prefixApiPath('/upload/image', apiPrefix),
+    prefixApiPath('/generate-content', apiPrefix),
+    prefixApiPath('/reddit/connect', apiPrefix),
+    prefixApiPath('/reddit/submit', apiPrefix),
+    prefixApiPath('/admin/*', apiPrefix),
+    prefixApiPath('/billing/*', apiPrefix),
+    prefixApiPath('/auth/delete-account', apiPrefix),
+    prefixApiPath('/user/settings', apiPrefix),
+  ];
+}
+
+export const csrfProtectedRoutes = buildCsrfProtectedRoutes();
 // Analytics request type
 interface AnalyticsRequest extends express.Request {
   sessionID: string;
 }
 
 // Import users table for type inference
 import { users, type ContentGeneration } from "@shared/schema";
 
 // AuthUser interface for passport serialization
 interface AuthUser {
   id: number;
   username?: string;
   isAdmin?: boolean;
 }
 
 // Auth request interface that includes user
 type SessionUser = typeof users.$inferSelect & { subscriptionTier?: string | null };
 
 interface AuthenticatedRequest extends express.Request {
   user?: SessionUser;
 }
 
 // User tier type
 type UserTier = 'free' | 'starter' | 'pro' | 'premium';
 
 // Additional interfaces for type safety
 interface PhotoInstructionsData {
   cameraAngle?: string;
   mood?: string;
   technicalSettings?: string;
   lighting?: string | string[];
   angles?: string | string[];
   composition?: string | string[];
   styling?: string | string[];
   technical?: string | string[];
 }
 
 interface SessionWithReddit extends Session {
   redditOAuthState?: string;
 }
 
 // ==========================================
 // PRO RESOURCES ROUTES
 // ==========================================
 
-function registerProResourcesRoutes(app: Express) {
+function registerProResourcesRoutes(app: Express, apiPrefix: string = API_PREFIX) {
+  const route = (path: string) => prefixApiPath(path, apiPrefix);
   const resolveTier = (tierValue: string | null | undefined): UserTier | undefined => {
     if (tierValue === 'pro' || tierValue === 'premium' || tierValue === 'starter') {
       return tierValue;
     }
     if (tierValue === 'free') {
       return 'free';
     }
     return undefined;
   };
 
   // Helper to get user tier with storage fallback when session lacks tier information
   const getUserTier = async (user: SessionUser | undefined): Promise<UserTier> => {
     if (!user?.id) {
       return 'free';
     }
 
     if (user.subscriptionTier !== undefined && user.subscriptionTier !== null) {
       return resolveTier(user.subscriptionTier) ?? 'free';
     }
 
     const tierFromUser = resolveTier(user.tier);
     if (tierFromUser) {
       return tierFromUser;
     }
 
     try {
       const persistedUser = await storage.getUserById(user.id);
       if (persistedUser) {
         const persistedTier = resolveTier(
           (persistedUser as SessionUser).subscriptionTier ?? persistedUser.tier
         );
         if (persistedTier) {
           return persistedTier;
         }
       }
     } catch (storageError) {
       logger.warn('Failed to resolve user tier from storage', {
         userId: user.id,
         error: storageError instanceof Error ? storageError.message : String(storageError)
       });
     }
 
     return 'free';
   };
 
 
   // GET /api/pro-resources - List all perks for authenticated users
-  app.get('/api/pro-resources', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/pro-resources'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(403).json({
           perks: [],
           accessGranted: false,
           message: "Authentication required for pro resources"
         });
       }
 
       const userTier = await getUserTier(req.user);
 
       // Only pro/premium users get access
       if (userTier === 'free' || userTier === 'starter') {
         return res.status(403).json({
           perks: [],
           accessGranted: false,
           message: "Pro subscription required to access these resources"
         });
       }
 
       const availablePerks = userTier === 'premium'
         ? getAvailablePerks('pro')
         : getAvailablePerks(userTier);
 
       res.json({
         perks: availablePerks,
         accessGranted: true
       });
 
     } catch (error) {
       logger.error("Pro resources error:", error);
       res.status(500).json({
         perks: [],
         accessGranted: false,
         message: "Failed to load pro resources"
       });
     }
   });
 
   // GET /api/pro-resources/:id/signup-instructions - Get detailed signup instructions
-  app.get('/api/pro-resources/:id/signup-instructions', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/pro-resources/:id/signup-instructions'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const userTier = await getUserTier(req.user);
       if (userTier === 'free' || userTier === 'starter') {
         return res.status(403).json({ message: "Pro subscription required" });
       }
 
       const perkId = req.params.id;
       if (!perkId) {
         return res.status(400).json({ message: "Perk ID required" });
       }
 
       // Verify the perk exists and user has access
       const availablePerks = userTier === 'premium'
         ? getAvailablePerks('pro')
         : getAvailablePerks(userTier);
       const perk = availablePerks.find(p => p.id === perkId);
 
       if (!perk) {
         return res.status(404).json({ message: "Perk not found or not accessible" });
       }
 
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -500,51 +503,51 @@ const deriveSharePercentage = (perk: ProPerk): number => {
     const percentMatches = Array.from(perk.commissionRate.matchAll(/(\d+(?:\.\d+)?)\s*%/g));
     if (percentMatches.length === 0) {
       return 20;
     }
 
     const numericPercents = percentMatches
       .map(match => Number.parseFloat(match[1]))
       .filter((value): value is number => Number.isFinite(value));
 
     if (numericPercents.length === 0) {
       return 20;
     }
 
     const normalizedPercents = numericPercents.map(value => {
       const rounded = Math.round(value);
       if (Number.isNaN(rounded)) {
         return 20;
       }
       return Math.min(100, Math.max(1, rounded));
     });
 
     return Math.max(...normalizedPercents);
   };
 
 
-export async function registerRoutes(app: Express, apiPrefix: string = '/api', options?: RegisterRoutesOptions): Promise<Server> {
+export async function registerRoutes(app: Express, apiPrefix: string = API_PREFIX, options?: RegisterRoutesOptions): Promise<Server> {
   // ==========================================
   // VALIDATE ENVIRONMENT & APPLY SECURITY
   // ==========================================
 
   // Set trust proxy securely for rate limiters
   app.set('trust proxy', (ip: string) => {
     // Trust localhost and private network ranges
     return ['127.0.0.1', '::1'].includes(ip) || ip.startsWith('10.') || ip.startsWith('192.168.');
   });
 
   // Validate required environment variables first
   validateEnvironment();
 
   // Log IPs first so downstream middleware can use req.userIP
   app.use(ipLoggingMiddleware);
   app.use(securityMiddleware);
 
   const sessionConfigured = app.get('sessionConfigured') === true;
 
   if (!sessionConfigured) {
     logger.warn('Session middleware not configured before registerRoutes; applying default session middleware');
     app.use(createSessionMiddleware());
     app.set('sessionConfigured', true);
   }
 
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -582,106 +585,109 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
   app.use((err: unknown, req: express.Request, res: express.Response, next: express.NextFunction) => {
     if (err instanceof Error && (err as { code?: string }).code === 'EBADCSRFTOKEN') {
       logger.warn('CSRF token validation failed', {
         ip: req.ip,
         userAgent: req.get('User-Agent'),
         path: req.path,
         method: req.method,
         hasSession: !!req.session
       });
       return res.status(403).json({
         message: 'Invalid CSRF token',
         code: 'CSRF_TOKEN_INVALID'
       });
     }
     // If Sentry is configured, capture the error
     if (options?.sentry) {
       options.sentry.captureException(err);
     }
     next(err);
   });
 
   // Apply CSRF protection to sensitive routes
   // Note: JWT-based routes rely on token authentication instead of CSRF
 
   // Apply CSRF protection to sensitive routes
-  csrfProtectedRoutes.forEach(route => {
-    if (route.includes('*')) {
+  const csrfRoutes = buildCsrfProtectedRoutes(apiPrefix);
+  const route = (path: string) => prefixApiPath(path, apiPrefix);
+
+  csrfRoutes.forEach((protectedRoute) => {
+    if (protectedRoute.includes('*')) {
       // Handle wildcard routes
-      const baseRoute = route.replace('/*', '');
+      const baseRoute = protectedRoute.replace('/*', '');
       app.use(baseRoute, csrfProtection);
-      app.use(baseRoute + '/*', csrfProtection);
+      app.use(`${baseRoute}/*`, csrfProtection);
     } else {
-      app.use(route, csrfProtection);
+      app.use(protectedRoute, csrfProtection);
     }
   });
 
   // CSRF token endpoint
-  app.get('/api/csrf-token', csrfProtection, (req, res) => {
+  app.get(route('/csrf-token'), csrfProtection, (req, res) => {
     res.json({ csrfToken: req.csrfToken() });
   });
 
   // ==========================================
   // AUTHENTICATION SETUP
   // ==========================================
 
   // Setup authentication
-  setupAuth(app);
+  setupAuth(app, apiPrefix);
   setupAdminRoutes(app);
 
   // Configure social authentication
-  configureSocialAuth();
+  configureSocialAuth(apiPrefix);
 
   // ==========================================
   // ROUTE REGISTRATION
   // ==========================================
 
   // Authentication routes - handled by setupAuth() in server/auth.ts
-  // app.use('/api/auth', authRoutes); // Removed - duplicate auth system
+  // app.use(route('/auth'), authRoutes); // Removed - duplicate auth system
 
   // Upload routes
-  app.use('/api/upload', uploadRoutes);
+  app.use(route('/upload'), uploadRoutes);
 
   // Media routes
-  app.use('/api/media', mediaRoutes);
+  app.use(route('/media'), mediaRoutes);
 
   // Analytics routes
-  app.use('/api/analytics', analyticsRouter);
+  app.use(route('/analytics'), analyticsRouter);
 
   // Referral routes
-  app.use('/api/referral', referralRouter);
+  app.use(route('/referral'), referralRouter);
 
   // Admin communities routes are exposed under a dedicated admin namespace
-  app.use('/api/admin/communities', adminCommunitiesRouter);
+  app.use(route('/admin/communities'), adminCommunitiesRouter);
 
   // Social auth routes
-  app.get('/api/auth/google', socialAuthRoutes.googleAuth);
-  app.get('/api/auth/google/callback', socialAuthRoutes.googleCallback);
-  app.get('/api/auth/facebook', socialAuthRoutes.facebookAuth);
-  app.get('/api/auth/facebook/callback', socialAuthRoutes.facebookCallback);
-  app.get('/api/auth/reddit', socialAuthRoutes.redditAuth);
-  app.get('/api/auth/reddit/callback', socialAuthRoutes.redditCallback);
+  app.get(route('/auth/google'), socialAuthRoutes.googleAuth);
+  app.get(route('/auth/google/callback'), socialAuthRoutes.googleCallback);
+  app.get(route('/auth/facebook'), socialAuthRoutes.facebookAuth);
+  app.get(route('/auth/facebook/callback'), socialAuthRoutes.facebookCallback);
+  app.get(route('/auth/reddit'), socialAuthRoutes.redditAuth);
+  app.get(route('/auth/reddit/callback'), socialAuthRoutes.redditCallback);
 
   // Serve uploaded files securely
   const uploadsRoot = path.resolve(path.join(process.cwd(), 'uploads'));
 
   const streamUpload = async (
     req: AuthenticatedRequest,
     res: Response,
     next: NextFunction
   ) => {
     const requestedFile = (req.params as { file?: string }).file;
 
     if (!requestedFile) {
       res.status(404).json({ message: 'File not found' });
       return;
     }
 
     const absolutePath = path.resolve(uploadsRoot, requestedFile);
 
     if (!absolutePath.startsWith(uploadsRoot)) {
       res.status(400).json({ message: 'Invalid file path' });
       return;
     }
 
     try {
       await stat(absolutePath);
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -699,51 +705,51 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
     res.setHeader('Content-Type', mimeType);
 
     const stream = createReadStream(absolutePath);
 
     stream.on('error', (error: NodeJS.ErrnoException) => {
       if (error.code === 'ENOENT') {
         if (!res.headersSent) {
           res.status(404).json({ message: 'File not found' });
         }
         return;
       }
 
       next(error);
     });
 
     stream.pipe(res);
   };
 
   app.get('/uploads/:file(*)', authenticateToken, streamUpload);
 
   // ==========================================
   // STRIPE PAYMENT ENDPOINTS
   // ==========================================
 
   // Create subscription payment intent
-  app.post("/api/create-subscription", authenticateToken, async (req: AuthRequest, res) => {
+  app.post(route('/create-subscription'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!stripe) {
         return res.status(503).json({
           message: "Payment system is not configured. Please try again later."
         });
       }
 
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const { plan, amount } = req.body;
 
       // Validate plan and amount
       if (!plan || !amount) {
         return res.status(400).json({ message: "Plan and amount are required" });
       }
 
       if (plan !== 'pro' && plan !== 'pro_plus') {
         return res.status(400).json({ message: "Invalid plan selected" });
       }
 
       // Get or create Stripe customer
       const user = await storage.getUser(req.user.id);
       let customerId = user?.stripeCustomerId;
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -791,51 +797,51 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
           plan: plan
         }
       });
 
       const invoice = subscription.latest_invoice as Stripe.Invoice;
       const paymentIntent = (invoice as { payment_intent?: Stripe.PaymentIntent }).payment_intent as Stripe.PaymentIntent;
       const billingPeriodEnd = resolveBillingPeriodEnd(subscription);
 
       res.json({
         subscriptionId: subscription.id,
         clientSecret: paymentIntent.client_secret,
         currentPeriodEnd: billingPeriodEnd
       });
     } catch (error: unknown) {
       logger.error("Subscription creation error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({
         message: "Error creating subscription: " + (error instanceof Error ? (error as Error).message : 'Unknown error')
       });
     }
   });
 
   // Get subscription status
-  app.get("/api/subscription-status", authenticateToken, async (req: AuthRequest, res) => {
+  app.get(route('/subscription-status'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!stripe) {
         return res.json({ hasSubscription: false, plan: 'free' });
       }
 
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const user = await storage.getUser(req.user.id);
 
       if (!user?.stripeCustomerId) {
         return res.json({ hasSubscription: false, plan: 'free' });
       }
 
       // Get active subscriptions for this customer
       const subscriptions = await stripe.subscriptions.list({
         customer: user.stripeCustomerId,
         status: 'active',
         limit: 1
       });
 
       if (subscriptions.data.length > 0) {
         const subscription = subscriptions.data[0];
         if ('deleted' in subscription && subscription.deleted) {
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -848,109 +854,109 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
           hasSubscription: true,
           plan,
           subscriptionId: subscription.id,
           currentPeriodEnd
         });
       }
 
       return res.json({ hasSubscription: false, plan: 'free' });
     } catch (error) {
       logger.error("Subscription status error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to get subscription status" });
     }
   });
 
   const cancelSubscriptionHandler = createCancelSubscriptionHandler({
     stripe,
     storage,
     logger,
     sentry: options?.sentry ?? null,
   });
 
   // Cancel subscription
-  app.post("/api/cancel-subscription", authenticateToken, cancelSubscriptionHandler);
+  app.post(route('/cancel-subscription'), authenticateToken, cancelSubscriptionHandler);
 
   // ==========================================
   // CONTENT GENERATION ENDPOINTS
   // ==========================================
 
   const generateContentBreaker = new CircuitBreaker(generateContent);
   const unifiedBreaker = new CircuitBreaker(generateUnifiedAIContent);
 
   // Generate content with rate limiting
-  app.post("/api/generate-content", generationLimiter, authenticateToken, async (req: AuthRequest, res, next) => {
+  app.post(route('/generate-content'), generationLimiter, authenticateToken, async (req: AuthRequest, res, next) => {
     if (!req.user?.id) {
       return res.status(401).json({ message: "Authentication required" });
     }
     const { platform, style, theme, timing, allowsPromotion } = req.body;
     try {
       const result = await generateContentBreaker.call(
         platform || 'reddit',
         style || 'playful',
         theme || 'lingerie',
         timing,
         allowsPromotion
       );
       const normalizedPhotoInstructions = normalizePhotoInstructions(result.photoInstructions);
       const toNormalizedString = (value: string | string[] | undefined, fallback: string): string => {
         const normalized = normalizeInstructionValue(value);
         return normalized ?? fallback;
       };
 
       const normalizedInstructions = normalizePhotoInstructions(result.photoInstructions ?? {});
       const photoInstructions = {
         lighting: toNormalizedString(normalizedInstructions.lighting, 'Natural lighting'),
         cameraAngle: toNormalizedString(normalizedInstructions.cameraAngle, 'Eye level'),
         composition: toNormalizedString(normalizedInstructions.composition, 'Center composition'),
         styling: toNormalizedString(normalizedInstructions.styling, 'Casual styling'),
         mood: toNormalizedString(normalizedInstructions.mood, 'Confident and natural'),
         technicalSettings: toNormalizedString(normalizedInstructions.technicalSettings, 'Auto settings')
       };
       await storage.createContentGeneration({
         userId: req.user.id,
         titles: result.titles || [],
         content: result.content || '',
         photoInstructions,
         platform: platform || "reddit",
         style: style || 'playful',
         theme: theme || 'lingerie',
         createdAt: new Date()
       });
       res.json(result);
     } catch (error: unknown) {
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
     }
   });
 
   // Unified AI generation endpoint - handles both text and image workflows
-  app.post('/api/generate-unified', generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res, next) => {
+  app.post(route('/generate-unified'), generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res, next) => {
     try {
       interface GenerationRequestBody {
         mode: string;
         prompt: string;
         platform?: string;
         style?: string;
         theme?: string;
         includePromotion?: boolean;
         customInstructions?: string;
       }
       const body = req.body as Partial<GenerationRequestBody>;
       if (!body.mode || !body.prompt) {
         return res.status(400).json({ error: 'mode and prompt are required' });
       }
       const {
         mode,
         prompt,
         platform,
         style,
         theme,
         includePromotion,
         customInstructions
       } = body;
 
       if (req.user?.id) {
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -997,61 +1003,61 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
       if (req.user?.id) {
         await storage.createContentGeneration({
           userId: req.user.id,
           platform: platform || 'reddit',
           style: style || 'playful',
           theme: theme || 'general',
           titles: result.titles,
           content: result.content,
           photoInstructions: result.photoInstructions,
           prompt: prompt || customInstructions,
           allowsPromotion: Boolean(includePromotion)
         });
       }
 
       res.json({ ...result });
     } catch (error: unknown) {
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
     }
   });
 
   // Get user stats
   // Debug endpoint for Reddit OAuth troubleshooting (temporary)
-  app.get('/api/debug/session', (req: express.Request, res) => {
+  app.get(route('/debug/session'), (req: express.Request, res) => {
     res.json({
       sessionId: req.sessionID,
       hasSession: !!req.session,
       redditState: req.session?.redditOAuthState,
       redditConnected: req.session?.redditConnected,
       cookies: req.headers.cookie ? 'present' : 'missing'
     });
   });
 
-  app.get("/api/user-stats", authenticateToken, async (req: AuthRequest, res) => {
+  app.get(route('/user-stats'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const generations = await storage.getGenerationsByUserId(req.user.id);
       const today = new Date();
       const todayGenerations = generations.filter((g: ContentGeneration) =>
         g.createdAt && new Date(g.createdAt).toDateString() === today.toDateString()
       );
 
       const stats = {
         total: generations.length,
         today: todayGenerations.length,
         thisWeek: generations.filter((g: ContentGeneration) => g.createdAt &&
           new Date(g.createdAt) > new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000)
         ).length,
         thisMonth: generations.filter((g: ContentGeneration) => g.createdAt &&
           new Date(g.createdAt).getMonth() === today.getMonth() &&
           new Date(g.createdAt).getFullYear() === today.getFullYear()
         ).length,
         dailyStreak: 0 // Would need more complex logic to calculate
       };
       const user = await storage.getUser(req.user.id);
       const userTier = user?.tier || 'free';
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1069,303 +1075,303 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
       const userStats = {
         postsCreated: stats.total,
         totalViews: 0, // Real views not tracked yet - show 0
         engagementRate: '0.0', // Real engagement not tracked yet - show 0
         streak: stats.dailyStreak || 0,
         thisWeek: stats.thisWeek,
         thisMonth: stats.thisMonth,
         dailyGenerations: {
           used: stats.today,
           limit: dailyLimit,
           remaining: dailyLimit === -1 ? -1 : Math.max(0, dailyLimit - stats.today)
         }
       };
 
       res.json(userStats);
     } catch (error) {
       logger.error("User stats error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to get user stats" });
     }
   });
 
   // Get content generation history
-  app.get("/api/content-generation-history", authenticateToken, async (req: AuthRequest, res) => {
+  app.get(route('/content-generation-history'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const limit = parseInt(req.query.limit as string) || 20;
       const history = await storage.getGenerationsByUserId(req.user.id);
 
       // Limit results and format for frontend
       const formattedHistory = history.slice(0, limit).map(gen => ({
         ...gen,
         titles: Array.isArray(gen.titles) ? gen.titles :
                 typeof gen.titles === 'string' ? JSON.parse(gen.titles || '[]') : []
       }));
 
       res.json(formattedHistory);
     } catch (error) {
       logger.error("Generation history error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to get generation history" });
     }
   });
 
   // ==========================================
   // REGISTER EXISTING ROUTE MODULES
   // ==========================================
 
   // Register new enterprise API routes
   registerApiRoutes(app);
 
   // Register Policy Routes
   registerPolicyRoutes(app);
 
   // Register Reddit Routes
   registerRedditRoutes(app);
 
   // Register Analytics Routes
   registerAnalyticsRoutes(app);
 
   // Register Social Media Routes
   registerSocialMediaRoutes(app);
 
   // Register Expense Routes (Tax Tracker API)
   registerExpenseRoutes(app);
 
   // Register Pro Resources Routes
-  registerProResourcesRoutes(app);
+  registerProResourcesRoutes(app, apiPrefix);
 
   // Register Caption Routes (2-pass Gemini pipeline) - MOVED UP to get routing priority
-  app.use('/api/caption', captionRouter);
+  app.use(route('/caption'), captionRouter);
 
   // Register Dashboard Routes
   import('./routes/dashboard.js').then(({ dashboardRouter }) => {
-    app.use('/api/dashboard', dashboardRouter);
+    app.use(route('/dashboard'), dashboardRouter);
   }).catch(err => {
     logger.error('Failed to load dashboard routes:', err);
     if (options?.sentry) {
       options.sentry.captureException(err);
     }
   });
 
   // ==========================================
   // CONTENT GENERATIONS HISTORY API
   // ==========================================
 
   // Get user's content generation history
-  app.get('/api/content-generations', authenticateToken, async (req: AuthRequest, res) => {
+  app.get(route('/content-generations'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const generations = await storage.getGenerationsByUserId(req.user.id);
       res.json(generations);
     } catch (error: unknown) {
       logger.error("Failed to get content generations:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to retrieve content history" });
     }
   });
 
   // Delete a content generation
-  app.delete('/api/content-generations/:id', authenticateToken, async (req: AuthRequest, res) => {
+  app.delete(route('/content-generations/:id'), authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const generationId = parseInt(req.params.id);
       if (isNaN(generationId)) {
         return res.status(400).json({ message: "Invalid generation ID" });
       }
 
       // Here you would typically verify the generation belongs to the user
       // and then delete it from the database
       // For now, just return success as the storage interface doesn't have delete method
       res.json({ success: true });
     } catch (error: unknown) {
       logger.error("Failed to delete content generation:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to delete content generation" });
     }
   });
 
   // Lead API routes (waitlist functionality)
-  app.post("/api/leads", createLead);
-  app.get("/api/leads/confirm", confirmLead);
-  app.get('/api/admin/leads', getLeads);
+  app.post(route('/leads'), createLead);
+  app.get(route('/leads/confirm'), confirmLead);
+  app.get(route('/admin/leads'), getLeads);
 
   // Compliance dashboard endpoint
-  app.get('/api/admin/compliance', getComplianceStatus);
+  app.get(route('/admin/compliance'), getComplianceStatus);
 
   // Reddit Communities Admin Routes (temporarily disabled for compilation)
   // TODO: Implement storage methods and re-enable routes
 
   // Debug endpoint for Reddit OAuth session
-  app.get('/api/debug/reddit-session', (req, res) => {
+  app.get(route('/debug/reddit-session'), (req, res) => {
     res.json({
       sessionID: req.sessionID,
       redditState: (req.session as SessionWithReddit).redditOAuthState,
       hasSession: !!req.session,
       cookies: req.headers.cookie,
       sessionData: req.session
     });
   });
 
   // ==========================================
   // PRODUCTION API ENDPOINTS - REAL IMPLEMENTATIONS
   // ==========================================
 
   // DISABLED - Using MediaManager endpoint from api-routes.ts instead
   // This endpoint was conflicting with the proper implementation that uses MediaManager
   /*
-  app.get('/api/media', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/media'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const userId = req.user?.id;
       if (!userId) {
         return res.status(401).json({ message: 'Authentication required' });
       }
 
       const images = await storage.getUserImages(userId);
       res.json(images);
     } catch (error) {
       logger.error('Failed to fetch media:', error);
       res.status(500).json({ message: 'Failed to fetch media' });
     }
   });
   */
 
   // DISABLED - Using MediaManager endpoint from api-routes.ts instead
   // This endpoint was conflicting with the proper implementation that uses S3/database storage
   /*
-  app.post('/api/media/upload', authenticateToken, upload.single('file'), async (req: AuthenticatedRequest, res) => {
+  app.post(route('/media/upload'), authenticateToken, upload.single('file'), async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.file) {
         return res.status(400).json({ message: 'No file uploaded' });
       }
 
       const imageData = await storage.createUserImage({
         userId: req.user.id,
         filename: req.file.filename,
         originalName: req.file.originalname,
         url: buildUploadUrl(req.file.filename),
         size: req.file.size,
         mimeType: req.file.mimetype,
         isProtected: false,
         metadata: {
           uploadedAt: new Date().toISOString()
         }
       });
 
       res.json(imageData);
     } catch (error) {
       logger.error('Upload failed:', error);
       res.status(500).json({ message: 'Upload failed' });
     }
   });
   */
 
   // DISABLED - Using MediaManager endpoint from api-routes.ts instead
   /*
-  app.delete('/api/media/:id', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.delete(route('/media/:id'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const imageId = parseInt(req.params.id);
       const userId = req.user.id;
 
       const image = await storage.getUserImage(imageId, userId);
       if (!image) {
         return res.status(404).json({ message: 'Image not found' });
       }
 
       const filePath = path.join(process.cwd(), 'uploads', image.filename);
       await fs.unlink(filePath).catch(() => {});
 
       await storage.deleteUserImage(imageId, userId);
 
       res.json({ success: true, message: 'Media deleted' });
     } catch (error) {
       logger.error('Failed to delete media:', error);
       res.status(500).json({ message: 'Failed to delete media' });
     }
   });
   */
 
   // Storage usage endpoint - REAL
-  app.get('/api/storage/usage', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/storage/usage'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const userId = req.user.id;
       const images = await storage.getUserImages(userId);
 
       let totalBytes = 0;
       for (const image of images) {
         totalBytes += image.size || 0;
       }
 
       const userTier = req.user.tier || 'free';
       const quotaBytes = {
         free: 100 * 1024 * 1024,
         starter: 500 * 1024 * 1024,
         pro: 5 * 1024 * 1024 * 1024
       }[userTier] || 100 * 1024 * 1024;
 
       res.json({
         usedBytes: totalBytes,
         quotaBytes: quotaBytes,
         usedPercentage: Math.round((totalBytes / quotaBytes) * 100),
         assetsCount: images.length,
         proUpgrade: {
           quotaBytes: 5 * 1024 * 1024 * 1024,
           features: ['5GB storage', 'Unlimited uploads', 'Advanced protection']
         }
       });
     } catch (error) {
       logger.error('Failed to fetch storage usage:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to fetch storage usage' });
     }
   });
 
   // AI generation endpoint - REAL
-  app.post('/api/ai/generate', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.post(route('/ai/generate'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const { prompt, platforms, styleHints, variants } = req.body;
 
       const results = await Promise.all(
         platforms.map(async (platform: string) => {
           const generated = await generateUnifiedAIContent({
             mode: 'text',
             prompt: prompt,
             platform: platform,
             style: styleHints?.[0] || 'authentic',
             theme: 'general',
             includePromotion: false,
             customInstructions: prompt
           });
 
           return {
             platform,
             titles: generated.titles,
             body: generated.content,
             photoInstructions: generated.photoInstructions,
             hashtags: generated.hashtags || [],
             style: styleHints?.[0] || 'authentic',
             confidence: 0.95
           };
         })
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1380,125 +1386,125 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
             theme: 'general',
             titles: result.titles,
             content: result.body,
             photoInstructions: result.photoInstructions,
             prompt: prompt
           });
         }
       }
 
       res.json({
         content: results,
         tokensUsed: results.length * 250,
         model: 'multi-provider',
         cached: false
       });
     } catch (error) {
       logger.error('AI generation failed:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Generation failed' });
     }
   });
 
   // Billing payment link endpoint - REAL
-  app.post('/api/billing/payment-link', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.post(route('/billing/payment-link'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const { plan, provider = 'stripe' } = req.body;
       const engines = {
         stripe: makeStripe(),
         paxum: makePaxum(),
         coinbase: makeCoinbase(),
       } as const;
       const engine = engines[provider as keyof typeof engines];
       if (!engine || !engine.enabled) {
         return res.status(503).json({ message: 'Payment system not configured' });
       }
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const { url } = await engine.createCheckout({
         userId: req.user.id.toString(),
         planId: plan,
         amountCents: 0,
         returnUrl: `${process.env.APP_BASE_URL}/dashboard`,
       });
       res.json({ paymentUrl: url });
     } catch (error) {
       logger.error('Failed to generate payment link:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to generate payment link' });
     }
   });
 
   // User settings endpoints - REAL
-  app.get('/api/user/settings', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/user/settings'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const preferences = await storage.getUserPreferences(req.user.id);
 
       res.json(preferences || {
         theme: 'light',
         notifications: true,
         emailUpdates: true,
         autoSave: true,
         defaultPlatform: 'reddit',
         defaultStyle: 'playful',
         watermarkPosition: 'bottom-right'
       });
     } catch (error) {
       logger.error('Failed to fetch settings:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to fetch settings' });
     }
   });
 
-  app.patch('/api/user/settings', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.patch(route('/user/settings'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const updated = await storage.updateUserPreferences(req.user.id, req.body);
       res.json({ success: true, settings: updated });
   } catch (error) {
       logger.error('Failed to update settings:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to update settings' });
     }
   });
 
   // Subscription status endpoint - REAL
-  app.get('/api/subscription', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/subscription'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const user = await storage.getUser(req.user.id);
 
       if (!user?.stripeCustomerId || !stripe) {
         return res.json({
           subscription: null,
           isPro: false,
           tier: user?.tier || 'free'
         });
       }
 
       const subscriptions = await stripe.subscriptions.list({
         customer: user.stripeCustomerId,
         status: 'active',
         limit: 1
       });
 
       if (subscriptions.data.length > 0) {
         const sub = subscriptions.data[0];
         if ('deleted' in sub && sub.deleted) {
           return res.json({
             subscription: null,
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1519,51 +1525,51 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
             plan: sub.metadata?.plan || user.tier,
             amount: sub.items.data[0].price.unit_amount,
             nextBillDate,
             createdAt: new Date(sub.created * 1000).toISOString()
           },
           isPro: ['pro', 'starter'].includes(user.tier || ''),
           tier: user.tier || 'free'
         });
       }
 
       res.json({
         subscription: null,
         isPro: false,
         tier: user.tier || 'free'
       });
     } catch (error) {
       logger.error('Failed to fetch subscription:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to fetch subscription' });
     }
   });
 
   // Social media quick post endpoint - REAL
-  app.post('/api/social-media/quick-post', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.post(route('/social-media/quick-post'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const { platform, content, accountId } = req.body as {
         platform?: string;
         content?: string;
         accountId?: number | string;
       };
 
       if (typeof content !== 'string' || content.trim().length === 0) {
         return res.status(400).json({ message: 'Content is required to create a social media post.' });
       }
 
       const normalizedContent = content.trim();
 
       const userAccounts = await storage.getUserSocialMediaAccounts(req.user.id);
       const activeAccounts = userAccounts.filter(account => account.isActive);
 
       if (activeAccounts.length === 0) {
         return res.status(400).json({
           message: 'No connected social media accounts found. Please connect an account to continue.'
         });
       }
 
diff --git a/server/routes.ts b/server/routes.ts
index a88f42407133b65d2d5d6b07994474556673f069..2e7974f696ed4c2f3ada0440775ed60261d484d1 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1593,127 +1599,127 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api', o
       const resolvedPlatform = selectedAccount.platform;
 
       const post = await storage.createSocialMediaPost({
         userId: req.user.id,
         platform: resolvedPlatform,
         content: normalizedContent,
         accountId: selectedAccount.id,
         status: 'draft'
       });
 
       res.json({
         success: true,
         postId: post.id,
         message: 'Content saved successfully'
       });
     } catch (error) {
       logger.error('Failed to post content:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to post content' });
     }
   });
 
   // Social media posts history - REAL
-  app.get('/api/social-media/posts', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.get(route('/social-media/posts'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
       const posts = await storage.getUserSocialMediaPosts(req.user.id, {
         limit: parseInt(req.query.limit as string) || 50,
         offset: parseInt(req.query.offset as string) || 0,
         platform: req.query.platform as string,
         status: req.query.status as string
       });
 
       res.json(posts);
     } catch (error) {
       logger.error('Failed to fetch posts:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to fetch posts' });
     }
   });
 
   // Image protection endpoint
-  app.post('/api/protect-image/:imageId', authenticateToken, async (req: AuthenticatedRequest, res) => {
+  app.post(route('/protect-image/:imageId'), authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const imageId = Number.parseInt(req.params.imageId, 10);
       if (Number.isNaN(imageId)) return res.status(400).json({ message: 'Invalid image id' });
       const userId = req.user?.id;
       if (!userId) return res.status(401).json({ message: 'Authentication required' });
       const { protectionLevel } = req.body as { protectionLevel?: keyof typeof protectionPresets };
       const image = await storage.getUserImage(imageId, userId);
       if (!image) return res.status(404).json({ message: 'Image not found' });
 
       const level = protectionLevel && protectionPresets[protectionLevel] ? protectionLevel : 'standard';
       const inputPath = path.join(process.cwd(), image.url.startsWith('/') ? image.url.slice(1) : image.url);
       const protectedName = `protected_${Date.now()}_${image.filename}`;
       const outputPath = path.join(process.cwd(), 'uploads', protectedName);
       await applyImageShieldProtection(inputPath, outputPath, level as 'light' | 'standard' | 'heavy', false);
       const protectedUrl = buildUploadUrl(protectedName);
       await storage.updateUserImage(imageId, userId, { url: protectedUrl, isProtected: true, protectionLevel: level });
 
       res.json({ success: true, protectedUrl, message: 'Image protected successfully' });
     } catch (error: unknown) {
       logger.error('Failed to protect image:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to protect image' });
     }
   });
 
   // Debug endpoint for environment variables
-  app.get('/api/debug/env', (req, res) => {
+  app.get(route('/debug/env'), (req, res) => {
     res.json({
       hasAdminEmail: !!process.env.ADMIN_EMAIL,
       hasAdminPassword: !!process.env.ADMIN_PASSWORD,
       hasAdminPasswordHash: !!process.env.ADMIN_PASSWORD_HASH,
       adminEmailLength: process.env.ADMIN_EMAIL?.length || 0,
       nodeEnv: process.env.NODE_ENV,
       // Don't send actual values for security!
     });
   });
 
   // ==========================================
   // ERROR HANDLER (MUST BE LAST)
   // ==========================================
 
   // Handle 404s for API routes specifically
-  app.use('/api/*', (req, res) => {
+  app.use(route('/*'), (req, res) => {
     res.status(404).json({ message: `API endpoint not found: ${req.path}` });
   });
 
   // Apply error handling middleware last
   app.use(errorHandler);
 
   // Final catch-all for any remaining requests (ensures SPA routing works)
   app.get('*', (req, res, next) => {
     // Skip if it's an API, auth, webhook, or assets route
-    if (req.path.startsWith('/api/') || req.path.startsWith('/auth/') || req.path.startsWith('/webhook/') || req.path.startsWith('/assets/')) {
+    if (req.path.startsWith(route('/')) || req.path.startsWith('/auth/') || req.path.startsWith('/webhook/') || req.path.startsWith('/assets/')) {
       return next();
     }
 
     // For SPA, always serve index.html for non-asset requests
     import('url').then(({ fileURLToPath }) => {
       import('path').then((path) => {
         import('fs').then((fs) => {
           const __dirname = path.dirname(fileURLToPath(import.meta.url));
           const clientPath = path.join(__dirname, '..', 'client');
 
           if (fs.existsSync(path.join(clientPath, 'index.html'))) {
             res.sendFile(path.join(clientPath, 'index.html'));
           } else {
             res.status(404).send('Client build not found');
           }
         }).catch(next);
       }).catch(next);
     }).catch(next);
   });
 
   const httpServer = createServer(app);
   return httpServer;
 }
