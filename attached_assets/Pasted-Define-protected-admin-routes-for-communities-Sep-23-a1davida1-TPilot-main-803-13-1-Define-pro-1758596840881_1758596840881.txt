Define protected admin routes for communities
Sep 23 · a1davida1/TPilot · main
+803-13
1. Define protected Express handlers (GET/POST/PUT/DELETE) for `/api/admin/communities` within `server/routes.ts` or a dedicated admin router, invoking `listCommunities`, `createCommunity`, `updateCommunity`, and `deleteCommunity` from `server/reddit-communities.ts`.
2. Gate the routes with `authenticateToken` plus an admin-role check so only authorized operators can mutate the directory.
3. Shape responses to match the `AdminCommunity` contract expected by `client/src/hooks/use-admin-communities.ts`, including normalized rule structures.
4. Add integration or route-level Vitest coverage that exercises list, create, update, and delete flows using supertest to prevent regressions.

Summary

    Added a dedicated adminCommunitiesRouter with token and admin gating plus CRUD handlers that normalize payloads and error responses, and mounted it under /api/admin/communities.

Extended the shared rule schema with linkRestrictions defaults and updated Reddit community helpers so list/create/update return normalized rule structures through the new NormalizedRedditCommunity helper.

Configured Vitest to prefer TypeScript sources and added supertest-based coverage for admin list/create/update/delete flows.

Testing

    ✅ npx vitest run tests/routes/admin-communities.test.ts

✅ npm run lint (warnings only; no lint errors)

❌ npm test (fails due to numerous pre-existing suite issues; command aborted after reporting unrelated failures)


server/lib/policy-linter.ts
+1-1
@@ -80,51 +80,51 @@ const DEFAULT_RULES: RuleSpec = {
  flairRequired: false, // Varies by subreddit
  manualFlags: {} // Only warn when communities explicitly specify requirements
};

/**
 * Coerce stored rule spec to ensure it has proper structure
 */
function coerceRuleSpec(rawRules: any): RuleSpec {
  // Handle legacy test format
  if ('titleRegex' in rawRules || 'prohibitedLinks' in rawRules || 'maxLength' in rawRules || 'minLength' in rawRules) {
    const testRules = rawRules as TestRuleSpec;
    return {
      bannedWords: testRules.bannedWords || [],
      titleRegexes: testRules.titleRegex || [],
      bodyRegexes: testRules.prohibitedLinks || [],
      maxTitleLength: testRules.maxLength,
      maxBodyLength: testRules.maxLength,
      requiredTags: [], // Remove context-dependent logic - will be handled in linter
      linkPolicy: 'one-link',
      flairRequired: false,
    };
  }

  // Handle new RuleSpec format or ensure it has proper structure
  const spec = rawRules as RuleSpec;
  let result: RuleSpec = {
  const result: RuleSpec = {
    bannedWords: spec.bannedWords || [],
    titleRegexes: spec.titleRegexes || [],
    bodyRegexes: spec.bodyRegexes || [],
    flairRequired: spec.flairRequired || false,
    linkPolicy: spec.linkPolicy || 'one-link',
    requiredTags: spec.requiredTags || [],
    maxTitleLength: spec.maxTitleLength,
    maxBodyLength: spec.maxBodyLength,
    manualFlags: spec.manualFlags || {},
    wikiNotes: spec.wikiNotes || [],
    source: spec.source,
    overrides: spec.overrides,
  };

  // Apply overrides if present (merge overrides onto base spec)
  if (spec.overrides) {
    Object.keys(spec.overrides).forEach(key => {
      const overrideValue = (spec.overrides as any)?.[key];
      if (overrideValue !== undefined && overrideValue !== null) {
        (result as any)[key] = overrideValue;
      }
    });
  }

  return result;
server/reddit-communities.ts
+22-10
@@ -6,50 +6,54 @@ import {
  insertRedditCommunitySchema,
  type InsertRedditCommunity,
  type RedditCommunityRuleSet,
  redditCommunityRuleSetSchema,
  createDefaultRules
} from '@shared/schema';
import { eq, ilike, desc, or } from 'drizzle-orm';
import { lintCaption } from './lib/policy-linter.js';

// ==========================================
// ELIGIBILITY TYPES AND INTERFACES
// ==========================================

export interface CommunityEligibilityCriteria {
  karma?: number;
  accountAgeDays?: number;
  verified: boolean;
}

export interface CommunityRules {
  minKarma?: number | null;
  minAccountAge?: number | null;
  verificationRequired?: boolean;
}

export type NormalizedRedditCommunity = Omit<RedditCommunity, 'rules'> & {
  rules: RedditCommunityRuleSet;
};

/**
 * Parse community rules from the database response
 * Handles both legacy column-level rules and new structured rules
 */
export function parseCommunityRules(community: RedditCommunity): CommunityRules {
  const columnLevelVerification = community.verificationRequired;
  const structuredRules = normalizeRules(community.rules, community.promotionAllowed, community.category);
  
  return {
    minKarma: structuredRules.minKarma,
    minAccountAge: structuredRules.minAccountAge,
    verificationRequired: columnLevelVerification || structuredRules.verificationRequired
  };
}

/**
 * Filter communities based on user eligibility criteria
 */
export async function getEligibleCommunitiesForUser(criteria: CommunityEligibilityCriteria): Promise<RedditCommunity[]> {
  // Get all communities
  const allCommunities = await listCommunities();
  
  // Filter based on eligibility criteria
  return allCommunities.filter(community => {
    const rules = parseCommunityRules(community);
@@ -72,136 +76,144 @@ export async function getEligibleCommunitiesForUser(criteria: CommunityEligibili
    if (rules.verificationRequired && !criteria.verified) {
      return false;
    }
    
    return true;
  });
}

/**
 * Normalize and hydrate community rules from database response
 * Handles backward compatibility with legacy array-based rules
 */
function normalizeRules(rawRules: unknown, promotionAllowed?: string, category?: string): RedditCommunityRuleSet {
  try {
    // Handle null or undefined
    if (!rawRules) {
      return createDefaultRules();
    }
    
    // Handle legacy array-based rules (backward compatibility)
    if (Array.isArray(rawRules)) {
      const defaults = createDefaultRules();
      return {
        ...defaults,
        contentRules: rawRules.filter(rule => typeof rule === 'string'),
        linkRestrictions: [],
        sellingAllowed: inferSellingPolicy(promotionAllowed || 'unknown', category || 'general')
      };
    }
    
    // Handle object-based rules
    if (typeof rawRules === 'object') {
      // Try to parse as structured rules
      const parsed = redditCommunityRuleSetSchema.parse(rawRules);
      
      // If sellingAllowed is unknown, try to infer from promotion flags
      if (parsed.sellingAllowed === 'unknown' && (promotionAllowed || category)) {
        parsed.sellingAllowed = inferSellingPolicy(promotionAllowed || 'unknown', category || 'general', parsed);
      }
      
      return parsed;
    }
    
    return createDefaultRules();
  } catch (error) {
    console.warn('Failed to parse community rules, using defaults:', error);
    return createDefaultRules();
  }
}

export function normalizeCommunityRecord(community: RedditCommunity): NormalizedRedditCommunity {
  return {
    ...community,
    rules: normalizeRules(community.rules, community.promotionAllowed, community.category)
  };
}

/**
 * Infer selling policy from promotion flags and category
 */
function inferSellingPolicy(promotionAllowed: string, category: string, rules?: RedditCommunityRuleSet): RedditCommunityRuleSet['sellingAllowed'] {
  // If rules already specify selling policy, use it
  if (rules?.sellingAllowed && rules.sellingAllowed !== 'unknown') {
    return rules.sellingAllowed;
  }
  
  // Infer from promotion flags and category
  if (promotionAllowed === 'yes' || category === 'selling') {
    return 'allowed';
  } else if (promotionAllowed === 'limited' || promotionAllowed === 'subtle') {
    return 'limited';
  } else if (promotionAllowed === 'no' || promotionAllowed === 'strict') {
    return 'not_allowed';
  }
  
  return 'unknown';
}

export async function listCommunities() {
export async function listCommunities(): Promise<NormalizedRedditCommunity[]> {
  const communities = await db.select().from(redditCommunities).orderBy(desc(redditCommunities.members));
  

  // Normalize rules for each community
  return communities.map(community => ({
    ...community,
    rules: normalizeRules(community.rules, community.promotionAllowed, community.category)
  }));
  return communities.map(normalizeCommunityRecord);
}

export async function searchCommunities(query: string) {
  const like = `%${query}%`;
  const communities = await db.select()
    .from(redditCommunities)
    .where(
      or(
        ilike(redditCommunities.name, like),
        ilike(redditCommunities.displayName, like),
        ilike(redditCommunities.description, like)
      )
    );
  
  // Normalize rules for each community
  return communities.map(community => ({
    ...community,
    rules: normalizeRules(community.rules, community.promotionAllowed, community.category)
  }));
}

export async function createCommunity(data: unknown) {
export async function createCommunity(data: unknown): Promise<NormalizedRedditCommunity> {
  const value: InsertRedditCommunity = insertRedditCommunitySchema.parse(data) as InsertRedditCommunity;
  const [row] = await db.insert(redditCommunities).values(value).returning();
  return row;
  if (!row) {
    throw new Error('Failed to insert community');
  }
  return normalizeCommunityRecord(row);
}

export async function updateCommunity(id: string, data: unknown) {
export async function updateCommunity(id: string, data: unknown): Promise<NormalizedRedditCommunity | undefined> {
  const value: Partial<InsertRedditCommunity> = insertRedditCommunitySchema
    .partial()
    .parse(data) as Partial<InsertRedditCommunity>;
  const [row] = await db.update(redditCommunities).set(value).where(eq(redditCommunities.id, id)).returning();
  return row;
  return row ? normalizeCommunityRecord(row) : undefined;
}

export async function deleteCommunity(id: string) {
  await db.delete(redditCommunities).where(eq(redditCommunities.id, id));
}

export async function getCommunityInsights(communityId: string): Promise<{
  bestTimes: string[];
  successTips: string[];
  warnings: string[];
}> {
  const [community] = await db
    .select()
    .from(redditCommunities)
    .where(eq(redditCommunities.id, communityId))
    .limit(1);
  if (!community) return { bestTimes: [], successTips: [], warnings: [] };

  // Normalize rules
  const rules = normalizeRules(community.rules, community.promotionAllowed, community.category);
  const successTips: string[] = [];
  const warnings: string[] = [];

  // Basic success indicators
  if ((community.successProbability ?? 0) > 85) successTips.push('High success rate - great choice');
server/routes.ts
+3-2
import type { Express, Response, NextFunction } from "express";
import express from "express";
import { createServer, type Server } from "http";
import session from 'express-session';
import path from 'path';
import connectPgSimple from 'connect-pg-simple';
import * as connectRedis from 'connect-redis';
import { Pool } from 'pg';
import Redis from 'ioredis';
import Stripe from 'stripe';
import passport from 'passport';

// Security and middleware
import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
import { AppError, CircuitBreaker } from "./lib/errors.js";
import { authenticateToken } from "./middleware/auth.js";

// Route modules
// import { authRoutes } from "./routes/auth.js"; // Removed - using server/auth.ts instead
import { uploadRoutes, applyImageShieldProtection, protectionPresets } from "./routes/upload.js";
import { mediaRoutes } from "./routes/media.js";
import { analyticsRouter } from "./routes/analytics.js";
import { registerExpenseRoutes } from "./expense-routes.js";
import { adminCommunitiesRouter } from "./routes/admin-communities.js";

// Core imports
import { storage } from "./storage.js";
import { setupAuth } from "./auth.js";
import { setupAdminRoutes } from "./admin-routes.js";
import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
import { visitorAnalytics } from "./visitor-analytics.js";
import { makePaxum, makeCoinbase, makeStripe } from "./payments/payment-providers.js";
import { deriveStripeConfig } from "./payments/stripe-config.js";
// Analytics request type
interface AnalyticsRequest extends express.Request {
  sessionID: string;
}

// Import users table for type inference
import { users, type ContentGeneration } from "@shared/schema";

// AuthUser interface for passport serialization
interface AuthUser {
  id: number;
  username?: string;
  isAdmin?: boolean;
}

// Auth request interface that includes user  
@@ -960,52 +961,52 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api'):
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const generationId = parseInt(req.params.id);
      if (isNaN(generationId)) {
        return res.status(400).json({ message: "Invalid generation ID" });
      }

      // Here you would typically verify the generation belongs to the user
      // and then delete it from the database
      // For now, just return success as the storage interface doesn't have delete method
      res.json({ success: true });
    } catch (error: unknown) {
      logger.error("Failed to delete content generation:", error);
      res.status(500).json({ message: "Failed to delete content generation" });
    }
  });

  // Lead API routes (waitlist functionality)
  app.post("/api/leads", createLead);
  app.get("/api/leads/confirm", confirmLead);
  app.get("/api/admin/leads", getLeads);

  // Reddit Communities Admin Routes (temporarily disabled for compilation)
  // TODO: Implement storage methods and re-enable routes
  // Reddit Communities Admin Routes
  app.use('/api/admin/communities', adminCommunitiesRouter);

  // Debug endpoint for Reddit OAuth session
  app.get('/api/debug/reddit-session', (req, res) => {
    res.json({
      sessionID: req.sessionID,
      redditState: (req.session as any).redditOAuthState,
      hasSession: !!req.session,
      cookies: req.headers.cookie,
      sessionData: req.session
    });
  });

  // ==========================================
  // PRODUCTION API ENDPOINTS - REAL IMPLEMENTATIONS
  // ==========================================
  
  // DISABLED - Using MediaManager endpoint from api-routes.ts instead
  // This endpoint was conflicting with the proper implementation that uses MediaManager
  /*
  app.get('/api/media', authenticateToken, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: 'Authentication required' });
      }
server/routes/admin-communities.ts
New
+463-0
import express from 'express';
import { z } from 'zod';

import { authenticateToken, type AuthRequest } from '../middleware/auth.js';
import { logger } from '../middleware/security.js';
import {
  listCommunities,
  createCommunity,
  updateCommunity,
  deleteCommunity,
  type NormalizedRedditCommunity
} from '../reddit-communities.js';
import {
  createDefaultRules,
  type RedditCommunityRuleSet,
  type InsertRedditCommunity
} from '@shared/schema';

type PromotionPolicy = 'yes' | 'no' | 'limited' | 'subtle' | 'strict' | 'unknown';
type GrowthTrend = 'growing' | 'stable' | 'declining' | 'unknown';
type ActivityLevel = 'low' | 'medium' | 'high' | 'unknown';
type CompetitionLevel = 'low' | 'medium' | 'high' | 'unknown';

interface PostingLimitsResponse {
  perDay?: number;
  perWeek?: number;
  cooldownHours?: number;
}

interface CommunityRulesResponse {
  minKarma?: number;
  minAccountAge?: number;
  watermarksAllowed?: boolean;
  sellingAllowed?: boolean;
  titleRules?: string[];
  contentRules?: string[];
  linkRestrictions?: string[];
  verificationRequired?: boolean;
  requiresApproval?: boolean;
  nsfwRequired?: boolean;
  maxPostsPerDay?: number;
  cooldownHours?: number;
}

export interface AdminCommunityResponse {
  id: string;
  name: string;
  displayName: string;
  category: string;
  members: number;
  engagementRate: number;
  verificationRequired: boolean;
  promotionAllowed: PromotionPolicy;
  postingLimits?: PostingLimitsResponse | null;
  rules?: CommunityRulesResponse | null;
  bestPostingTimes?: string[] | null;
  averageUpvotes?: number | null;
  successProbability?: number | null;
  growthTrend?: GrowthTrend | null;
  modActivity?: ActivityLevel | null;
  description?: string | null;
  tags?: string[] | null;
  competitionLevel?: CompetitionLevel | null;
}

type AdminRequest = AuthRequest;
type CommunityRulesInput = z.infer<typeof communityRulesInputSchema>;
type PostingLimitsInput = z.infer<typeof postingLimitsSchema>;
type AdminCommunityPayload = z.infer<typeof adminCommunityPayloadSchema>;
type PostingLimitsRecord = {
  perDay?: number | null;
  perWeek?: number | null;
  cooldownHours?: number | null;
};

const postingLimitsSchema = z.object({
  perDay: z.number().nonnegative().optional(),
  perWeek: z.number().nonnegative().optional(),
  cooldownHours: z.number().nonnegative().optional()
});

const communityRulesInputSchema = z.object({
  minKarma: z.number().nonnegative().optional(),
  minAccountAge: z.number().nonnegative().optional(),
  watermarksAllowed: z.boolean().optional(),
  sellingAllowed: z.boolean().optional(),
  titleRules: z.array(z.string()).optional(),
  contentRules: z.array(z.string()).optional(),
  linkRestrictions: z.array(z.string()).optional(),
  verificationRequired: z.boolean().optional(),
  requiresApproval: z.boolean().optional(),
  nsfwRequired: z.boolean().optional(),
  maxPostsPerDay: z.number().nonnegative().optional(),
  cooldownHours: z.number().nonnegative().optional()
});

const adminCommunityPayloadSchema = z.object({
  id: z.string().min(1).optional(),
  name: z.string().min(1),
  displayName: z.string().min(1),
  category: z.string().min(1),
  members: z.number().int().nonnegative(),
  engagementRate: z.number(),
  verificationRequired: z.boolean(),
  promotionAllowed: z.enum(['yes', 'no', 'limited', 'subtle', 'strict', 'unknown']),
  postingLimits: postingLimitsSchema.nullable().optional(),
  rules: communityRulesInputSchema.nullable().optional(),
  bestPostingTimes: z.array(z.string()).nullable().optional(),
  averageUpvotes: z.number().nullable().optional(),
  successProbability: z.number().nullable().optional(),
  growthTrend: z.enum(['growing', 'stable', 'declining', 'unknown']).nullable().optional(),
  modActivity: z.enum(['low', 'medium', 'high', 'unknown']).nullable().optional(),
  description: z.string().nullable().optional(),
  tags: z.array(z.string()).nullable().optional(),
  competitionLevel: z.enum(['low', 'medium', 'high', 'unknown']).nullable().optional()
});

function sanitizeStringArray(values: readonly string[] | null | undefined): string[] | null {
  if (!values) {
    return null;
  }

  const trimmed = values
    .map(value => value.trim())
    .filter(value => value.length > 0);

  return trimmed.length > 0 ? trimmed : null;
}

function isAdminUser(user: AdminRequest['user']): boolean {
  if (!user) {
    return false;
  }

  return Boolean(user.isAdmin || user.role === 'admin' || user.tier === 'admin' || user.id === 999);
}

function ensureAdmin(req: express.Request, res: express.Response, next: express.NextFunction): void {
  const adminReq = req as AdminRequest;
  const user = adminReq.user;

  if (!user) {
    res.status(401).json({ message: 'Authentication required' });
    return;
  }

  if (!isAdminUser(user)) {
    res.status(403).json({ message: 'Admin access required' });
    return;
  }

  next();
}

function sellingFlagToBoolean(value: RedditCommunityRuleSet['sellingAllowed']): boolean | undefined {
  if (value === 'allowed' || value === 'limited') {
    return true;
  }
  if (value === 'not_allowed') {
    return false;
  }
  return undefined;
}

function mapPostingLimitsResponse(limits: unknown): PostingLimitsResponse | null {
  if (!limits || typeof limits !== 'object') {
    return null;
  }

  const record = limits as PostingLimitsRecord;
  const response: PostingLimitsResponse = {};

  if (typeof record.perDay === 'number') {
    response.perDay = record.perDay;
  }
  if (typeof record.perWeek === 'number') {
    response.perWeek = record.perWeek;
  }
  if (typeof record.cooldownHours === 'number') {
    response.cooldownHours = record.cooldownHours;
  }

  return Object.keys(response).length > 0 ? response : null;
}

function mapRulesResponse(ruleSet: RedditCommunityRuleSet | null | undefined): CommunityRulesResponse | null {
  if (!ruleSet) {
    return null;
  }

  const response: CommunityRulesResponse = {};

  if (ruleSet.minKarma !== null && ruleSet.minKarma !== undefined) {
    response.minKarma = ruleSet.minKarma;
  }
  if (ruleSet.minAccountAge !== null && ruleSet.minAccountAge !== undefined) {
    response.minAccountAge = ruleSet.minAccountAge;
  }

  if (ruleSet.watermarksAllowed !== null && ruleSet.watermarksAllowed !== undefined) {
    response.watermarksAllowed = ruleSet.watermarksAllowed;
  }

  const sellingAllowed = sellingFlagToBoolean(ruleSet.sellingAllowed);
  if (sellingAllowed !== undefined) {
    response.sellingAllowed = sellingAllowed;
  }

  if (ruleSet.titleRules.length > 0) {
    response.titleRules = ruleSet.titleRules;
  }
  if (ruleSet.contentRules.length > 0) {
    response.contentRules = ruleSet.contentRules;
  }
  if (ruleSet.linkRestrictions.length > 0) {
    response.linkRestrictions = ruleSet.linkRestrictions;
  }

  if (ruleSet.verificationRequired) {
    response.verificationRequired = true;
  }
  if (ruleSet.requiresApproval) {
    response.requiresApproval = true;
  }
  if (ruleSet.nsfwRequired) {
    response.nsfwRequired = true;
  }

  if (ruleSet.maxPostsPerDay !== null && ruleSet.maxPostsPerDay !== undefined) {
    response.maxPostsPerDay = ruleSet.maxPostsPerDay;
  }
  if (ruleSet.cooldownHours !== null && ruleSet.cooldownHours !== undefined) {
    response.cooldownHours = ruleSet.cooldownHours;
  }

  return Object.keys(response).length > 0 ? response : null;
}

function mapPostingLimits(limits: PostingLimitsInput | null | undefined): PostingLimitsRecord | null {
  if (!limits) {
    return null;
  }

  const record: PostingLimitsRecord = {};

  if (limits.perDay !== undefined) {
    record.perDay = limits.perDay;
  }
  if (limits.perWeek !== undefined) {
    record.perWeek = limits.perWeek;
  }
  if (limits.cooldownHours !== undefined) {
    record.cooldownHours = limits.cooldownHours;
  }

  return Object.keys(record).length > 0 ? record : null;
}

function mapRulesInput(rules: CommunityRulesInput | null | undefined): RedditCommunityRuleSet | null {
  if (!rules) {
    return null;
  }

  const defaults = createDefaultRules();
  const normalized: RedditCommunityRuleSet = { ...defaults };

  normalized.minKarma = rules.minKarma ?? defaults.minKarma;
  normalized.minAccountAge = rules.minAccountAge ?? defaults.minAccountAge;
  normalized.watermarksAllowed = rules.watermarksAllowed ?? defaults.watermarksAllowed;
  normalized.sellingAllowed = rules.sellingAllowed === undefined
    ? defaults.sellingAllowed
    : rules.sellingAllowed
      ? 'allowed'
      : 'not_allowed';

  const titleRules = sanitizeStringArray(rules.titleRules ?? null);
  normalized.titleRules = titleRules ?? defaults.titleRules;

  const contentRules = sanitizeStringArray(rules.contentRules ?? null);
  normalized.contentRules = contentRules ?? defaults.contentRules;

  const linkRestrictions = sanitizeStringArray(rules.linkRestrictions ?? null);
  normalized.linkRestrictions = linkRestrictions ?? defaults.linkRestrictions;

  normalized.verificationRequired = rules.verificationRequired ?? defaults.verificationRequired;
  normalized.requiresApproval = rules.requiresApproval ?? defaults.requiresApproval;
  normalized.nsfwRequired = rules.nsfwRequired ?? defaults.nsfwRequired;
  normalized.maxPostsPerDay = rules.maxPostsPerDay ?? defaults.maxPostsPerDay;
  normalized.cooldownHours = rules.cooldownHours ?? defaults.cooldownHours;

  return normalized;
}

function buildInsertPayload(payload: AdminCommunityPayload): InsertRedditCommunity {
  const sanitizedDescription = payload.description?.trim() ?? null;
  const descriptionValue = sanitizedDescription && sanitizedDescription.length > 0 ? sanitizedDescription : null;
  const sanitizedBestPostingTimes = sanitizeStringArray(payload.bestPostingTimes ?? null);
  const sanitizedTags = sanitizeStringArray(payload.tags ?? null);

  return {
    id: (payload.id?.trim() || payload.name.trim()),
    name: payload.name.trim(),
    displayName: payload.displayName.trim(),
    category: payload.category.trim(),
    members: payload.members,
    engagementRate: payload.engagementRate,
    verificationRequired: payload.verificationRequired,
    promotionAllowed: payload.promotionAllowed,
    postingLimits: mapPostingLimits(payload.postingLimits ?? null),
    rules: mapRulesInput(payload.rules ?? null),
    bestPostingTimes: sanitizedBestPostingTimes,
    averageUpvotes: payload.averageUpvotes ?? null,
    successProbability: payload.successProbability ?? null,
    growthTrend: payload.growthTrend ?? null,
    modActivity: payload.modActivity ?? null,
    description: descriptionValue,
    tags: sanitizedTags,
    competitionLevel: payload.competitionLevel ?? null
  };
}

function formatAdminCommunity(community: NormalizedRedditCommunity): AdminCommunityResponse {
  return {
    id: community.id,
    name: community.name,
    displayName: community.displayName,
    category: community.category,
    members: community.members,
    engagementRate: community.engagementRate,
    verificationRequired: community.verificationRequired,
    promotionAllowed: community.promotionAllowed as PromotionPolicy,
    postingLimits: mapPostingLimitsResponse(community.postingLimits ?? null),
    rules: mapRulesResponse(community.rules),
    bestPostingTimes: community.bestPostingTimes ?? null,
    averageUpvotes: community.averageUpvotes ?? null,
    successProbability: community.successProbability ?? null,
    growthTrend: (community.growthTrend ?? null) as GrowthTrend | null,
    modActivity: (community.modActivity ?? null) as ActivityLevel | null,
    description: community.description ?? null,
    tags: community.tags ?? null,
    competitionLevel: (community.competitionLevel ?? null) as CompetitionLevel | null
  };
}

function parseBooleanQuery(value: unknown): boolean | undefined {
  if (typeof value !== 'string') {
    return undefined;
  }
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  return undefined;
}

export const adminCommunitiesRouter = express.Router();

adminCommunitiesRouter.use(authenticateToken, ensureAdmin);

adminCommunitiesRouter.get('/', async (req, res) => {
  try {
    const search = typeof req.query.search === 'string' ? req.query.search.trim().toLowerCase() : '';
    const category = typeof req.query.category === 'string' ? req.query.category.trim() : '';
    const promotionAllowed = typeof req.query.promotionAllowed === 'string'
      ? req.query.promotionAllowed.trim() as PromotionPolicy
      : '';
    const verificationFilter = parseBooleanQuery(req.query.verificationRequired);

    let communities = await listCommunities();

    if (search) {
      communities = communities.filter(community => {
        const description = community.description ? community.description.toLowerCase() : '';
        return community.name.toLowerCase().includes(search)
          || community.displayName.toLowerCase().includes(search)
          || description.includes(search);
      });
    }

    if (category) {
      communities = communities.filter(community => community.category === category);
    }

    if (promotionAllowed) {
      communities = communities.filter(community => community.promotionAllowed === promotionAllowed);
    }

    if (verificationFilter !== undefined) {
      communities = communities.filter(community => community.verificationRequired === verificationFilter);
    }

    res.json(communities.map(formatAdminCommunity));
  } catch (error) {
    logger.error('Failed to list admin communities', {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ message: 'Failed to load communities' });
  }
});

adminCommunitiesRouter.post('/', async (req, res) => {
  try {
    const payload = adminCommunityPayloadSchema.parse(req.body);
    const insertPayload = buildInsertPayload(payload);
    const created = await createCommunity(insertPayload);
    res.status(201).json(formatAdminCommunity(created));
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        message: 'Invalid community payload',
        issues: error.issues
      });
    }

    logger.error('Failed to create admin community', {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ message: 'Failed to create community' });
  }
});

adminCommunitiesRouter.put('/:id', async (req, res) => {
  try {
    const payload = adminCommunityPayloadSchema.parse(req.body);
    const insertPayload = buildInsertPayload(payload);
    const { id: _ignored, ...updatePayload } = insertPayload;
    const updated = await updateCommunity(req.params.id, updatePayload as Partial<InsertRedditCommunity>);

    if (!updated) {
      return res.status(404).json({ message: 'Community not found' });
    }

    res.json(formatAdminCommunity(updated));
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        message: 'Invalid community payload',
        issues: error.issues
      });
    }

    logger.error('Failed to update admin community', {
      communityId: req.params.id,
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ message: 'Failed to update community' });
  }
});

adminCommunitiesRouter.delete('/:id', async (req, res) => {
  try {
    await deleteCommunity(req.params.id);
    res.json({ success: true });
  } catch (error) {
    logger.error('Failed to delete admin community', {
      communityId: req.params.id,
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ message: 'Failed to delete community' });
  }
});
shared/schema.ts
+2-0
@@ -217,67 +217,69 @@ export const postPreviews = pgTable("post_previews", {
export const postJobs = pgTable("post_jobs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  subreddit: varchar("subreddit", { length: 100 }).notNull(),
  titleFinal: text("title_final").notNull(),
  bodyFinal: text("body_final").notNull(),
  mediaKey: varchar("media_key", { length: 255 }),
  scheduledAt: timestamp("scheduled_at").notNull(),
  status: varchar("status", { length: 20 }).default("queued").notNull(), // "queued" | "sent" | "failed" | "paused"
  resultJson: jsonb("result_json"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// ==========================================
// REDDIT COMMUNITY RULE SCHEMAS
// ==========================================

export const redditCommunityRuleSetSchema = z.object({
  minKarma: z.number().nullable().default(null),
  minAccountAge: z.number().nullable().default(null), // in days
  watermarksAllowed: z.boolean().nullable().default(null),
  sellingAllowed: z.enum(['allowed', 'limited', 'not_allowed', 'unknown']).default('unknown'),
  titleRules: z.array(z.string()).default([]),
  contentRules: z.array(z.string()).default([]),
  linkRestrictions: z.array(z.string()).default([]),
  verificationRequired: z.boolean().default(false),
  requiresApproval: z.boolean().default(false),
  nsfwRequired: z.boolean().default(false),
  maxPostsPerDay: z.number().nullable().default(null),
  cooldownHours: z.number().nullable().default(null)
});

export type RedditCommunityRuleSet = z.infer<typeof redditCommunityRuleSetSchema>;

// Default rule set factory
export const createDefaultRules = (): RedditCommunityRuleSet => ({
  minKarma: null,
  minAccountAge: null,
  watermarksAllowed: null,
  sellingAllowed: 'unknown',
  titleRules: [],
  contentRules: [],
  linkRestrictions: [],
  verificationRequired: false,
  requiresApproval: false,
  nsfwRequired: false,
  maxPostsPerDay: null,
  cooldownHours: null
});

export const redditCommunities = pgTable("reddit_communities", {
  id: varchar("id", { length: 100 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  displayName: varchar("display_name", { length: 255 }).notNull(),
  members: integer("members").notNull(),
  engagementRate: integer("engagement_rate").notNull(),
  category: varchar("category", { length: 50 }).notNull(),
  verificationRequired: boolean("verification_required").default(false).notNull(),
  promotionAllowed: varchar("promotion_allowed", { length: 20 }).default("no").notNull(),
  postingLimits: jsonb("posting_limits"),
  rules: jsonb("rules").$type<RedditCommunityRuleSet>(),
  bestPostingTimes: jsonb("best_posting_times").$type<string[]>(),
  averageUpvotes: integer("average_upvotes"),
  successProbability: integer("success_probability"),
  growthTrend: varchar("growth_trend", { length: 20 }),
  modActivity: varchar("mod_activity", { length: 20 }),
  description: text("description"),
  tags: jsonb("tags").$type<string[]>(),
tests/routes/admin-communities.test.ts
New
+311-0
import { describe, it, expect, beforeEach, afterEach, vi, type Mock } from 'vitest';
import express from 'express';
import request from 'supertest';

import type { AuthRequest } from '../../server/middleware/auth.js';
import type { NormalizedRedditCommunity } from '../../server/reddit-communities.js';
import { createDefaultRules, type InsertRedditCommunity } from '@shared/schema';
import { adminCommunitiesRouter } from '../../server/routes/admin-communities.js';

type CommunityListMock = () => Promise<NormalizedRedditCommunity[]>;
type CommunityCreateMock = (payload: InsertRedditCommunity) => Promise<NormalizedRedditCommunity>;
type CommunityUpdateMock = (id: string, payload: Partial<InsertRedditCommunity>) => Promise<NormalizedRedditCommunity | undefined>;
type CommunityDeleteMock = (id: string) => Promise<void>;

let currentUser: AuthRequest['user'] | null = null;

let listCommunitiesMock: Mock<Parameters<CommunityListMock>, ReturnType<CommunityListMock>> = vi.fn<Parameters<CommunityListMock>, ReturnType<CommunityListMock>>();
let createCommunityMock: Mock<Parameters<CommunityCreateMock>, ReturnType<CommunityCreateMock>> = vi.fn<Parameters<CommunityCreateMock>, ReturnType<CommunityCreateMock>>();
let updateCommunityMock: Mock<Parameters<CommunityUpdateMock>, ReturnType<CommunityUpdateMock>> = vi.fn<Parameters<CommunityUpdateMock>, ReturnType<CommunityUpdateMock>>();
let deleteCommunityMock: Mock<Parameters<CommunityDeleteMock>, ReturnType<CommunityDeleteMock>> = vi.fn<Parameters<CommunityDeleteMock>, ReturnType<CommunityDeleteMock>>();

vi.mock('../../server/reddit-communities.js', () => ({
  listCommunities: (...args: Parameters<CommunityListMock>) => listCommunitiesMock(...args),
  createCommunity: (...args: Parameters<CommunityCreateMock>) => createCommunityMock(...args),
  updateCommunity: (...args: Parameters<CommunityUpdateMock>) => updateCommunityMock(...args),
  deleteCommunity: (...args: Parameters<CommunityDeleteMock>) => deleteCommunityMock(...args)
}));

vi.mock('../../server/middleware/auth.js', () => ({
  authenticateToken: (req: AuthRequest, _res: express.Response, next: express.NextFunction) => {
    if (currentUser) {
      req.user = currentUser;
    } else {
      delete req.user;
    }
    next();
  }
}));

function makeUser(overrides?: Partial<AuthRequest['user']>): AuthRequest['user'] {
  const now = new Date();
  return {
    id: 1,
    username: 'user',
    email: 'user@example.com',
    password: '',
    emailVerified: true,
    tier: 'free',
    mustChangePassword: false,
    subscriptionStatus: 'inactive',
    createdAt: now,
    updatedAt: now,
    isAdmin: false,
    role: 'user',
    isDeleted: false,
    ...overrides
  } as AuthRequest['user'];
}

function buildCommunity(overrides: Partial<NormalizedRedditCommunity> = {}): NormalizedRedditCommunity {
  const defaults = createDefaultRules();
  const rules = {
    ...defaults,
    minKarma: 100,
    minAccountAge: 30,
    watermarksAllowed: false,
    sellingAllowed: 'not_allowed' as const,
    titleRules: ['Must include age'],
    contentRules: ['OC only'],
    linkRestrictions: ['No short links']
  };

  return {
    id: 'gonewild',
    name: 'gonewild',
    displayName: 'Gone Wild',
    category: 'nsfw',
    members: 500_000,
    engagementRate: 5,
    verificationRequired: true,
    promotionAllowed: 'limited',
    postingLimits: { perDay: 1, cooldownHours: 24 },
    rules,
    bestPostingTimes: ['morning'],
    averageUpvotes: 150,
    successProbability: 70,
    growthTrend: 'stable',
    modActivity: 'high',
    description: 'Test community',
    tags: ['nsfw'],
    competitionLevel: 'high',
    ...overrides
  };
}

describe('adminCommunitiesRouter', () => {
  let app: express.Express;

  beforeEach(() => {
    vi.clearAllMocks();
    listCommunitiesMock = vi.fn<Parameters<CommunityListMock>, ReturnType<CommunityListMock>>();
    createCommunityMock = vi.fn<Parameters<CommunityCreateMock>, ReturnType<CommunityCreateMock>>();
    updateCommunityMock = vi.fn<Parameters<CommunityUpdateMock>, ReturnType<CommunityUpdateMock>>();
    deleteCommunityMock = vi.fn<Parameters<CommunityDeleteMock>, ReturnType<CommunityDeleteMock>>();
    currentUser = makeUser({
      id: 999,
      username: 'admin',
      tier: 'admin',
      subscriptionStatus: 'active',
      isAdmin: true,
      role: 'admin'
    });

    app = express();
    app.use(express.json());
    app.use('/api/admin/communities', adminCommunitiesRouter);
  });

  afterEach(() => {
    currentUser = null;
  });

  it('requires admin privileges', async () => {
    currentUser = makeUser();

    const response = await request(app)
      .get('/api/admin/communities')
      .expect(403);

    expect(response.body).toEqual({ message: 'Admin access required' });
    expect(listCommunitiesMock).not.toHaveBeenCalled();
  });

  it('requires authentication', async () => {
    currentUser = null;

    const response = await request(app)
      .get('/api/admin/communities')
      .expect(401);

    expect(response.body).toEqual({ message: 'Authentication required' });
    expect(listCommunitiesMock).not.toHaveBeenCalled();
  });

  it('lists communities with filters and normalizes response data', async () => {
    const communities: NormalizedRedditCommunity[] = [
      buildCommunity(),
      buildCommunity({
        id: 'photography',
        name: 'photography',
        displayName: 'Photography',
        category: 'creative',
        verificationRequired: false,
        promotionAllowed: 'yes',
        description: 'Photography enthusiasts',
        rules: {
          ...createDefaultRules(),
          sellingAllowed: 'allowed',
          watermarksAllowed: true,
          linkRestrictions: []
        },
        postingLimits: null,
        bestPostingTimes: ['afternoon'],
        tags: ['creative']
      })
    ];

    listCommunitiesMock.mockResolvedValue(communities);

    const response = await request(app)
      .get('/api/admin/communities?search=wild&promotionAllowed=limited')
      .expect(200);

    expect(listCommunitiesMock).toHaveBeenCalledTimes(1);
    expect(response.body).toHaveLength(1);
    expect(response.body[0]).toMatchObject({
      id: 'gonewild',
      promotionAllowed: 'limited',
      postingLimits: { perDay: 1, cooldownHours: 24 },
      rules: {
        sellingAllowed: false,
        watermarksAllowed: false,
        titleRules: ['Must include age'],
        contentRules: ['OC only']
      }
    });
  });

  it('creates a community with normalized payload', async () => {
    const created = buildCommunity();
    createCommunityMock.mockResolvedValue(created);

    const payload = {
      name: 'gonewild',
      displayName: 'Gone Wild',
      category: 'nsfw',
      members: 500_000,
      engagementRate: 5,
      verificationRequired: true,
      promotionAllowed: 'limited',
      postingLimits: { perDay: 1, cooldownHours: 24 },
      rules: {
        minKarma: 100,
        minAccountAge: 30,
        watermarksAllowed: false,
        sellingAllowed: false,
        titleRules: ['Must include age'],
        contentRules: ['OC only'],
        linkRestrictions: ['No short links']
      },
      bestPostingTimes: ['morning'],
      averageUpvotes: 150,
      successProbability: 70,
      growthTrend: 'stable',
      modActivity: 'high',
      description: 'Test community',
      tags: ['nsfw'],
      competitionLevel: 'high'
    };

    const response = await request(app)
      .post('/api/admin/communities')
      .send(payload)
      .expect(201);

    expect(createCommunityMock).toHaveBeenCalledWith(expect.objectContaining({
      id: 'gonewild',
      postingLimits: { perDay: 1, cooldownHours: 24 },
      rules: expect.objectContaining({
        sellingAllowed: 'not_allowed',
        linkRestrictions: ['No short links']
      })
    }));

    expect(response.body).toMatchObject({
      id: 'gonewild',
      rules: expect.objectContaining({ sellingAllowed: false, watermarksAllowed: false })
    });
  });

  it('updates a community and returns the normalized record', async () => {
    const updatedCommunity = buildCommunity({
      promotionAllowed: 'yes',
      rules: {
        ...createDefaultRules(),
        sellingAllowed: 'allowed',
        watermarksAllowed: true,
        linkRestrictions: []
      },
      postingLimits: null
    });

    updateCommunityMock.mockResolvedValue(updatedCommunity);

    const payload = {
      name: 'gonewild',
      displayName: 'Gone Wild',
      category: 'nsfw',
      members: 500_000,
      engagementRate: 5,
      verificationRequired: true,
      promotionAllowed: 'yes',
      postingLimits: null,
      rules: {
        sellingAllowed: true,
        watermarksAllowed: true
      },
      bestPostingTimes: null,
      averageUpvotes: null,
      successProbability: null,
      growthTrend: 'stable',
      modActivity: 'medium',
      description: null,
      tags: null,
      competitionLevel: 'medium'
    };

    const response = await request(app)
      .put('/api/admin/communities/gonewild')
      .send(payload)
      .expect(200);

    expect(updateCommunityMock).toHaveBeenCalledWith(
      'gonewild',
      expect.objectContaining({
        name: 'gonewild',
        rules: expect.objectContaining({ sellingAllowed: 'allowed', watermarksAllowed: true })
      })
    );

    const updateArgs = updateCommunityMock.mock.calls[0][1];
    expect(updateArgs).not.toHaveProperty('id');

    expect(response.body).toMatchObject({
      promotionAllowed: 'yes',
      rules: expect.objectContaining({ sellingAllowed: true, watermarksAllowed: true }),
      postingLimits: null
    });
  });

  it('deletes a community', async () => {
    deleteCommunityMock.mockResolvedValue();

    const response = await request(app)
      .delete('/api/admin/communities/gonewild')
      .expect(200);

    expect(deleteCommunityMock).toHaveBeenCalledWith('gonewild');
    expect(response.body).toEqual({ success: true });
  });
});
vitest.config.ts
+1-0
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node', // Default to Node for server tests
    environmentMatchGlobs: [
      ['client/**', 'jsdom'], // Use jsdom for client tests
      ['tests/**/*.{tsx,jsx}', 'jsdom'], // Use jsdom for React tests
    ],
    setupFiles: ['./tests/vitest-setup.ts'],
    testTimeout: 10000,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './client/src'),
      '@shared': path.resolve(__dirname, './shared'),
      '@server': path.resolve(__dirname, './server'),
    },
    extensions: ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.json', '.node'],
  },
});
