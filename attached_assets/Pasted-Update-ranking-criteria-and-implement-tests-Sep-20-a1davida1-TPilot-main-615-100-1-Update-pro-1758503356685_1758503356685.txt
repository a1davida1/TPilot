Update ranking criteria and implement tests
Sep 20 · a1davida1/TPilot · main
+615-100
1. Update `prompts/rank.txt` to add criteria such as “Disqualify any option containing sparkle-filler (‘Check out this amazing content’, ‘✨ Enhanced’), generic hashtags, or repeated CTA templates; explain the specific violations in the reason.”
2. In both `rankAndSelect` functions, inspect the chosen `final` caption; if it matches a banned phrase regex, trigger another ranking round with a hint or discard the offending variant before re-ranking.
3. Create regression tests confirming the ranking layer never returns captions containing the known filler phrases and instead surfaces human-sounding alternatives.

Summary

    Hardened the ranking prompt so evaluators explicitly reject sparkle-filler phrasing, generic hashtag bundles, and canned CTAs while documenting any violations in their rationale.

Introduced rankGuards utilities and wired them into the text-only, rewrite, and Gemini rankers to normalize outputs, detect banned patterns, rerank with targeted hints, and sanitize fallbacks with human-sounding captions, hashtags, and CTAs.

Added regression coverage ensuring the ranking layer either reruns selection or cleans up filler-heavy winners so sparkle phrases never reach callers.

Testing

    ✅ npm run lint -- --quiet

❌ npm test *(fails: repository’s broader suite already contains numerous unrelated failures across payments, email verification, expenses, uploads, and worker initialization; run aborted after observing these pre-existing issues)*


prompts/rank.txt
+2-1
Rank the 5 for Relevance(40), Voice(25), Originality(20), CTA(10), Safety(5).
Return JSON:
{"winner_index":0,"scores":[0,0,0,0,0],"reason":"<240 chars","final":{"caption":"","alt":"","hashtags":[],"cta":"","mood":"","style":"","safety_level":""}}
Trim hashtags to platform limits.
Trim hashtags to platform limits.
Disqualify any option containing sparkle-filler phrases ("Check out this amazing content", "✨ Enhanced"), stacks of generic hashtags ("#content", "#creative", "#amazing", "#lifestyle"), or canned CTA templates like "Check it out"; call out the specific violations in the reason.
server/caption/geminiPipeline.ts
+102-29
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);
@@ -206,123 +214,188 @@ export async function generateVariants(params: {
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = HUMAN_CTA;
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Detailed social media alt text describing the scene.";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < fallbackHashtags(params.platform).length) {
        variant.hashtags = [...fallbackHashtags(params.platform)];
      }
      if(typeof variant.caption !== 'string' || variant.caption.trim().length < 1) {
        variant.caption = "Sharing something I'm genuinely proud of.";
      }
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        caption: "Sharing something I'm genuinely proud of.",
        alt: "Detailed social media alt text describing the scene.",
        hashtags: fallbackHashtags(params.platform),
        cta: HUMAN_CTA,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
function normalizeGeminiFinal(final: Record<string, unknown>, platform?: string){
  final.safety_level = normalizeSafetyLevel(
    typeof final.safety_level === "string" ? final.safety_level : "normal"
  );
  final.mood = typeof final.mood === "string" && final.mood.trim().length >= 2 ? final.mood.trim() : "engaging";
  final.style = typeof final.style === "string" && final.style.trim().length >= 2 ? final.style.trim() : "authentic";
  const trimmedCta = typeof final.cta === "string" ? final.cta.trim() : "";
  final.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof final.alt === "string" ? final.alt.trim() : "";
  final.alt = trimmedAlt.length >= 20
    ? trimmedAlt
    : "Detailed social media alt text describing the scene.";
  const fallback = fallbackHashtags(platform);
  let hashtags: string[] = [];
  if (Array.isArray(final.hashtags)) {
    hashtags = (final.hashtags as unknown[])
      .map((tag) => (typeof tag === "string" ? tag.trim() : ""))
      .filter((tag) => tag.length > 0);
  }
  if (hashtags.length < fallback.length) {
    hashtags = [...fallback];
  }
  final.hashtags = hashtags;
  const trimmedCaption = typeof final.caption === "string" ? final.caption.trim() : "";
  final.caption = trimmedCaption.length > 0 ? trimmedCaption : "Sharing something I'm genuinely proud of.";
}

async function requestGeminiRanking(
  variantsInput: z.infer<typeof CaptionArray>,
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
): Promise<unknown> {
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
    res=await textModel.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object

  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
      final: winner ?? variantsInput[0]
    };
  }
  
  // Accept any safety_level in final result

  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";
    normalizeGeminiFinal(final, platform);
  }
  return RankResult.parse(json);

  return json;
}

export async function rankAndSelect(
  variants: z.infer<typeof CaptionArray>,
  params?: { platform?: string }
): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestGeminiRanking(variants, serializedVariants, promptBlock, params?.platform);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  if (violations.length === 0) {
    return parsed;
  }

  const rerank = await requestGeminiRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

export async function pipeline({ imageUrl, platform, voice = "flirty_playful", style, mood, nsfw = false }: {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  style?: string;
  mood?: string;
  nsfw?: boolean;
}): Promise<CaptionResult> {
  try {
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, style, mood, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let ranked = await rankAndSelect(variants, { platform });
    let out = ranked.final;

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({ platform, voice, facts, hint:`Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`, nsfw });
      ranked = await rankAndSelect(variants);
      ranked = await rankAndSelect(variants, { platform });
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/rankGuards.ts
New
+195-0
import { z } from "zod";

import { CaptionItem } from "./schema";

export type CaptionData = z.infer<typeof CaptionItem>;
export const HUMAN_CTA = "Tell me what you think";

const GENERIC_HASHTAG_SET = new Set([
  "#content",
  "#creative",
  "#amazing",
  "#lifestyle"
]);

const SPARKLE_RULES: Array<{ pattern: RegExp; replacement: string; detail: string }> = [
  {
    pattern: /check\s+out\s+this\s+amazing\s+content!?/gi,
    replacement: "Sharing something I'm genuinely proud of",
    detail: "uses sparkle filler phrase \"Check out this amazing content\""
  },
  {
    pattern: /✨\s*enhanced/gi,
    replacement: "feels even more alive",
    detail: "uses sparkle filler \"✨ Enhanced\""
  }
];

const CTA_PATTERNS: Array<{ pattern: RegExp; detail: string }> = [
  {
    pattern: /\bcheck\s*(?:it|this)\s*out!?/i,
    detail: "repeats the canned CTA \"Check it out\""
  }
];

function hashtagPolicy(platform?: string) {
  switch (platform) {
    case "x":
      return {
        min: 1,
        max: 3,
        fallback: ["#RealTalk", "#DailyBuild", "#BehindTheScenes"]
      } as const;
    case "tiktok":
      return {
        min: 2,
        max: 5,
        fallback: ["#DailyJoy", "#StoryBehindTheShot", "#LifeInMotion", "#InTheMaking"]
      } as const;
    case "reddit":
      return {
        min: 1,
        max: 3,
        fallback: ["community story", "daily discussion", "real moments"]
      } as const;
    case "instagram":
    default:
      return {
        min: 3,
        max: 8,
        fallback: ["#StoryBehindTheShot", "#DailyJoy", "#RealMoments", "#MakingItReal"]
      } as const;
  }
}

export function detectVariantViolations(final: CaptionData): string[] {
  const violations = new Set<string>();
  const caption = final.caption;

  for (const rule of SPARKLE_RULES) {
    if (rule.pattern.test(caption)) {
      violations.add(rule.detail);
    }
  }

  for (const rule of CTA_PATTERNS) {
    if (rule.pattern.test(final.cta) || rule.pattern.test(caption)) {
      violations.add(rule.detail);
    }
  }

  const normalizedTags = final.hashtags.map((tag) => tag.toLowerCase());
  if (
    normalizedTags.length > 0 &&
    normalizedTags.every((tag) => GENERIC_HASHTAG_SET.has(tag))
  ) {
    violations.add(
      "uses the generic hashtag stack (#content/#creative/#amazing/#lifestyle)"
    );
  }

  return Array.from(violations);
}

function scrubCaptionSparkle(caption: string): string {
  let output = caption;
  for (const rule of SPARKLE_RULES) {
    output = output.replace(rule.pattern, rule.replacement);
  }
  return output.replace(/\s+/g, " ").replace(/\s([,.!?])/g, "$1").trim();
}

function cleanHashtags(
  tags: string[],
  platform?: string
): string[] {
  const policy = hashtagPolicy(platform);
  const filtered = tags.filter((tag) => !GENERIC_HASHTAG_SET.has(tag.toLowerCase()));

  const hashtags = filtered.slice(0, policy.max);
  for (const fallback of policy.fallback) {
    if (hashtags.length >= policy.min) {
      break;
    }
    if (!hashtags.includes(fallback)) {
      hashtags.push(fallback);
    }
  }

  if (hashtags.length === 0) {
    hashtags.push(policy.fallback[0]);
  }

  if (hashtags.length > policy.max) {
    hashtags.length = policy.max;
  }

  return hashtags;
}

function cleanCta(cta: string): string {
  for (const rule of CTA_PATTERNS) {
    if (rule.pattern.test(cta)) {
      return HUMAN_CTA;
    }
  }
  return cta;
}

export function sanitizeFinalVariant(
  final: CaptionData,
  platform?: string
): CaptionData {
  const cleanedCaption = scrubCaptionSparkle(final.caption);
  const normalizedCaption = CTA_PATTERNS.reduce((text, rule) => {
    if (rule.pattern.test(text)) {
      return text.replace(rule.pattern, HUMAN_CTA);
    }
    return text;
  }, cleanedCaption);

  const cleanedHashtags = cleanHashtags(final.hashtags, platform);
  const cleanedCta = cleanCta(final.cta);

  const sanitized: CaptionData = {
    ...final,
    caption: normalizedCaption.length > 0
      ? normalizedCaption
      : "Sharing a moment that actually matters.",
    hashtags: cleanedHashtags,
    cta: cleanedCta
  };

  const remainingViolations = detectVariantViolations(sanitized);
  if (remainingViolations.length === 0) {
    return sanitized;
  }

  const policy = hashtagPolicy(platform);
  return {
    ...sanitized,
    caption: "Sharing a moment that actually matters.",
    hashtags: policy.fallback.slice(0, Math.max(policy.min, 1)),
    cta: HUMAN_CTA
  };
}

export function formatViolationSummary(violations: string[]): string {
  if (violations.length === 0) {
    return "";
  }
  const summary = `Auto-fixed banned filler: ${violations.join(", ")}`;
  return summary.length > 240 ? summary.slice(0, 240) : summary;
}

export function buildRerankHint(violations: string[]): string {
  if (violations.length === 0) {
    return "";
  }
  return `Previous winner violated policies (${violations.join(", ")}). Pick the most natural, specific option without sparkle filler, canned hashtags, or template CTAs.`;
}

export function fallbackHashtags(platform?: string): string[] {
  const policy = hashtagPolicy(platform);
  return policy.fallback.slice(0, Math.max(policy.min, 1));
}
server/caption/rewritePipeline.ts
+102-31
import fs from "node:fs/promises";
import path from "node:path";
import { textModel, visionModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: unknown;
  facts?: unknown;
  variants?: unknown;
  ranked?: unknown;
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
async function b64(url:string){ const r=await fetch(url); if(!r.ok) throw new Error("fetch failed"); const b=Buffer.from(await r.arrayBuffer()); return b.toString("base64"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

export async function variantsRewrite(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, existingCaption:string, facts?:Record<string, unknown>, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rewrite.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}EXISTING_CAPTION: "${params.existingCaption}"${params.facts?`\nIMAGE_FACTS: ${JSON.stringify(params.facts)}`:""}\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json=stripToJSON(res.response.text()) as unknown;
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags=["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content, you'll love it and want more!";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta=HUMAN_CTA;
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Detailed social media alt text describing the scene.";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < fallbackHashtags(params.platform).length) {
        variant.hashtags=[...fallbackHashtags(params.platform)];
      }
      if(typeof variant.caption !== 'string' || variant.caption.trim().length<1) {
        variant.caption="Here's the real story behind this shot.";
      }
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content, you'll love it and want more!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        caption: "Here's the real story behind this shot.",
        alt: "Detailed social media alt text describing the scene.",
        hashtags: fallbackHashtags(params.platform),
        cta: HUMAN_CTA,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} This enhanced version provides much more engaging content and better call-to-action for your audience! (Variant ${json.length + 1})`
        caption: `${template.caption as string} This version leans into a more personal hook and clearer takeaway (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[]){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
function normalizeRewriteFinal(final: Record<string, unknown>, platform?: string){
  final.safety_level = normalizeSafetyLevel(
    typeof final.safety_level === "string" ? final.safety_level : "normal"
  );
  final.mood = typeof final.mood === "string" && final.mood.trim().length >= 2 ? final.mood.trim() : "engaging";
  final.style = typeof final.style === "string" && final.style.trim().length >= 2 ? final.style.trim() : "authentic";
  const trimmedCta = typeof final.cta === "string" ? final.cta.trim() : "";
  final.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof final.alt === "string" ? final.alt.trim() : "";
  final.alt = trimmedAlt.length >= 20
    ? trimmedAlt
    : "Detailed social media alt text describing the scene.";
  const fallback = fallbackHashtags(platform);
  let hashtags: string[] = [];
  if (Array.isArray(final.hashtags)) {
    hashtags = (final.hashtags as unknown[])
      .map((tag) => (typeof tag === "string" ? tag.trim() : ""))
      .filter((tag) => tag.length > 0);
  }
  if (hashtags.length < fallback.length) {
    hashtags = [...fallback];
  }
  final.hashtags = hashtags;
  const trimmedCaption = typeof final.caption === "string" ? final.caption.trim() : "";
  final.caption = trimmedCaption.length > 0 ? trimmedCaption : "Here's the real story behind this shot.";
}

async function requestRewriteRanking(
  variantsInput: unknown[],
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
){
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
    res=await textModel.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object

  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
      final: winner ?? variantsInput[0]
    };
  }
  

  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";
    normalizeRewriteFinal(final, platform);
  }
  return RankResult.parse(json);

  return json;
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string }){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestRewriteRanking(variants, serializedVariants, promptBlock, params?.platform);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  if (violations.length === 0) {
    return parsed;
  }

  const rerank = await requestRewriteRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;
    let variants = await variantsRewrite({ platform, voice, style, mood, existingCaption, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let ranked = await rankAndSelect(variants, { platform });
    let out = ranked.final;
    

    // Ensure rewritten caption is longer and more engaging than original
    if(out.caption.length <= existingCaption.length) {
      out.caption = existingCaption + " ✨ Enhanced with engaging content and call-to-action that drives better engagement!";
      out.caption = `${existingCaption} — now with a clearer hook and invitation to respond.`;
    }

    const err = platformChecks(platform, out);
    if (err) {
      variants = await variantsRewrite({ platform, voice, existingCaption, facts, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
      ranked = await rankAndSelect(variants);
      ranked = await rankAndSelect(variants, { platform });
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/textOnlyPipeline.ts
+98-39
import fs from "node:fs/promises";
import path from "node:path";
import { textModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function generateVariantsTextOnly(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, theme:string, context?:string, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants_textonly.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: "${params.theme}"\nCONTEXT: "${params.context||''}"\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  const raw=stripToJSON(res.response.text());
  const json=Array.isArray(raw)?raw:[raw];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 3) {
        if(params.platform === 'instagram') {
          variant.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
        } else {
          variant.hashtags=["#content", "#creative", "#amazing"];
        }
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta=HUMAN_CTA;
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Detailed social media alt text describing the scene.";
      const fallbackTags = fallbackHashtags(params.platform);
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < fallbackTags.length) {
        variant.hashtags=[...fallbackTags];
      }
      if(typeof variant.caption !== 'string' || variant.caption.trim().length<1) {
        variant.caption="Sharing something I'm genuinely proud of.";
      }
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content!";
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        caption: "Sharing something I'm genuinely proud of.",
        alt: "Detailed social media alt text describing the scene.",
        hashtags: fallbackHashtags(params.platform),
        cta: HUMAN_CTA,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
function normalizeFinalFields(final: Record<string, unknown>, platform?: string){
  final.safety_level = normalizeSafetyLevel(
    typeof final.safety_level === "string" ? final.safety_level : "normal"
  );
  final.mood = typeof final.mood === "string" && final.mood.trim().length >= 2 ? final.mood.trim() : "engaging";
  final.style = typeof final.style === "string" && final.style.trim().length >= 2 ? final.style.trim() : "authentic";
  const trimmedCta = typeof final.cta === "string" ? final.cta.trim() : "";
  final.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof final.alt === "string" ? final.alt.trim() : "";
  final.alt = trimmedAlt.length >= 20
    ? trimmedAlt
    : "Detailed social media alt text describing the scene.";
  const fallback = fallbackHashtags(platform);
  let hashtags: string[] = [];
  if (Array.isArray(final.hashtags)) {
    hashtags = (final.hashtags as unknown[])
      .map((tag) => (typeof tag === "string" ? tag.trim() : ""))
      .filter((tag) => tag.length > 0);
  }
  if (hashtags.length < fallback.length) {
    hashtags = [...fallback];
  }
  final.hashtags = hashtags;
  const trimmedCaption = typeof final.caption === "string" ? final.caption.trim() : "";
  final.caption = trimmedCaption.length > 0 ? trimmedCaption : "Sharing something I'm genuinely proud of.";
}

async function requestRanking(
  variantsInput: unknown[],
  serializedVariants: string,
  promptBlock: string,
  platform?: string,
  extraHint?: string
){
  const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
  const res=await textModel.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object

  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
      final: winner ?? variantsInput[0]
    };
  }
  
  // Fix safety_level in final result

  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags) || final.hashtags.length < 3) {
      if(params?.platform === 'instagram') {
        final.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
      } else {
        final.hashtags=["#content", "#creative", "#amazing"];
      }
    }
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";
    normalizeFinalFields(final, platform);
  }
  return RankResult.parse(json);

  return json;
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestRanking(variants, serializedVariants, promptBlock, params?.platform);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  if (violations.length === 0) {
    return parsed;
  }

  const rerank = await requestRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

export async function pipelineTextOnly({ platform, voice="flirty_playful", style, mood, theme, context, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, theme:string, context?:string, nsfw?:boolean }){
  let variants = await generateVariantsTextOnly({ platform, voice, style, mood, theme, context, nsfw });
  let ranked = await rankAndSelect(variants, { platform, nsfw });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
    ranked = await rankAndSelect(variants);
    ranked = await rankAndSelect(variants, { platform, nsfw });
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/unit/caption/ranking-cleanup.test.ts
New
+116-0
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { CaptionArray } from '../../../server/caption/schema.js';
import { rankAndSelect as textRankAndSelect } from '../../../server/caption/textOnlyPipeline.js';
import { rankAndSelect as rewriteRankAndSelect } from '../../../server/caption/rewritePipeline.js';

vi.mock('../../../server/lib/gemini.js', () => ({
  textModel: {
    generateContent: vi.fn(),
  },
  visionModel: {
    generateContent: vi.fn(),
  },
}));

const baseVariant = {
  alt: 'A detailed alt description that clearly exceeds the minimum character requirement.',
  hashtags: ['#BehindTheScenes', '#DailyBuild', '#RealTalk'],
  safety_level: 'normal',
  mood: 'curious',
  style: 'authentic',
  cta: 'Tell me what you think',
  nsfw: false,
};

const bannedWinner = {
  caption: 'Check out this amazing content! ✨ Enhanced',
  hashtags: ['#content', '#creative', '#amazing'],
  safety_level: 'normal',
  mood: 'engaging',
  style: 'authentic',
  cta: 'Check it out',
  alt: 'A descriptive alt text that is well over twenty characters for validation purposes.',
  nsfw: false,
};

const makeVariants = () => CaptionArray.parse([
  { ...baseVariant, caption: bannedWinner.caption, hashtags: bannedWinner.hashtags, cta: bannedWinner.cta },
  { ...baseVariant, caption: 'A real look at our late-night build session', hashtags: ['#BehindTheScenes', '#DailyBuild', '#RealTalk'] },
  { ...baseVariant, caption: 'Why this project matters to us right now' },
  { ...baseVariant, caption: 'Moments from shipping night that you never see' },
  { ...baseVariant, caption: 'Sharing how the build actually comes together' },
]);

const mockedResponse = (payload: unknown) => ({
  response: {
    text: () => JSON.stringify(payload),
  },
});

describe('ranking fallback guards', () => {
  beforeEach(async () => {
    const { textModel } = await import('../../../server/lib/gemini.js');
    vi.mocked(textModel.generateContent).mockReset();
  });

  it('re-ranks to surface a natural caption when the first winner contains banned filler', async () => {
    const variants = makeVariants();
    const { textModel } = await import('../../../server/lib/gemini.js');
    const generate = vi.mocked(textModel.generateContent);

    const fallbackWinner = {
      winner_index: 1,
      scores: [3, 5, 2, 1, 0],
      reason: 'Better storytelling and conversational tone',
      final: {
        ...variants[1],
        caption: variants[1].caption,
      },
    };

    generate
      .mockResolvedValueOnce(mockedResponse({
        winner_index: 0,
        scores: [5, 4, 3, 2, 1],
        reason: 'Picked the punchiest line',
        final: bannedWinner,
      }))
      .mockResolvedValueOnce(mockedResponse(fallbackWinner));

    const result = await textRankAndSelect(variants, { platform: 'instagram' });

    expect(generate).toHaveBeenCalledTimes(2);
    expect(result.final.caption).toBe(variants[1].caption);
    expect(result.final.hashtags).toEqual(variants[1].hashtags);
    expect(result.final.cta).toBe('Tell me what you think');
    expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
    expect(result.final.caption).not.toMatch(/✨\s*Enhanced/i);
  });

  it('sanitizes the final caption when re-ranking still yields filler', async () => {
    const variants = makeVariants();
    const { textModel } = await import('../../../server/lib/gemini.js');
    const generate = vi.mocked(textModel.generateContent);

    const repeatedPayload = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: 'Selected for energy',
      final: bannedWinner,
    };

    generate
      .mockResolvedValueOnce(mockedResponse(repeatedPayload))
      .mockResolvedValueOnce(mockedResponse(repeatedPayload));

    const result = await rewriteRankAndSelect(variants, { platform: 'instagram' });

    expect(generate).toHaveBeenCalledTimes(2);
    expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
    expect(result.final.caption).not.toMatch(/✨\s*Enhanced/i);
    expect(result.final.hashtags.every(tag => !['#content', '#creative', '#amazing'].includes(tag.toLowerCase()))).toBe(true);
    expect(result.final.cta).toBe('Tell me what you think');
    expect(result.reason).toMatch(/Auto-fixed banned filler/i);
  });
});
