Remove Authorization headers and add credentials
Sep 26 · a1davida1/TPilot · main ·
+83-104
1. Remove the `Authorization` headers that read `localStorage.getItem('authToken')`.
2. Add `credentials: 'include'` to each fetch so the `authToken` cookie is transmitted.
3. Test the widget while logged in to confirm authorized endpoints succeed.

Summary

    Updated core content generation flows to stop reading tokens from localStorage and to include session cookies when calling protected APIs, covering the AI generator, unified creator, and automation widgets.

Shifted analytics, insights, and pro perks modules to rely on cookie-based authentication while pruning obsolete bearer headers, ensuring each fetch transmits credentials for authorized data loads.

Reinforced shared hooks and utilities—including admin community queries, auth handling, image shielding, and the retry helper—to default to credentials: 'include', keeping session cookies attached across the app.

Testing

    ⚠️ npm run lint *(fails: eslint config depends on missing globals package in this environment)*

⚠️ npm test *(fails: vitest executable is not installed in the environment)*


client/src/components/PolicyPreview.tsx
+2-1
@@ -27,51 +27,52 @@ interface PolicyPreviewProps {
  hasLink?: boolean;
  hasLink?: boolean;
  onPreviewComplete?: (result: PolicyResult) => void;
  onPreviewComplete?: (result: PolicyResult) => void;
}
}


export function PolicyPreview({ subreddit, title, body, hasLink = false, onPreviewComplete }: PolicyPreviewProps) {
export function PolicyPreview({ subreddit, title, body, hasLink = false, onPreviewComplete }: PolicyPreviewProps) {
  const queryClient = useQueryClient();
  const queryClient = useQueryClient();
  const [lastPreviewResult, setLastPreviewResult] = useState<PolicyResult | null>(null);
  const [lastPreviewResult, setLastPreviewResult] = useState<PolicyResult | null>(null);


  // Get user's preview gate stats
  // Get user's preview gate stats
  const { data: previewStats, isLoading: statsLoading } = useQuery<PreviewStats>({
  const { data: previewStats, isLoading: statsLoading } = useQuery<PreviewStats>({
    queryKey: ['/api/user/previewStats'],
    queryKey: ['/api/user/previewStats'],
    refetchInterval: 30000, // Refresh every 30 seconds
    refetchInterval: 30000, // Refresh every 30 seconds
  });
  });


  // Get policy feature flags
  // Get policy feature flags
  const { data: policyFlags } = useQuery<{ blockOnWarn: boolean }>({
  const { data: policyFlags } = useQuery<{ blockOnWarn: boolean }>({
    queryKey: ['/api/policy/flags'],
    queryKey: ['/api/policy/flags'],
  });
  });


  // Preview content mutation
  // Preview content mutation
  const previewMutation = useMutation({
  const previewMutation = useMutation({
    mutationFn: async (previewData: { subreddit: string; title: string; body: string; hasLink: boolean }) => {
    mutationFn: async (previewData: { subreddit: string; title: string; body: string; hasLink: boolean }) => {
      const response = await fetch('/api/preview', {
      const response = await fetch('/api/preview', {
        method: 'POST',
        method: 'POST',
        body: JSON.stringify(previewData),
        body: JSON.stringify(previewData),
        headers: { 'Content-Type': 'application/json' }
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include'
      });
      });
      if (!response.ok) throw new Error('Preview failed');
      if (!response.ok) throw new Error('Preview failed');
      return response.json();
      return response.json();
    },
    },
    onSuccess: (result: unknown) => {
    onSuccess: (result: unknown) => {
      const resultData = result as { policyState: 'ok' | 'warn' | 'block'; warnings: string[] };
      const resultData = result as { policyState: 'ok' | 'warn' | 'block'; warnings: string[] };
      const policyResult: PolicyResult = {
      const policyResult: PolicyResult = {
        state: resultData.policyState,
        state: resultData.policyState,
        warnings: resultData.warnings
        warnings: resultData.warnings
      };
      };
      setLastPreviewResult(policyResult);
      setLastPreviewResult(policyResult);
      onPreviewComplete?.(policyResult);
      onPreviewComplete?.(policyResult);
      
      
      // Refresh preview stats
      // Refresh preview stats
      queryClient.invalidateQueries({ queryKey: ['/api/user/previewStats'] });
      queryClient.invalidateQueries({ queryKey: ['/api/user/previewStats'] });
    },
    },
    onError: (error) => {
    onError: (error) => {
      console.error('Preview error:', error);
      console.error('Preview error:', error);
      setLastPreviewResult({
      setLastPreviewResult({
        state: 'warn',
        state: 'warn',
        warnings: ['Content review temporarily unavailable']
        warnings: ['Content review temporarily unavailable']
      });
      });
    }
    }
  });
  });


client/src/components/aesthetic-landing.tsx
+1-1
@@ -7,51 +7,51 @@ import {
  Sparkles, 
  Sparkles, 
  Brain, 
  Brain, 
  Shield, 
  Shield, 
  TrendingUp,
  TrendingUp,
  Star,
  Star,
  Check,
  Check,
  Lock,
  Lock,
  Users,
  Users,
  Eye,
  Eye,
  DollarSign,
  DollarSign,
  Target,
  Target,
  Crown
  Crown
} from "lucide-react";
} from "lucide-react";
import { EnhancedAIGenerator } from "@/components/enhanced-ai-generator";
import { EnhancedAIGenerator } from "@/components/enhanced-ai-generator";
import { SocialAuth } from "@/components/social-auth";
import { SocialAuth } from "@/components/social-auth";
// import { motion } from "framer-motion";
// import { motion } from "framer-motion";


export function AestheticLanding() {
export function AestheticLanding() {
  const [activeTab, setActiveTab] = useState("generate");
  const [activeTab, setActiveTab] = useState("generate");
  const [isVisible, setIsVisible] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [metrics, setMetrics] = useState<{ creators: number; templates: number; support?: string } | null>(null);
  const [metrics, setMetrics] = useState<{ creators: number; templates: number; support?: string } | null>(null);


  useEffect(() => {
  useEffect(() => {
    setIsVisible(true);
    setIsVisible(true);
    fetch('/api/metrics')
    fetch('/api/metrics', { credentials: 'include' })
      .then(res => (res.ok ? res.json() : null))
      .then(res => (res.ok ? res.json() : null))
      .then(setMetrics)
      .then(setMetrics)
      .catch(() => {});
      .catch(() => {});
    
    
    const handleMouseMove = (e: MouseEvent) => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePosition({ x: e.clientX, y: e.clientY });
      setMousePosition({ x: e.clientX, y: e.clientY });
    };
    };
    
    
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  }, []);


  const stats = metrics
  const stats = metrics
    ? [
    ? [
        { icon: <Users className="h-5 w-5" />, value: "Beta", label: "Early Access" },
        { icon: <Users className="h-5 w-5" />, value: "Beta", label: "Early Access" },
        { icon: <Sparkles className="h-5 w-5" />, value: `${metrics.templates}+`, label: "Templates" },
        { icon: <Sparkles className="h-5 w-5" />, value: `${metrics.templates}+`, label: "Templates" },
        { icon: <TrendingUp className="h-5 w-5" />, value: metrics.support || "24/7", label: "Support" },
        { icon: <TrendingUp className="h-5 w-5" />, value: metrics.support || "24/7", label: "Support" },
        { icon: <Star className="h-5 w-5" />, value: "New", label: "Platform" }
        { icon: <Star className="h-5 w-5" />, value: "New", label: "Platform" }
      ]
      ]
    : [];
    : [];


  const features = [
  const features = [
    {
    {
      icon: <Brain />,
      icon: <Brain />,
      title: "AI-Powered Content",
      title: "AI-Powered Content",
client/src/components/ai-generator.tsx
+5-11
@@ -34,73 +34,70 @@ interface GeneratedContentDisplay extends Omit<ContentGeneration, 'titles' | 'ph
}
}


interface AIGeneratorProps {
interface AIGeneratorProps {
  onContentGenerated: (generation: ContentGeneration) => void;
  onContentGenerated: (generation: ContentGeneration) => void;
}
}


export function AIGenerator({ onContentGenerated }: AIGeneratorProps) {
export function AIGenerator({ onContentGenerated }: AIGeneratorProps) {
  const [generationType, setGenerationType] = useState<'ai-prompt' | 'ai-image' | 'template'>('ai-prompt');
  const [generationType, setGenerationType] = useState<'ai-prompt' | 'ai-image' | 'template'>('ai-prompt');
  const [platform, setPlatform] = useState('reddit');
  const [platform, setPlatform] = useState('reddit');
  const [customPrompt, setCustomPrompt] = useState('');
  const [customPrompt, setCustomPrompt] = useState('');
  const [subreddit, setSubreddit] = useState('');
  const [subreddit, setSubreddit] = useState('');
  const [allowsPromotion, setAllowsPromotion] = useState('no');
  const [allowsPromotion, setAllowsPromotion] = useState('no');
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [userProfile, setUserProfile] = useState({
  const [userProfile, setUserProfile] = useState({
    toneOfVoice: 'confident',
    toneOfVoice: 'confident',
    contentStyle: 'authentic',
    contentStyle: 'authentic',
    personalBrand: 'girl-next-door',
    personalBrand: 'girl-next-door',
    contentLength: 'medium' as 'short' | 'medium' | 'long',
    contentLength: 'medium' as 'short' | 'medium' | 'long',
    includeEmojis: true,
    includeEmojis: true,
    promotionLevel: 'moderate' as 'subtle' | 'moderate' | 'direct'
    promotionLevel: 'moderate' as 'subtle' | 'moderate' | 'direct'
  });
  });


  useEffect(() => {
  useEffect(() => {
    async function loadProfile() {
    async function loadProfile() {
      const token = localStorage.getItem('authToken');
      if (!token) return;
      try {
      try {
        const res = await fetch('/api/user/profile', {
        const res = await fetch('/api/user/profile', {
          headers: { Authorization: `Bearer ${token}` }
          credentials: 'include'
        });
        });
        if (res.ok) setUserProfile(await res.json());
        if (res.ok) setUserProfile(await res.json());
      } catch {}
      } catch {}
    }
    }
    loadProfile();
    loadProfile();
  }, []);
  }, []);


  const saveProfile = async (profile: typeof userProfile) => {
  const saveProfile = async (profile: typeof userProfile) => {
    setUserProfile(profile);
    setUserProfile(profile);
    const token = localStorage.getItem('authToken');
    try {
    try {
      await fetch('/api/user/profile', {
      await fetch('/api/user/profile', {
        method: 'PUT',
        method: 'PUT',
        headers: {
        headers: {
          'Content-Type': 'application/json',
          'Content-Type': 'application/json'
          Authorization: `Bearer ${token || ''}`
        },
        },
        body: JSON.stringify(profile)
        body: JSON.stringify(profile),
        credentials: 'include'
      });
      });
    } catch {}
    } catch {}
  };
  };


  const updateProfile = (patch: Partial<typeof userProfile>) =>
  const updateProfile = (patch: Partial<typeof userProfile>) =>
    saveProfile({ ...userProfile, ...patch });
    saveProfile({ ...userProfile, ...patch });
  
  
  // Output display states
  // Output display states
  const [generatedContent, setGeneratedContent] = useState<GeneratedContentDisplay | null>(null);
  const [generatedContent, setGeneratedContent] = useState<GeneratedContentDisplay | null>(null);
  const [copiedItem, setCopiedItem] = useState<string | null>(null);
  const [copiedItem, setCopiedItem] = useState<string | null>(null);


  const { toast } = useToast();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const queryClient = useQueryClient();


  const copyToClipboard = async (text: string, itemName: string) => {
  const copyToClipboard = async (text: string, itemName: string) => {
    try {
    try {
      await navigator.clipboard.writeText(text);
      await navigator.clipboard.writeText(text);
      setCopiedItem(itemName);
      setCopiedItem(itemName);
      toast({
      toast({
        title: "Copied!",
        title: "Copied!",
        description: `${itemName} copied to clipboard`
        description: `${itemName} copied to clipboard`
      });
      });
      
      
      // Reset copied state after 2 seconds
      // Reset copied state after 2 seconds
      setTimeout(() => setCopiedItem(null), 2000);
      setTimeout(() => setCopiedItem(null), 2000);
@@ -109,54 +106,51 @@ export function AIGenerator({ onContentGenerated }: AIGeneratorProps) {
        title: "Copy Failed",
        title: "Copy Failed",
        description: "Unable to copy to clipboard",
        description: "Unable to copy to clipboard",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  };
  };


  const generateMutation = useMutation({
  const generateMutation = useMutation({
    mutationFn: async (data: unknown) => {
    mutationFn: async (data: unknown) => {
      try {
      try {
        const formData = new FormData();
        const formData = new FormData();
        Object.keys(data as Record<string, string | File | unknown>).forEach(key => {
        Object.keys(data as Record<string, string | File | unknown>).forEach(key => {
          const typedData = data as Record<string, string | File | unknown>;
          const typedData = data as Record<string, string | File | unknown>;
          if (key === 'userProfile') {
          if (key === 'userProfile') {
            formData.append(key, JSON.stringify(typedData[key]));
            formData.append(key, JSON.stringify(typedData[key]));
          } else if (key === 'image' && typedData[key]) {
          } else if (key === 'image' && typedData[key]) {
            formData.append(key, typedData[key] as File);
            formData.append(key, typedData[key] as File);
          } else if (typedData[key] !== undefined && typedData[key] !== null) {
          } else if (typedData[key] !== undefined && typedData[key] !== null) {
            formData.append(key, String(typedData[key]));
            formData.append(key, String(typedData[key]));
          }
          }
        });
        });
        
        
        const res = await fetch('/api/generate-ai', {
        const res = await fetch('/api/generate-ai', {
          method: 'POST',
          method: 'POST',
          body: formData,
          body: formData,
          credentials: 'include',
          credentials: 'include'
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
          }
        });
        });
        
        
        if (!res.ok) {
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ message: res.statusText }));
          const errorData = await res.json().catch(() => ({ message: res.statusText }));
          throw new Error(errorData.message || `HTTP ${res.status}: ${res.statusText}`);
          throw new Error(errorData.message || `HTTP ${res.status}: ${res.statusText}`);
        }
        }
        
        
        return await res.json();
        return await res.json();
      } catch (error) {
      } catch (error) {
        console.error('Generation error:', error);
        console.error('Generation error:', error);
        throw error;
        throw error;
      }
      }
    },
    },
    onSuccess: (data) => {
    onSuccess: (data) => {
      // Ensure titles is always an array
      // Ensure titles is always an array
      const displayData = {
      const displayData = {
        ...data,
        ...data,
        titles: Array.isArray(data.titles) ? data.titles : [data.titles].filter(Boolean)
        titles: Array.isArray(data.titles) ? data.titles : [data.titles].filter(Boolean)
      } as GeneratedContentDisplay;
      } as GeneratedContentDisplay;
      
      
      setGeneratedContent(displayData);
      setGeneratedContent(displayData);
      onContentGenerated(data);
      onContentGenerated(data);
      queryClient.invalidateQueries({ queryKey: ['/api/stats'] });
      queryClient.invalidateQueries({ queryKey: ['/api/stats'] });
      toast({
      toast({
        title: "Content Generated!",
        title: "Content Generated!",
client/src/components/analytics/SmartAnalytics.tsx
+3-9
@@ -74,63 +74,57 @@ const safeNumber = (value: unknown, fallback: number = 0): number => {
  const num = Number(value);
  const num = Number(value);
  return isNaN(num) ? fallback : num;
  return isNaN(num) ? fallback : num;
};
};


// Safe division to prevent division by zero
// Safe division to prevent division by zero
const safeDivide = (numerator: number, denominator: number, fallback: number = 0): number => {
const safeDivide = (numerator: number, denominator: number, fallback: number = 0): number => {
  return denominator === 0 ? fallback : numerator / denominator;
  return denominator === 0 ? fallback : numerator / denominator;
};
};


// Safe array access
// Safe array access
function safeArrayAccess<T>(array: T[] | undefined | null, index: number, fallback: T): T {
function safeArrayAccess<T>(array: T[] | undefined | null, index: number, fallback: T): T {
  return Array.isArray(array) && array.length > index && index >= 0 ? array[index] : fallback;
  return Array.isArray(array) && array.length > index && index >= 0 ? array[index] : fallback;
}
}


export default function SmartAnalytics() {
export default function SmartAnalytics() {
  const [timeRange, setTimeRange] = useState('7d');
  const [timeRange, setTimeRange] = useState('7d');
  
  
  // Real data from analytics API and content generation stats with comprehensive error handling
  // Real data from analytics API and content generation stats with comprehensive error handling
  const { data: analyticsData, isLoading, error } = useQuery<AnalyticsData>({
  const { data: analyticsData, isLoading, error } = useQuery<AnalyticsData>({
    queryKey: ['/api/analytics', timeRange],
    queryKey: ['/api/analytics', timeRange],
    queryFn: async () => {
    queryFn: async () => {
      try {
      try {
        // Get analytics data and stats in parallel
        // Get analytics data and stats in parallel
        const [analyticsRes, statsRes, revenueRes] = await Promise.all([
        const [analyticsRes, statsRes, revenueRes] = await Promise.all([
          fetch(`/api/analytics/${timeRange}`, {
          fetch(`/api/analytics/${timeRange}`, {
            headers: {
            credentials: 'include'
              'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
            }
          }),
          }),
          fetch('/api/stats', {
          fetch('/api/stats', {
            headers: {
            credentials: 'include'
              'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
            }
          }),
          }),
          fetch('/api/revenue', {
          fetch('/api/revenue', {
            headers: {
            credentials: 'include'
              'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
            }
          })
          })
        ]);
        ]);


        if (!analyticsRes.ok || !statsRes.ok || !revenueRes.ok) {
        if (!analyticsRes.ok || !statsRes.ok || !revenueRes.ok) {
          throw new Error(`Analytics API failed: ${analyticsRes.status} ${statsRes.status} ${revenueRes.status}`);
          throw new Error(`Analytics API failed: ${analyticsRes.status} ${statsRes.status} ${revenueRes.status}`);
        }
        }


        const analytics = await analyticsRes.json();
        const analytics = await analyticsRes.json();
        const stats = await statsRes.json();
        const stats = await statsRes.json();
        const revenue = await revenueRes.json();
        const revenue = await revenueRes.json();
        
        
        // Validate response structure
        // Validate response structure
        if (!analytics || !stats || !revenue) {
        if (!analytics || !stats || !revenue) {
          throw new Error('Invalid response structure from analytics API');
          throw new Error('Invalid response structure from analytics API');
        }
        }
        
        
        // Safe data extraction with fallbacks
        // Safe data extraction with fallbacks
        const totalViews = safeNumber(analytics.totalViews, 0);
        const totalViews = safeNumber(analytics.totalViews, 0);
        const totalGenerations = safeNumber(stats.totalGenerations, 1); // Prevent division by zero
        const totalGenerations = safeNumber(stats.totalGenerations, 1); // Prevent division by zero
        const averageEngagementRate = safeNumber(analytics.averageEngagementRate, 0);
        const averageEngagementRate = safeNumber(analytics.averageEngagementRate, 0);
        const successRate = safeNumber(stats.successRate, 0);
        const successRate = safeNumber(stats.successRate, 0);
        
        
        // Revenue calculation with real Stripe data
        // Revenue calculation with real Stripe data
        const totalRevenue = safeNumber(revenue.available, 0) / 100; // Convert from cents to dollars
        const totalRevenue = safeNumber(revenue.available, 0) / 100; // Convert from cents to dollars
        
        
client/src/components/audience-insights.tsx
+1-6
@@ -5,58 +5,53 @@ import { Users, Globe, Clock, TrendingUp, Calendar, Eye } from 'lucide-react';
import { useQuery } from '@tanstack/react-query';
import { useQuery } from '@tanstack/react-query';


interface AudienceData {
interface AudienceData {
  platform: string;
  platform: string;
  bestTime: string;
  bestTime: string;
  activeUsers: string;
  activeUsers: string;
  engagement: number;
  engagement: number;
  demographics: {
  demographics: {
    age: string;
    age: string;
    location: string;
    location: string;
    interests: string[];
    interests: string[];
  };
  };
}
}


interface SubredditInsight {
interface SubredditInsight {
  name: string;
  name: string;
  members: string;
  members: string;
  growth: string;
  growth: string;
}
}


export function AudienceInsights() {
export function AudienceInsights() {
  // Fetch real audience insights from analytics
  // Fetch real audience insights from analytics
  const { data: insightsData, isLoading } = useQuery({
  const { data: insightsData, isLoading } = useQuery({
    queryKey: ['audience-insights'],
    queryKey: ['audience-insights'],
    queryFn: async () => {
    queryFn: async () => {
      const token = localStorage.getItem('authToken');
      if (!token) {
        return { audienceData: [], topSubreddits: [] };
      }
      
      try {
      try {
        const response = await fetch('/api/audience-insights', {
        const response = await fetch('/api/audience-insights', {
          headers: { 'Authorization': `Bearer ${token}` }
          credentials: 'include'
        });
        });
        if (!response.ok) {
        if (!response.ok) {
          throw new Error('Failed to fetch insights');
          throw new Error('Failed to fetch insights');
        }
        }
        return response.json();
        return response.json();
      } catch (error) {
      } catch (error) {
        // Return empty data instead of mock data
        // Return empty data instead of mock data
        return { audienceData: [], topSubreddits: [] };
        return { audienceData: [], topSubreddits: [] };
      }
      }
    }
    }
  });
  });


  const audienceData: AudienceData[] = insightsData?.audienceData || [];
  const audienceData: AudienceData[] = insightsData?.audienceData || [];
  const topSubreddits = insightsData?.topSubreddits || [];
  const topSubreddits = insightsData?.topSubreddits || [];
  const postingSchedule: Record<string, string[]> = insightsData?.postingSchedule || {};
  const postingSchedule: Record<string, string[]> = insightsData?.postingSchedule || {};


  // Show message when no data is available
  // Show message when no data is available
  if (!isLoading && audienceData.length === 0) {
  if (!isLoading && audienceData.length === 0) {
    return (
    return (
      <div className="space-y-6">
      <div className="space-y-6">
        <Card className="bg-gray-900/50 backdrop-blur-xl border-white/10">
        <Card className="bg-gray-900/50 backdrop-blur-xl border-white/10">
          <CardHeader>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5 text-purple-400" />
              <Users className="h-5 w-5 text-purple-400" />
              Audience Insights
              Audience Insights
client/src/components/auth-modal.tsx
+6-3
@@ -190,114 +190,117 @@ export function AuthModal({ isOpen, onClose, onSuccess, initialMode = 'login' }:
              size="sm"
              size="sm"
              variant="outline"
              variant="outline"
              onClick={() => resendVerification(error.email || formData.username)}
              onClick={() => resendVerification(error.email || formData.username)}
            >
            >
              Resend
              Resend
            </Button>
            </Button>
          )
          )
        });
        });
      } else {
      } else {
        toast({
        toast({
          title: 'Error',
          title: 'Error',
          description: error.message || 'Authentication failed. Please try again.',
          description: error.message || 'Authentication failed. Please try again.',
          variant: 'destructive'
          variant: 'destructive'
        });
        });
      }
      }
    }
    }
  });
  });


  const forgotPasswordMutation = useMutation({
  const forgotPasswordMutation = useMutation({
    mutationFn: async (email: string) => {
    mutationFn: async (email: string) => {
      const response = await fetch('/api/auth/forgot-password', {
      const response = await fetch('/api/auth/forgot-password', {
        method: 'POST',
        method: 'POST',
        headers: {
        headers: {
          'Content-Type': 'application/json'
          'Content-Type': 'application/json'
        },
        },
        body: JSON.stringify({ email })
        body: JSON.stringify({ email }),
        credentials: 'include'
      });
      });


      if (!response.ok) {
      if (!response.ok) {
        const error = await response.json();
        const error = await response.json();
        throw new Error(error.message || 'Failed to send reset email');
        throw new Error(error.message || 'Failed to send reset email');
      }
      }


      return response.json();
      return response.json();
    },
    },
    onSuccess: () => {
    onSuccess: () => {
      toast({
      toast({
        title: 'Reset Email Sent',
        title: 'Reset Email Sent',
        description: 'Please check your email for password reset instructions.',
        description: 'Please check your email for password reset instructions.',
        variant: 'default'
        variant: 'default'
      });
      });
      setMode('login');
      setMode('login');
      setResetEmail('');
      setResetEmail('');
    },
    },
    onError: (error: AuthError) => {
    onError: (error: AuthError) => {
      toast({
      toast({
        title: 'Error',
        title: 'Error',
        description: error.message || 'Failed to send reset email. Please try again.',
        description: error.message || 'Failed to send reset email. Please try again.',
        variant: 'destructive'
        variant: 'destructive'
      });
      });
    }
    }
  });
  });


  // Enhanced resend verification function
  // Enhanced resend verification function
  const resendVerification = async (email: string) => {
  const resendVerification = async (email: string) => {
    setIsResending(true);
    setIsResending(true);
    try {
    try {
      const res = await fetch('/api/auth/resend-verification', {
      const res = await fetch('/api/auth/resend-verification', {
        method: 'POST',
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
        body: JSON.stringify({ email }),
        credentials: 'include'
      });
      });
      
      
      const data = await res.json();
      const data = await res.json();
      toast({
      toast({
        title: "Verification email sent",
        title: "Verification email sent",
        description: "Please check your inbox and spam folder",
        description: "Please check your inbox and spam folder",
        variant: "default",
        variant: "default",
      });
      });
      setShowResendVerification(false);
      setShowResendVerification(false);
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Error",
        title: "Error",
        description: "Failed to resend verification email",
        description: "Failed to resend verification email",
        variant: "destructive"
        variant: "destructive"
      });
      });
    } finally {
    } finally {
      setIsResending(false);
      setIsResending(false);
    }
    }
  };
  };


  const resendVerificationMutation = useMutation({
  const resendVerificationMutation = useMutation({
    mutationFn: async (email: string) => {
    mutationFn: async (email: string) => {
      const response = await fetch('/api/auth/resend-verification', {
      const response = await fetch('/api/auth/resend-verification', {
        method: 'POST',
        method: 'POST',
        headers: {
        headers: {
          'Content-Type': 'application/json'
          'Content-Type': 'application/json'
        },
        },
        body: JSON.stringify({ email })
        body: JSON.stringify({ email }),
        credentials: 'include'
      });
      });


      if (!response.ok) {
      if (!response.ok) {
        const error = await response.json();
        const error = await response.json();
        throw new Error(error.message || 'Failed to resend verification email');
        throw new Error(error.message || 'Failed to resend verification email');
      }
      }


      return response.json();
      return response.json();
    },
    },
    onSuccess: () => {
    onSuccess: () => {
      toast({
      toast({
        title: 'Verification Email Sent',
        title: 'Verification Email Sent',
        description: 'Please check your inbox and spam folder.',
        description: 'Please check your inbox and spam folder.',
        variant: 'default'
        variant: 'default'
      });
      });
    },
    },
    onError: (error: AuthError) => {
    onError: (error: AuthError) => {
      toast({
      toast({
        title: 'Error',
        title: 'Error',
        description: error.message || 'Failed to resend verification email. Please try again.',
        description: error.message || 'Failed to resend verification email. Please try again.',
        variant: 'destructive'
        variant: 'destructive'
      });
      });
    }
    }
  });
  });


client/src/components/automation/SocialAutomation.tsx
+4-6
@@ -2,72 +2,70 @@ import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Switch } from '@/components/ui/switch';
import { Badge } from '@/components/ui/badge';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Slider } from '@/components/ui/slider';
import { Slider } from '@/components/ui/slider';
import { Clock, Zap, Target, TrendingUp, Settings, Users, BarChart3, Calendar } from 'lucide-react';
import { Clock, Zap, Target, TrendingUp, Settings, Users, BarChart3, Calendar } from 'lucide-react';


export function SocialAutomation() {
export function SocialAutomation() {
  const [autoPostingEnabled, setAutoPostingEnabled] = useState(false);
  const [autoPostingEnabled, setAutoPostingEnabled] = useState(false);
  const [engagementOptimization, setEngagementOptimization] = useState(true);
  const [engagementOptimization, setEngagementOptimization] = useState(true);
  const [trendAnalysis, setTrendAnalysis] = useState(true);
  const [trendAnalysis, setTrendAnalysis] = useState(true);
  const [postFrequency, setPostFrequency] = useState([3]);
  const [postFrequency, setPostFrequency] = useState([3]);
  const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>(['reddit', 'twitter']);
  const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>(['reddit', 'twitter']);
  const [jobId, setJobId] = useState<string | null>(null);
  const [jobId, setJobId] = useState<string | null>(null);
  const [posts, setPosts] = useState<{ id: string; content: string; platform: string; status: string; timestamp: string }[]>([]);
  const [posts, setPosts] = useState<{ id: string; content: string; platform: string; status: string; timestamp: string }[]>([]);


  const handleQuickPost = async () => {
  const handleQuickPost = async () => {
    const caption = localStorage.getItem('latestCaption') || '';
    const caption = localStorage.getItem('latestCaption') || '';
    const image = localStorage.getItem('latestImage');
    const image = localStorage.getItem('latestImage');
    try {
    try {
      const res = await fetch('/api/social-media/quick-post', {
      const res = await fetch('/api/social-media/quick-post', {
        method: 'POST',
        method: 'POST',
        headers: {
        headers: {
          'Content-Type': 'application/json',
          'Content-Type': 'application/json'
          'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
        },
        },
        body: JSON.stringify({ content: { text: caption, mediaUrls: image ? [image] : [] } })
        body: JSON.stringify({ content: { text: caption, mediaUrls: image ? [image] : [] } }),
        credentials: 'include'
      });
      });
      const data = await res.json();
      const data = await res.json();
      if (data.jobId) {
      if (data.jobId) {
        setJobId(data.jobId);
        setJobId(data.jobId);
      }
      }
    } catch (err) {
    } catch (err) {
      console.error('Quick post failed:', err);
      console.error('Quick post failed:', err);
    }
    }
  };
  };


  useEffect(() => {
  useEffect(() => {
    if (!jobId) return;
    if (!jobId) return;
    const interval = setInterval(async () => {
    const interval = setInterval(async () => {
      try {
      try {
        const res = await fetch('/api/social-media/posts', {
        const res = await fetch('/api/social-media/posts', {
          headers: {
          credentials: 'include'
            'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
          }
        });
        });
        const data = await res.json();
        const data = await res.json();
        setPosts(data.posts || []);
        setPosts(data.posts || []);
      } catch (err) {
      } catch (err) {
        console.error('Failed to fetch posts:', err);
        console.error('Failed to fetch posts:', err);
      }
      }
    }, 5000);
    }, 5000);
    return () => clearInterval(interval);
    return () => clearInterval(interval);
  }, [jobId]);
  }, [jobId]);


  const automationFeatures = [
  const automationFeatures = [
    {
    {
      id: 'auto-posting',
      id: 'auto-posting',
      title: 'Smart Auto-Posting',
      title: 'Smart Auto-Posting',
      description: 'AI-powered posting at optimal times across platforms',
      description: 'AI-powered posting at optimal times across platforms',
      icon: Clock,
      icon: Clock,
      enabled: autoPostingEnabled,
      enabled: autoPostingEnabled,
      toggle: setAutoPostingEnabled,
      toggle: setAutoPostingEnabled,
      stats: { success: '94%', posts: '847', engagement: '+23%' }
      stats: { success: '94%', posts: '847', engagement: '+23%' }
    },
    },
    {
    {
      id: 'engagement-opt',
      id: 'engagement-opt',
      title: 'Engagement Optimization',
      title: 'Engagement Optimization',
      description: 'Real-time optimization of content for maximum engagement',
      description: 'Real-time optimization of content for maximum engagement',
      icon: Target,
      icon: Target,
client/src/components/enterprise/MediaLibrary.tsx
+1-0
@@ -34,50 +34,51 @@ export default function MediaLibrary() {
    queryKey: ['/api/media'],
    queryKey: ['/api/media'],
  });
  });


  // Fetch storage usage
  // Fetch storage usage
  const { data: usage } = useQuery({
  const { data: usage } = useQuery({
    queryKey: ['/api/storage/usage'],
    queryKey: ['/api/storage/usage'],
  });
  });


  // Upload mutation
  // Upload mutation
  const uploadMutation = useMutation({
  const uploadMutation = useMutation({
    mutationFn: async (file: File) => {
    mutationFn: async (file: File) => {
      const formData = new FormData();
      const formData = new FormData();
      formData.append('file', file);
      formData.append('file', file);
      formData.append('watermark', 'true'); // Default watermark for uploads
      formData.append('watermark', 'true'); // Default watermark for uploads


      // Simulate progress (in real app, track actual upload progress)
      // Simulate progress (in real app, track actual upload progress)
      setUploadProgress(0);
      setUploadProgress(0);
      const progressInterval = setInterval(() => {
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => Math.min(prev + 10, 90));
        setUploadProgress(prev => Math.min(prev + 10, 90));
      }, 200);
      }, 200);


      try {
      try {
        const response = await fetch('/api/media/upload', {
        const response = await fetch('/api/media/upload', {
          method: 'POST',
          method: 'POST',
          body: formData,
          body: formData,
          credentials: 'include',
        });
        });
        if (!response.ok) {
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        }
        const result = await response.json();
        const result = await response.json();
        clearInterval(progressInterval);
        clearInterval(progressInterval);
        setUploadProgress(100);
        setUploadProgress(100);
        setTimeout(() => setUploadProgress(0), 1000);
        setTimeout(() => setUploadProgress(0), 1000);
        return result;
        return result;
      } catch (error) {
      } catch (error) {
        clearInterval(progressInterval);
        clearInterval(progressInterval);
        setUploadProgress(0);
        setUploadProgress(0);
        throw error;
        throw error;
      }
      }
    },
    },
    onSuccess: () => {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/media'] });
      queryClient.invalidateQueries({ queryKey: ['/api/media'] });
      queryClient.invalidateQueries({ queryKey: ['/api/storage/usage'] });
      queryClient.invalidateQueries({ queryKey: ['/api/storage/usage'] });
      toast({
      toast({
        title: "Upload successful",
        title: "Upload successful",
        description: "Your media has been uploaded and protected",
        description: "Your media has been uploaded and protected",
      });
      });
    },
    },
    onError: (error: unknown) => {
    onError: (error: unknown) => {
      const errorMessage = error instanceof Error ? error.message : "Failed to upload media";
      const errorMessage = error instanceof Error ? error.message : "Failed to upload media";
client/src/components/fine-tuning-settings.tsx
+2-1
@@ -50,51 +50,52 @@ export function FineTuningSettings() {


  const [settings, setSettings] = useState<UserPreferences>({
  const [settings, setSettings] = useState<UserPreferences>({
    userId: 1,
    userId: 1,
    fineTuningEnabled: false,
    fineTuningEnabled: false,
    writingStyle: { tone: 50, formality: 50, explicitness: 50 },
    writingStyle: { tone: 50, formality: 50, explicitness: 50 },
    contentPreferences: { themes: "", avoid: "" },
    contentPreferences: { themes: "", avoid: "" },
    prohibitedWords: [],
    prohibitedWords: [],
    photoStyle: { lighting: 50, mood: 50, composition: 50 }
    photoStyle: { lighting: 50, mood: 50, composition: 50 }
  });
  });


  const [newProhibitedWord, setNewProhibitedWord] = useState("");
  const [newProhibitedWord, setNewProhibitedWord] = useState("");


  useEffect(() => {
  useEffect(() => {
    if (preferences) {
    if (preferences) {
      setSettings(preferences);
      setSettings(preferences);
    }
    }
  }, [preferences]);
  }, [preferences]);


  const saveMutation = useMutation({
  const saveMutation = useMutation({
    mutationFn: async (data: UserPreferences) => {
    mutationFn: async (data: UserPreferences) => {
      const response = await fetch("/api/user-preferences", {
      const response = await fetch("/api/user-preferences", {
        method: "PUT",
        method: "PUT",
        headers: {
        headers: {
          "Content-Type": "application/json"
          "Content-Type": "application/json"
        },
        },
        body: JSON.stringify(data)
        body: JSON.stringify(data),
        credentials: 'include'
      });
      });
      if (!response.ok) {
      if (!response.ok) {
        throw new Error("Failed to save preferences");
        throw new Error("Failed to save preferences");
      }
      }
      return response.json();
      return response.json();
    },
    },
    onSuccess: () => {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/user-preferences"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user-preferences"] });
      toast({
      toast({
        title: "Settings saved",
        title: "Settings saved",
        description: "Your fine-tuning preferences have been updated."
        description: "Your fine-tuning preferences have been updated."
      });
      });
      setHasChanges(false);
      setHasChanges(false);
    },
    },
    onError: () => {
    onError: () => {
      toast({
      toast({
        title: "Error",
        title: "Error",
        description: "Failed to save settings. Please try again.",
        description: "Failed to save settings. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  });
  });


  const updateSettings = (updates: Partial<UserPreferences>) => {
  const updateSettings = (updates: Partial<UserPreferences>) => {
    setSettings(prev => ({ ...prev, ...updates }));
    setSettings(prev => ({ ...prev, ...updates }));
client/src/components/image-gallery.tsx
+3-1
@@ -139,51 +139,53 @@ export function ImageGallery() {
        });
        });
        URL.revokeObjectURL(previewUrl); // Clean up preview URL
        URL.revokeObjectURL(previewUrl); // Clean up preview URL
      } else {
      } else {
        // Upload to server if authenticated
        // Upload to server if authenticated
        const formData = new FormData();
        const formData = new FormData();
        formData.append('file', file);
        formData.append('file', file);
        if (selectedTags) {
        if (selectedTags) {
          formData.append('tags', selectedTags);
          formData.append('tags', selectedTags);
        }
        }
        uploadMutation.mutate(formData);
        uploadMutation.mutate(formData);
        URL.revokeObjectURL(previewUrl); // Clean up preview URL
        URL.revokeObjectURL(previewUrl); // Clean up preview URL
      }
      }
    }
    }
    
    
    // Reset input
    // Reset input
    event.target.value = '';
    event.target.value = '';
    setSelectedTags('');
    setSelectedTags('');
  };
  };


  const handleProtectImage = async (image: UserImage, level: string) => {
  const handleProtectImage = async (image: UserImage, level: string) => {
    protectMutation.mutate({ imageId: image.id.toString(), protectionLevel: level });
    protectMutation.mutate({ imageId: image.id.toString(), protectionLevel: level });
  };
  };


  const handleDownloadProtected = async (image: UserImage) => {
  const handleDownloadProtected = async (image: UserImage) => {
    try {
    try {
      const response = await fetch(image.signedUrl || image.downloadUrl || '');
      const response = await fetch(image.signedUrl || image.downloadUrl || '', {
        credentials: 'include'
      });
      const blob = await response.blob();
      const blob = await response.blob();
      downloadProtectedImage(blob, image.filename);
      downloadProtectedImage(blob, image.filename);
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Download failed",
        title: "Download failed",
        description: "Could not download image.",
        description: "Could not download image.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  };
  };


  const filteredImages = images.filter(image => 
  const filteredImages = images.filter(image => 
    !selectedTags || image.filename.toLowerCase().includes(selectedTags.toLowerCase())
    !selectedTags || image.filename.toLowerCase().includes(selectedTags.toLowerCase())
  );
  );


  return (
  return (
    <div className="space-y-6">
    <div className="space-y-6">
      {/* Upload Section */}
      {/* Upload Section */}
      <Card>
      <Card>
        <CardHeader>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
          <CardTitle className="flex items-center gap-2">
            <Upload className="h-5 w-5" />
            <Upload className="h-5 w-5" />
            Upload Images
            Upload Images
          </CardTitle>
          </CardTitle>
          <CardDescription>
          <CardDescription>
client/src/components/image-protector.tsx
+1-1
@@ -117,51 +117,51 @@ export function ImageProtector({ userTier = 'guest' }: ImageProtectorProps) {
            size="sm" 
            size="sm" 
            variant="outline"
            variant="outline"
            onClick={() => downloadImage()}
            onClick={() => downloadImage()}
          >
          >
            <Download className="h-3 w-3 mr-1" />
            <Download className="h-3 w-3 mr-1" />
            Download
            Download
          </Button>
          </Button>
        )
        )
      });
      });
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Processing failed",
        title: "Processing failed",
        description: "Failed to process the image. Please try again.",
        description: "Failed to process the image. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
      console.error('Image processing error:', error);
      console.error('Image processing error:', error);
    } finally {
    } finally {
      setIsProcessing(false);
      setIsProcessing(false);
    }
    }
  };
  };


  const downloadImage = async () => {
  const downloadImage = async () => {
    if (!selectedFile || !protectedImageUrl) return;
    if (!selectedFile || !protectedImageUrl) return;
    
    
    try {
    try {
      const response = await fetch(protectedImageUrl);
      const response = await fetch(protectedImageUrl, { credentials: 'include' });
      const blob = await response.blob();
      const blob = await response.blob();
      const timestamp = new Date().toISOString().slice(0, 10);
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `protected_${timestamp}_${selectedFile.name}`;
      const filename = `protected_${timestamp}_${selectedFile.name}`;
      downloadProtectedImage(blob, filename);
      downloadProtectedImage(blob, filename);
      
      
      toast({
      toast({
        title: "Download started",
        title: "Download started",
        description: "Your protected image is downloading..."
        description: "Your protected image is downloading..."
      });
      });
    } catch (_error) {
    } catch (_error) {
      toast({
      toast({
        title: "Download failed",
        title: "Download failed",
        description: "Failed to download the image. Please try again.",
        description: "Failed to download the image. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  };
  };


  const resetAll = () => {
  const resetAll = () => {
    setSelectedFile(null);
    setSelectedFile(null);
    setOriginalImageUrl(null);
    setOriginalImageUrl(null);
    setProtectedImageUrl(null);
    setProtectedImageUrl(null);
    setShowComparison(false);
    setShowComparison(false);
    if (fileInputRef.current) {
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
      fileInputRef.current.value = '';
client/src/components/image-shield-unified.tsx
+9-9
@@ -45,95 +45,95 @@ interface MediaAsset {
  key: string;
  key: string;
  filename: string;
  filename: string;
  bytes: number;
  bytes: number;
  mime: string;
  mime: string;
  visibility: string;
  visibility: string;
  signedUrl: string;
  signedUrl: string;
  createdAt: string;
  createdAt: string;
}
}


export function ImageShieldUnified({ userTier = 'guest' }: ImageShieldUnifiedProps) {
export function ImageShieldUnified({ userTier = 'guest' }: ImageShieldUnifiedProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [originalImageUrl, setOriginalImageUrl] = useState<string | null>(null);
  const [originalImageUrl, setOriginalImageUrl] = useState<string | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [protectedImageUrl, setProtectedImageUrl] = useState<string | null>(null);
  const [protectedImageUrl, setProtectedImageUrl] = useState<string | null>(null);
  const [preset, setPreset] = useState<'light' | 'standard' | 'heavy'>('standard');
  const [preset, setPreset] = useState<'light' | 'standard' | 'heavy'>('standard');
  const [customSettings, setCustomSettings] = useState<ImageProcessingOptions>(protectionPresets.standard);
  const [customSettings, setCustomSettings] = useState<ImageProcessingOptions>(protectionPresets.standard);
  const [useCustom, setUseCustom] = useState(false);
  const [useCustom, setUseCustom] = useState(false);
  const [showComparison, setShowComparison] = useState(false);
  const [showComparison, setShowComparison] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const [selectedTags, setSelectedTags] = useState<string>('');
  const [selectedTags, setSelectedTags] = useState<string>('');
  const [selectedImage, setSelectedImage] = useState<MediaAsset | null>(null);
  const [selectedImage, setSelectedImage] = useState<MediaAsset | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const galleryInputRef = useRef<HTMLInputElement>(null);
  const galleryInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const queryClient = useQueryClient();
  const { token } = useAuth() as unknown as { token: string };
  const { user } = useAuth();
  const isAuthenticated = Boolean(user);


  const isProUser = userTier === 'pro';
  const isProUser = userTier === 'pro';
  const showGallery = isProUser; // Only Pro users see gallery
  const showGallery = isProUser; // Only Pro users see gallery


  // Authenticated API request helper
  // Authenticated API request helper
  const authenticatedRequest = async (url: string, method: string = 'GET', data?: unknown) => {
  const authenticatedRequest = async (url: string, method: string = 'GET', data?: unknown) => {
    let body: FormData | string | undefined;
    let body: FormData | string | undefined;
    const headers: { [key: string]: string } = {
    const headers: Record<string, string> = {};
      'Authorization': `Bearer ${token}`

    };
    
    if (data instanceof FormData) {
    if (data instanceof FormData) {
      body = data;
      body = data;
    } else if (data) {
    } else if (data) {
      headers['Content-Type'] = 'application/json';
      headers['Content-Type'] = 'application/json';
      body = JSON.stringify(data);
      body = JSON.stringify(data);
    }
    }
    

    const response = await fetch(url, {
    const response = await fetch(url, {
      method,
      method,
      headers,
      headers,
      body
      body,
      credentials: 'include'
    });
    });
    
    
    if (!response.ok) {
    if (!response.ok) {
      const errorText = await response.text();
      const errorText = await response.text();
      let errorMessage;
      let errorMessage;
      try {
      try {
        const errorJson = JSON.parse(errorText);
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error || errorText;
        errorMessage = errorJson.error || errorText;
      } catch {
      } catch {
        errorMessage = errorText || response.statusText;
        errorMessage = errorText || response.statusText;
      }
      }
      throw new Error(errorMessage);
      throw new Error(errorMessage);
    }
    }
    
    
    return response.json();
    return response.json();
  };
  };


  // Gallery functionality - only for Pro/Premium users
  // Gallery functionality - only for Pro/Premium users
  const { data: galleryImages = [] } = useQuery<MediaAsset[]>({
  const { data: galleryImages = [] } = useQuery<MediaAsset[]>({
    queryKey: ['/api/media'],
    queryKey: ['/api/media'],
    queryFn: () => authenticatedRequest('/api/media'),
    queryFn: () => authenticatedRequest('/api/media'),
    enabled: !!token && showGallery
    enabled: isAuthenticated && showGallery
  });
  });


  const uploadToGalleryMutation = useMutation({
  const uploadToGalleryMutation = useMutation({
    mutationFn: async (formData: FormData) => {
    mutationFn: async (formData: FormData) => {
      return authenticatedRequest('/api/media/upload', 'POST', formData);
      return authenticatedRequest('/api/media/upload', 'POST', formData);
    },
    },
    onSuccess: () => {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/media'] });
      queryClient.invalidateQueries({ queryKey: ['/api/media'] });
      toast({
      toast({
        title: "Image uploaded to gallery",
        title: "Image uploaded to gallery",
        description: "Your image has been saved and is ready for protection."
        description: "Your image has been saved and is ready for protection."
      });
      });
    },
    },
    onError: (error: unknown) => {
    onError: (error: unknown) => {
      toast({
      toast({
        title: "Upload failed",
        title: "Upload failed",
        description: getErrorMessage(error) || "Failed to upload image to gallery.",
        description: getErrorMessage(error) || "Failed to upload image to gallery.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  });
  });


  const deleteImageMutation = useMutation({
  const deleteImageMutation = useMutation({
    mutationFn: async (imageId: number) => {
    mutationFn: async (imageId: number) => {
      return authenticatedRequest(`/api/media/${imageId}`, 'DELETE');
      return authenticatedRequest(`/api/media/${imageId}`, 'DELETE');
@@ -240,51 +240,51 @@ export function ImageShieldUnified({ userTier = 'guest' }: ImageShieldUnifiedPro
            size="sm" 
            size="sm" 
            variant="outline"
            variant="outline"
            onClick={() => downloadImage()}
            onClick={() => downloadImage()}
          >
          >
            <Download className="h-3 w-3 mr-1" />
            <Download className="h-3 w-3 mr-1" />
            Download
            Download
          </Button>
          </Button>
        )
        )
      });
      });
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Processing failed",
        title: "Processing failed",
        description: "Failed to process the image. Please try again.",
        description: "Failed to process the image. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
      console.error('Image processing error:', error);
      console.error('Image processing error:', error);
    } finally {
    } finally {
      setIsProcessing(false);
      setIsProcessing(false);
    }
    }
  };
  };


  const downloadImage = async () => {
  const downloadImage = async () => {
    if (!selectedFile || !protectedImageUrl) return;
    if (!selectedFile || !protectedImageUrl) return;
    
    
    try {
    try {
      const response = await fetch(protectedImageUrl);
      const response = await fetch(protectedImageUrl, { credentials: 'include' });
      const blob = await response.blob();
      const blob = await response.blob();
      const timestamp = new Date().toISOString().slice(0, 10);
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `protected_${timestamp}_${selectedFile.name}`;
      const filename = `protected_${timestamp}_${selectedFile.name}`;
      downloadProtectedImage(blob, filename);
      downloadProtectedImage(blob, filename);
      
      
      toast({
      toast({
        title: "Download started",
        title: "Download started",
        description: "Your protected image is downloading..."
        description: "Your protected image is downloading..."
      });
      });
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Download failed",
        title: "Download failed",
        description: "Failed to download the image. Please try again.",
        description: "Failed to download the image. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    }
    }
  };
  };


  const resetAll = () => {
  const resetAll = () => {
    setSelectedFile(null);
    setSelectedFile(null);
    setOriginalImageUrl(null);
    setOriginalImageUrl(null);
    setProtectedImageUrl(null);
    setProtectedImageUrl(null);
    setShowComparison(false);
    setShowComparison(false);
    if (fileInputRef.current) {
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
      fileInputRef.current.value = '';
client/src/components/performance-optimization.tsx
+3-6
@@ -36,56 +36,53 @@ interface PerformanceMetrics {
  cacheHitRate: number;
  cacheHitRate: number;
}
}


// Memoized component for better performance
// Memoized component for better performance
export const PerformanceOptimization = memo(() => {
export const PerformanceOptimization = memo(() => {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    loadTime: 0,
    loadTime: 0,
    apiResponseTime: 0,
    apiResponseTime: 0,
    memoryUsage: 0,
    memoryUsage: 0,
    networkStatus: 'excellent',
    networkStatus: 'excellent',
    cacheHitRate: 95
    cacheHitRate: 95
  });
  });
  
  
  const [isOptimizing, setIsOptimizing] = useState(false);
  const [isOptimizing, setIsOptimizing] = useState(false);


  // Enhanced performance monitoring with API response tracking
  // Enhanced performance monitoring with API response tracking
  const measurePerformance = useCallback(async () => {
  const measurePerformance = useCallback(async () => {
    const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    
    
    if (navigationTiming) {
    if (navigationTiming) {
      const loadTime = navigationTiming.loadEventEnd - (navigationTiming.fetchStart || 0);
      const loadTime = navigationTiming.loadEventEnd - (navigationTiming.fetchStart || 0);
      
      
      // Test API response time
      // Test API response time
      const apiStartTime = performance.now();
      const apiStartTime = performance.now();
      try {
      try {
        const token = localStorage.getItem('authToken');
        await fetch('/api/auth/user', {
        if (token) {
          credentials: 'include'
          await fetch('/api/auth/user', {
        });
            headers: { 'Authorization': `Bearer ${token}` }
          });
        }
      } catch (error) {
      } catch (error) {
        // API call failed, don't update response time
        // API call failed, don't update response time
      }
      }
      const apiResponseTime = performance.now() - apiStartTime;
      const apiResponseTime = performance.now() - apiStartTime;
      
      
      setMetrics(prev => ({
      setMetrics(prev => ({
        ...prev,
        ...prev,
        loadTime: Math.round(loadTime),
        loadTime: Math.round(loadTime),
        apiResponseTime: Math.round(apiResponseTime),
        apiResponseTime: Math.round(apiResponseTime),
        memoryUsage: (() => {
        memoryUsage: (() => {
          const mem = (performance as ExtendedPerformance).memory;
          const mem = (performance as ExtendedPerformance).memory;
          return mem ? Math.round((mem.usedJSHeapSize / mem.totalJSHeapSize) * 100) : 0;
          return mem ? Math.round((mem.usedJSHeapSize / mem.totalJSHeapSize) * 100) : 0;
        })(), // Memory usage calculation with null check
        })(), // Memory usage calculation with null check
        cacheHitRate: prev.cacheHitRate // Keep existing cache hit rate
        cacheHitRate: prev.cacheHitRate // Keep existing cache hit rate
      }));
      }));
    }
    }
  }, []);
  }, []);


  // Network status detection
  // Network status detection
  const detectNetworkStatus = useCallback(() => {
  const detectNetworkStatus = useCallback(() => {
    const extNavigator = navigator as ExtendedNavigator;
    const extNavigator = navigator as ExtendedNavigator;
    const connection = extNavigator.connection || extNavigator.mozConnection || extNavigator.webkitConnection;
    const connection = extNavigator.connection || extNavigator.mozConnection || extNavigator.webkitConnection;
    
    
    if (connection) {
    if (connection) {
      const { effectiveType, downlink } = connection;
      const { effectiveType, downlink } = connection;
client/src/components/pro-perks.tsx
+21-29
@@ -124,59 +124,53 @@ const statusStyles: Record<ProPerk["status"], { label: string; className: string
    className: "bg-yellow-500/20 text-yellow-300 border-yellow-500/30"
    className: "bg-yellow-500/20 text-yellow-300 border-yellow-500/30"
  },
  },
  "coming-soon": {
  "coming-soon": {
    label: "Coming Soon",
    label: "Coming Soon",
    className: "bg-slate-500/20 text-slate-300 border-slate-500/30"
    className: "bg-slate-500/20 text-slate-300 border-slate-500/30"
  }
  }
};
};


export function ProPerks({ userTier = "pro" }: ProPerksProps) {
export function ProPerks({ userTier = "pro" }: ProPerksProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [activeCategory, setActiveCategory] = useState<CategoryFilter>("all");
  const [activeCategory, setActiveCategory] = useState<CategoryFilter>("all");
  const [selectedPerk, setSelectedPerk] = useState<ProPerk | null>(null);
  const [selectedPerk, setSelectedPerk] = useState<ProPerk | null>(null);
  const [instructionsByPerk, setInstructionsByPerk] = useState<Record<string, SignupInstructions>>({});
  const [instructionsByPerk, setInstructionsByPerk] = useState<Record<string, SignupInstructions>>({});
  const [referralCodes, setReferralCodes] = useState<Record<string, string>>({});
  const [referralCodes, setReferralCodes] = useState<Record<string, string>>({});
  const [instructionsLoading, setInstructionsLoading] = useState<string | null>(null);
  const [instructionsLoading, setInstructionsLoading] = useState<string | null>(null);
  const [referralLoading, setReferralLoading] = useState<string | null>(null);
  const [referralLoading, setReferralLoading] = useState<string | null>(null);
  const { toast } = useToast();
  const { toast } = useToast();


  // Fetch real resources from API
  // Fetch real resources from API
  const { data, isLoading, isError } = useQuery<ProResourcesResult>({
  const { data, isLoading, isError } = useQuery<ProResourcesResult>({
    queryKey: ["pro-resources"],
    queryKey: ["pro-resources"],
    queryFn: async () => {
    queryFn: async () => {
      if (typeof window === "undefined") {
      if (typeof window === "undefined") {
        return { perks: [], accessGranted: false } satisfies ProResourcesResult;
        return { perks: [], accessGranted: false } satisfies ProResourcesResult;
      }
      }

      const token = window.localStorage.getItem("authToken");
      if (!token) {
        return { perks: [], accessGranted: false } satisfies ProResourcesResult;
      }

      try {
      try {
        const response = await fetch("/api/pro-resources", {
        const response = await fetch("/api/pro-resources", {
          headers: { Authorization: `Bearer ${token}` }
          credentials: 'include'
        });
        });


        if (response.status === 403) {
        if (response.status === 403) {
          return { perks: [], accessGranted: false } satisfies ProResourcesResult;
          return { perks: [], accessGranted: false } satisfies ProResourcesResult;
        }
        }


        if (!response.ok) {
        if (!response.ok) {
          throw new Error("Failed to fetch pro resources");
          throw new Error("Failed to fetch pro resources");
        }
        }


        const payload = await response.json() as { perks: ProPerk[] };
        const payload = await response.json() as { perks: ProPerk[] };
        return { perks: payload.perks, accessGranted: true } satisfies ProResourcesResult;
        return { perks: payload.perks, accessGranted: true } satisfies ProResourcesResult;
      } catch (error) {
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to fetch pro resources";
        const message = error instanceof Error ? error.message : "Failed to fetch pro resources";
        throw new Error(message);
        throw new Error(message);
      }
      }
    }
    }
  });
  });


  const perks = data?.perks ?? [];
  const perks = data?.perks ?? [];
  const hasAccess = data?.accessGranted ?? false;
  const hasAccess = data?.accessGranted ?? false;


  const categories = useMemo(() => {
  const categories = useMemo(() => {
    const uniqueCategories = new Set<ProPerk["category"]>(perks.map((perk) => perk.category));
    const uniqueCategories = new Set<ProPerk["category"]>(perks.map((perk) => perk.category));
    const baseCategory = {
    const baseCategory = {
@@ -222,113 +216,111 @@ export function ProPerks({ userTier = "pro" }: ProPerksProps) {


  const affiliateCount = useMemo(
  const affiliateCount = useMemo(
    () => perks.filter((perk) => perk.category === "affiliate").length,
    () => perks.filter((perk) => perk.category === "affiliate").length,
    [perks]
    [perks]
  );
  );


  const applicationRequiredCount = useMemo(
  const applicationRequiredCount = useMemo(
    () => perks.filter((perk) => perk.status === "application-required").length,
    () => perks.filter((perk) => perk.status === "application-required").length,
    [perks]
    [perks]
  );
  );


  const availableNowCount = useMemo(
  const availableNowCount = useMemo(
    () => perks.filter((perk) => perk.status === "available").length,
    () => perks.filter((perk) => perk.status === "available").length,
    [perks]
    [perks]
  );
  );


  const ensureInstructions = useCallback(async (perk: ProPerk) => {
  const ensureInstructions = useCallback(async (perk: ProPerk) => {
    if (instructionsByPerk[perk.id]) {
    if (instructionsByPerk[perk.id]) {
      return;
      return;
    }
    }


    if (typeof window === "undefined") {
    if (typeof window === "undefined") {
      return;
      return;
    }
    }


    const token = window.localStorage.getItem("authToken");
    if (!token) {
      toast({
        title: "Sign in required",
        description: "Log in with your Pro account to view detailed signup steps.",
        variant: "destructive"
      });
      return;
    }

    try {
    try {
      setInstructionsLoading(perk.id);
      setInstructionsLoading(perk.id);
      const response = await fetch(`/api/pro-resources/${perk.id}/signup-instructions`, {
      const response = await fetch(`/api/pro-resources/${perk.id}/signup-instructions`, {
        headers: { Authorization: `Bearer ${token}` }
        credentials: 'include'
      });
      });


      if (response.status === 401 || response.status === 403) {
        toast({
          title: "Sign in required",
          description: "Log in with your Pro account to view detailed signup steps.",
          variant: "destructive"
        });
        return;
      }

      if (!response.ok) {
      if (!response.ok) {
        throw new Error("Failed to load signup instructions");
        throw new Error("Failed to load signup instructions");
      }
      }


      const payload = await response.json() as { instructions: SignupInstructions };
      const payload = await response.json() as { instructions: SignupInstructions };
      setInstructionsByPerk((previous) => ({
      setInstructionsByPerk((previous) => ({
        ...previous,
        ...previous,
        [perk.id]: payload.instructions
        [perk.id]: payload.instructions
      }));
      }));
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Unable to load instructions",
        title: "Unable to load instructions",
        description: error instanceof Error ? error.message : "Unexpected error loading perk guidance.",
        description: error instanceof Error ? error.message : "Unexpected error loading perk guidance.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    } finally {
    } finally {
      setInstructionsLoading(null);
      setInstructionsLoading(null);
    }
    }
  }, [instructionsByPerk, toast]);
  }, [instructionsByPerk, toast]);


  const handleOpenPerk = useCallback((perk: ProPerk) => {
  const handleOpenPerk = useCallback((perk: ProPerk) => {
    setSelectedPerk(perk);
    setSelectedPerk(perk);
    void ensureInstructions(perk);
    void ensureInstructions(perk);
  }, [ensureInstructions]);
  }, [ensureInstructions]);


  const handleGenerateReferral = useCallback(async (perk: ProPerk) => {
  const handleGenerateReferral = useCallback(async (perk: ProPerk) => {
    if (typeof window === "undefined") {
    if (typeof window === "undefined") {
      return;
      return;
    }
    }


    const token = window.localStorage.getItem("authToken");
    if (!token) {
      toast({
        title: "Sign in required",
        description: "Log in with your Pro account to generate referral codes.",
        variant: "destructive"
      });
      return;
    }

    try {
    try {
      setReferralLoading(perk.id);
      setReferralLoading(perk.id);
      const response = await fetch(`/api/pro-resources/${perk.id}/referral-code`, {
      const response = await fetch(`/api/pro-resources/${perk.id}/referral-code`, {
        method: "POST",
        method: "POST",
        headers: { Authorization: `Bearer ${token}` }
        credentials: 'include'
      });
      });


      if (response.status === 401 || response.status === 403) {
        toast({
          title: "Sign in required",
          description: "Log in with your Pro account to generate referral codes.",
          variant: "destructive"
        });
        return;
      }

      if (!response.ok) {
      if (!response.ok) {
        throw new Error("Failed to generate referral code");
        throw new Error("Failed to generate referral code");
      }
      }


      const payload = await response.json() as { referralCode: string };
      const payload = await response.json() as { referralCode: string };
      setReferralCodes((previous) => ({
      setReferralCodes((previous) => ({
        ...previous,
        ...previous,
        [perk.id]: payload.referralCode
        [perk.id]: payload.referralCode
      }));
      }));


      if (window.navigator && window.navigator.clipboard) {
      if (window.navigator && window.navigator.clipboard) {
        await window.navigator.clipboard.writeText(payload.referralCode);
        await window.navigator.clipboard.writeText(payload.referralCode);
        toast({
        toast({
          title: "Referral Code Generated",
          title: "Referral Code Generated",
          description: `Code "${payload.referralCode}" copied to clipboard!`,
          description: `Code "${payload.referralCode}" copied to clipboard!`,
        });
        });
      } else {
      } else {
        toast({
        toast({
          title: "Referral Code Generated",
          title: "Referral Code Generated",
          description: `Your code: ${payload.referralCode}`,
          description: `Your code: ${payload.referralCode}`,
        });
        });
      }
      }
    } catch (error) {
    } catch (error) {
      toast({
      toast({
        title: "Unable to generate referral",
        title: "Unable to generate referral",
client/src/components/social-auth.tsx
+1-3
@@ -44,53 +44,51 @@ export function SocialAuth({ onSuccess, isLoading = false }: SocialAuthProps) {
    handler?: () => Promise<void>;
    handler?: () => Promise<void>;
    recommended?: boolean;
    recommended?: boolean;
    popular?: boolean;
    popular?: boolean;
  }
  }


  const socialProviders: SocialProvider[] = [
  const socialProviders: SocialProvider[] = [
    {
    {
      id: 'google',
      id: 'google',
      name: 'Google',
      name: 'Google',
      icon: <FaGoogle className="h-5 w-5" />,
      icon: <FaGoogle className="h-5 w-5" />,
      color: 'bg-red-500 hover:bg-red-600',
      color: 'bg-red-500 hover:bg-red-600',
      description: 'Fast & secure with Google',
      description: 'Fast & secure with Google',
      url: '/api/auth/google',
      url: '/api/auth/google',
      popular: true
      popular: true
    },
    },
    {
    {
      id: 'reddit',
      id: 'reddit',
      name: 'Reddit',
      name: 'Reddit',
      icon: <FaReddit className="h-5 w-5" />,
      icon: <FaReddit className="h-5 w-5" />,
      color: 'bg-orange-500 hover:bg-orange-600',
      color: 'bg-orange-500 hover:bg-orange-600',
      description: 'Perfect for content creators',
      description: 'Perfect for content creators',
      url: '', // Handled in handleSocialAuth
      url: '', // Handled in handleSocialAuth
      handler: async () => {
      handler: async () => {
        try {
        try {
          const response = await fetch('/api/reddit/connect', {
          const response = await fetch('/api/reddit/connect', {
            headers: {
            credentials: 'include'
              'Authorization': `Bearer ${localStorage.getItem('token')}`
            }
          });
          });
          const data = await response.json();
          const data = await response.json();
          if (data.authUrl) {
          if (data.authUrl) {
            window.location.href = data.authUrl;
            window.location.href = data.authUrl;
          }
          }
        } catch (error) {
        } catch (error) {
          console.error('Failed to connect Reddit:', error);
          console.error('Failed to connect Reddit:', error);
        }
        }
      },
      },
      recommended: true
      recommended: true
    },
    },
    {
    {
      id: 'facebook',
      id: 'facebook',
      name: 'Facebook',
      name: 'Facebook',
      icon: <FaFacebook className="h-5 w-5" />,
      icon: <FaFacebook className="h-5 w-5" />,
      color: 'bg-blue-600 hover:bg-blue-700',
      color: 'bg-blue-600 hover:bg-blue-700',
      description: 'Connect with Facebook',
      description: 'Connect with Facebook',
      url: '/api/auth/facebook'
      url: '/api/auth/facebook'
    }
    }
  ];
  ];


  const handleSocialAuth = async (provider: typeof socialProviders[0]) => {
  const handleSocialAuth = async (provider: typeof socialProviders[0]) => {
    setLoadingProvider(provider.id);
    setLoadingProvider(provider.id);
    
    
    try {
    try {
client/src/components/trending-tags.tsx
+1-2
@@ -7,53 +7,52 @@ import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@
import { TrendingUp, Hash, Sparkles, Copy, Check, Search, Clock, Filter } from 'lucide-react';
import { TrendingUp, Hash, Sparkles, Copy, Check, Search, Clock, Filter } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useToast } from '@/hooks/use-toast';
import { useQuery } from '@tanstack/react-query';
import { useQuery } from '@tanstack/react-query';


interface TrendingTag {
interface TrendingTag {
  tag: string;
  tag: string;
  posts: number;
  posts: number;
  growth: string;
  growth: string;
  subreddit: string;
  subreddit: string;
  heat: 'hot' | 'warm' | 'rising' | 'stable';
  heat: 'hot' | 'warm' | 'rising' | 'stable';
  category: string;
  category: string;
  rank: number;
  rank: number;
}
}


export function TrendingTags() {
export function TrendingTags() {
  const [copiedTag, setCopiedTag] = useState<string | null>(null);
  const [copiedTag, setCopiedTag] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [timeRange, setTimeRange] = useState("24h");
  const [timeRange, setTimeRange] = useState("24h");
  const [categoryFilter, setCategoryFilter] = useState("all");
  const [categoryFilter, setCategoryFilter] = useState("all");
  const { toast } = useToast();
  const { toast } = useToast();


  // Fetch real trending tags from API
  // Fetch real trending tags from API
  const { data: trendingData, isLoading } = useQuery({
  const { data: trendingData, isLoading } = useQuery({
    queryKey: ['trending-tags', timeRange, categoryFilter],
    queryKey: ['trending-tags', timeRange, categoryFilter],
    queryFn: async () => {
    queryFn: async () => {
      const token = localStorage.getItem('authToken');
      const response = await fetch(`/api/trending-tags?timeRange=${timeRange}&category=${categoryFilter}`, {
      const response = await fetch(`/api/trending-tags?timeRange=${timeRange}&category=${categoryFilter}`, {
        headers: token ? { 'Authorization': `Bearer ${token}` } : {}
        credentials: 'include'
      });
      });
      if (!response.ok) {
      if (!response.ok) {
        throw new Error('Failed to fetch trending tags');
        throw new Error('Failed to fetch trending tags');
      }
      }
      return response.json();
      return response.json();
    }
    }
  });
  });


  const lastUpdateTime = trendingData?.lastUpdated ? 
  const lastUpdateTime = trendingData?.lastUpdated ? 
    new Date(trendingData.lastUpdated).toLocaleString('en-US', { 
    new Date(trendingData.lastUpdated).toLocaleString('en-US', { 
      hour: 'numeric', 
      hour: 'numeric', 
      minute: '2-digit', 
      minute: '2-digit', 
      hour12: true 
      hour12: true 
    }) : 'Never';
    }) : 'Never';


  const allTrendingTags: TrendingTag[] = trendingData?.tags || [];
  const allTrendingTags: TrendingTag[] = trendingData?.tags || [];


  // Filter tags based on search and category
  // Filter tags based on search and category
  const filteredTags = allTrendingTags.filter(item => {
  const filteredTags = allTrendingTags.filter(item => {
    const matchesSearch = searchTerm === "" || 
    const matchesSearch = searchTerm === "" || 
      item.tag.toLowerCase().includes(searchTerm.toLowerCase()) ||
      item.tag.toLowerCase().includes(searchTerm.toLowerCase()) ||
      item.subreddit.toLowerCase().includes(searchTerm.toLowerCase());
      item.subreddit.toLowerCase().includes(searchTerm.toLowerCase());
    
    
    const matchesCategory = categoryFilter === "all" || item.category === categoryFilter;
    const matchesCategory = categoryFilter === "all" || item.category === categoryFilter;
    
    
client/src/components/unified-content-creator.tsx
+3-7
@@ -210,58 +210,54 @@ export function UnifiedContentCreator({
      const data = _data as Record<string, string | string[] | unknown>; // Type assertion for mutation data
      const data = _data as Record<string, string | string[] | unknown>; // Type assertion for mutation data
      // Use FormData for unified endpoint that handles both text and images
      // Use FormData for unified endpoint that handles both text and images
      const formData = new FormData();
      const formData = new FormData();


      // Set mode based on workflow
      // Set mode based on workflow
      if (workflowMode === 'image' && imageFile) {
      if (workflowMode === 'image' && imageFile) {
        formData.append('mode', 'image');
        formData.append('mode', 'image');
        formData.append('image', imageFile);
        formData.append('image', imageFile);
      } else {
      } else {
        formData.append('mode', 'text');
        formData.append('mode', 'text');
        formData.append('prompt', String(data.customPrompt || data.prompt || ''));
        formData.append('prompt', String(data.customPrompt || data.prompt || ''));
      }
      }


      // Add common parameters
      // Add common parameters
      formData.append('platform', String(data.platform || platform));
      formData.append('platform', String(data.platform || platform));
      formData.append('style', String(data.style || 'playful'));
      formData.append('style', String(data.style || 'playful'));
      formData.append('theme', String(data.theme || ''));
      formData.append('theme', String(data.theme || ''));
      formData.append('includePromotion', String(data.allowsPromotion === 'high'));
      formData.append('includePromotion', String(data.allowsPromotion === 'high'));
      formData.append('customInstructions', String(data.customPrompt || ''));
      formData.append('customInstructions', String(data.customPrompt || ''));
      formData.append('photoType', String(data.photoType || selectedPhotoType));
      formData.append('photoType', String(data.photoType || selectedPhotoType));
      formData.append('textTone', String(data.textTone || selectedTextTone));
      formData.append('textTone', String(data.textTone || selectedTextTone));
      formData.append('hashtags', Array.isArray(data.hashtags) ? data.hashtags.join(',') : selectedHashtags.join(','));
      formData.append('hashtags', Array.isArray(data.hashtags) ? data.hashtags.join(',') : selectedHashtags.join(','));




      // Send to unified endpoint  
      // Send to unified endpoint  
      const token = localStorage.getItem('authToken');
      
      const response = await fetch('/api/generate-unified', {
      const response = await fetch('/api/generate-unified', {
        method: 'POST',
        method: 'POST',
        headers: {
        body: formData,
          'Authorization': `Bearer ${token || ''}`,
        credentials: 'include'
        },
        body: formData
      });
      });


      if (!response.ok) {
      if (!response.ok) {
        const error = await response.json();
        const error = await response.json();
        throw new Error(error.message || 'Failed to generate content');
        throw new Error(error.message || 'Failed to generate content');
      }
      }


      return await response.json();
      return await response.json();
    },
    },
    onSuccess: (data) => {
    onSuccess: (data) => {
      // Clear existing content first to ensure overwrite
      // Clear existing content first to ensure overwrite
      setGeneratedContent(null);
      setGeneratedContent(null);
      
      
      // Invalidate user stats to refresh daily generation counter
      // Invalidate user stats to refresh daily generation counter
      queryClient.invalidateQueries({ queryKey: ['/api/user/stats'] });
      queryClient.invalidateQueries({ queryKey: ['/api/user/stats'] });
      
      
      // Ensure proper data structure for display
      // Ensure proper data structure for display
      const displayData: GeneratedContentDisplay = {
      const displayData: GeneratedContentDisplay = {
        ...data,
        ...data,
        titles: Array.isArray(data.titles) ? data.titles : 
        titles: Array.isArray(data.titles) ? data.titles : 
                typeof data.titles === 'string' ? [data.titles] :
                typeof data.titles === 'string' ? [data.titles] :
                data.titles ? Object.values(data.titles).filter(Boolean) : [],
                data.titles ? Object.values(data.titles).filter(Boolean) : [],
        photoInstructions: data.photoInstructions || {}
        photoInstructions: data.photoInstructions || {}
      };
      };


@@ -354,51 +350,51 @@ export function UnifiedContentCreator({
        description: "Failed to protect the image. Please try again.",
        description: "Failed to protect the image. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
      console.error('ImageShield protection failed:', _error);
      console.error('ImageShield protection failed:', _error);
    }
    }
  };
  };


  // Manual protection function for user-triggered protection
  // Manual protection function for user-triggered protection
  const protectCurrentImage = async () => {
  const protectCurrentImage = async () => {
    if (!imageFile) {
    if (!imageFile) {
      toast({
      toast({
        title: "No Image",
        title: "No Image",
        description: "Please upload an image first",
        description: "Please upload an image first",
        variant: "destructive"
        variant: "destructive"
      });
      });
      return;
      return;
    }
    }
    
    
    await applyImageShieldProtection(imageFile);
    await applyImageShieldProtection(imageFile);
  };
  };


  // Download protected image
  // Download protected image
  const downloadCurrentProtectedImage = () => {
  const downloadCurrentProtectedImage = () => {
    if (!protectedImageUrl || !imageFile) return;
    if (!protectedImageUrl || !imageFile) return;
    
    
    fetch(protectedImageUrl)
    fetch(protectedImageUrl, { credentials: 'include' })
      .then(response => response.blob())
      .then(response => response.blob())
      .then(blob => {
      .then(blob => {
        const originalFileName = imageFile.name;
        const originalFileName = imageFile.name;
        const timestamp = new Date().toISOString().slice(0, 10);
        const timestamp = new Date().toISOString().slice(0, 10);
        const filename = `protected_${timestamp}_${originalFileName}`;
        const filename = `protected_${timestamp}_${originalFileName}`;
        downloadProtectedImage(blob, filename);
        downloadProtectedImage(blob, filename);
      })
      })
      .catch(error => {
      .catch(error => {
        toast({
        toast({
          title: "Download Failed",
          title: "Download Failed",
          description: "Failed to download protected image",
          description: "Failed to download protected image",
          variant: "destructive"
          variant: "destructive"
        });
        });
      });
      });
  };
  };


  const handleGenerate = () => {
  const handleGenerate = () => {
    if (!requireAuth("generate content")) return;
    if (!requireAuth("generate content")) return;
    
    
    // Clear existing content before new generation
    // Clear existing content before new generation
    setGeneratedContent(null);
    setGeneratedContent(null);
    
    
    if (workflowMode === 'text') {
    if (workflowMode === 'text') {
      if (!customPrompt.trim()) {
      if (!customPrompt.trim()) {
        toast({
        toast({
client/src/components/unified-landing.tsx
+1-1
@@ -9,51 +9,51 @@ import {
  Shield,
  Shield,
  Brain,
  Brain,
  TrendingUp,
  TrendingUp,
  Users,
  Users,
  CheckCircle,
  CheckCircle,
  Star,
  Star,
  Calendar,
  Calendar,
  Target,
  Target,
  Clock,
  Clock,
  BarChart3,
  BarChart3,
  DollarSign,
  DollarSign,
  Crown,
  Crown,
  Play,
  Play,
  ArrowRight
  ArrowRight
} from "lucide-react";
} from "lucide-react";


export function UnifiedLanding() {
export function UnifiedLanding() {
  const [scrollY, setScrollY] = useState(0);
  const [scrollY, setScrollY] = useState(0);
  const [metrics, setMetrics] = useState<{ creators: number; posts: number; engagement: number } | null>(null);
  const [metrics, setMetrics] = useState<{ creators: number; posts: number; engagement: number } | null>(null);
  const { toast } = useToast();
  const { toast } = useToast();
  
  
  useEffect(() => {
  useEffect(() => {
    const handleScroll = () => setScrollY(window.scrollY);
    const handleScroll = () => setScrollY(window.scrollY);
    window.addEventListener('scroll', handleScroll);
    window.addEventListener('scroll', handleScroll);
    
    
    fetch('/api/metrics')
    fetch('/api/metrics', { credentials: 'include' })
      .then(res => (res.ok ? res.json() : null))
      .then(res => (res.ok ? res.json() : null))
      .then(setMetrics)
      .then(setMetrics)
      .catch(() => {});
      .catch(() => {});
      
      
    return () => window.removeEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);
  }, []);


  const handleTryFeatures = () => {
  const handleTryFeatures = () => {
    toast({
    toast({
      description: "Try our features without signing up!",
      description: "Try our features without signing up!",
    });
    });
  };
  };


  return (
  return (
    <div className="min-h-screen bg-white dark:bg-gray-900">
    <div className="min-h-screen bg-white dark:bg-gray-900">
      {/* Hero Section */}
      {/* Hero Section */}
      <section className="relative overflow-hidden bg-gradient-to-br from-indigo-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900">
      <section className="relative overflow-hidden bg-gradient-to-br from-indigo-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900">
        {/* Background Elements */}
        {/* Background Elements */}
        <div className="absolute inset-0 overflow-hidden">
        <div className="absolute inset-0 overflow-hidden">
          <div 
          <div 
            className="absolute -top-40 -right-32 w-80 h-80 rounded-full bg-gradient-to-br from-purple-400/20 to-pink-400/20 blur-3xl"
            className="absolute -top-40 -right-32 w-80 h-80 rounded-full bg-gradient-to-br from-purple-400/20 to-pink-400/20 blur-3xl"
            style={{ transform: `translate(${scrollY * 0.3}px, ${scrollY * 0.1}px)` }}
            style={{ transform: `translate(${scrollY * 0.3}px, ${scrollY * 0.1}px)` }}
          />
          />
          <div 
          <div 
            className="absolute -bottom-40 -left-32 w-80 h-80 rounded-full bg-gradient-to-br from-blue-400/20 to-cyan-400/20 blur-3xl"
            className="absolute -bottom-40 -left-32 w-80 h-80 rounded-full bg-gradient-to-br from-blue-400/20 to-cyan-400/20 blur-3xl"
client/src/hooks/use-admin-communities.ts
+1-1
@@ -81,51 +81,51 @@ export interface CommunityFilters {
  verificationRequired?: 'all' | 'required' | 'not-required';
  verificationRequired?: 'all' | 'required' | 'not-required';
}
}


export function useAdminCommunities(filters?: CommunityFilters) {
export function useAdminCommunities(filters?: CommunityFilters) {
  const queryParams = new URLSearchParams();
  const queryParams = new URLSearchParams();


  if (filters?.search) {
  if (filters?.search) {
    queryParams.set('search', filters.search);
    queryParams.set('search', filters.search);
  }
  }
  if (filters?.category && filters.category !== 'all') {
  if (filters?.category && filters.category !== 'all') {
    queryParams.set('category', filters.category);
    queryParams.set('category', filters.category);
  }
  }
  if (filters?.promotionAllowed && filters.promotionAllowed !== 'all') {
  if (filters?.promotionAllowed && filters.promotionAllowed !== 'all') {
    queryParams.set('promotionAllowed', filters.promotionAllowed);
    queryParams.set('promotionAllowed', filters.promotionAllowed);
  }
  }
  if (filters?.verificationRequired && filters.verificationRequired !== 'all') {
  if (filters?.verificationRequired && filters.verificationRequired !== 'all') {
    queryParams.set('verificationRequired', filters.verificationRequired === 'required' ? 'true' : 'false');
    queryParams.set('verificationRequired', filters.verificationRequired === 'required' ? 'true' : 'false');
  }
  }


  const queryString = queryParams.toString();
  const queryString = queryParams.toString();
  const url = `/api/admin/communities${queryString ? `?${queryString}` : ''}`;
  const url = `/api/admin/communities${queryString ? `?${queryString}` : ''}`;


  return useQuery<AdminCommunity[]>({
  return useQuery<AdminCommunity[]>({
    queryKey: ['admin-communities', filters],
    queryKey: ['admin-communities', filters],
    queryFn: async () => {
    queryFn: async () => {
      const res = await fetch(url);
      const res = await fetch(url, { credentials: 'include' });
      if (!res.ok) throw new Error('Failed to fetch communities');
      if (!res.ok) throw new Error('Failed to fetch communities');
      const payload = await res.json();
      const payload = await res.json();


      if (Array.isArray(payload)) {
      if (Array.isArray(payload)) {
        return payload as AdminCommunity[];
        return payload as AdminCommunity[];
      }
      }


      if (payload && Array.isArray((payload as { data?: unknown }).data)) {
      if (payload && Array.isArray((payload as { data?: unknown }).data)) {
        return (payload as { data: AdminCommunity[] }).data;
        return (payload as { data: AdminCommunity[] }).data;
      }
      }


      throw new Error('Unexpected response format when loading communities');
      throw new Error('Unexpected response format when loading communities');
    },
    },
  });
  });
}
}


export function useCreateCommunity() {
export function useCreateCommunity() {
  const queryClient = useQueryClient();
  const queryClient = useQueryClient();


  return useMutation({
  return useMutation({
    mutationFn: (payload: CommunityPayload) => 
    mutationFn: (payload: CommunityPayload) => 
      apiRequest('POST', '/api/admin/communities', payload),
      apiRequest('POST', '/api/admin/communities', payload),
    onSuccess: () => {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
    },
client/src/hooks/useAuth.ts
+2-1
@@ -121,47 +121,48 @@ export function useAuth() {
    };
    };
    
    
    // Check cookie auth if we have OAuth redirect params
    // Check cookie auth if we have OAuth redirect params
    if (reddit || error) {
    if (reddit || error) {
      checkCookieAuth();
      checkCookieAuth();
    }
    }
  }, [refetch]);
  }, [refetch]);


  // Quick admin login - development only
  // Quick admin login - development only
  const quickAdminLogin = async () => {
  const quickAdminLogin = async () => {
    if (import.meta.env.MODE !== 'development') {
    if (import.meta.env.MODE !== 'development') {
      throw new Error('Admin backdoor disabled in production');
      throw new Error('Admin backdoor disabled in production');
    }
    }
    
    
    try {
    try {
      const email = import.meta.env.VITE_ADMIN_EMAIL;
      const email = import.meta.env.VITE_ADMIN_EMAIL;
      const password = import.meta.env.VITE_ADMIN_PASSWORD;
      const password = import.meta.env.VITE_ADMIN_PASSWORD;


      if (!email || !password) {
      if (!email || !password) {
        throw new Error('Admin credentials not configured');
        throw new Error('Admin credentials not configured');
      }
      }


      const response = await fetch('/api/auth/login', {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
        body: JSON.stringify({ email, password }),
        credentials: 'include'
      });
      });
      
      
      if (response.ok) {
      if (response.ok) {
        const data = await response.json();
        const data = await response.json();
        login();
        login();
      }
      }
    } catch (error) {
    } catch (error) {
      // Silent fail in production
      // Silent fail in production
    }
    }
  };
  };


  return {
  return {
    user,
    user,
    isLoading,
    isLoading,
    isAuthenticated: !!user,
    isAuthenticated: !!user,
    login,
    login,
    logout,
    logout,
    refetch,
    refetch,
    ...(import.meta.env.MODE === 'development' && { quickAdminLogin })
    ...(import.meta.env.MODE === 'development' && { quickAdminLogin })
  };
  };
}
}
client/src/lib/analytics-tracker.ts
+1-2
@@ -229,52 +229,51 @@ class AnalyticsTracker {
      timestamp: new Date().toISOString(),
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      userAgent: navigator.userAgent,
      url: window.location.href,
      url: window.location.href,
      referrer: document.referrer,
      referrer: document.referrer,
      ...(data as Record<string, unknown>)
      ...(data as Record<string, unknown>)
    };
    };


    this.eventQueue.push(eventData);
    this.eventQueue.push(eventData);


    // Batch send events to reduce server load
    // Batch send events to reduce server load
    if (this.eventQueue.length >= 5) {
    if (this.eventQueue.length >= 5) {
      this.flushEvents();
      this.flushEvents();
    }
    }
  }
  }


  private async flushEvents() {
  private async flushEvents() {
    if (this.eventQueue.length === 0) return;
    if (this.eventQueue.length === 0) return;


    const events = [...this.eventQueue];
    const events = [...this.eventQueue];
    this.eventQueue = [];
    this.eventQueue = [];


    try {
    try {
      await fetch('/api/analytics/events', {
      await fetch('/api/analytics/events', {
        method: 'POST',
        method: 'POST',
        headers: {
        headers: {
          'Content-Type': 'application/json',
          'Content-Type': 'application/json'
          'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
        },
        },
        body: JSON.stringify({ events }),
        body: JSON.stringify({ events }),
        credentials: 'include', // Include session cookies
        credentials: 'include', // Include session cookies
        keepalive: true // Important for events sent during page unload
        keepalive: true // Important for events sent during page unload
      });
      });
    } catch (error) {
    } catch (error) {
      console.warn('Failed to send analytics events:', error);
      console.warn('Failed to send analytics events:', error);
      // Re-queue events on failure
      // Re-queue events on failure
      this.eventQueue.unshift(...events);
      this.eventQueue.unshift(...events);
    }
    }
  }
  }


  private updateActivity() {
  private updateActivity() {
    this.session.lastActivity = Date.now();
    this.session.lastActivity = Date.now();
  }
  }


  private startHeartbeat() {
  private startHeartbeat() {
    this.heartbeatInterval = window.setInterval(() => {
    this.heartbeatInterval = window.setInterval(() => {
      this.updateActivity();
      this.updateActivity();
      this.flushEvents();
      this.flushEvents();
    }, 30000); // Send events every 30 seconds
    }, 30000); // Send events every 30 seconds
  }
  }


  private endSession() {
  private endSession() {
    this.trackPageEnd();
    this.trackPageEnd();
client/src/pages/email-verification.tsx
+3-1
@@ -35,51 +35,53 @@ export default function EmailVerificationPage() {
        'missing_token': 'Verification link is invalid. Please request a new one.',
        'missing_token': 'Verification link is invalid. Please request a new one.',
        'invalid_token': 'Verification link has expired. Please request a new one.',
        'invalid_token': 'Verification link has expired. Please request a new one.',
        'expired_token': 'Verification link has expired. Please request a new one.',
        'expired_token': 'Verification link has expired. Please request a new one.',
        'invalid_token_type': 'Invalid verification link. Please request a new one.',
        'invalid_token_type': 'Invalid verification link. Please request a new one.',
        'user_not_found': 'Account not found. Please sign up first.',
        'user_not_found': 'Account not found. Please sign up first.',
        'verification_failed': 'Verification failed. Please try again or contact support.'
        'verification_failed': 'Verification failed. Please try again or contact support.'
      };
      };
      setErrorMessage(errorMessages[error] || 'Verification failed. Please try again.');
      setErrorMessage(errorMessages[error] || 'Verification failed. Please try again.');
      // Clear URL params
      // Clear URL params
      window.history.replaceState({}, '', '/email-verification');
      window.history.replaceState({}, '', '/email-verification');
      return;
      return;
    }
    }


    // If we have a token, verify it
    // If we have a token, verify it
    if (token) {
    if (token) {
      verifyEmail(token);
      verifyEmail(token);
    } else {
    } else {
      setVerificationStatus('error');
      setVerificationStatus('error');
      setErrorMessage('No verification token provided.');
      setErrorMessage('No verification token provided.');
    }
    }
  }, []);
  }, []);


  const verifyEmail = async (token: string) => {
  const verifyEmail = async (token: string) => {
    try {
    try {
      // The backend expects a GET request with token as query param
      // The backend expects a GET request with token as query param
      const response = await fetch(`/api/auth/verify-email?token=${encodeURIComponent(token)}`);
      const response = await fetch(`/api/auth/verify-email?token=${encodeURIComponent(token)}`, {
        credentials: 'include'
      });
      
      
      if (response.ok) {
      if (response.ok) {
        // Backend will redirect, but in case it returns JSON
        // Backend will redirect, but in case it returns JSON
        setVerificationStatus('success');
        setVerificationStatus('success');
      } else {
      } else {
        const data = await response.json();
        const data = await response.json();
        setVerificationStatus('error');
        setVerificationStatus('error');
        setErrorMessage(data.message || 'Verification failed.');
        setErrorMessage(data.message || 'Verification failed.');
      }
      }
    } catch (_error) {
    } catch (_error) {
      setVerificationStatus('error');
      setVerificationStatus('error');
      setErrorMessage('Network error. Please try again.');
      setErrorMessage('Network error. Please try again.');
    }
    }
  };
  };


  if (verificationStatus === 'loading') {
  if (verificationStatus === 'loading') {
    return (
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
        <Card className="w-full max-w-md">
        <Card className="w-full max-w-md">
          <CardHeader className="text-center">
          <CardHeader className="text-center">
            <div className="flex justify-center mb-4">
            <div className="flex justify-center mb-4">
              <ThottoPilotLogo />
              <ThottoPilotLogo />
            </div>
            </div>
            <CardTitle className="text-2xl font-bold flex items-center justify-center gap-2">
            <CardTitle className="text-2xl font-bold flex items-center justify-center gap-2">
              <Loader2 className="h-6 w-6 animate-spin" />
              <Loader2 className="h-6 w-6 animate-spin" />
client/src/pages/forgot-password.tsx
+2-1
@@ -2,51 +2,52 @@ import { useState } from 'react';
import { useLocation } from 'wouter';
import { useLocation } from 'wouter';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useToast } from '@/hooks/use-toast';
import { useToast } from '@/hooks/use-toast';
import { Mail, Loader2, CheckCircle } from 'lucide-react';
import { Mail, Loader2, CheckCircle } from 'lucide-react';
import { ThottoPilotLogo } from '@/components/thottopilot-logo';
import { ThottoPilotLogo } from '@/components/thottopilot-logo';


export default function ForgotPasswordPage() {
export default function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [emailSent, setEmailSent] = useState(false);
  const [emailSent, setEmailSent] = useState(false);
  const { toast } = useToast();
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [, setLocation] = useLocation();


  const handleSubmit = async (e: React.FormEvent) => {
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    e.preventDefault();
    setIsLoading(true);
    setIsLoading(true);


    try {
    try {
      const res = await fetch('/api/auth/forgot-password', {
      const res = await fetch('/api/auth/forgot-password', {
        method: 'POST',
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
        body: JSON.stringify({ email }),
        credentials: 'include'
      });
      });


      const data = await res.json();
      const data = await res.json();


      if (res.ok) {
      if (res.ok) {
        setEmailSent(true);
        setEmailSent(true);
        toast({
        toast({
          title: "Reset email sent",
          title: "Reset email sent",
          description: "If an account exists with this email, you'll receive reset instructions."
          description: "If an account exists with this email, you'll receive reset instructions."
        });
        });
      } else {
      } else {
        toast({
        toast({
          title: "Error",
          title: "Error",
          description: data.message || "Failed to send reset email",
          description: data.message || "Failed to send reset email",
          variant: "destructive"
          variant: "destructive"
        });
        });
      }
      }
    } catch (_error) {
    } catch (_error) {
      toast({
      toast({
        title: "Error",
        title: "Error",
        description: "Something went wrong. Please try again.",
        description: "Something went wrong. Please try again.",
        variant: "destructive"
        variant: "destructive"
      });
      });
    } finally {
    } finally {
      setIsLoading(false);
      setIsLoading(false);
client/src/utils/error-handler.ts
+6-1
@@ -155,51 +155,56 @@ export function isRetryableError(error: unknown): boolean {
  // Retry network and server errors
  // Retry network and server errors
  if (
  if (
    errorString.includes('network') ||
    errorString.includes('network') ||
    errorString.includes('timeout') ||
    errorString.includes('timeout') ||
    errorString.includes('fetch') ||
    errorString.includes('fetch') ||
    (errorWithStatus?.status && errorWithStatus.status >= 500) ||
    (errorWithStatus?.status && errorWithStatus.status >= 500) ||
    code === 'ECONNRESET' ||
    code === 'ECONNRESET' ||
    code === 'ETIMEDOUT'
    code === 'ETIMEDOUT'
  ) {
  ) {
    return true;
    return true;
  }
  }
  
  
  return false;
  return false;
}
}


/**
/**
 * Enhanced fetch with retry logic
 * Enhanced fetch with retry logic
 */
 */
export async function fetchWithRetry(
export async function fetchWithRetry(
  url: string,
  url: string,
  options: RequestInit = {},
  options: RequestInit = {},
  retryOptions: RetryOptions = {}
  retryOptions: RetryOptions = {}
): Promise<Response> {
): Promise<Response> {
  return retryWithBackoff(
  return retryWithBackoff(
    async () => {
    async () => {
      const response = await fetch(url, options);
      const requestOptions: RequestInit = {
        credentials: 'include',
        ...options,
      };

      const response = await fetch(url, requestOptions);
      
      
      // Throw error for non-OK responses to trigger retry
      // Throw error for non-OK responses to trigger retry
      if (!response.ok && response.status >= 500) {
      if (!response.ok && response.status >= 500) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      }
      
      
      return response;
      return response;
    },
    },
    {
    {
      ...retryOptions,
      ...retryOptions,
      shouldRetry: (error) => {
      shouldRetry: (error) => {
        // Custom retry logic for fetch
        // Custom retry logic for fetch
        if (retryOptions.shouldRetry) {
        if (retryOptions.shouldRetry) {
          return retryOptions.shouldRetry(error);
          return retryOptions.shouldRetry(error);
        }
        }
        return isRetryableError(error);
        return isRetryableError(error);
      }
      }
    }
    }
  );
  );
}
}


/**
/**
 * Error recovery suggestions
 * Error recovery suggestions
 */
 */
export function getErrorRecoverySuggestion(error: unknown): string | null {
export function getErrorRecoverySuggestion(error: unknown): string | null {
