Complete Auth.ts Fix - Add ALL Missing Routes
ADD these routes to server/routes/auth.ts (add them AFTER the logout route):
typescript// Add these imports at the TOP of the file if not present:
import jwt from 'jsonwebtoken';
import { emailService } from '../lib/email-service.js';

// UPDATE the signup route to send verification email:
router.post("/signup", authLimiter, async (req, res) => {
  try {
    const { email, password, username } = req.body;
    
    // Validate password strength
    if (!password || password.length < 8) {
      return res.status(400).json({ message: 'Password must be at least 8 characters' });
    }
    
    // Check if user already exists
    const existingUser = await storage.getUserByEmail(email);
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists with this email' });
    }

    // Hash password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // Create user with emailVerified set to false
    const newUser = await storage.createUser({
      email,
      password: hashedPassword,
      username: username || email.split('@')[0],
      tier: 'free',
      emailVerified: false // IMPORTANT: Set to false initially
    });

    // Generate verification token
    const verificationToken = jwt.sign(
      { 
        email: newUser.email, 
        userId: newUser.id, 
        type: 'email-verification'  // CRITICAL: Include type
      },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' }
    );

    // Send verification email
    try {
      await emailService.sendVerificationEmail(newUser.email, newUser.username, verificationToken);
      console.log('Verification email sent to:', newUser.email);
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError);
      // Continue anyway - user can request resend
    }

    // Generate JWT token for immediate login (optional)
    const token = createToken(newUser);

    // Remove password from response
    const { password: _, ...userResponse } = newUser;

    res.status(201).json({
      message: 'User created successfully. Please check your email to verify your account.',
      token,
      user: userResponse,
      emailSent: true
    });
  } catch (error) {
    logger.error('Signup error:', error);
    res.status(500).json({ message: 'Error creating user' });
  }
});

// ADD ALL THESE NEW ROUTES AFTER THE LOGOUT ROUTE:

// Email verification route
router.get("/verify-email", async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      console.log('No token provided for email verification');
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=missing_token`);
    }

    console.log('Processing email verification token...');

    // Verify and decode the token
    let decoded: unknown;
    try {
      decoded = jwt.verify(token as string, process.env.JWT_SECRET!);
      console.log('Token decoded successfully for email:', decoded.email);
    } catch (error) {
      console.error('Token verification failed:', error);
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=invalid_token`);
    }

    // Check token type
    if (decoded.type !== 'email-verification') {
      console.error('Invalid token type:', decoded.type);
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=invalid_token_type`);
    }

    // Update user's email verification status
    try {
      const user = await storage.getUserByEmail(decoded.email);
      
      if (!user) {
        console.error('User not found for email:', decoded.email);
        return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=user_not_found`);
      }

      console.log('Found user:', user.email, 'Current verification status:', user.emailVerified);

      // Update the emailVerified field using storage method
      await storage.updateUserEmailVerified(decoded.email, true);

      console.log('Email verified successfully for:', decoded.email);

      // Send welcome email after verification
      try {
        await emailService.sendWelcomeEmail(user.email, user.username);
      } catch (emailError) {
        console.error('Failed to send welcome email:', emailError);
      }

      // Redirect with success message
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?verified=true&email=${encodeURIComponent(decoded.email)}`);
      
    } catch (dbError) {
      console.error('Database update failed:', dbError);
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=verification_failed`);
    }
    
  } catch (error) {
    console.error('Email verification error:', error);
    res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=verification_failed`);
  }
});

// Resend verification email route
router.post("/resend-verification", authLimiter, async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ message: 'Email required' });
    }
    
    const user = await storage.getUserByEmail(email);
    if (!user) {
      // Don't reveal if email exists for security
      return res.json({ message: 'If that email exists, we sent a verification link' });
    }

    if (user.emailVerified) {
      return res.status(400).json({ message: 'Email already verified' });
    }

    const token = jwt.sign(
      { 
        email: user.email, 
        userId: user.id, 
        type: 'email-verification' 
      },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' }
    );

    await emailService.sendVerificationEmail(user.email, user.username, token);

    res.json({ message: 'Verification email sent. Please check your inbox.' });
    
  } catch (error) {
    logger.error('Resend verification error:', error);
    res.status(500).json({ message: 'Error sending verification email' });
  }
});

// Request password reset route
router.post("/request-password-reset", authLimiter, async (req, res) => {
  try {
    const { email } = req.body;
    
    console.log('ðŸ” Password reset request received for:', email);
    console.log('ðŸ” SENDGRID_API_KEY exists:', !!process.env.SENDGRID_API_KEY);
    console.log('ðŸ” Email service configured:', emailService.isEmailServiceConfigured);
    
    const user = await storage.getUserByEmail(email);
    if (!user) {
      console.log('ðŸ” User not found for email:', email);
      // Don't reveal if email exists
      return res.json({ message: 'If that email exists, we sent a reset link' });
    }

    console.log('ðŸ” User found:', user.username);

    // Send password reset email (token is generated inside the email service)
    await emailService.sendPasswordResetEmail(user.email, user.username);

    res.json({ message: 'Password reset email sent' });
    
  } catch (error) {
    logger.error('Password reset request error:', error);
    res.status(500).json({ message: 'Error sending reset email' });
  }
});

// Verify reset token route
router.post("/verify-reset-token", async (req, res) => {
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.status(400).json({ message: 'Token required' });
    }
    
    const decoded = jwt.verify(decodeURIComponent(token), process.env.JWT_SECRET!) as any;
    
    if (decoded.type !== 'password-reset') {
      return res.status(400).json({ message: 'Invalid token type' });
    }
    
    res.json({ valid: true, email: decoded.email });
  } catch (error) {
    res.status(400).json({ message: 'Invalid or expired token' });
  }
});

// Complete password reset route
router.post("/complete-reset", async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    
    // Validate password strength
    if (!newPassword || newPassword.length < 8) {
      return res.status(400).json({ message: 'Password must be at least 8 characters' });
    }
    
    const decoded = jwt.verify(decodeURIComponent(token), process.env.JWT_SECRET!) as any;
    
    if (decoded.type !== 'password-reset') {
      return res.status(400).json({ message: 'Invalid reset token' });
    }
    
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    
    // Update password and mark email as verified
    await storage.updateUserPassword(decoded.email, hashedPassword);
    await storage.updateUserEmailVerified(decoded.email, true);
    
    res.json({ message: 'Password reset successful' });
    
  } catch (error) {
    logger.error('Password reset error:', error);
    res.status(400).json({ message: 'Invalid or expired token' });
  }
});

// Change password route (for logged-in users)
router.post("/change-password", async (req: unknown, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const token = authHeader.substring(7);
    const { verifyToken } = await import('../middleware/auth.js');
    const decoded = verifyToken(token) as any;
    
    const userId = decoded.userId || decoded.id;
    const { currentPassword, newPassword } = req.body;
    
    if (!newPassword || newPassword.length < 8) {
      return res.status(400).json({ message: 'New password must be at least 8 characters' });
    }
    
    const user = await storage.getUser(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Verify current password
    const validPassword = await bcrypt.compare(currentPassword, user.password);
    if (!validPassword) {
      return res.status(400).json({ message: 'Current password is incorrect' });
    }
    
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await storage.updateUserPassword(user.email, hashedPassword);
    
    res.json({ message: 'Password changed successfully' });
  } catch (error) {
    logger.error('Change password error:', error);
    res.status(500).json({ message: 'Error changing password' });
  }
});

// TEMPORARY DEBUG ROUTES (remove in production)
router.get("/debug/check-email/:email", async (req, res) => {
  try {
    const { email } = req.params;
    const user = await storage.getUserByEmail(decodeURIComponent(email));
    
    if (!user) {
      return res.json({ error: 'User not found' });
    }
    
    res.json({
      email: user.email,
      emailVerified: user.emailVerified,
      username: user.username,
      createdAt: user.createdAt
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to check email status' });
  }
});

router.post("/debug/force-verify", async (req, res) => {
  try {
    const { email } = req.body;
    
    await storage.updateUserEmailVerified(email, true);
    
    res.json({ 
      success: true, 
      message: 'Email verified successfully'
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to verify email' });
  }
});
Also UPDATE server/auth.ts login handler to include better error:
Find the email verification check in server/auth.ts and update it:
typescript// Check email verification
if (!user.emailVerified) {
  return res.status(403).json({ 
    message: 'Email not verified. Please check your email or resend verification.',
    code: 'EMAIL_NOT_VERIFIED',
    email: user.email // Include email for resend option
  });
}