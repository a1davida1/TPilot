diff --git a/tests/routes/caption-generation.test.ts b/tests/routes/caption-generation.test.ts
index 5770fb737acb5e4b9a524eab4fa26ebd2b85b10b..c1064d69104bafdd8fb713b2f3ba33f56e2eac76 100644
--- a/tests/routes/caption-generation.test.ts
+++ b/tests/routes/caption-generation.test.ts
@@ -1,53 +1,56 @@
-import { describe, it, expect, beforeEach, vi } from 'vitest';
+import { describe, it, expect, beforeEach, vi, type Mock } from 'vitest';
 import { pipeline } from '../../server/caption/geminiPipeline.js';
-import { pipelineRewrite } from '../../server/caption/rewritePipeline.js';
+import { pipelineRewrite, extractKeyEntities } from '../../server/caption/rewritePipeline.js';
 import { pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';
 
 // Mock dependencies
 vi.mock('../../server/lib/gemini.js', () => ({
   textModel: {
     generateContent: vi.fn(),
   },
   visionModel: {
     generateContent: vi.fn(),
   },
 }));
 
 vi.mock('../../server/caption/openaiFallback.js', () => ({
   openAICaptionFallback: vi.fn().mockResolvedValue({
     caption: 'Fallback caption',
     hashtags: ['#fallback1', '#fallback2', '#fallback3'],
     safety_level: 'normal',
     alt: 'Fallback alt text that is sufficiently long',
     mood: 'neutral',
     style: 'informative',
     cta: 'Check this out',
     nsfw: false,
   }),
 }));
 
+const asMock = <T extends (...args: unknown[]) => unknown>(fn: T) =>
+  fn as unknown as Mock<Parameters<T>, ReturnType<T>>;
+
 vi.mock('../../server/storage.ts', () => ({
   storage: {
     getUserById: vi.fn(),
     createContentGeneration: vi.fn(),
     updateContentGeneration: vi.fn(),
   },
 }));
 
 describe('Caption Generation', () => {
   beforeEach(() => {
     vi.clearAllMocks();
   });
 
   describe('Gemini Pipeline', () => {
     it('should handle image-based caption generation', async () => {
       const mockImageUrl =
         'data:image/jpeg;base64,' +
         '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAAAAAAAAAAAAAAAAAACP/EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAD8Af//Z';
       const mockPlatform = 'instagram';
       const mockVoice = 'flirty_playful';
 
       // Mock successful responses
       const mockFactsResponse = {
         response: {
           text: () => JSON.stringify({
diff --git a/tests/routes/caption-generation.test.ts b/tests/routes/caption-generation.test.ts
index 5770fb737acb5e4b9a524eab4fa26ebd2b85b10b..c1064d69104bafdd8fb713b2f3ba33f56e2eac76 100644
--- a/tests/routes/caption-generation.test.ts
+++ b/tests/routes/caption-generation.test.ts
@@ -76,144 +79,250 @@ describe('Caption Generation', () => {
         },
       };
 
       const mockRankResponse = {
         response: {
           text: () =>
             JSON.stringify({
               winner_index: 0,
               scores: [5, 4, 3, 2, 1],
               reason: 'Selected based on engagement potential',
               final: {
                 caption: 'Feeling gorgeous tonight ✨',
                 hashtags: ['#lingerie', '#confidence', '#style'],
                 safety_level: 'spicy_safe',
                 mood: 'confident',
                 style: 'authentic',
                 cta: 'What do you think?',
                 alt: 'A glamorous example alt text to satisfy schema',
                 nsfw: false,
               },
             }),
         },
       };
 
       const { textModel, visionModel } = await import('../../server/lib/gemini.js');
-      (visionModel.generateContent as any).mockResolvedValueOnce(mockFactsResponse);
-      (textModel.generateContent as any)
+      const visionGenerateMock = asMock(visionModel.generateContent);
+      visionGenerateMock.mockResolvedValueOnce(mockFactsResponse);
+      const textGenerateMock = asMock(textModel.generateContent);
+      textGenerateMock
         .mockResolvedValueOnce(mockVariantsResponse)
         .mockResolvedValueOnce(mockRankResponse);
 
       const result = await pipeline({
         imageUrl: mockImageUrl,
         platform: mockPlatform,
         voice: mockVoice,
       });
 
       const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');
 
       expect(openAICaptionFallback).not.toHaveBeenCalled();
       expect(result.final).toMatchObject({
         caption: expect.any(String),
         safety_level: expect.stringMatching(/safe|low|spicy_safe/),
       });
     });
 
     it('should handle safety level normalization', async () => {
       const mockResponse = {
         response: {
           text: () => JSON.stringify([
             {
               caption: 'Test caption',
               hashtags: ['#test'],
               safety_level: 'spicy_safe', // Should be normalized to spicy_safe
               mood: 'confident',
               style: 'authentic',
               cta: 'Check it out',
             },
           ]),
         },
       };
 
       const { textModel } = await import('../../server/lib/gemini.js');
-      (textModel.generateContent as any).mockResolvedValue(mockResponse);
+      const textGenerateMock = asMock(textModel.generateContent);
+      textGenerateMock.mockResolvedValue(mockResponse);
 
       // This would normally be called as part of the pipeline
       const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
       const result = await generateVariants({
         platform: 'instagram',
         voice: 'flirty_playful',
         facts: { objects: ['test'] },
       });
 
       expect(result[0].safety_level).toBe('spicy_safe');
     });
   });
 
   describe('Text-Only Pipeline', () => {
     it('should generate content without image context', async () => {
       const mockResponse = {
         response: {
           text: () => JSON.stringify([
             {
               caption: 'Motivational content for today!',
               hashtags: ['#motivation', '#mindset'],
               safety_level: 'normal',
               mood: 'inspiring',
               style: 'authentic',
               cta: 'What motivates you?',
             },
           ]),
         },
       };
 
       const { textModel } = await import('../../server/lib/gemini.js');
-      (textModel.generateContent as any).mockResolvedValue(mockResponse);
+      const textGenerateMock = asMock(textModel.generateContent);
+      textGenerateMock.mockResolvedValue(mockResponse);
 
       const result = await pipelineTextOnly({
         platform: 'instagram',
         voice: 'inspiring',
         theme: 'motivation',
         context: 'morning motivation post',
       });
 
       expect(result.final).toMatchObject({
         caption: expect.stringContaining('Motivational'),
         safety_level: 'normal',
       });
     });
   });
 
   describe('Rewrite Pipeline', () => {
     it('should improve existing captions', async () => {
       const existingCaption = 'Basic caption here';
       const mockResponse = {
         response: {
           text: () => JSON.stringify([
             {
               caption: 'Enhanced and engaging caption! ✨',
               hashtags: ['#enhanced', '#content'],
               safety_level: 'normal',
               mood: 'engaging',
               style: 'authentic',
               cta: 'What do you think?',
             },
           ]),
         },
       };
 
       const { textModel } = await import('../../server/lib/gemini.js');
-      const genSpy = vi.spyOn(textModel, 'generateContent').mockResolvedValue(mockResponse as any);
+      const textGenerateMock = asMock(textModel.generateContent);
+      textGenerateMock.mockResolvedValue(mockResponse);
 
       const result = await pipelineRewrite({
         platform: 'instagram',
         voice: 'engaging',
         existingCaption,
       });
 
       expect(result.final.caption).not.toBe(existingCaption);
       expect(result.final.caption).toContain('Enhanced');
 
-      genSpy.mockRestore();
+      textGenerateMock.mockReset();
+    });
+
+    it('retries when mandatory tokens are dropped', async () => {
+      const existingCaption = 'Launch day! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ #LaunchDay';
+      const variantFactory = (caption: string) => ({
+        caption,
+        hashtags: ['#LaunchDay', '#EventTime', '#RSVPNow'],
+        safety_level: 'normal',
+        mood: 'excited',
+        style: 'authentic',
+        cta: 'Reserve your spot',
+        alt: 'Detailed alt text describing the MegaCorp launch announcement in a complete sentence.',
+        nsfw: false,
+      });
+
+      const missingVariants = {
+        response: {
+          text: () => JSON.stringify(
+            Array.from({ length: 5 }, (_, index) =>
+              variantFactory(`Variant ${index + 1} without mandatory tokens`)
+            )
+          ),
+        },
+      };
+
+      const missingRank = {
+        response: {
+          text: () => JSON.stringify({
+            winner_index: 0,
+            scores: [5, 4, 3, 2, 1],
+            reason: 'Initial selection missing mandatory tokens',
+            final: variantFactory('Variant 1 without mandatory tokens'),
+          }),
+        },
+      };
+
+      const enforcedCaption = 'Launch day! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ #LaunchDay — limited seats!';
+      const enforcedVariants = {
+        response: {
+          text: () => JSON.stringify(
+            Array.from({ length: 5 }, (_, index) =>
+              variantFactory(`${enforcedCaption} Option ${index + 1}`)
+            )
+          ),
+        },
+      };
+
+      const enforcedRank = {
+        response: {
+          text: () => JSON.stringify({
+            winner_index: 0,
+            scores: [5, 4, 3, 2, 1],
+            reason: 'Retry keeps mandatory tokens',
+            final: variantFactory(enforcedCaption),
+          }),
+        },
+      };
+
+      const { textModel } = await import('../../server/lib/gemini.js');
+      const textGenerateMock = asMock(textModel.generateContent);
+      textGenerateMock
+        .mockResolvedValueOnce(missingVariants)
+        .mockResolvedValueOnce(missingRank)
+        .mockResolvedValueOnce(enforcedVariants)
+        .mockResolvedValueOnce(enforcedRank);
+
+      const result = await pipelineRewrite({
+        platform: 'instagram',
+        voice: 'engaging',
+        existingCaption,
+      });
+
+      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');
+      expect(openAICaptionFallback).not.toHaveBeenCalled();
+      expect(textGenerateMock).toHaveBeenCalledTimes(4);
+      expect(result.final.caption).toContain('https://example.com/launch');
+      expect(result.final.caption).toContain('@LaunchHQ');
+      expect(result.final.caption).toContain('#LaunchDay');
+      expect(result.final.caption).toContain('12/25');
+      expect(result.final.caption).toContain('"Mega Launch"');
+      expect(result.final.caption).toContain('MegaCorp™');
+
+      textGenerateMock.mockReset();
     });
   });
-});
+});
+
+describe('extractKeyEntities', () => {
+  it('captures urls, handles, hashtags, numbers, quotes, and branded terms', () => {
+    const caption = 'Launch day 2024! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ and NASA #LaunchDay';
+    const entities = extractKeyEntities(caption);
+
+    expect(entities).toEqual([
+      '2024',
+      'https://example.com/launch',
+      '@LaunchHQ',
+      '12/25',
+      '"Mega Launch"',
+      'MegaCorp™',
+      'NASA',
+      '#LaunchDay',
+    ]);
+  });
+});
