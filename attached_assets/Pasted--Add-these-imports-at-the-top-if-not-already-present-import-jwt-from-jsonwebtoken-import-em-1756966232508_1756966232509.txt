// Add these imports at the top if not already present
import jwt from 'jsonwebtoken';
import { emailService } from '../lib/email-service.js';

// After your existing login route (around line 100), ADD all these routes:

// Email verification route
router.get("/verify-email", async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      return res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=missing_token`);
    }

    const decoded = jwt.verify(token as string, process.env.JWT_SECRET!) as any;
    
    await storage.db.user.update({
      where: { email: decoded.email },
      data: { emailVerified: true }
    });
    
    res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?verified=true`);
  } catch (error) {
    logger.error('Email verification error:', error);
    res.redirect(`${process.env.FRONTEND_URL || 'https://thottopilot.com'}/login?error=invalid_token`);
  }
});

// Resend verification email route
router.post("/resend-verification", authLimiter, async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ message: 'Email required' });
    }
    
    const user = await storage.getUserByEmail(email);
    if (!user) {
      return res.json({ message: 'If that email exists, we sent a verification link' });
    }

    if (user.emailVerified) {
      return res.status(400).json({ message: 'Email already verified' });
    }

    const token = jwt.sign(
      { email: user.email, userId: user.id, type: 'email-verification' },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' }
    );

    await emailService.sendVerificationEmail(user.email, user.username, token);

    res.json({ message: 'Verification email sent. Please check your inbox.' });
  } catch (error) {
    logger.error('Resend verification error:', error);
    res.status(500).json({ message: 'Error sending verification email' });
  }
});

// Password reset request route (if missing)
router.post("/request-password-reset", authLimiter, async (req, res) => {
  try {
    const { email } = req.body;
    
    const user = await storage.getUserByEmail(email);
    if (!user) {
      // Don't reveal if email exists
      return res.json({ message: 'If that email exists, we sent a reset link' });
    }

    const resetToken = jwt.sign(
      { email: user.email, type: 'password-reset' },
      process.env.JWT_SECRET!,
      { expiresIn: '1h' }
    );

    await emailService.sendPasswordResetEmail(user.email, user.username);

    res.json({ message: 'Password reset email sent' });
  } catch (error) {
    logger.error('Password reset request error:', error);
    res.status(500).json({ message: 'Error sending reset email' });
  }
});

// Password reset token verification route
router.post("/verify-reset-token", async (req, res) => {
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.status(400).json({ message: 'Token required' });
    }
    
    const decoded = jwt.verify(decodeURIComponent(token), process.env.JWT_SECRET!) as any;
    
    if (decoded.type !== 'password-reset') {
      return res.status(400).json({ message: 'Invalid token type' });
    }
    
    res.json({ valid: true, email: decoded.email });
  } catch (error) {
    res.status(400).json({ message: 'Invalid or expired token' });
  }
});

// Password reset completion route  
router.post("/complete-reset", async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    
    // Validate password strength
    if (!newPassword || newPassword.length < 8) {
      return res.status(400).json({ message: 'Password must be at least 8 characters' });
    }
    
    const decoded = jwt.verify(decodeURIComponent(token), process.env.JWT_SECRET!) as any;
    
    if (decoded.type !== 'password-reset') {
      return res.status(400).json({ message: 'Invalid reset token' });
    }
    
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    
    await storage.db.user.update({
      where: { email: decoded.email },
      data: { 
        password: hashedPassword,
        emailVerified: true // Auto-verify on password reset
      }
    });
    
    res.json({ message: 'Password reset successful' });
  } catch (error) {
    logger.error('Password reset error:', error);
    res.status(400).json({ message: 'Invalid or expired token' });
  }
});

// Change password route (for logged-in users)
router.post("/change-password", async (req: any, res) => {
  try {
    // Check if user is authenticated
    if (!req.user && !req.userId) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const userId = req.user?.id || req.userId;
    const { currentPassword, newPassword } = req.body;
    
    if (!newPassword || newPassword.length < 8) {
      return res.status(400).json({ message: 'New password must be at least 8 characters' });
    }
    
    const user = await storage.getUser(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Verify current password
    const validPassword = await bcrypt.compare(currentPassword, user.password);
    if (!validPassword) {
      return res.status(400).json({ message: 'Current password is incorrect' });
    }
    
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    
    await storage.db.user.update({
      where: { id: userId },
      data: { password: hashedPassword }
    });
    
    res.json({ message: 'Password changed successfully' });
  } catch (error) {
    logger.error('Change password error:', error);
    res.status(500).json({ message: 'Error changing password' });
  }
});

// Delete account route
router.delete("/delete-account", async (req: any, res) => {
  try {
    if (!req.user && !req.userId) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const userId = req.user?.id || req.userId;
    const { password } = req.body;
    
    const user = await storage.getUser(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Verify password before deletion
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(400).json({ message: 'Password verification failed' });
    }
    
    // Soft delete - mark as deleted
    await storage.db.user.update({
      where: { id: userId },
      data: { 
        deletedAt: new Date(),
        email: `deleted_${Date.now()}_${user.email}` // Prevent email reuse
      }
    });
    
    res.json({ message: 'Account scheduled for deletion' });
  } catch (error) {
    logger.error('Delete account error:', error);
    res.status(500).json({ message: 'Error deleting account' });
  }
});