 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/api-routes.ts b/server/api-routes.ts
index c7c23d2ca3a7d118f78d4d9ee4925872fdce39cf..000a2c8491fb6dd546a3b76a5b6e75a69702b971 100644
--- a/server/api-routes.ts
+++ b/server/api-routes.ts
@@ -1,38 +1,38 @@
 import type { Express } from "express";
-import { z } from "zod";
+import { z, ZodError } from "zod";
 import { db } from "./db.js";
 import { storage } from "./storage.js";
 import { AiService } from "./lib/ai-service.js";
 import { generateEnhancedContent } from "./services/enhanced-ai-service.js";
 import { AppError, CircuitBreaker } from "./lib/errors.js";
 import { MediaManager } from "./lib/media.js";
 import { CCBillProcessor } from "./lib/billing.js";
 import { PolicyLinter } from "./lib/policyLinter.js";
 import { PostScheduler } from "./lib/scheduling.js";
 import { addJob, QueueNames } from "./lib/queue/index.js";
-import { getErrorMessage } from "./utils/error.js";
+import { getErrorMessage, formatZodError } from "./utils/error.js";
 import { RedditManager } from "./lib/reddit.js";
 import { postJobs, subscriptions, mediaAssets, creatorAccounts, users, userSamples } from "@shared/schema";
 import { eq, desc, sql } from "drizzle-orm";
 import multer from "multer";
 import type { Request, Response, NextFunction } from 'express';
 import { authenticateToken } from './middleware/auth.js';
 
 interface PostingJobPayload {
   userId: number;
   postJobId: number;
   subreddit: string;
   titleFinal: string;
   bodyFinal: string;
   mediaKey?: string;
 }
 
 // Create a proper User type alias from the schema
 type UserType = typeof users.$inferSelect;
 
 // Augment Express namespace to add user property
 declare global {
   namespace Express {
     interface Request {
       user?: UserType;
     }
diff --git a/server/api-routes.ts b/server/api-routes.ts
index c7c23d2ca3a7d118f78d4d9ee4925872fdce39cf..000a2c8491fb6dd546a3b76a5b6e75a69702b971 100644
--- a/server/api-routes.ts
+++ b/server/api-routes.ts
@@ -40,86 +40,102 @@ declare global {
 }
 
 
 // Multer configuration for file uploads
 const upload = multer({
   storage: multer.memoryStorage(),
   limits: {
     fileSize: 50 * 1024 * 1024, // 50MB limit
   },
 });
 
 export function registerApiRoutes(app: Express) {
   
   const aiServiceBreaker = new CircuitBreaker(AiService.generateContent);
   const enhancedContentBreaker = new CircuitBreaker(generateEnhancedContent);
   
   // AI Content Generation
   app.post('/api/ai/generate', authenticateToken, async (req: Request, res, next: NextFunction) => {
     try {
       const schema = z.object({
         prompt: z.string().optional(),
         platforms: z.array(z.string()).min(1),
         styleHints: z.array(z.string()).optional(),
         variants: z.number().min(1).max(5).default(1),
       });
-      const data: z.infer<typeof schema> = schema.parse(req.body);
+      let data: z.infer<typeof schema>;
+      try {
+        data = schema.parse(req.body);
+      } catch (error: unknown) {
+        if (error instanceof ZodError) {
+          return res.status(400).json({ error: formatZodError(error, 'Invalid AI generation request') });
+        }
+        throw error;
+      }
       if (!req.user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       const result = await aiServiceBreaker.call({
         ...data,
         platforms: data.platforms || [],
         userId: req.user.id,
       });
       res.json(result);
     } catch (error: unknown) {
       next(error instanceof AppError ? error : new AppError('AI generation failed', 500));
     }
   });
 
   // Enhanced AI Content Generation
   app.post('/api/ai/enhanced', authenticateToken, async (req: Request, res, next: NextFunction) => {
     try {
       const schema = z.object({
         mode: z.enum(['text', 'image', 'hybrid']).default('text'),
         prompt: z.string().optional(),
         imageBase64: z.string().optional(),
         platform: z.enum(['reddit', 'twitter', 'instagram', 'tiktok', 'onlyfans']),
         style: z.enum(['playful', 'mysterious', 'bold', 'elegant', 'confident', 'authentic', 'sassy', 'professional']),
         theme: z.string().optional(),
         tone: z.enum(['casual', 'formal', 'flirty', 'friendly', 'provocative']).optional(),
         contentType: z.enum(['teasing', 'promotional', 'engagement', 'lifestyle', 'announcement', 'educational']).optional(),
         includePromotion: z.boolean().optional(),
         promotionLevel: z.enum(['none', 'subtle', 'moderate', 'direct']).optional(),
         targetAudience: z.enum(['general', 'fans', 'potential-subscribers', 'pro-tier']).optional(),
         customInstructions: z.string().optional(),
         subreddit: z.string().optional(),
         niche: z.string().optional(),
         personalBrand: z.string().optional(),
       });
-      const data: z.infer<typeof schema> = schema.parse(req.body);
+      let data: z.infer<typeof schema>;
+      try {
+        data = schema.parse(req.body);
+      } catch (error: unknown) {
+        if (error instanceof ZodError) {
+          return res.status(400).json({ error: formatZodError(error, 'Invalid enhanced AI request') });
+        }
+        throw error;
+      }
       if (!req.user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       const result = await enhancedContentBreaker.call({
         ...data,
         mode: data.mode || 'text',
         platform: data.platform || 'reddit',
         style: data.style || 'authentic',
         userId: String(req.user.id),
       });
       res.json(result);
     } catch (error: unknown) {
       next(error instanceof AppError ? error : new AppError('Enhanced AI generation failed', 500));
     }
   });
 
   // Media Upload
   app.post('/api/media/upload', authenticateToken, upload.single('file'), async (req: Request, res) => {
     try {
       if (!req.file) {
         return res.status(400).json({ error: 'No file provided' });
       }
 
       if (!req.user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
diff --git a/server/api-routes.ts b/server/api-routes.ts
index c7c23d2ca3a7d118f78d4d9ee4925872fdce39cf..000a2c8491fb6dd546a3b76a5b6e75a69702b971 100644
--- a/server/api-routes.ts
+++ b/server/api-routes.ts
@@ -176,73 +192,89 @@ export function registerApiRoutes(app: Express) {
       const mediaId = parseInt(req.params.id);
 
       const success = await MediaManager.deleteAsset(mediaId, userId);
       
       if (success) {
         res.json({ success: true });
       } else {
         res.status(404).json({ error: 'Media not found' });
       }
     } catch (error: unknown) {
       console.error('Failed to delete media:', error);
       res.status(500).json({ error: getErrorMessage(error) });
     }
   });
 
   // Policy Linting
   app.post('/api/content/lint', async (req, res) => {
     try {
       const schema = z.object({
         subreddit: z.string(),
         title: z.string(),
         body: z.string(),
         hasImage: z.boolean().default(false),
       });
 
-      const data = schema.parse(req.body);
+      let data: z.infer<typeof schema>;
+      try {
+        data = schema.parse(req.body);
+      } catch (error: unknown) {
+        if (error instanceof ZodError) {
+          return res.status(400).json({ error: formatZodError(error, 'Invalid content lint request') });
+        }
+        throw error;
+      }
       const linter = await PolicyLinter.forSubreddit(data.subreddit);
       const result = await linter.lintPost(data.title, data.body, data.hasImage);
 
       res.json(result);
     } catch (error: unknown) {
       console.error('Content linting failed:', error);
       res.status(500).json({ error: getErrorMessage(error) });
     }
   });
 
   // Schedule Post
   app.post('/api/posts/schedule', authenticateToken, async (req, res) => {
     try {
       const schema = z.object({
         subreddit: z.string(),
         title: z.string(),
         body: z.string(),
         mediaKey: z.string().optional(),
         scheduledAt: z.string().datetime().optional(),
       });
 
-      const data = schema.parse(req.body);
+      let data: z.infer<typeof schema>;
+      try {
+        data = schema.parse(req.body);
+      } catch (error: unknown) {
+        if (error instanceof ZodError) {
+          return res.status(400).json({ error: formatZodError(error, 'Invalid post scheduling request') });
+        }
+        throw error;
+      }
       const user = req.user;
       
       if (!user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       
       const userId = user.id;
 
       // Schedule the post
       const scheduledAt = data.scheduledAt 
         ? new Date(data.scheduledAt)
         : await PostScheduler.chooseSendTime(data.subreddit);
 
       // Create post job
       const [postJob] = await db.insert(postJobs).values({
         userId,
         subreddit: data.subreddit,
         titleFinal: data.title,
         bodyFinal: data.body,
         mediaKey: data.mediaKey,
         scheduledAt,
       }).returning();
 
       // Add to queue
       await addJob<PostingJobPayload>('posting' as QueueNames, {
 
EOF
)