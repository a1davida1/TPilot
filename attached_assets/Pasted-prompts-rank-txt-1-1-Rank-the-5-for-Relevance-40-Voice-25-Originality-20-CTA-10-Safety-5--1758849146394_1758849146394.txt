prompts/rank.txt
+1-1
Rank the 5 for Relevance(40), Voice(25), Originality(20), CTA(10), Safety(5). Any option containing banned words (ai, ai-generated, content) must be disqualified and the reason should cite the offending term.
Disqualify any option containing sparkle-filler phrases ("Check out this amazing content", "✨ Enhanced"), stacks of generic hashtags ("#content", "#creative", "#amazing", "#lifestyle"), or canned CTA templates like "Check it out"; call out the specific violations in the reason.
Disqualify any option containing sparkle-filler phrases ("Check out this amazing content", "✨ Enhanced"), stacks of generic hashtags ("#content", "#creative", "#amazing", "#lifestyle"), or canned / repeated CTA templates like "Check it out" or "Link in bio"; explain each concrete violation in the reason.
You receive JSON: {"variants":[...],"retry_hint":string|null,"banned_examples":string[]}.
If retry_hint is provided, obey it strictly, drop the flagged options, and choose the most human alternative.
Return JSON:
{"winner_index":0,"scores":[0,0,0,0,0],"reason":"<240 chars","final":{"caption":"","alt":"","hashtags":[],"cta":"","mood":"","style":"","safety_level":""}}
Trim hashtags to platform limits.
server/caption/__tests__/ranking-integration.test.ts
+75-0
@@ -46,50 +46,62 @@ const scenarios: ScenarioConfig[] = [
];

describe.each(scenarios)('Ranking Integration Tests ($label)', ({ applyGeminiMock }) => {
  let rankAndSelect: (typeof import('../geminiPipeline'))['rankAndSelect'];
  let textModelMock: TextModelMock;

  beforeEach(async () => {
    vi.resetModules();

    vi.doMock('../../lib/prompts', () => ({
      load: vi.fn().mockImplementation((filename: string) => {
        if (filename === 'system.txt') return Promise.resolve('System prompt');
        if (filename === 'guard.txt') return Promise.resolve('Guard prompt');
        if (filename === 'rank.txt') return Promise.resolve('Ranking prompt with violation detection');
        return Promise.resolve('Mock prompt');
      })
    }));

    const { textModelMock: appliedMock } = applyGeminiMock();
    textModelMock = appliedMock;

    ({ rankAndSelect } = await import('../geminiPipeline'));
  });

  describe('rankAndSelect', () => {
    const extractVariantsFromCall = (callIndex: number) => {
      const callArgs = textModelMock.mock.calls[callIndex]?.[0];
      const promptEntry = Array.isArray(callArgs) ? callArgs[0] : undefined;
      const promptText = promptEntry && typeof promptEntry.text === 'string' ? promptEntry.text : '';
      const serialized = promptText.slice(promptText.lastIndexOf('\n') + 1);
      try {
        return JSON.parse(serialized);
      } catch (error) {
        return [];
      }
    };

    it('should sanitize output when AI returns banned content', async () => {
      // Mock AI returning banned content
      const mockBannedResponse = createMockResponse({
        final: {
          caption: 'Check out this amazing content! ✨',
          alt: 'A photo',
          hashtags: ['#content', '#creative', '#amazing'],
          cta: 'Link in bio for more!'
        },
        reason: 'Selected for engagement'
      });

      // Mock successful rerank attempt with clean content
      const mockCleanResponse = createMockResponse({
        final: {
          caption: 'Enjoying the peaceful morning light',
          alt: 'Person in a sunlit room',
          hashtags: ['#morninglight', '#peaceful'],
          cta: 'What\'s your favorite time of day?'
        },
        reason: 'Clean, engaging content'
      });

      textModelMock
        .mockResolvedValueOnce(mockBannedResponse)
@@ -137,50 +149,113 @@ describe.each(scenarios)('Ranking Integration Tests ($label)', ({ applyGeminiMoc
        .mockResolvedValueOnce(mockBannedResponse); // Rerank also fails

      const variants: CaptionItemType[] = [
        {
          caption: "Clean test caption",
          alt: "Clean test alt",
          hashtags: ["#photography"],
          cta: "What do you think?",
          mood: "engaging",
          style: "authentic",
          safety_level: "normal",
          nsfw: false
        }
      ];

      const result = await rankAndSelect(variants, { platform: 'instagram' });

      // Should be sanitized
      expect(result.final.caption).not.toContain('✨');
      expect(result.final.caption).not.toContain('Amazing content');
      expect(result.final.cta).toBe("What do you think?");
      expect(result.final.hashtags).toEqual(["#behindthescenes", "#handcrafted", "#maker", "#creator"]);
      expect(result.reason).toContain('Sanitized');
    });

    it('should drop sparkle-filler winners before reranking', async () => {
      const mockBannedResponse = createMockResponse({
        winner_index: 0,
        final: {
          caption: 'Check out this amazing content! ✨',
          alt: 'Banned alt',
          hashtags: ['#content', '#creative'],
          cta: 'Check it out'
        },
        reason: 'Initial pick'
      });

      const mockHumanResponse = createMockResponse({
        winner_index: 0,
        final: {
          caption: 'Cozy morning tea with a splash of sunlight',
          alt: 'Warm mug near the window',
          hashtags: ['#morningtea'],
          cta: 'How do you start your day?'
        },
        reason: 'Human alternative'
      });

      textModelMock
        .mockResolvedValueOnce(mockBannedResponse)
        .mockResolvedValueOnce(mockHumanResponse);

      const variants: CaptionItemType[] = [
        {
          caption: 'Filler sparkle caption',
          alt: 'Sparkle alt',
          hashtags: ['#content'],
          cta: 'Check it out',
          mood: 'excited',
          style: 'flashy',
          safety_level: 'normal',
          nsfw: false
        },
        {
          caption: 'Cozy morning tea with a splash of sunlight',
          alt: 'Warm mug near the window',
          hashtags: ['#morningtea'],
          cta: 'How do you start your day?',
          mood: 'calm',
          style: 'authentic',
          safety_level: 'normal',
          nsfw: false
        }
      ];

      const result = await rankAndSelect(variants, { platform: 'instagram' });

      expect(result.final.caption).toBe('Cozy morning tea with a splash of sunlight');
      expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
      expect(textModelMock).toHaveBeenCalledTimes(2);

      const firstVariants = extractVariantsFromCall(0);
      const secondVariants = extractVariantsFromCall(1);
      expect(firstVariants).toHaveLength(2);
      expect(secondVariants).toHaveLength(1);
      expect(secondVariants[0]?.caption).toBe('Cozy morning tea with a splash of sunlight');
    });

    it('should preserve clean content without modification', async () => {
      const mockCleanResponse = JSON.stringify({
        final: {
          caption: "Enjoying the peaceful morning in my garden",
          alt: "Person tending to flowers in sunlit garden",
          hashtags: ["#gardening", "#morninglight", "#peaceful"],
          cta: "What's your favorite flower?"
        },
        reason: "Clean, authentic content"
      });

      (textModelMock as ReturnType<typeof vi.fn>).mockResolvedValueOnce(mockCleanResponse);

      const variants: CaptionItemType[] = [
        {
          caption: "Test caption",
          alt: "Test alt", 
          hashtags: ["#test"],
          cta: "Test CTA",
          mood: "engaging",
          style: "authentic",
          safety_level: "normal",
          nsfw: false
        }
      ];
server/caption/__tests__/textOnly-ranking-integration.test.ts
New
+143-0
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { CaptionItem } from '../schema';
import { z } from 'zod';

type CaptionItemType = z.infer<typeof CaptionItem>;
type TextModelMock = ReturnType<typeof vi.fn>;

const createMockResponse = (payload: unknown) => ({
  response: {
    text: () => (typeof payload === 'string' ? payload : JSON.stringify(payload))
  }
});

type ScenarioConfig = {
  label: string;
  applyGeminiMock: () => { textModelMock: TextModelMock };
};

const scenarios: ScenarioConfig[] = [
  {
    label: 'function-based textModel mock',
    applyGeminiMock: () => {
      const textModelMock = vi.fn();

      vi.doMock('../../lib/gemini', () => ({
        textModel: textModelMock
      }));

      return { textModelMock };
    }
  },
  {
    label: 'object-based textModel mock',
    applyGeminiMock: () => {
      const generateContent = vi.fn();

      vi.doMock('../../lib/gemini', () => ({
        textModel: { generateContent }
      }));

      return { textModelMock: generateContent };
    }
  }
];

describe.each(scenarios)('Text-only ranking integration ($label)', ({ applyGeminiMock }) => {
  let rankAndSelect: (typeof import('../textOnlyPipeline'))['rankAndSelect'];
  let textModelMock: TextModelMock;

  const extractVariantsFromCall = (callIndex: number) => {
    const callArgs = textModelMock.mock.calls[callIndex]?.[0];
    const promptEntry = Array.isArray(callArgs) ? callArgs[0] : undefined;
    const promptText = promptEntry && typeof promptEntry.text === 'string' ? promptEntry.text : '';
    const serialized = promptText.slice(promptText.lastIndexOf('\n') + 1);
    try {
      return JSON.parse(serialized);
    } catch (error) {
      return [];
    }
  };

  beforeEach(async () => {
    vi.resetModules();

    vi.doMock('../../lib/prompts', () => ({
      load: vi.fn().mockImplementation((filename: string) => {
        if (filename === 'system.txt') return Promise.resolve('System prompt');
        if (filename === 'guard.txt') return Promise.resolve('Guard prompt');
        if (filename === 'rank.txt') return Promise.resolve('Ranking prompt');
        return Promise.resolve('Mock prompt');
      })
    }));

    const { textModelMock: appliedMock } = applyGeminiMock();
    textModelMock = appliedMock;

    ({ rankAndSelect } = await import('../textOnlyPipeline'));
  });

  it('filters sparkle filler selections before reranking', async () => {
    const mockBannedResponse = createMockResponse({
      winner_index: 0,
      final: {
        caption: 'Check out this amazing content! ✨',
        alt: 'Banned alt',
        hashtags: ['#content', '#creative'],
        cta: 'Check it out'
      },
      reason: 'Initial filler'
    });

    const mockHumanResponse = createMockResponse({
      winner_index: 0,
      final: {
        caption: 'Hand-thrown mug fresh from the kiln',
        alt: 'Potter holding a mug in the studio',
        hashtags: ['#makerspace'],
        cta: 'What would you glaze it with?'
      },
      reason: 'Clean alternative'
    });

    textModelMock
      .mockResolvedValueOnce(mockBannedResponse)
      .mockResolvedValueOnce(mockHumanResponse);

    const variants: CaptionItemType[] = [
      {
        caption: 'Filler sparkle caption',
        alt: 'Sparkle alt',
        hashtags: ['#content'],
        cta: 'Check it out',
        mood: 'excited',
        style: 'flashy',
        safety_level: 'normal',
        nsfw: false
      },
      {
        caption: 'Hand-thrown mug fresh from the kiln',
        alt: 'Potter holding a mug in the studio',
        hashtags: ['#makerspace'],
        cta: 'What would you glaze it with?',
        mood: 'calm',
        style: 'authentic',
        safety_level: 'normal',
        nsfw: false
      }
    ];

    const result = await rankAndSelect(variants, { platform: 'instagram' });

    expect(result.final.caption).toBe('Hand-thrown mug fresh from the kiln');
    expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
    expect(textModelMock).toHaveBeenCalledTimes(2);

    const firstVariants = extractVariantsFromCall(0);
    const secondVariants = extractVariantsFromCall(1);
    expect(firstVariants).toHaveLength(2);
    expect(secondVariants).toHaveLength(1);
    expect(secondVariants[0]?.caption).toBe('Hand-thrown mug fresh from the kiln');
  });
});

server/caption/geminiPipeline.ts
+34-14
@@ -701,71 +701,91 @@ async function requestGeminiRanking(
    container.reason = truncateReason(reasonText);

    const fallbackIndex = container.winner_index as number;
    const winnerVariant =
      variantsInput[fallbackIndex] ?? variantsInput[0] ?? defaultVariant;

    const providedFinal = container.final;
    const normalizedFinal =
      providedFinal && typeof providedFinal === "object"
        ? { ...(providedFinal as Record<string, unknown>) }
        : { ...winnerVariant };
    container.final = normalizedFinal;
  }

  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    normalizeGeminiFinal(final, platform, facts);
  }
  return json;
}

export async function rankAndSelect(
  variants: z.infer<typeof CaptionArray>,
  params?: { platform?: string; facts?: Record<string, unknown> }
): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const sys = await load("system.txt"), guard = await load("guard.txt"), prompt = await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestGeminiRanking(variants, serializedVariants, promptBlock, params?.platform, undefined, params?.facts);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  const runRanking = async (
    variantsInput: z.infer<typeof CaptionArray>,
    hint?: string
  ): Promise<z.infer<typeof RankResult>> => {
    const serialized = JSON.stringify(variantsInput);
    const response = await requestGeminiRanking(
      variantsInput,
      serialized,
      promptBlock,
      params?.platform,
      hint,
      params?.facts
    );
    return RankResult.parse(response);
  };

  let activeVariants = variants;
  let parsed = await runRanking(activeVariants);
  let violations = detectVariantViolations(parsed.final);

  const hasBannedPhrase = violations.some((violation) => violation.type === "banned_phrase");
  if (hasBannedPhrase && typeof parsed.winner_index === "number") {
    const filtered = activeVariants.filter((_, index) => index !== parsed.winner_index);
    if (filtered.length > 0) {
      activeVariants = filtered;
      const hint = buildRerankHint(violations) ||
        "Avoid sparkle emojis, canned CTAs, and pick the most human option remaining.";
      parsed = await runRanking(activeVariants, hint);
      violations = detectVariantViolations(parsed.final);
    }
  }

  if (violations.length === 0) {
    return parsed;
  }

  const rerank = await requestGeminiRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations),
    params?.facts
  );
  parsed = RankResult.parse(rerank);
  const rerank = await runRanking(activeVariants, buildRerankHint(violations));
  parsed = rerank;
  const rerankViolations = detectVariantViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type GeminiPipelineArgs = {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};

/**
server/caption/textOnlyPipeline.ts
+38-16
@@ -354,77 +354,99 @@ async function requestTextOnlyRanking(
  } catch (error) {
    console.error('Text-only textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  if(Array.isArray(json)) {
    const winner = json[0] as Record<string, unknown> | undefined;
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner ?? variantsInput[0]
    };
  }
  
  return json;
}

export async function rankAndSelect(
  variants: unknown[],
  params?: { platform?: string; theme?: string; context?: string }
): Promise<z.infer<typeof RankResult>> {
  const sys = await load("system.txt"), guard = await load("guard.txt"), prompt = await load("rank.txt");
  const promptBlock = `${sys}\n${guard}\n${prompt}`;
  const serializedVariants = JSON.stringify(variants);

  const first = await requestTextOnlyRanking(variants, serializedVariants, promptBlock, params?.platform);
  let parsed = RankResult.parse(first);
  const violations = detectVariantViolations(parsed.final);
  
  const runRanking = async (variantsInput: unknown[], hint?: string) => {
    const serialized = JSON.stringify(variantsInput);
    const response = await requestTextOnlyRanking(
      variantsInput,
      serialized,
      promptBlock,
      params?.platform,
      hint
    );
    return RankResult.parse(response);
  };

  let activeVariants = variants;
  let parsed = await runRanking(activeVariants);
  let violations = detectVariantViolations(parsed.final);

  const hasBannedPhrase = violations.some((violation) => violation.type === "banned_phrase");
  if (hasBannedPhrase && typeof parsed.winner_index === "number") {
    const filtered = Array.isArray(activeVariants)
      ? activeVariants.filter((_, index) => index !== parsed.winner_index)
      : activeVariants;
    if (Array.isArray(filtered) && filtered.length > 0) {
      activeVariants = filtered;
      const hint = buildRerankHint(violations) ||
        "Drop the filler pick and highlight the most natural-sounding caption left.";
      parsed = await runRanking(activeVariants, hint);
      violations = detectVariantViolations(parsed.final);
    }
  }

  if (violations.length === 0) {
    // Always sanitize final variant to ensure required fields like alt are present
    const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
    return RankResult.parse({
      ...parsed,
      final: sanitizedFinal
    });
  }

  const rerank = await requestTextOnlyRanking(
    variants,
    serializedVariants,
    promptBlock,
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerank = await runRanking(activeVariants, buildRerankHint(violations));
  parsed = rerank;
  const rerankViolations = detectVariantViolations(parsed.final);
  

  if (rerankViolations.length === 0) {
    return parsed;
    const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
    return RankResult.parse({
      ...parsed,
      final: sanitizedFinal
    });
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type TextOnlyPipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  theme:string;
  context?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

/**
 * Text-only caption pipeline for brainstorming without an image upload.
 *
 * @remarks