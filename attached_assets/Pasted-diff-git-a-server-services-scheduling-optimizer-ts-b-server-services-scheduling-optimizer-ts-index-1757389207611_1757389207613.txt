diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index e4d50be9ae5540c67531fb2f95ad66e49e369501..ea966797a862f741c2fa7014ff030370a020cda7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -3,50 +3,57 @@ import { socialMediaPosts, platformEngagement } from '@shared/schema';
 import { and, eq, gte, lte, sql, desc } from 'drizzle-orm';
 
 interface ContentSuggestion {
   topic: string;
   platform: string;
   estimatedEngagement: number;
   suggestedStyle: string;
   bestPostTime: Date;
 }
 
 interface PostPerformance {
   postId: number;
   engagement: number;
   postedAt: Date | null;
   platform: string;
 }
 
 interface PlatformStats {
   platform: string;
   avgEngagement: number;
   bestHours: number[];
   bestDays: number[];
   topHashtags: string[];
 }
 
+interface TrendingTopic {
+  topic: string;
+  platform: string;
+  score: number;
+  category: string;
+}
+
 
 class SchedulingOptimizer {
   // Best posting times by platform (based on industry research)
   private defaultBestTimes = {
     reddit: {
       weekdays: [6, 7, 8, 12, 17, 18, 19, 20, 21, 22, 23], // Early morning, lunch, evening
       weekends: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
     },
     twitter: {
       weekdays: [8, 9, 12, 17, 18, 19, 20],
       weekends: [9, 10, 11, 12, 13, 17, 18, 19, 20]
     },
     instagram: {
       weekdays: [6, 7, 11, 12, 13, 17, 18, 19, 20],
       weekends: [10, 11, 12, 13, 14, 17, 18, 19, 20]
     },
     onlyfans: {
       weekdays: [8, 9, 10, 12, 17, 18, 19, 20, 21, 22, 23],
       weekends: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
     },
     tiktok: {
       weekdays: [6, 10, 19, 20, 21],
       weekends: [8, 9, 10, 11, 19, 20, 21]
     }
   };
diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index e4d50be9ae5540c67531fb2f95ad66e49e369501..ea966797a862f741c2fa7014ff030370a020cda7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -199,73 +206,73 @@ class SchedulingOptimizer {
   async suggestContentBasedOnTrends(userId: number): Promise<ContentSuggestion[]> {
     try {
       // Get trending topics (in production, this would call external APIs)
       const trends = await this.getTrendingTopics();
       
       // Get user's niche/interests
       const userNiche = await this.getUserNiche(userId);
       
       // Generate suggestions
       return trends
         .filter(trend => this.matchesNiche(trend, userNiche))
         .slice(0, 5)
         .map(trend => ({
           topic: trend.topic,
           platform: trend.platform,
           estimatedEngagement: trend.score,
           suggestedStyle: this.getSuggestedStyle(trend),
           bestPostTime: this.getDefaultBestTime(trend.platform)
         }));
     } catch (error) {
       console.error('Error suggesting content:', error);
       return [];
     }
   }
 
-  private async getTrendingTopics(): Promise<any[]> {
+  private async getTrendingTopics(): Promise<TrendingTopic[]> {
     // In production, this would fetch from Reddit API, Twitter API, etc.
     // For now, return mock trending topics
     return [
       { topic: 'Fitness transformation', platform: 'instagram', score: 85, category: 'fitness' },
       { topic: 'Behind the scenes', platform: 'onlyfans', score: 92, category: 'exclusive' },
       { topic: 'Cosplay showcase', platform: 'reddit', score: 78, category: 'creative' },
       { topic: 'Quick tips', platform: 'tiktok', score: 88, category: 'educational' },
       { topic: 'Q&A session', platform: 'twitter', score: 75, category: 'engagement' }
     ];
   }
 
   private async getUserNiche(userId: number): Promise<string[]> {
     // Analyze user's past content to determine their niche
     // For now, return common niches
     return ['fitness', 'creative', 'lifestyle', 'exclusive'];
   }
 
-  private matchesNiche(trend: unknown, userNiche: string[]): boolean {
+  private matchesNiche(trend: TrendingTopic, userNiche: string[]): boolean {
     return userNiche.includes(trend.category) || trend.score > 80;
   }
 
-  private getSuggestedStyle(trend: unknown): string {
+  private getSuggestedStyle(trend: TrendingTopic): string {
     const styleMap: Record<string, string> = {
       'fitness': 'motivational',
       'exclusive': 'teasing',
       'creative': 'showcase',
       'educational': 'informative',
       'engagement': 'conversational'
     };
     
     return styleMap[trend.category] || 'casual';
   }
 
   async optimizePostingSchedule<T extends { platform: string }>(
     userId: number,
     posts: T[]
   ): Promise<(T & { scheduledTime: Date; optimizationScore: number })[]> {
     // Distribute posts optimally across time slots
     const optimizedPosts: (T & { scheduledTime: Date; optimizationScore: number })[] = [];
     const usedSlots = new Set<string>();
     
     for (const post of posts) {
       const bestTime = await this.getBestPostTime(userId, post.platform);
       
       // Ensure minimum 2-hour gap between posts on same platform
       let scheduledTime = bestTime;
       let attempts = 0;
