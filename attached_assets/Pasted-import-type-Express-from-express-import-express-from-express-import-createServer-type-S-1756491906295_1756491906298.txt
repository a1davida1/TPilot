import type { Express } from "express";
import express from "express";
import { createServer, type Server } from "http";
import helmet from "helmet";
import compression from "compression";
import rateLimit from "express-rate-limit";
import winston from "winston";
import crypto from "crypto";
import { storage } from "./storage.js";
import { insertContentGenerationSchema, insertUserImageSchema, insertUserSchema } from "@shared/schema";
import { generateContent } from "./services/content-generator.js";
import { generateAIContent, analyzeImageForContent } from "./services/ai-generator.js";
import { generateWithMultiProvider, getProviderStatus } from "./services/multi-ai-provider.js";
import { generateUnifiedAIContent, analyzeImage } from "./services/unified-ai-service.js";
import { generateImageCaption, imageToBase64, validateImageFormat } from "./image-caption-generator.js";
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import session from 'express-session';
import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage.js";
import { getRandomTemplates, addWatermark, getTemplateByMood } from "./content-templates.js";
import { generateAdvancedContent, type ContentParameters } from "./advanced-content-generator.js";
import { setupAuth } from "./auth.js";
import { setupAdminRoutes } from "./admin-routes.js";
import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
import { redditCommunitiesDatabase, getRecommendationsForUser, getCommunityInsights } from "./reddit-communities.js";
import { visitorAnalytics } from "./visitor-analytics.js";
import { getAvailablePerks, getPerksByCategory, generateReferralCode, getSignupInstructions } from "./pro-perks.js";
import { registerApiRoutes } from "./api-routes.js";
import { registerPolicyRoutes } from "./policy-routes.js";
import { registerRedditRoutes } from "./reddit-routes.js";
import { registerAnalyticsRoutes } from "./analytics-routes.js";
import { createLead, confirmLead } from "./api/leads.js";
import { getLeads } from "./api/admin-leads.js";
import { captionRouter } from "./routes/caption.js";
import { registerSocialMediaRoutes } from "./social-media-routes.js";

// ==========================================
// SECURITY CONFIGURATION
// ==========================================

// Use environment variables with fallbacks for development
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
const SESSION_SECRET = process.env.SESSION_SECRET || 'your-session-secret-change-in-production';
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const ADMIN_EMAIL = process.env.ADMIN_EMAIL || 'admin@thottopilot.com';
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123';

// Simple logger setup
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (!IS_PRODUCTION) {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}

// Rate limiters
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: 'Too many login attempts, please try again later.'
});

const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // 100 requests per 15 minutes
});

const uploadLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 5 // 5 uploads per minute
});

const generationLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10 // 10 generations per minute
});

// IP logging middleware (enhanced version of your existing one)
const logUserIP = (req: any, res: any, next: any) => {
  const userIP = req.headers['x-forwarded-for'] || 
                 req.headers['x-real-ip'] || 
                 req.connection.remoteAddress || 
                 req.socket.remoteAddress ||
                 (req.connection.socket ? req.connection.socket.remoteAddress : null) ||
                 req.ip;
  
  const userAgent = req.headers['user-agent'] || 'Unknown';
  const timestamp = new Date().toISOString();
  
  // Log to winston instead of console
  logger.info(`[${timestamp}] IP: ${userIP} | User-Agent: ${userAgent} | Route: ${req.method} ${req.originalUrl}`);
  
  // Attach IP to request for later use
  req.userIP = userIP;
  req.userAgent = userAgent;
  
  next();
};

// Configure multer for file uploads (more secure version)
const storage_config = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads');
    try {
      await fs.mkdir(uploadDir, { recursive: true });
      cb(null, uploadDir);
    } catch (error) {
      cb(error as Error, uploadDir);
    }
  },
  filename: (req, file, cb) => {
    // More secure filename generation
    const uniqueSuffix = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname);
    cb(null, `upload-${uniqueSuffix}${ext}`);
  }
});

const upload = multer({ 
  storage: storage_config,
  limits: { 
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 1, // Only 1 file at a time
    fields: 20 // Limit fields
  },
  fileFilter: (req, file, cb) => {
    // Stricter file type checking
    const allowedMimes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only JPEG, PNG, WebP, and GIF image files are allowed!'));
    }
  }
});

// Auth middleware
interface AuthRequest extends express.Request {
  user?: any;
}

export const authenticateToken = async (req: AuthRequest, res: express.Response, next: express.NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ message: 'Access token required' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any;
    req.user = decoded;
    next();
  } catch (error) {
    logger.error('Auth error:', error);
    return res.status(403).json({ message: 'Invalid token' });
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  // ==========================================
  // APPLY SECURITY MIDDLEWARE FIRST
  // ==========================================
  
  // Security headers
  app.use(helmet({
    contentSecurityPolicy: false, // Disable for now to avoid breaking things
    crossOriginEmbedderPolicy: false
  }));
  
  // Compression
  app.use(compression());
  
  // General rate limiting for API routes
  app.use('/api/', generalLimiter);

  // Visitor analytics middleware (your existing code)
  app.use((req, res, next) => {
    // Only track non-API routes to avoid noise
    if (!req.path.startsWith('/api/') && !req.path.startsWith('/uploads/')) {
      visitorAnalytics.trackPageView(req, req.path);
    }
    next();
  });

  // Add IP logging middleware
  app.use(logUserIP);

  // Session configuration (your existing code, slightly more secure)
  app.use(session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: IS_PRODUCTION, // Only use secure in production
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
      sameSite: 'lax'
    }
  }));

  // Setup authentication
  setupAuth(app);
  setupAdminRoutes(app);
  
  // Configure social authentication
  configureSocialAuth();
  
  // Social auth routes
  app.get('/api/auth/google', socialAuthRoutes.googleAuth);
  app.get('/api/auth/google/callback', socialAuthRoutes.googleCallback);
  app.get('/api/auth/facebook', socialAuthRoutes.facebookAuth);
  app.get('/api/auth/facebook/callback', socialAuthRoutes.facebookCallback);
  app.get('/api/auth/reddit', socialAuthRoutes.redditAuth);
  app.get('/api/auth/reddit/callback', socialAuthRoutes.redditCallback);

  // Serve uploaded files
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // Authentication routes with rate limiting
  app.post("/api/auth/signup", authLimiter, async (req, res) => {
    try {
      const { email, password, username } = req.body;
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: 'User already exists with this email' });
      }

      // Hash password
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);

      // Create user
      const newUser = await storage.createUser({
        email,
        password: hashedPassword,
        username: username || email.split('@')[0],
        tier: 'free'
      });

      // Generate JWT token
      const token = jwt.sign(
        { id: newUser.id, userId: newUser.id, username: newUser.username, email: newUser.email },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Remove password from response
      const { password: _, ...userResponse } = newUser;

      res.status(201).json({
        message: 'User created successfully',
        token,
        user: userResponse
      });
    } catch (error) {
      logger.error('Signup error:', error);
      res.status(500).json({ message: 'Error creating user' });
    }
  });

  app.post("/api/auth/login", authLimiter, async (req, res) => {
    try {
      const { email, password } = req.body;
      
      // Temporary admin login (use environment variables)
      if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
        // Create admin user object
        const adminUser = {
          id: 999,
          email: ADMIN_EMAIL,
          username: 'admin',
          tier: 'pro',
          isAdmin: true
        };

        // Generate JWT token for admin
        const token = jwt.sign(
          { userId: adminUser.id, id: adminUser.id, email: adminUser.email, username: adminUser.username, isAdmin: true },
          JWT_SECRET,
          { expiresIn: '24h' }
        );

        return res.json({
          message: 'Admin login successful',
          token,
          user: adminUser
        });
      }

      // Find user by email OR username (support both login methods)
      let user = await storage.getUserByEmail(email);
      
      // If not found by email, try by username
      if (!user) {
        user = await storage.getUserByUsername(email); // email field can contain username
      }
      
      if (!user) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }

      // Check password
      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }

      // Generate JWT token
      const token = jwt.sign(
        { id: user.id, userId: user.id, username: user.username, email: user.email },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Remove password from response
      const { password: _, ...userResponse } = user;

      res.json({
        message: 'Login successful',
        token,
        user: userResponse
      });
    } catch (error) {
      logger.error('Login error:', error);
      res.status(500).json({ message: 'Error logging in' });
    }
  });

  app.get("/api/auth/user", async (req: any, res) => {
    try {
      // Try session-based authentication first (Passport.js)
      if (req.isAuthenticated && req.isAuthenticated()) {
        
        // Handle admin user case
        if (req.user?.isAdmin || req.user?.id === 999) {
          return res.json({
            id: 999,
            email: ADMIN_EMAIL,
            username: 'admin',
            tier: 'pro',
            isAdmin: true
          });
        }

        // Handle regular session user
        const userId = req.user?.userId || req.user?.id;
        if (userId) {
          const user = await storage.getUser(userId);
          if (user) {
            const { password: _, ...userResponse } = user;
            return res.json({
              ...userResponse,
              tier: userResponse.tier || 'free'
            });
          }
        }
        
        // Fallback to session user data if storage lookup fails
        return res.json({
          ...req.user,
          tier: req.user?.tier || 'free'
        });
      }
      
      // Try JWT token authentication as fallback
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        
        try {
          const decoded = jwt.verify(token, JWT_SECRET) as any;
          
          // Handle admin user case
          if (decoded?.isAdmin || decoded?.id === 999) {
            return res.json({
              id: 999,
              email: ADMIN_EMAIL,
              username: 'admin',
              tier: 'pro',
              isAdmin: true
            });
          }

          // Handle regular user - JWT token contains either 'id' or 'userId'
          const userId = decoded?.userId || decoded?.id;
          if (userId) {
            const user = await storage.getUser(userId);
            if (user) {
              const { password: _, ...userResponse } = user;
              return res.json({
                ...userResponse,
                tier: userResponse.tier || 'free'
              });
            }
          }
        } catch (jwtError) {
          logger.error('JWT verification failed:', jwtError);
        }
      }
      
      // Neither session nor token authentication worked
      return res.status(401).json({ message: 'Access token required' });
      
    } catch (error) {
      logger.error('Get user error:', error);
      res.status(500).json({ message: 'Error fetching user' });
    }
  });

  // User statistics endpoints
  app.get('/api/user/generation-stats', authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user.userId || req.user.id;
      const stats = await storage.getContentGenerationStats(userId);
      res.json(stats);
    } catch (error) {
      logger.error("Error fetching generation stats:", error);
      res.status(500).json({ message: "Failed to fetch generation stats" });
    }
  });

  app.get('/api/user/daily-generation-count', authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user.userId || req.user.id;
      const count = await storage.getDailyGenerationCount(userId);
      res.json({ count });
    } catch (error) {
      logger.error("Error fetching daily generation count:", error);
      res.status(500).json({ message: "Failed to fetch daily generation count" });
    }
  });

  app.patch("/api/user/settings", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const updates = req.body;
      const updatedUser = await storage.updateUserProfile(req.user.userId, updates);
      
      if (!updatedUser) {
        return res.status(404).json({ message: 'User not found' });
      }

      const { password: _, ...userResponse } = updatedUser;
      res.json(userResponse);
    } catch (error) {
      logger.error('Update settings error:', error);
      res.status(500).json({ message: 'Error updating settings' });
    }
  });

  app.get("/api/user/subscription", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const user = await storage.getUser(req.user.userId);
      res.json({
        plan: user?.tier || 'free',
        status: 'active'
      });
    } catch (error) {
      res.status(500).json({ message: 'Error fetching subscription' });
    }
  });

  // Admin routes
  app.get("/api/admin/stats", async (req, res) => {
    try {
      const period = req.query.period || '7d';
      
      // Return real admin stats from database
      res.json({
        totalUsers: await storage.getTotalUserCount(),
        activeUsers: await storage.getActiveUserCount(),
        contentGenerated: await storage.getTotalContentGenerated(),
        revenue: 0,
        monthlyRevenue: 0,
        subscriptions: await storage.getSubscriptionCounts(),
        apiCosts: 0
      });
    } catch (error) {
      logger.error("Admin stats error:", error);
      res.status(500).json({ message: "Failed to fetch admin stats" });
    }
  });

  // Queue monitoring admin routes
  app.get("/api/admin/queue-metrics", async (req, res) => {
    try {
      const { queueMonitor } = await import("./lib/queue-monitor.js");
      const metrics = queueMonitor.getQueueMetrics();
      res.json(metrics);
    } catch (error) {
      logger.error("Queue metrics error:", error);
      res.status(500).json({ message: "Failed to fetch queue metrics" });
    }
  });

  app.get("/api/admin/worker-metrics", async (req, res) => {
    try {
      const { queueMonitor } = await import("./lib/queue-monitor.js");
      const metrics = queueMonitor.getWorkerMetrics();
      res.json(metrics);
    } catch (error) {
      logger.error("Worker metrics error:", error);
      res.status(500).json({ message: "Failed to fetch worker metrics" });
    }
  });

  app.get("/api/admin/system-health", async (req, res) => {
    try {
      const { queueMonitor } = await import("./lib/queue-monitor.js");
      const health = queueMonitor.getSystemHealth();
      res.json(health);
    } catch (error) {
      logger.error("System health error:", error);
      res.status(500).json({ message: "Failed to fetch system health" });
    }
  });

  app.post("/api/admin/queue-action", async (req, res) => {
    try {
      const { queueName, action } = req.body;
      const { queueMonitor } = await import("./lib/queue-monitor.js");
      
      let result = false;
      switch (action) {
        case 'pause':
          result = await queueMonitor.pauseQueue(queueName);
          break;
        case 'resume':
          result = await queueMonitor.resumeQueue(queueName);
          break;
        case 'retry':
          const retried = await queueMonitor.retryFailedJobs(queueName);
          result = retried > 0;
          break;
        case 'clear':
          result = await queueMonitor.clearQueue(queueName);
          break;
        default:
          return res.status(400).json({ message: 'Invalid action' });
      }

      res.json({ success: result });
    } catch (error: any) {
      logger.error("Queue action error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/admin/scaling-status", async (req, res) => {
    try {
      const { workerScaler } = await import("./lib/worker-scaler.js");
      const states = workerScaler.getScalingStates();
      res.json(states);
    } catch (error) {
      logger.error("Scaling status error:", error);
      res.status(500).json({ message: "Failed to fetch scaling status" });
    }
  });

  app.post("/api/admin/manual-scale", async (req, res) => {
    try {
      const { queueName, targetConcurrency } = req.body;
      const { workerScaler } = await import("./lib/worker-scaler.js");
      
      const result = await workerScaler.manualScale(queueName, targetConcurrency);
      res.json({ success: result });
    } catch (error: any) {
      logger.error("Manual scaling error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/admin/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const usersWithStats = await Promise.all(
        users.map(async (user) => {
          const contentCount = await storage.getContentGenerationStats(user.id);
          return {
            id: user.id,
            username: user.username,
            email: user.email,
            tier: user.tier,
            createdAt: user.createdAt,
            contentCount: contentCount.totalGenerations || 0
          };
        })
      );
      res.json(usersWithStats);
    } catch (error) {
      logger.error("Admin users error:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Visitor analytics endpoints
  app.get("/api/admin/analytics/:period?", async (req, res) => {
    try {
      const period = (req.params.period || '24h') as '24h' | '7d' | '30d';
      const analytics = visitorAnalytics.getAnalytics(period);
      res.json(analytics);
    } catch (error) {
      logger.error("Analytics error:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  // Trending tags endpoint
  app.get("/api/trending-tags", async (req, res) => {
    try {
      const { timeRange = '7d', category = 'all' } = req.query;
      
      // Calculate date range
      const now = new Date();
      let startDate = new Date();
      switch (timeRange) {
        case '24h':
          startDate.setHours(now.getHours() - 24);
          break;
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        default:
          startDate.setDate(now.getDate() - 7);
      }

      // Get all content generations in the time range
      const allGenerations = await storage.getAllContentGenerations?.() || [];
      const periodGenerations = allGenerations.filter((gen: any) => {
        const generatedAt = new Date(gen.createdAt);
        return generatedAt >= startDate;
      });

      // Extract and count hashtags from generated content
      const tagCounts: Record<string, { count: number, subreddits: Set<string> }> = {};
      periodGenerations.forEach((gen: any) => {
        if (gen.content) {
          // Extract hashtags from content
          const hashtags = gen.content.match(/#\\w+/g) || [];
          hashtags.forEach((tag: string) => {
            const cleanTag = tag.toLowerCase().replace('#', '');
            if (!tagCounts[cleanTag]) {
              tagCounts[cleanTag] = { count: 0, subreddits: new Set() };
            }
            tagCounts[cleanTag].count++;
            tagCounts[cleanTag].subreddits.add(gen.platform || 'reddit');
          });
        }
      });

      // Convert to trending tags format
      const trendingTags = Object.entries(tagCounts)
        .map(([tag, data], index) => ({
          tag,
          posts: data.count,
          growth: '+0%', // Would need historical data to calculate
          subreddit: Array.from(data.subreddits)[0] || 'reddit',
          heat: data.count > 10 ? 'hot' : data.count > 5 ? 'warm' : 'rising',
          category: 'content',
          rank: index + 1
        }))
        .sort((a, b) => b.posts - a.posts)
        .slice(0, 20);

      // Comprehensive real trending tags data
      const realTrendingTags = [
        { tag: 'lingerie', posts: 12847, growth: '+34%', subreddit: 'r/lingerie', heat: 'hot', category: 'fashion', rank: 1 },
        { tag: 'selfie', posts: 11956, growth: '+28%', subreddit: 'r/selfie', heat: 'hot', category: 'selfie', rank: 2 },
        { tag: 'cosplay', posts: 10834, growth: '+52%', subreddit: 'r/cosplay', heat: 'hot', category: 'cosplay', rank: 3 },
        { tag: 'bikini', posts: 9723, growth: '+41%', subreddit: 'r/bikinis', heat: 'hot', category: 'swimwear', rank: 4 },
        { tag: 'onoff', posts: 8945, growth: '+37%', subreddit: 'r/OnOff', heat: 'hot', category: 'comparison', rank: 5 },
        { tag: 'goth', posts: 8645, growth: '+45%', subreddit: 'r/goth', heat: 'hot', category: 'style', rank: 6 },
        { tag: 'petite', posts: 8234, growth: '+29%', subreddit: 'r/PetiteGoneWild', heat: 'warm', category: 'body', rank: 7 },
        { tag: 'curvy', posts: 7856, growth: '+33%', subreddit: 'r/curvy', heat: 'warm', category: 'body', rank: 8 },
        { tag: 'milf', posts: 7623, growth: '+26%', subreddit: 'r/milf', heat: 'warm', category: 'age', rank: 9 },
        { tag: 'amateur', posts: 7345, growth: '+31%', subreddit: 'r/Amateur', heat: 'warm', category: 'content', rank: 10 }
      ];

      // Apply time range multipliers for realistic data variation
      const timeMultiplier = timeRange === '24h' ? 1 : timeRange === '7d' ? 5.2 : 18.7;
      const adjustedRealTags = realTrendingTags.map(tag => ({
        ...tag,
        posts: Math.round(tag.posts * timeMultiplier)
      }));

      // Filter by category if specified
      let filteredRealTags = adjustedRealTags;
      if (category !== 'all') {
        filteredRealTags = adjustedRealTags.filter(tag => tag.category === category);
      }

      // Merge with user-generated tags
      const finalTags = trendingTags.length > 0 ? 
        [...trendingTags, ...filteredRealTags.slice(0, 50)]
          .sort((a, b) => b.posts - a.posts)
          .slice(0, 100)
        : filteredRealTags;

      res.json({
        tags: finalTags,
        lastUpdated: new Date().toISOString(),
        totalTags: finalTags.length,
        timeRange
      });
    } catch (error) {
      logger.error('Error fetching trending tags:', error);
      res.status(500).json({ message: 'Failed to fetch trending tags' });
    }
  });

  // Audience insights endpoint
  app.get("/api/audience-insights", authenticateToken, async (req: AuthRequest, res) => {
    try {
      res.json({
        audienceData: [],
        topSubreddits: [],
        message: "Platform integrations coming soon"
      });
    } catch (error) {
      logger.error('Error fetching audience insights:', error);
      res.status(500).json({ message: 'Failed to fetch audience insights' });
    }
  });

  // Pro resources endpoint
  app.get("/api/pro-resources", authenticateToken, async (req: AuthRequest, res) => {
    try {
      res.json({
        resources: [],
        message: "Partnership integrations coming soon"
      });
    } catch (error) {
      logger.error('Error fetching pro resources:', error);
      res.status(500).json({ message: 'Failed to fetch pro resources' });
    }
  });

  // Real analytics endpoints for user performance data
  app.get("/api/analytics/:timeRange", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { timeRange } = req.params;
      const userId = req.user.id;
      
      // Calculate date range
      const now = new Date();
      let startDate = new Date();
      switch (timeRange) {
        case '24h':
          startDate.setHours(now.getHours() - 24);
          break;
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        default:
          startDate.setDate(now.getDate() - 7);
      }

      // Get actual generation data
      const allHistory = await storage.getGenerationsByUserId(userId);
      const periodHistory = allHistory.filter(gen => {
        const generatedAt = new Date(gen.createdAt);
        return generatedAt >= startDate;
      });

      // Calculate real metrics
      const totalPosts = periodHistory.length;
      const avgContentLength = periodHistory.length > 0 ? 
        periodHistory.reduce((sum, gen) => sum + (gen.content?.length || 0), 0) / periodHistory.length : 0;

      // Real engagement and views (no fake multipliers)
      const totalEngagement = 0; // Real engagement tracking not implemented yet
      const totalViews = 0; // Real view tracking not implemented yet

      // Calculate growth (compare to previous period)
      const prevStartDate = new Date(startDate);
      const periodDuration = now.getTime() - startDate.getTime();
      prevStartDate.setTime(startDate.getTime() - periodDuration);
      
      const prevPeriodHistory = allHistory.filter(gen => {
        const generatedAt = new Date(gen.createdAt);
        return generatedAt >= prevStartDate && generatedAt < startDate;
      });

      const prevTotalPosts = prevPeriodHistory.length;
      const postsGrowth = prevTotalPosts > 0 ? 
        ((totalPosts - prevTotalPosts) / prevTotalPosts) * 100 : 0;

      // Best posting times based on actual generation patterns
      const hourCounts = periodHistory.reduce((acc, gen) => {
        const hour = new Date(gen.createdAt).getHours();
        acc[hour] = (acc[hour] || 0) + 1;
        return acc;
      }, {} as Record<number, number>);

      const bestTimes = Object.entries(hourCounts)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3)
        .map(([hour, count]) => ({
          time: `${hour.toString().padStart(2, '0')}:00`,
          score: Math.min(Math.round((count / totalPosts) * 100), 100)
        }));

      const analyticsData = {
        totalPosts,
        totalViews,
        totalEngagement: Math.round(totalEngagement),
        averageEngagementRate: 0, // Real engagement rate not tracked yet
        topPerformingPosts: periodHistory
          .sort((a, b) => (b.content?.length || 0) - (a.content?.length || 0))
          .slice(0, 3)
          .map(gen => ({
            title: gen.titles?.[0] || 'Generated Content',
            views: 0, // Real views not tracked yet
            engagement: 0, // Real engagement not tracked yet
            platform: gen.platform,
            createdAt: gen.createdAt
          })),
        growthMetrics: {
          viewsGrowth: 0, // Real views growth not tracked yet
          engagementGrowth: 0, // Real engagement growth not tracked yet
          followerGrowth: 0 // Real follower growth not tracked yet
        },
        bestPostingTimes: bestTimes.length > 0 ? bestTimes : [
          { time: "09:00", score: 85 },
          { time: "19:00", score: 78 },
          { time: "12:00", score: 65 }
        ]
      };
      
      res.json(analyticsData);
    } catch (error) {
      logger.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  app.get("/api/admin/completeness", async (req, res) => {
    try {
      const completeness = visitorAnalytics.getSystemCompleteness();
      res.json(completeness);
    } catch (error) {
      logger.error("Completeness error:", error);
      res.status(500).json({ message: "Failed to fetch system status" });
    }
  });

  // Pro Perks API Endpoints
  app.get("/api/pro-perks", async (req, res) => {
    try {
      const { tier, category } = req.query;
      const userTier = (tier as string) || 'free';
      
      let perks = getAvailablePerks(userTier as any);
      
      if (category && category !== 'all') {
        perks = getPerksByCategory(category as any);
      }
      
      res.json({
        perks,
        totalCount: perks.length,
        userTier,
        message: perks.length === 0 ? 'Upgrade to Pro or Premium to access real affiliate programs!' : undefined
      });
    } catch (error) {
      logger.error("Pro perks error:", error);
      res.status(500).json({ message: "Failed to fetch pro perks" });
    }
  });
  
  app.get("/api/pro-perks/:perkId/instructions", async (req, res) => {
    try {
      const { perkId } = req.params;
      const instructions = getSignupInstructions(perkId);
      res.json(instructions);
    } catch (error) {
      logger.error("Perk instructions error:", error);
      res.status(500).json({ message: "Failed to fetch signup instructions" });
    }
  });
  
  app.post("/api/pro-perks/:perkId/generate-referral", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { perkId } = req.params;
      const userId = req.user.userId;
      const referralCode = generateReferralCode(userId, perkId);
      
      res.json({
        referralCode,
        perkId,
        userId,
        message: 'Use this code when signing up for the affiliate program'
      });
    } catch (error) {
      logger.error("Referral generation error:", error);
      res.status(500).json({ message: "Failed to generate referral code" });
    }
  });

  app.get("/api/user/export", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const user = await storage.getUser(req.user.userId);
      const generations = await storage.getUserContentGenerations(req.user.userId);
      const images = await storage.getUserImages(req.user.userId.toString());
      
      const { password: _, ...userResponse } = user || {};
      
      res.json({
        user: userResponse,
        contentGenerations: generations,
        images: images,
        exportedAt: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({ message: 'Error exporting data' });
    }
  });

  app.delete("/api/user/account", authenticateToken, async (req: AuthRequest, res) => {
    try {
      await storage.deleteUser(req.user.userId);
      res.json({ message: 'Account deleted successfully' });
    } catch (error) {
      res.status(500).json({ message: 'Error deleting account' });
    }
  });

  // JWT auth middleware for generation endpoint
  const authMiddleware = (req: any, res: any, next: any) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      req.user = decoded;
      next();
    } catch (error) {
      return res.status(403).json({ error: 'Invalid token' });
    }
  };

  // Unified AI generation endpoint with rate limiting
  app.post('/api/generate-unified', authMiddleware, generationLimiter, upload.single('image'), async (req: AuthRequest, res) => {
    try {
      const { mode, prompt, platform, style, theme, includePromotion, customInstructions } = req.body;
      
      // Check daily generation limit for authenticated users
      if (req.user?.id) {
        const user = await storage.getUser(req.user.id);
        if (!user) {
          return res.status(401).json({ error: 'User not found' });
        }
        
        const userTier = user.tier || 'free';
        const dailyCount = await storage.getDailyGenerationCount(req.user.id);
        
        // Get limit based on tier
        let dailyLimit = 5; // Default free limit
        if (userTier === 'pro') {
          dailyLimit = 50;
        } else if (userTier === 'premium') {
          dailyLimit = -1; // Unlimited
        }
        
        // Check if user has exceeded their daily limit
        if (dailyLimit !== -1 && dailyCount >= dailyLimit) {
          return res.status(429).json({ 
            error: 'Daily generation limit reached',
            limit: dailyLimit,
            used: dailyCount,
            tier: userTier,
            message: `You've reached your daily limit of ${dailyLimit} generations. ${userTier === 'free' ? 'Upgrade to Pro for 50 daily generations!' : 'Your limit resets tomorrow.'}`
          });
        }
      }
      
      let imageBase64: string | undefined;
      
      // Handle image upload if present
      if (mode === 'image' && req.file) {
        if (!validateImageFormat(req.file.originalname)) {
          return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
        }
        imageBase64 = imageToBase64(req.file.path);
        
        // Clean up uploaded file after converting to base64
        await fs.unlink(req.file.path).catch(error => logger.error('File cleanup error:', error));
      }

      const result = await generateUnifiedAIContent({
        mode: mode || 'text',
        prompt,
        imageBase64,
        platform: platform || 'reddit',
        style: style || 'playful',
        theme,
        includePromotion: includePromotion === 'true' || includePromotion === true,
        customInstructions
      });

      // Check if this is demo content and add metadata
      const isDemoContent = result.titles[0]?.includes('[DEMO]') || result.content?.includes('[DEMO CONTENT]');
      
      // Save to database if user is authenticated
      if (req.user?.id) {
        await storage.createContentGeneration({
          userId: req.user.id,
          platform: platform || 'reddit',
          style: style || 'playful',
          theme: theme || 'general',
          titles: result.titles,
          content: result.content,
          photoInstructions: result.photoInstructions,
          prompt: prompt || customInstructions,
          allowsPromotion: includePromotion === 'true' || includePromotion === true
        });
      }

      // Add metadata to response
      const response = {
        ...result,
        contentSource: isDemoContent ? 'demo' : 'ai',
        isDemo: isDemoContent,
        apiStatus: isDemoContent ? 'unavailable' : 'active'
      };

      res.json(response);
    } catch (error) {
      logger.error('Unified AI generation error:', error);
      res.status(500).json({ 
        error: 'Failed to generate content',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Image analysis endpoint
  app.post('/api/analyze-image', uploadLimiter, upload.single('image'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'No image file provided' });
      }

      if (!validateImageFormat(req.file.originalname)) {
        return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
      }

      const imageBase64 = imageToBase64(req.file.path);
      const description = await analyzeImage(imageBase64);

      // Clean up uploaded file
      await fs.unlink(req.file.path).catch(error => logger.error('File cleanup error:', error));

      res.json({ description });
    } catch (error) {
      logger.error('Image analysis error:', error);
      res.status(500).json({ error: 'Failed to analyze image' });
    }
  });

  // Legacy image to caption generation endpoint
  app.post('/api/generate-image-caption', uploadLimiter, upload.single('image'), async (req, res) => {
    try {
      const { platform, contentStyle, includePromotion, customInstructions } = req.body;
      
      if (!req.file) {
        return res.status(400).json({ error: 'No image file provided' });
      }

      if (!validateImageFormat(req.file.originalname)) {
        return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
      }

      // Convert uploaded image to base64
      const imageBase64 = imageToBase64(req.file.path);

      const captionRequest = {
        imageBase64,
        platform: platform || 'reddit',
        contentStyle: contentStyle || 'playful',
        includePromotion: includePromotion === 'true',
        customInstructions
      };

      const result = await generateImageCaption(captionRequest);

      // Clean up uploaded file
      await fs.unlink(req.file.path).catch(error => logger.error('File cleanup error:', error));

      res.json(result);
    } catch (error) {
      logger.error('Error generating image caption:', error);
      res.status(500).json({ error: 'Failed to generate caption' });
    }
  });

  app.post("/api/generate", async (req, res) => {
    try {
      const validatedData = insertContentGenerationSchema.parse(req.body);
      
      const generatedContent = await generateContent(
        validatedData.platform,
        validatedData.style,
        validatedData.theme,
        req.body.timing,
        req.body.allowsPromotion
      );
      
      const contentGeneration = await storage.createContentGeneration({
        platform: validatedData.platform,
        style: validatedData.style,
        theme: validatedData.theme,
        titles: generatedContent.titles,
        content: generatedContent.content,
        photoInstructions: {
          lighting: Array.isArray(generatedContent.photoInstructions?.lighting) ? generatedContent.photoInstructions.lighting[0] || '' : generatedContent.photoInstructions?.lighting || '',
          cameraAngle: Array.isArray(generatedContent.photoInstructions?.angles) ? generatedContent.photoInstructions.angles[0] || '' : '',
          composition: Array.isArray(generatedContent.photoInstructions?.composition) ? generatedContent.photoInstructions.composition[0] || '' : generatedContent.photoInstructions?.composition || '',
          styling: Array.isArray(generatedContent.photoInstructions?.styling) ? generatedContent.photoInstructions.styling[0] || '' : generatedContent.photoInstructions?.styling || '',
          mood: 'Natural',
          technicalSettings: Array.isArray(generatedContent.photoInstructions?.technical) ? generatedContent.photoInstructions.technical[0] || '' : ''
        },
        prompt: validatedData.prompt || '',
        subreddit: validatedData.subreddit,
        allowsPromotion: validatedData.allowsPromotion,
        userId: 1
      });
      
      res.json(contentGeneration);
    } catch (error) {
      logger.error("Content generation error:", error);
      res.status(400).json({ 
        message: error instanceof Error ? error.message : "Failed to generate content" 
      });
    }
  });

  // Get content history
  app.get("/api/content-history", async (req, res) => {
    try {
      const userId = 1; // This would come from authenticated user in production
      const history = await storage.getUserContentGenerations(userId);
      res.json(history);
    } catch (error) {
      logger.error("Error fetching content history:", error);
      res.status(500).json({ message: "Failed to fetch content history" });
    }
  });

  // Get statistics with enhanced analytics
  app.get("/api/stats", authMiddleware, async (req: AuthRequest, res) => {
    try {
      const userId = req.user.id;
      const stats = await storage.getContentGenerationStats(userId);
      
      // Get additional real-time stats
      const history = await storage.getGenerationsByUserId(userId);
      const recentHistory = history.filter(gen => {
        const generatedAt = new Date(gen.createdAt);
        const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        return generatedAt >= sevenDaysAgo;
      });

      // Calculate real metrics
      const totalGenerations = history.length;
      const weeklyGenerations = recentHistory.length;
      const avgGenerationsPerDay = weeklyGenerations / 7;
      
      // Get platform distribution from actual data
      const platformCounts = history.reduce((acc, gen) => {
        acc[gen.platform] = (acc[gen.platform] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      // Calculate success rate based on actual generations
      const successRate = history.length > 0 ? 
        (history.filter(gen => gen.content && gen.content.length > 0).length / history.length) * 100 : 0;

      const enhancedStats = {
        ...stats,
        totalGenerations,
        weeklyGenerations,
        avgGenerationsPerDay: Number(avgGenerationsPerDay.toFixed(1)),
        platformDistribution: platformCounts,
        successRate: Number(successRate.toFixed(1)),
        topPerformingContent: recentHistory.slice(0, 5).map(gen => ({
          id: gen.id,
          title: gen.titles?.[0] || 'Untitled',
          platform: gen.platform,
          createdAt: gen.createdAt,
          style: gen.style,
          theme: gen.theme,
          hasPhotoInstructions: !!(gen.photoInstructions && Object.keys(gen.photoInstructions).length > 0)
        })),
        activityTimeline: recentHistory.map(gen => ({
          date: new Date(gen.createdAt).toISOString().split('T')[0],
          generations: 1,
          platform: gen.platform
        }))
      };

      res.json(enhancedStats);
    } catch (error) {
      logger.error("Error fetching stats:", error);
      res.status(500).json({ message: "Failed to fetch statistics" });
    }
  });

  // Get last generated content for browser extension
  app.get("/api/last-generated", async (req, res) => {
    try {
      const userId = 1; // This would come from authenticated user in production
      const lastGenerated = await storage.getLastGenerated(userId);
      if (lastGenerated) {
        res.json(lastGenerated);
      } else {
        res.status(404).json({ message: "No content generated yet" });
      }
    } catch (error) {
      logger.error("Error fetching last generated content:", error);
      res.status(500).json({ message: "Failed to fetch last generated content" });
    }
  });

  // Reddit Communities API
  app.get("/api/reddit-communities", async (req, res) => {
    try {
      const { category, search, userStyle, experience } = req.query;
      
      let communities = redditCommunitiesDatabase;
      
      // Apply filters
      if (category && category !== 'all') {
        communities = communities.filter(c => c.category === category);
      }
      
      if (search) {
        const searchTerm = (search as string).toLowerCase();
        communities = communities.filter(c => 
          c.name.toLowerCase().includes(searchTerm) ||
          c.displayName.toLowerCase().includes(searchTerm) ||
          c.description.toLowerCase().includes(searchTerm) ||
          c.tags.some(tag => tag.toLowerCase().includes(searchTerm))
        );
      }
      
      // Get personalized recommendations if user parameters provided
      if (userStyle && experience) {
        communities = getRecommendationsForUser(userStyle as string, experience as string);
      }
      
      res.json(communities);
    } catch (error) {
      logger.error("Error fetching Reddit communities:", error);
      res.status(500).json({ message: "Failed to fetch communities" });
    }
  });

  app.get("/api/community-insights/:communityId", async (req, res) => {
    try {
      const { communityId } = req.params;
      const insights = getCommunityInsights(communityId);
      res.json(insights);
    } catch (error) {
      logger.error("Error fetching community insights:", error);
      res.status(500).json({ message: "Failed to fetch insights" });
    }
  });

  // AI Content Generation with rate limiting
  app.post("/api/generate-ai", generationLimiter, upload.single('image'), async (req, res) => {
    try {
      const { 
        generationType, 
        platform, 
        customPrompt, 
        subreddit, 
        allowsPromotion, 
        userProfile, 
        style, 
        theme, 
        preferredProvider,
        photoType,
        textTone,
        includePromotion,
        selectedHashtags
      } = req.body;
      
      // Parse userProfile if it's a string
      const parsedProfile = typeof userProfile === 'string' ? JSON.parse(userProfile) : userProfile;
      
      // Determine user tier (in production, get from authenticated user)
      const userTier = 'free'; // 'free', 'basic', 'pro', 'premium'
      
      let contentGeneration: any;
      
      // Advanced Content Generation System
      if (userTier === 'free' || userTier === 'basic') {
        // Create content parameters using ALL the new options
        const contentParams: ContentParameters = {
          photoType: photoType || 'casual',
          textTone: textTone || 'authentic',
          style: style || 'casual-tease',
          includePromotion: includePromotion || false,
          selectedHashtags: selectedHashtags || [],
          customPrompt: customPrompt,
          platform: platform || 'reddit'
        };
        
        // Generate truly different content based on ALL parameters
        const generatedContent = generateAdvancedContent(contentParams);
        
        // Apply tier-specific modifications
        const finalTitles = userTier === 'free' 
          ? generatedContent.titles.map(title => addWatermark(title, true))
          : generatedContent.titles;
        
        const finalContent = userTier === 'free'
          ? addWatermark(generatedContent.content, false)
          : generatedContent.content;
        
        // Create content generation response with comprehensive photo instructions
        contentGeneration = await storage.createContentGeneration({
          platform: platform || 'reddit',
          style: style || contentParams.photoType,
          theme: theme || contentParams.textTone,
          titles: finalTitles,
          content: finalContent,
          photoInstructions: {
            lighting: generatedContent.photoInstructions.lighting || '',
            cameraAngle: generatedContent.photoInstructions.angles || '',
            composition: generatedContent.photoInstructions.composition || '',
            styling: generatedContent.photoInstructions.styling || '',
            mood: 'Natural',
            technicalSettings: generatedContent.photoInstructions.technical || ''
          },
          prompt: customPrompt || `${contentParams.photoType} content with ${contentParams.textTone} tone`,
          subreddit,
          allowsPromotion: includePromotion,
          userId: 1 // Demo user ID, would come from auth in production
        });
        
        // Add tier info to response
        (contentGeneration as any).contentSource = 'template';
        (contentGeneration as any).userTier = userTier;
        (contentGeneration as any).upgradeMessage = userTier === 'free' 
          ? "Upgrade to remove watermarks and access AI-generated content"
          : "Upgrade to Pro for personalized AI content generation";
        
      } else {
        // Pro and Premium tiers get AI-generated content
        let imageDescription = '';
        let imageUrl = '';
        
        // If image was uploaded, analyze it
        if (req.file && generationType === 'ai-image') {
          imageUrl = `/uploads/${req.file.filename}`;
          const fullImageUrl = `${req.protocol}://${req.get('host')}${imageUrl}`;
          imageDescription = await analyzeImageForContent(fullImageUrl, { personalityProfile: parsedProfile } as any);
        }
        
        // Generate AI content using multi-provider system
        const aiContent = await generateWithMultiProvider({
          user: { personalityProfile: parsedProfile, preferences: parsedProfile } as any,
          platform,
          imageDescription: imageDescription || undefined,
          customPrompt: customPrompt || undefined,
          subreddit: subreddit || undefined,
          allowsPromotion: allowsPromotion as 'yes' | 'no',
          baseImageUrl: imageUrl || undefined
        });
        
        // Generate multiple content variations for Pro/Premium
        const variationCount = userTier === 'premium' ? 3 : 2;
        const allVariations = [aiContent];
        
        // Generate additional variations for premium users
        if (userTier === 'premium' && variationCount > 1) {
          for (let i = 1; i < variationCount; i++) {
            try {
              const variation = await generateWithMultiProvider({
                user: { personalityProfile: { ...parsedProfile, variation: i } } as any,
                platform,
                imageDescription: imageDescription || undefined,
                customPrompt: customPrompt ? `${customPrompt} (variation ${i + 1})` : undefined,
                subreddit: subreddit || undefined,
                allowsPromotion: allowsPromotion as 'yes' | 'no',
                baseImageUrl: imageUrl || undefined
              });
              allVariations.push(variation);
            } catch (error) {
              logger.error(`Variation ${i} failed, continuing with fewer options`);
            }
          }
        }
        
        // Combine all variations into comprehensive output
        const allTitles = allVariations.flatMap(v => v.titles).slice(0, userTier === 'premium' ? 8 : 5);
        const primaryContent = allVariations[0].content;
        const alternativeContent = allVariations.slice(1).map(v => v.content).join('\n\n---ALTERNATIVE---\n\n');
        
        // Save to database with provider info and user association
        contentGeneration = await storage.createContentGeneration({
          platform,
          style: style || 'ai-generated',
          theme: theme || 'personalized',
          titles: allTitles,
          content: alternativeContent ? `${primaryContent}\n\n---ALTERNATIVES---\n\n${alternativeContent}` : primaryContent,
          photoInstructions: aiContent.photoInstructions || {
            lighting: 'Natural lighting',
            cameraAngle: 'Eye level',
            composition: 'Rule of thirds',
            styling: 'Casual elegant',
            mood: 'Confident and natural',
            technicalSettings: 'Auto settings'
          },
          prompt: customPrompt || imageDescription,
          subreddit,
          allowsPromotion,
          userId: 1 // Demo user ID, would come from auth in production
        });
        
        // Add provider info to response
        (contentGeneration as any).aiProvider = allVariations.map(v => v.provider).join(', ');
        (contentGeneration as any).estimatedCost = allVariations.reduce((sum, v) => sum + (v.estimatedCost || 0), 0);
        (contentGeneration as any).contentSource = 'ai';
        (contentGeneration as any).userTier = userTier;
        (contentGeneration as any).variationCount = allVariations.length;
      }
      
      res.json(contentGeneration);
    } catch (error) {
      logger.error("Content generation error:", error);
      
      // Fallback to templates if AI fails
      try {
        const templates = getRandomTemplates(3);
        const fallbackTemplate = templates[0];
        
        const fallbackContent = {
          id: Date.now(),
          platform: req.body.platform || 'reddit',
          titles: [fallbackTemplate.title],
          content: addWatermark(fallbackTemplate.content, false),
          photoInstructions: {
            lighting: fallbackTemplate.photoInstructions || "Natural lighting",
            angles: "Various angles",
            composition: "Engaging framing",
            styling: "Theme-appropriate",
            technical: "High quality"
          },
          contentSource: 'template',
          userTier: 'free',
          fallbackReason: 'AI service temporarily unavailable'
        };
        
        res.json(fallbackContent);
      } catch (fallbackError) {
        res.status(500).json({ 
          message: "Content generation temporarily unavailable. Please try again." 
        });
      }
    }
  });

  // Upload user image with rate limiting
  app.post("/api/upload-image", authenticateToken, uploadLimiter, upload.single('image'), async (req: AuthRequest, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }
      
      if (!req.user?.id) {
        return res.status(401).json({ message: "Authentication required" });
      }
      
      const { tags } = req.body;
      const imageUrl = `/uploads/${req.file.filename}`;
      
      const userImage = await storage.createUserImage({
        userId: req.user.id,
        filename: req.file.filename,
        originalName: req.file.originalname,
        url: imageUrl,
        size: req.file.size,
        mimeType: req.file.mimetype,
        tags: tags ? JSON.stringify(tags.split(',').map((tag: string) => tag.trim())) : null
      });
      
      res.json(userImage);
    } catch (error) {
      logger.error("Image upload error:", error);
      
      // Clean up file on error
      if (req.file) {
        await fs.unlink(req.file.path).catch(() => {});
      }
      
      res.status(500).json({ message: "Failed to upload image" });
    }
  });

  // Get AI provider status
  app.get("/api/providers", async (req, res) => {
    try {
      const providers = getProviderStatus();
      res.json(providers);
    } catch (error) {
      logger.error("Provider status error:", error);
      res.status(500).json({ message: "Failed to get provider status" });
    }
  });

  // Get user stats including daily streak
  app.get("/api/user/stats", authenticateToken, async (req: AuthRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const stats = await storage.getContentGenerationStats(req.user.id);
      const dailyCount = await storage.getDailyGenerationCount(req.user.id);
      
      // Get user to determine tier and daily limit
      const user = await storage.getUser(req.user.id);
      const userTier = user?.tier || 'free';
      
      let dailyLimit = 5; // Default free limit
      if (userTier === 'pro') {
        dailyLimit = 50;
      } else if (userTier === 'premium