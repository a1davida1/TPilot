Apply serializePromptField to hints
Sep 22 · a1davida1/TPilot · main
+98-1
1. In `server/caption/geminiPipeline.ts`, apply `serializePromptField` (with `{ block: true }` when appropriate) to both `params.hint` and any `currentHint` text before interpolating them into the `HINT:` line.
2. Add/restore unit coverage in `tests/routes/caption-generation.test.ts` (and any Gemini-specific suites) that feeds hints containing quotes or line breaks to ensure the sanitized prompt survives the new retry flow.

Summary

    Ensured the Gemini variant generator serializes the initial hint and any retry hints with serializePromptField(..., { block: true }) before interpolating them into the HINT: line, so quotes and control characters can’t corrupt the prompt during retries.

Added Gemini route tests that feed hints containing quotes and line breaks, confirming the sanitized prompt survives both the first attempt and the duplicate-driven retry flow.

Testing

    ✅ npm run lint (completes with existing repo warnings only).

❌ npm test *(fails: suite depends on numerous external services/env like E2E admin secrets, Neon DB URLs, Coinbase mocks, etc.; failures are pre-existing and include missing env vars and DB connection errors).*


server/caption/geminiPipeline.ts
+7-1
@@ -277,97 +277,103 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

type GeminiVariantParams = {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};

export async function generateVariants(params: GeminiVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  let serializedHint = currentHint
    ? serializePromptField(currentHint, { block: true })
    : undefined;
  let variants: z.infer<typeof CaptionItem>[] = [];
  const keyIndex = new Map<string, number>();

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;
    const voiceContext = formatVoiceContext(params.voice);
    const user = `PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${voiceContext ? `${voiceContext}\n` : ''}${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}${currentHint ? `\nHINT:${currentHint}` : ''}`;
    const user = `PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${voiceContext ? `${voiceContext}\n` : ''}${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}${serializedHint ? `\nHINT:${serializedHint}` : ''}`;

    let res;
    try {
      res = await textModel.generateContent([{ text: `${sys}\n${guard}\n${prompt}\n${user}` }]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    const raw = stripToJSON(res.response.text());
    const items = Array.isArray(raw) ? raw : [raw];
    const iterationDuplicates: string[] = [];

    items.forEach(item => {
      const candidate = (typeof item === "object" && item !== null ? item : {}) as Record<string, unknown>;
      const normalized = normalizeVariantFields(candidate);
      const key = uniqueCaptionKey(normalized.caption);
      const existingIndex = keyIndex.get(key);

      if (existingIndex === undefined) {
        variants.push(normalized);
        keyIndex.set(key, variants.length - 1);
      } else {
        iterationDuplicates.push(normalized.caption);
        const existing = variants[existingIndex];
        if (normalized.caption.length > existing.caption.length) {
          variants[existingIndex] = normalized;
        }
      }
    });

    variants = dedupeCaptionVariants(variants).slice(0, VARIANT_TARGET);
    keyIndex.clear();
    variants.forEach((variant, index) => {
      keyIndex.set(uniqueCaptionKey(variant.caption), index);
    });

    if (variants.length < VARIANT_TARGET) {
      const needed = VARIANT_TARGET - variants.length;
      currentHint = buildRetryHint(params.hint, iterationDuplicates, needed);
      serializedHint = currentHint
        ? serializePromptField(currentHint, { block: true })
        : undefined;
    }
  }

  if (variants.length !== VARIANT_TARGET) {
    throw new Error(`Failed to generate ${VARIANT_TARGET} unique caption variants.`);
  }

  return CaptionArray.parse(variants);
}

function normalizeGeminiFinal(final: Record<string, unknown>, platform?: string){
  final.safety_level = normalizeSafetyLevel(
    typeof final.safety_level === "string" ? final.safety_level : "normal"
  );
  final.mood = typeof final.mood === "string" && final.mood.trim().length >= 2 ? final.mood.trim() : "engaging";
  final.style = typeof final.style === "string" && final.style.trim().length >= 2 ? final.style.trim() : "authentic";
  const trimmedCta = typeof final.cta === "string" ? final.cta.trim() : "";
  final.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof final.alt === "string" ? final.alt.trim() : "";
  final.alt = trimmedAlt.length >= 20
    ? trimmedAlt
    : "Detailed social media alt text describing the scene.";
  const fallback = fallbackHashtags(platform);
  let hashtags: string[] = [];
  if (Array.isArray(final.hashtags)) {
tests/routes/caption-generation.test.ts
+91-0
@@ -307,50 +307,141 @@ describe('Caption Generation', () => {
        },
      ];

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(duplicateBatch) },
        })
        .mockResolvedValueOnce({
          response: { text: () => JSON.stringify(uniqueBatch) },
        });

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const secondPrompt = textGenerateMock.mock.calls[1][0][0].text as string;
      expect(secondPrompt).toContain('HINT:You already wrote');
      expect(new Set(result.map(v => v.caption.toLowerCase().slice(0, 80))).size).toBe(5);
    });

    it('sanitizes base hints with quotes and line breaks for Gemini variants', async () => {
      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);

      const variantFactory = (index: number) => ({
        caption: `Unique caption ${index}`,
        hashtags: ['#hint', '#coverage', '#retry'],
        safety_level: 'normal',
        mood: 'confident',
        style: 'authentic',
        cta: 'Drop a thought',
        alt: 'Detailed alt text to satisfy schema enforcement for hint serialization testing.',
        nsfw: false,
      });

      textGenerateMock.mockResolvedValueOnce({
        response: {
          text: () => JSON.stringify(Array.from({ length: 5 }, (_, index) => variantFactory(index))),
        },
      });

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const hint = 'Keep it "fresh"\nline two';
      await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['hint'] },
        hint,
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(1);
      const prompt = textGenerateMock.mock.calls[0][0][0].text as string;
      const { serializePromptField } = await import('../../server/caption/promptUtils.js');
      const sanitizedHint = serializePromptField(hint, { block: true });
      expect(prompt).toContain(`\nHINT:${sanitizedHint}`);
      expect(prompt).not.toContain(`HINT:${hint}`);
    });

    it('preserves sanitized retry hints built from duplicates', async () => {
      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);

      const duplicateCaption = 'Fresh drop "today"';
      const duplicateVariant = {
        caption: duplicateCaption,
        hashtags: ['#gemini', '#retry', '#duplicates'],
        safety_level: 'normal',
        mood: 'engaging',
        style: 'authentic',
        cta: 'Sound off',
        alt: 'Long-form alt text to exercise duplicate retry sanitization.',
        nsfw: false,
      };

      const duplicateBatch = Array.from({ length: 5 }, () => ({ ...duplicateVariant }));

      const uniqueBatch = Array.from({ length: 5 }, (_, index) => ({
        ...duplicateVariant,
        caption: `Unique retry caption ${index}`,
      }));

      textGenerateMock
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(duplicateBatch) } })
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(uniqueBatch) } });

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const baseHint = 'Line1\nLine2 "quoted"';
      await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['retry'] },
        hint: baseHint,
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const firstPrompt = textGenerateMock.mock.calls[0][0][0].text as string;
      const secondPrompt = textGenerateMock.mock.calls[1][0][0].text as string;

      const { serializePromptField } = await import('../../server/caption/promptUtils.js');
      const sanitizedBaseHint = serializePromptField(baseHint, { block: true });
      expect(firstPrompt).toContain(`\nHINT:${sanitizedBaseHint}`);
      expect(firstPrompt).not.toContain('HINT:Line1\nLine2 "quoted"');

      const retryHintRaw = `${baseHint} You already wrote "${duplicateCaption}". Deliver a fresh angle and add 4 more unique captions.`;
      const sanitizedRetryHint = serializePromptField(retryHintRaw, { block: true });
      expect(secondPrompt).toContain(`\nHINT:${sanitizedRetryHint}`);
      expect(secondPrompt).not.toContain(
        'HINT:Line1\nLine2 "quoted" You already wrote "Fresh drop "today"". Deliver a fresh angle and add 4 more unique captions.'
      );
    });
  });

  describe('Text-Only Pipeline', () => {
    it('should generate content without image context', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Motivational content for today!',
              hashtags: ['#motivation', '#mindset'],
              safety_level: 'normal',
              mood: 'inspiring',
              style: 'authentic',
              cta: 'What motivates you?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock.mockResolvedValue(mockResponse);

      const result = await pipelineTextOnly({
        platform: 'instagram',
