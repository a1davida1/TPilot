diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index 10a54075275c17eb35b89a6e3f6b44b6769ba27d..269171ca1d1aa349088524b7847df1b644f5f9d7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -1,41 +1,41 @@
 import { db } from '../db';
 import { socialMediaPosts, platformEngagement } from '@shared/schema';
 import { and, eq, gte, lte, sql, desc } from 'drizzle-orm';
 
 interface ContentSuggestion {
   topic: string;
   platform: string;
   estimatedEngagement: number;
   suggestedStyle: string;
   bestPostTime: Date;
 }
 
 interface PostPerformance {
   postId: number;
   engagement: number;
-  postedAt: Date;
+  postedAt: Date | null;
   platform: string;
 }
 
 interface PlatformStats {
   platform: string;
   avgEngagement: number;
   bestHours: number[];
   bestDays: number[];
   topHashtags: string[];
 }
 
 class SchedulingOptimizer {
   // Best posting times by platform (based on industry research)
   private defaultBestTimes = {
     reddit: {
       weekdays: [6, 7, 8, 12, 17, 18, 19, 20, 21, 22, 23], // Early morning, lunch, evening
       weekends: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
     },
     twitter: {
       weekdays: [8, 9, 12, 17, 18, 19, 20],
       weekends: [9, 10, 11, 12, 13, 17, 18, 19, 20]
     },
     instagram: {
       weekdays: [6, 7, 11, 12, 13, 17, 18, 19, 20],
       weekends: [10, 11, 12, 13, 14, 17, 18, 19, 20]
diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index 10a54075275c17eb35b89a6e3f6b44b6769ba27d..269171ca1d1aa349088524b7847df1b644f5f9d7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -77,68 +77,76 @@ class SchedulingOptimizer {
       return this.getDefaultBestTime(platform);
     }
   }
 
   private async getUserPostHistory(userId: number, platform: string): Promise<PostPerformance[]> {
     try {
       const posts = await db.select({
         postId: socialMediaPosts.id,
         engagement: socialMediaPosts.engagement,
         postedAt: socialMediaPosts.createdAt,
         platform: socialMediaPosts.platform
       })
       .from(socialMediaPosts)
       .where(
         and(
           eq(socialMediaPosts.userId, userId),
           eq(socialMediaPosts.platform, platform),
           eq(socialMediaPosts.status, 'published')
         )
       )
       .orderBy(desc(socialMediaPosts.createdAt))
       .limit(100);
       
       return posts.map(p => ({
         postId: p.postId,
-        engagement: p.engagement || 0,
-        postedAt: p.postedAt,
+        engagement: typeof p.engagement === 'number'
+          ? p.engagement
+          : (p.engagement?.likes ?? 0)
+            + (p.engagement?.comments ?? 0)
+            + (p.engagement?.shares ?? 0)
+            + (p.engagement?.views ?? 0)
+            + (p.engagement?.retweets ?? 0)
+            + (p.engagement?.quotes ?? 0),
+        postedAt: p.postedAt ?? null,
         platform: p.platform
       }));
     } catch (error) {
       console.error('Error fetching post history:', error);
       return [];
     }
   }
 
   private analyzeUserPatterns(history: PostPerformance[]): Date | null {
     if (history.length === 0) return null;
     
     // Calculate average engagement by hour
     const hourlyEngagement = new Map<number, { total: number; count: number }>();
     
     history.forEach(post => {
-      const hour = new Date(post.postedAt).getHours();
+      if (!post.postedAt) return;
+      const hour = post.postedAt.getHours();
       const current = hourlyEngagement.get(hour) || { total: 0, count: 0 };
       hourlyEngagement.set(hour, {
         total: current.total + post.engagement,
         count: current.count + 1
       });
     });
     
     // Find hour with highest average engagement
     let bestHour = 0;
     let maxAvgEngagement = 0;
     
     hourlyEngagement.forEach((data, hour) => {
       const avgEngagement = data.total / data.count;
       if (avgEngagement > maxAvgEngagement) {
         maxAvgEngagement = avgEngagement;
         bestHour = hour;
       }
     });
     
     // Calculate next occurrence of best hour
     return this.getNextTimeAtHour(bestHour);
   }
 
   private getDefaultBestTime(platform: string): Date {
     const times = this.defaultBestTimes[platform as keyof typeof this.defaultBestTimes] 
diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index 10a54075275c17eb35b89a6e3f6b44b6769ba27d..269171ca1d1aa349088524b7847df1b644f5f9d7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -224,53 +232,56 @@ class SchedulingOptimizer {
     ];
   }
 
   private async getUserNiche(userId: number): Promise<string[]> {
     // Analyze user's past content to determine their niche
     // For now, return common niches
     return ['fitness', 'creative', 'lifestyle', 'exclusive'];
   }
 
   private matchesNiche(trend: unknown, userNiche: string[]): boolean {
     return userNiche.includes(trend.category) || trend.score > 80;
   }
 
   private getSuggestedStyle(trend: unknown): string {
     const styleMap: Record<string, string> = {
       'fitness': 'motivational',
       'exclusive': 'teasing',
       'creative': 'showcase',
       'educational': 'informative',
       'engagement': 'conversational'
     };
     
     return styleMap[trend.category] || 'casual';
   }
 
-  async optimizePostingSchedule(userId: number, posts: unknown[]): Promise<any[]> {
+  async optimizePostingSchedule<T extends { platform: string }>(
+    userId: number,
+    posts: T[]
+  ): Promise<(T & { scheduledTime: Date; optimizationScore: number })[]> {
     // Distribute posts optimally across time slots
-    const optimizedPosts = [];
+    const optimizedPosts: (T & { scheduledTime: Date; optimizationScore: number })[] = [];
     const usedSlots = new Set<string>();
     
     for (const post of posts) {
       const bestTime = await this.getBestPostTime(userId, post.platform);
       
       // Ensure minimum 2-hour gap between posts on same platform
       let scheduledTime = bestTime;
       let attempts = 0;
       
       while (usedSlots.has(`${post.platform}-${scheduledTime.getTime()}`) && attempts < 10) {
         scheduledTime = new Date(scheduledTime);
         scheduledTime.setHours(scheduledTime.getHours() + 2);
         attempts++;
       }
       
       usedSlots.add(`${post.platform}-${scheduledTime.getTime()}`);
       
       optimizedPosts.push({
         ...post,
         scheduledTime,
         optimizationScore: this.calculateOptimizationScore(scheduledTime, post.platform)
       });
     }
     
     return optimizedPosts.sort((a, b) => 
diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
index 10a54075275c17eb35b89a6e3f6b44b6769ba27d..269171ca1d1aa349088524b7847df1b644f5f9d7 100644
--- a/server/services/scheduling-optimizer.ts
+++ b/server/services/scheduling-optimizer.ts
@@ -312,69 +323,71 @@ class SchedulingOptimizer {
   async getPlatformStats(userId: number): Promise<PlatformStats[]> {
     const platforms = ['reddit', 'twitter', 'instagram', 'onlyfans', 'tiktok'];
     const stats: PlatformStats[] = [];
     
     for (const platform of platforms) {
       const history = await this.getUserPostHistory(userId, platform);
       
       if (history.length === 0) {
         // Return defaults for platforms with no history
         stats.push({
           platform,
           avgEngagement: 0,
           bestHours: this.defaultBestTimes[platform as keyof typeof this.defaultBestTimes]?.weekdays.slice(0, 3) || [],
           bestDays: this.bestDays[platform as keyof typeof this.bestDays] || [],
           topHashtags: []
         });
         continue;
       }
       
       // Calculate average engagement
       const avgEngagement = history.reduce((sum, p) => sum + p.engagement, 0) / history.length;
       
       // Find best performing hours
       const hourlyPerformance = new Map<number, number[]>();
       history.forEach(post => {
-        const hour = new Date(post.postedAt).getHours();
+        if (!post.postedAt) return;
+        const hour = post.postedAt.getHours();
         const perf = hourlyPerformance.get(hour) || [];
         perf.push(post.engagement);
         hourlyPerformance.set(hour, perf);
       });
       
       const bestHours = Array.from(hourlyPerformance.entries())
         .map(([hour, engagements]) => ({
           hour,
           avg: engagements.reduce((a, b) => a + b, 0) / engagements.length
         }))
         .sort((a, b) => b.avg - a.avg)
         .slice(0, 3)
         .map(h => h.hour);
       
       // Find best performing days
       const dailyPerformance = new Map<number, number[]>();
       history.forEach(post => {
-        const day = new Date(post.postedAt).getDay();
+        if (!post.postedAt) return;
+        const day = post.postedAt.getDay();
         const perf = dailyPerformance.get(day) || [];
         perf.push(post.engagement);
         dailyPerformance.set(day, perf);
       });
       
       const bestDays = Array.from(dailyPerformance.entries())
         .map(([day, engagements]) => ({
           day,
           avg: engagements.reduce((a, b) => a + b, 0) / engagements.length
         }))
         .sort((a, b) => b.avg - a.avg)
         .slice(0, 3)
         .map(d => d.day);
       
       stats.push({
         platform,
         avgEngagement,
         bestHours,
         bestDays,
         topHashtags: [] // Would be extracted from post content in production
       });
     }
     
     return stats;
   }
