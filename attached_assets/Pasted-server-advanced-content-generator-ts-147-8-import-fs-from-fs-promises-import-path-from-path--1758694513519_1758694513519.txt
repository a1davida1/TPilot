server/advanced-content-generator.ts
+147-8
import fs from 'fs/promises';
import path from 'path';

import {
  applyConversationalTone,
  buildConversationalToneConfig,
  type ConversationalToneConfig
} from './conversational-tone.js';
import {
  getCommunityVoicePack,
  sampleCommunityReference,
  type CommunityVoicePack
} from './community-voice-packs.js';
import {
  applyStoryPersonaSegments,
  getStoryPersona,
  type PersonaTone
} from './story-persona.js';
import { scoreAuthenticity, type AuthenticityScore } from './authenticity-metrics.js';
import {
  assignExperimentVariant,
  getExperimentDefinition,
  isTreatmentVariant,
  type ExperimentAssignment
} from './engagement-experiments.js';

export interface HumanizationConfig {
  maxQuirks?: number;
  random?: () => number;
}

export interface ContentParameters {
  photoType: 'casual' | 'workout' | 'shower' | 'showing-skin' | 'spicy' | 'very-spicy' | 'all-xs' | 'needs_review';
  textTone: 'confident' | 'playful' | 'mysterious' | 'authentic' | 'sassy';
  style: string;
  includePromotion: boolean;
  selectedHashtags: string[];
  customPrompt?: string;
  platform: string;
  humanization?: HumanizationConfig;
  targetCommunity?: string;
  conversationalOverrides?: Partial<ConversationalToneConfig>;
  experiment?: ExperimentRequest;
  narrativePersonaOverride?: PersonaTone;
}

export interface PhotoInstructions {
  lighting: string;
  angles: string;
  composition: string;
  styling: string;
  technical: string;
  sceneSetup: string;
}

export interface GeneratedContent {
  titles: string[];
  content: string;
  photoInstructions: PhotoInstructions;
  tags: string[];
  diagnostics?: ContentDiagnostics;
}

export interface ExperimentRequest {
  id: string;
  variant?: string;
}

export interface ContentDiagnostics {
  authenticity: AuthenticityScore;
  experiment?: ExperimentAssignment;
  voiceMarkersUsed: string[];
}

export interface PresetVariation {
  titles: string[];
  content: string;
  photoInstructions: PhotoInstructions;
}

export interface PhotoConfig {
  themes: string[];
  settings: string[];
  clothing: string[];
  lighting: string;
  angles: string;
  mood: string;
}

export interface ToneStyle {
  starters: string[];
  descriptors: string[];
  endings: string[];
  emojis: string[];
  imperfectionTokens?: string[];
  connectors?: string[];
  titlePatterns?: TitlePatternDefinition[];
@@ -105,69 +144,123 @@ interface FragmentRuntimeContext {
  pickDescriptor(): string;
  pickTheme(): string;
  pickSetting(): string;
  pickEmoji(): string;
  pickFiller(): string;
  mood: string;
  photoType: ContentParameters['photoType'];
}

interface PlatformPostProcessContext {
  emojiPool: string[];
  emojiCount: number;
}

interface PlatformProfile {
  maxSentenceLength: number[];
  paragraphCounts: number[];
  emojiDensity: number[];
  callToActions: string[];
  paragraphSeparator: string;
  sentenceSeparator: string;
  postProcessContent?: (content: string, context: PlatformPostProcessContext) => string;
  postProcessTitle?: (title: string, context: PlatformPostProcessContext) => string;
}

interface MainContentBuildResult {
  content: string;
  voiceMarkersUsed: string[];
  callbacksUsed: string[];
  communityPack: CommunityVoicePack;
}

const DEFAULT_MAX_HUMANIZATION_QUIRKS = 2;

type RandomGenerator = () => number;

interface HumanizationOptions {
  maxQuirks?: number;
  random?: RandomGenerator;
}

interface HumanizationContext {
  random: RandomGenerator;
  toneStyle: ToneStyle;
}

interface HumanizationQuirk {
  chance: number;
  apply: (text: string, context: HumanizationContext) => string;
}

function resolvePersonaTone(params: ContentParameters): PersonaTone {
  return (params.narrativePersonaOverride ?? params.textTone) as PersonaTone;
}

function resolveExperimentAssignment(
  request: ExperimentRequest | undefined,
  random: () => number
): ExperimentAssignment | undefined {
  if (!request) {
    return undefined;
  }

  if (request.variant) {
    const definition = getExperimentDefinition(request.id);
    const controlVariant = definition?.controlVariant ?? 'control';
    return {
      id: request.id,
      variant: request.variant,
      isControl: request.variant === controlVariant
    };
  }

  return assignExperimentVariant(request.id, random);
}

function createConversationalToneConfig(
  params: ContentParameters,
  communityPack: CommunityVoicePack,
  experimentAssignment: ExperimentAssignment | undefined,
  random: () => number
): ConversationalToneConfig {
  const overrides: Partial<ConversationalToneConfig> = {
    ...params.conversationalOverrides
  };

  if (experimentAssignment) {
    if (isTreatmentVariant(experimentAssignment)) {
      overrides.voiceMarkerProbability = Math.max(overrides.voiceMarkerProbability ?? 0.6, 0.75);
      overrides.contractionProbability = Math.max(overrides.contractionProbability ?? 0.55, 0.65);
    } else if (overrides.voiceMarkerProbability === undefined) {
      overrides.voiceMarkerProbability = 0.45;
    }
  }

  return buildConversationalToneConfig(communityPack, overrides, random, params.platform);
}

const LOWERCASE_INTERJECTIONS: readonly string[] = ['hmm', 'haha', 'um', 'oh'];

const SPELLING_VARIATIONS: Array<{ pattern: RegExp; replacement: string }> = [
  { pattern: /\bkind of\b/i, replacement: 'kinda' },
  { pattern: /\bsort of\b/i, replacement: 'sorta' },
  { pattern: /\bgoing to\b/i, replacement: 'gonna' },
  { pattern: /\bwant to\b/i, replacement: 'wanna' }
];

export function applyHumanization(content: string, toneStyle: ToneStyle, options?: HumanizationOptions): string {
  if (content.trim().length === 0) {
    return content;
  }

  const random: RandomGenerator = options?.random ?? Math.random;
  const requestedMax = options?.maxQuirks ?? DEFAULT_MAX_HUMANIZATION_QUIRKS;
  const maxQuirks = Math.max(0, Math.floor(requestedMax));

  if (maxQuirks === 0) {
    return content;
  }

  const context: HumanizationContext = { random, toneStyle };

  const quirks: HumanizationQuirk[] = [
@@ -1416,61 +1509,76 @@ const platformProfiles: Record<string, PlatformProfile> = {

// Generate content based on all parameters
export function generateAdvancedContent(params: ContentParameters): GeneratedContent {
  // Check if this is a preset request and use preset variations
  const presetVariation = getRandomPresetVariation(params.style);
  if (presetVariation) {
    console.log(`ðŸŽ¯ Using preset variation for: ${params.style}`);
    return {
      titles: presetVariation.titles,
      content: presetVariation.content,
      photoInstructions: {
        lighting: presetVariation.photoInstructions.lighting,
        angles: presetVariation.photoInstructions.angles || "natural angles",
        composition: presetVariation.photoInstructions.composition,
        styling: presetVariation.photoInstructions.styling,
        technical: presetVariation.photoInstructions.technical || "natural lighting",
        sceneSetup: presetVariation.photoInstructions.sceneSetup || "casual setting"
      },
      tags: ['preset-content', params.style, params.platform]
    };
  }

  // Fallback to existing system for non-preset requests
  const photoConfig = photoTypeVariations[params.photoType as keyof typeof photoTypeVariations] || photoTypeVariations['casual'] as PhotoConfig;
  const toneStyle = textToneStyles[params.textTone as keyof typeof textToneStyles] || textToneStyles['authentic'] as ToneStyle;
  const random = params.humanization?.random ?? Math.random;
  const experimentAssignment = resolveExperimentAssignment(params.experiment, random);

  const titles = generateTitles(params, photoConfig, toneStyle, platformProfiles);
  const content = generateMainContent(params, photoConfig, toneStyle);
  const mainContent = generateMainContent(params, photoConfig, toneStyle, experimentAssignment);
  const photoInstructions = generatePhotoInstructions(params, photoConfig);
  const tags = generateTags(params, photoConfig);

  const authenticity = scoreAuthenticity({
    content: mainContent.content,
    titles,
    voiceMarkersUsed: mainContent.voiceMarkersUsed,
    callbacksUsed: mainContent.callbacksUsed,
    communityPack: mainContent.communityPack
  });

  return {
    titles,
    content,
    content: mainContent.content,
    photoInstructions,
    tags
    tags,
    diagnostics: {
      authenticity,
      experiment: experimentAssignment,
      voiceMarkersUsed: mainContent.voiceMarkersUsed
    }
  };
}

async function loadPresetVariations(): Promise<Record<string, PresetVariation[]>> {
  try {
    const presetPath = path.join(process.cwd(), 'prompts', 'preset-variations.json');
    const data = await fs.readFile(presetPath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    console.warn('No preset variations file found, using built-in presets');
    return {
      'morning-coffee': [{
        titles: ["Morning coffee and cozy vibes â˜•", "Starting my day right", "Coffee in hand, ready for anything"],
        content: "There's something magical about that first sip of coffee in the morning. Messy hair, cozy sweater, and that peaceful moment before the day begins. Just me and my thoughts in the quiet morning light.",
        photoInstructions: {
          lighting: "Soft morning light, golden hour glow through windows",
          angles: "Candid morning shots, cozy intimate angles",
          composition: "Natural comfortable framing with coffee elements",
          styling: "Cozy morning wear, comfortable and relaxed",
          technical: "Natural lighting, soft focus, warm tones",
          sceneSetup: "Cozy morning setting with coffee and natural light"
        }
      }],
      'workout-motivation': [{
        titles: ["Post-workout glow hits different ðŸ’ª", "Feeling strong and unstoppable", "Sweat, determination, and pride"],
@@ -1598,120 +1706,151 @@ function generateTitles(
        emoji: selectEmoji(emojis, DEFAULT_EMOJI_PROBABILITY),
        punctuation: choosePunctuation(fallbackPattern.type),
        hedge: fallbackPattern.template.includes('{hedge}') ? randomFromArray(hedgeOptions) : '',
        photoType: readablePhotoType
      };

      generatedTitles.add(renderTitleFromPattern(fallbackPattern, fallbackContext));
    }
  }

  const titles = shuffleArray(Array.from(generatedTitles));

  if (titles.length > 0) {
    titles[0] = `${titles[0]} ${callToAction}`.trim();
  }

  const processedTitles = titles
    .map(title => applyEmojiDensity(title, emojis, emojiCount))
    .map(title => clampSentenceLength(title, maxSentenceLength))
    .map(title => (profile.postProcessTitle ? profile.postProcessTitle(title, context) : title))
    .map(title => clampSentenceLength(title, maxSentenceLength));

  return processedTitles.slice(0, desiredTitleCount);
}

function generateMainContent(params: ContentParameters, photoConfig: PhotoConfig, toneStyle: ToneStyle): string {
function generateMainContent(
  params: ContentParameters,
  photoConfig: PhotoConfig,
  toneStyle: ToneStyle,
  experimentAssignment: ExperimentAssignment | undefined
): MainContentBuildResult {
  const themes = photoConfig.themes;
  const settings = photoConfig.settings;
  const descriptors = toneStyle.descriptors;
  const endings = toneStyle.endings;
  const emojis = toneStyle.emojis;
  const personalTone = personalToneConfigs[params.textTone];
  const profile = platformProfiles[params.platform] ?? platformProfiles.default;
  const random = params.humanization?.random ?? Math.random;
  const communityPack = getCommunityVoicePack(params.targetCommunity, params.platform);
  const persona = getStoryPersona(resolvePersonaTone(params));

  const segments: string[] = [];
  const starter = pickRandom(toneStyle.starters);
  const opener = pickRandom(personalTone.openers);
  const descriptor = pickRandom(descriptors);
  const theme = pickRandom(themes);
  const setting = pickRandom(settings);
  const emoji = pickRandom(emojis);

  segments.push(`${opener} ${starter} I curated some ${descriptor} ${theme} moments in my ${setting} just for you ${emoji}.`);

  if (params.photoType === 'casual') {
    segments.push('Just me being my natural self for youâ€”coffee in hand, messy hair, and that perfect morning light while I imagined you here with me.');
  } else if (params.photoType === 'workout') {
    segments.push('Pushed past my limits because I know you crave that post-session glowâ€”every drop of sweat proof that I was thinking about you.');
  } else if (params.photoType === 'shower') {
    segments.push('Water, steam, and a room full of thoughts about you while the mirror fogged up like our private secret.');
  } else if (params.photoType === 'showing-skin') {
    segments.push('Turned the lens into a love letterâ€”each curve and shadow composed with you in mind.');
  } else if (params.photoType === 'spicy') {
    segments.push('Let the heat rise just for you: silk sliding, shadows flickering, my gaze locked where I picture you standing.');
  } else if (params.photoType === 'very-spicy') {
    segments.push('Dropped every guard because you can handle itâ€”raw passion, unapologetic and saved for your eyes only.');
  } else if (params.photoType === 'all-xs') {
    segments.push('Let myself go completely with you in mindâ€”no limits, just the unfiltered truth I keep for you.');
  } else if (params.photoType === 'needs_review') {
    segments.push('Created something special that only you deserve to seeâ€”carefully curated with your desires in mind.');
  }

  const customPrompt = params.customPrompt?.trim();
  if (customPrompt) {
    const promptIntro = pickRandom(personalTone.customPromptIntros);
    segments.push(ensureTerminalPunctuation(`${promptIntro} ${customPrompt}`));
  }

  if (params.includePromotion) {
    segments.push(pickRandom(personalTone.promoHooks));
  }

  const ending = capitalizeSentence(ensureTerminalPunctuation(pickRandom(endings)));
  const closer = pickRandom(personalTone.closers);
  segments.push(`${ending} ${closer}`);
  const personaResult = applyStoryPersonaSegments(segments, persona, {
    communityPack,
    random
  });

  const contentBody = personaResult.segments
    .filter(segment => segment.trim().length > 0)
    .join(` ${profile.sentenceSeparator} `)
    .trim();

  let content = segments.filter(segment => segment.trim().length > 0).join(` ${profile.sentenceSeparator} `);
  const toneConfig = createConversationalToneConfig(params, communityPack, experimentAssignment, random);
  const conversational = applyConversationalTone(contentBody, toneConfig);
  let conversationalContent = conversational.text;

  if (params.platform.toLowerCase() === 'reddit') {
    const communityReference = sampleCommunityReference(communityPack, random);
    if (communityReference && !conversationalContent.includes(communityReference)) {
      conversationalContent = `${conversationalContent} ${communityReference}`.trim();
    }
  }

  if (params.selectedHashtags.length > 0) {
    content += ` ${params.selectedHashtags.join(' ')}`;
    conversationalContent = `${conversationalContent} ${params.selectedHashtags.join(' ')}`;
  }

  const humanized = applyHumanization(content, toneStyle, {
  const humanized = applyHumanization(conversationalContent, toneStyle, {
    maxQuirks: params.humanization?.maxQuirks,
    random: params.humanization?.random
  });

  const context: PlatformPostProcessContext = {
    emojiPool: toneStyle.emojis,
    emojiCount: pickRandom(profile.emojiDensity)
  };

  const processedContent = profile.postProcessContent ? profile.postProcessContent(humanized, context) : humanized;

  return processedContent;
  return {
    content: processedContent,
    voiceMarkersUsed: conversational.voiceMarkersUsed,
    callbacksUsed: personaResult.callbacksUsed,
    communityPack
  };
}

function generatePhotoInstructions(params: ContentParameters, photoConfig: PhotoConfig): GeneratedContent['photoInstructions'] {
  return {
    lighting: photoConfig.lighting + (params.photoType === 'shower' ? ', emphasis on steam and water reflections' :
               params.photoType === 'workout' ? ', bright and energetic to show determination' :
               params.photoType === 'very-spicy' || params.photoType === 'all-xs' ? ', dramatic contrasts and artistic shadows' : ''),
    angles: photoConfig.angles + (params.textTone === 'confident' ? ', powerful perspective shots' :
            params.textTone === 'playful' ? ', fun candid angles' :
            params.textTone === 'mysterious' ? ', shadowy artistic angles' : ''),
    composition: `${photoConfig.mood} composition with ${params.photoType === 'casual' ? 'natural framing' :
                 params.photoType === 'workout' ? 'dynamic action elements' :
                 params.photoType === 'shower' ? 'steam and water elements' :
                 params.photoType === 'showing-skin' ? 'artistic tasteful framing' :
                 params.photoType === 'spicy' ? 'seductive elegant framing' :
                 params.photoType === 'very-spicy' ? 'bold intimate framing' :
                 'unlimited creative framing'}`,
    styling: `${photoConfig.clothing.join(' or ')}, ${photoConfig.mood} aesthetic`,
    technical: `High resolution, sharp focus, professional quality${params.photoType === 'very-spicy' || params.photoType === 'all-xs' ? ', studio-grade equipment recommended' : ''}`,
    sceneSetup: `${photoConfig.settings.join(' or ')}, ${params.photoType} theme environment`
  };
}

function generateTags(params: ContentParameters, photoConfig: PhotoConfig): string[] {
  const baseTags = [params.photoType, params.textTone, params.platform];
server/authenticity-metrics.ts
New
+127-0
import type { CommunityVoicePack } from './community-voice-packs.js';

export interface AuthenticityScoreDetails {
  voiceMarkerDensity: number;
  firstPersonRatio: number;
  sentenceVariance: number;
  humorReferenceCount: number;
  callbacksUsed: number;
}

export interface AuthenticityScore {
  score: number;
  details: AuthenticityScoreDetails;
  warnings: string[];
}

export interface AuthenticityScoreInput {
  readonly content: string;
  readonly titles: readonly string[];
  readonly voiceMarkersUsed: readonly string[];
  readonly callbacksUsed: readonly string[];
  readonly communityPack: CommunityVoicePack;
}

function safeDivide(numerator: number, denominator: number): number {
  if (denominator === 0) {
    return 0;
  }
  return numerator / denominator;
}

function clamp(value: number, min: number, max: number): number {
  if (Number.isNaN(value)) {
    return min;
  }
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

function calculateSentenceVariance(sentences: string[]): number {
  if (sentences.length <= 1) {
    return sentences.length === 1 ? clamp(sentences[0].length / 120, 0, 1) : 0;
  }
  const lengths = sentences.map(sentence => sentence.trim().length).filter(length => length > 0);
  if (lengths.length === 0) {
    return 0;
  }
  const minLength = Math.min(...lengths);
  const maxLength = Math.max(...lengths);
  const variance = maxLength - minLength;
  return clamp(variance / Math.max(1, maxLength), 0, 1);
}

function countFirstPerson(content: string): number {
  const matches = content.match(/\b(I|me|my|mine|myself)\b/giu);
  return matches ? matches.length : 0;
}

function countHumorReferences(content: string, pack: CommunityVoicePack): number {
  const lowerContent = content.toLowerCase();
  return pack.humorReferences.reduce((count, reference) => {
    return lowerContent.includes(reference.toLowerCase()) ? count + 1 : count;
  }, 0);
}

export function scoreAuthenticity(input: AuthenticityScoreInput): AuthenticityScore {
  const sentences = input.content.split(/(?<=[.!?])\s+/u).filter(sentence => sentence.trim().length > 0);
  const wordCount = input.content.split(/\s+/u).filter(word => word.length > 0).length;
  const firstPersonCount = countFirstPerson(input.content);
  const humorReferences = countHumorReferences(input.content, input.communityPack);

  const voiceMarkerDensity = clamp(
    safeDivide(input.voiceMarkersUsed.length, Math.max(1, sentences.length)),
    0,
    1
  );
  const firstPersonRatio = clamp(safeDivide(firstPersonCount, Math.max(1, wordCount)), 0, 1);
  const sentenceVariance = calculateSentenceVariance(sentences);
  const callbacksUsed = input.callbacksUsed.length;

  const humorScore = clamp(
    safeDivide(humorReferences, Math.max(1, input.communityPack.humorReferences.length)),
    0,
    1
  );

  const score = parseFloat(
    (
      voiceMarkerDensity * 0.25 +
      firstPersonRatio * 0.35 +
      sentenceVariance * 0.2 +
      humorScore * 0.15 +
      clamp(callbacksUsed / 3, 0, 1) * 0.05
    ).toFixed(3)
  );

  const warnings: string[] = [];
  if (firstPersonRatio < 0.15) {
    warnings.push('Increase first-person storytelling for authenticity.');
  }
  if (voiceMarkerDensity < 0.15) {
    warnings.push('Conversation markers are sparse; try adding vernacular touches.');
  }
  if (sentenceVariance < 0.1) {
    warnings.push('Sentence lengths feel too uniformâ€”vary pacing.');
  }
  if (humorReferences === 0 && input.communityPack.humorReferences.length > 0) {
    warnings.push('Consider referencing community humor or inside jokes.');
  }

  return {
    score,
    details: {
      voiceMarkerDensity,
      firstPersonRatio,
      sentenceVariance,
      humorReferenceCount: humorReferences,
      callbacksUsed
    },
    warnings
  };
}
server/community-voice-packs.ts
New
+117-0
export interface CommunityVoicePack {
  readonly slug: string;
  readonly platform: string;
  readonly lexicon: readonly string[];
  readonly humorReferences: readonly string[];
  readonly voiceMarkers: readonly string[];
  readonly storytellingPrompts: readonly string[];
  readonly callouts: readonly string[];
}

const defaultPack: CommunityVoicePack = {
  slug: 'default',
  platform: 'general',
  lexicon: ['vibes', 'crew', 'fam', 'low-key', 'irl'],
  humorReferences: ['did someone say snacks?', 'gonna need receipts for that'],
  voiceMarkers: ['honestly', 'tbh', 'ngl'],
  storytellingPrompts: [
    'I keep replaying how it felt in the moment',
    'Took a beat to notice the small details and how they reminded me of you',
    'Had to tell you before the feeling fades'
  ],
  callouts: ['btw, you know I read every comment', 'appreciate the love, fr']
};

const redditDefaultPack: CommunityVoicePack = {
  slug: 'reddit:default',
  platform: 'reddit',
  lexicon: ['thread', 'upvote', 'mods', 'lurkers', 'wholesome', 'chaotic good'],
  humorReferences: [
    'mods are asleep, post cozy vibes',
    'sending virtual snacks for the real ones',
    'petition to make this a sticky?'
  ],
  voiceMarkers: ['ngl', 'low-key', 'real talk', 'honestly'],
  storytellingPrompts: [
    'Sat down to share the full story before it got lost in drafts',
    'So I was vibing and thought: redditors deserve the behind-the-scenes',
    'One minute it was casual, next I had a whole story I had to tell you'
  ],
  callouts: ['drop your take in the comments', 'mods please don\'t bonk me', 'shout-out to the lurkers']
};

const redditCoffeePack: CommunityVoicePack = {
  slug: 'reddit:r/coffee',
  platform: 'reddit',
  lexicon: ['dialed in', 'espresso', 'pour-over', 'dial', 'crema', 'bloom'],
  humorReferences: [
    'yes I logged this in my brew journal',
    'send help, my grinder settings are chaos',
    'this roast? big cozy energy'
  ],
  voiceMarkers: ['ngl', 'honestly', 'not gonna lie'],
  storytellingPrompts: [
    'I swear the kettle whistle sounded like applause',
    'Tracked the bloom just to flex for you',
    'Pulled this shot imagining we were sharing it together'
  ],
  callouts: ['tell me your favorite roast', 'drop grinder tips below']
};

const redditFitnessPack: CommunityVoicePack = {
  slug: 'reddit:r/fitness',
  platform: 'reddit',
  lexicon: ['PR', 'rep scheme', 'DOMS', 'split', 'hypertrophy', 'bulk'],
  humorReferences: [
    'coach probably wants me to deload but lol no',
    'DOMS hit harder than mod deletions',
    'ate like a goblin for these gains'
  ],
  voiceMarkers: ['fr', 'honestly', 'low-key'],
  storytellingPrompts: [
    'Logged the session just so I could brag to you',
    'Hit a mini PR because I pictured you cheering from the sidelines',
    'Turned the gym mirror into a confession booth for us'
  ],
  callouts: ['drop your current split', 'flex check thread when?']
};

const packs: Record<string, CommunityVoicePack> = {
  [defaultPack.slug]: defaultPack,
  [redditDefaultPack.slug]: redditDefaultPack,
  [redditCoffeePack.slug]: redditCoffeePack,
  [redditFitnessPack.slug]: redditFitnessPack
};

function normalizeCommunityKey(community?: string, platform?: string): string {
  if (!community) {
    return platform ? `${platform.toLowerCase()}:default` : defaultPack.slug;
  }
  const trimmed = community.trim().toLowerCase();
  if (trimmed.startsWith('reddit:')) {
    return trimmed;
  }
  if (trimmed.startsWith('r/')) {
    return `reddit:${trimmed}`;
  }
  if (!platform) {
    return trimmed;
  }
  return `${platform.toLowerCase()}:${trimmed}`;
}

export function getCommunityVoicePack(community?: string, platform?: string): CommunityVoicePack {
  const key = normalizeCommunityKey(community, platform);
  return packs[key] ?? packs[`${platform?.toLowerCase() ?? 'general'}:default`] ?? defaultPack;
}

export function sampleCommunityReference(
  pack: CommunityVoicePack,
  random: () => number = Math.random
): string | undefined {
  if (pack.humorReferences.length === 0) {
    return undefined;
  }
  const index = Math.floor(random() * pack.humorReferences.length);
  return pack.humorReferences[index];
}
server/conversational-tone.ts
New
+253-0
import type { CommunityVoicePack } from './community-voice-packs.js';

export interface ConversationalToneConfig {
  readonly platform?: string;
  readonly voiceMarkers: readonly string[];
  readonly fillerWords: readonly string[];
  readonly contractionProbability: number;
  readonly voiceMarkerProbability: number;
  readonly fragmentProbability: number;
  readonly allowImperfections?: boolean;
  readonly random?: () => number;
}

export interface ConversationalToneResult {
  text: string;
  voiceMarkersUsed: string[];
  contractionsApplied: number;
  fragmentsInserted: number;
}

const BASE_VOICE_MARKERS: readonly string[] = ['tbh', 'honestly', 'ngl', 'fr', 'I mean'];
const BASE_FILLERS: readonly string[] = ['and yeah,', 'so, like,', 'no lie,', 'for real,', 'not gonna lie,'];
const DEFAULT_FRAGMENT_TEMPLATE = (marker: string): string => `${marker} not gonna lie.`;

interface ContractionRule {
  readonly matcher: RegExp;
  readonly replacement: string;
}

const CONTRACTION_RULES: readonly ContractionRule[] = [
  { matcher: /\bI am\b/gi, replacement: "I'm" },
  { matcher: /\bare not\b/gi, replacement: "aren't" },
  { matcher: /\bis not\b/gi, replacement: "isn't" },
  { matcher: /\bwas not\b/gi, replacement: "wasn't" },
  { matcher: /\bwere not\b/gi, replacement: "weren't" },
  { matcher: /\bdo not\b/gi, replacement: "don't" },
  { matcher: /\bdid not\b/gi, replacement: "didn't" },
  { matcher: /\bdoes not\b/gi, replacement: "doesn't" },
  { matcher: /\bwill not\b/gi, replacement: "won't" },
  { matcher: /\bcan not\b/gi, replacement: "can't" },
  { matcher: /\bcannot\b/gi, replacement: "can't" },
  { matcher: /\bhave not\b/gi, replacement: "haven't" },
  { matcher: /\bhas not\b/gi, replacement: "hasn't" },
  { matcher: /\bhad not\b/gi, replacement: "hadn't" },
  { matcher: /\bshould have\b/gi, replacement: "should've" },
  { matcher: /\bcould have\b/gi, replacement: "could've" },
  { matcher: /\bwould have\b/gi, replacement: "would've" },
  { matcher: /\bI would\b/gi, replacement: "I'd" },
  { matcher: /\bI will\b/gi, replacement: "I'll" },
  { matcher: /\bI have\b/gi, replacement: "I've" },
  { matcher: /\bthat is\b/gi, replacement: "that's" },
  { matcher: /\bthere is\b/gi, replacement: "there's" }
];

function clamp(value: number, min: number, max: number): number {
  if (Number.isNaN(value)) {
    return min;
  }
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

function pickRandom<T>(values: readonly T[], random: () => number): T {
  if (values.length === 0) {
    throw new Error('Attempted to pick from an empty collection');
  }
  const index = Math.floor(random() * values.length);
  return values[index] ?? values[0];
}

function lowercaseFirst(value: string): string {
  if (value.length === 0) {
    return value;
  }
  return value.charAt(0).toLowerCase() + value.slice(1);
}

function applyCaseFromSource(source: string, replacement: string): string {
  if (source.toUpperCase() === source) {
    return replacement.toUpperCase();
  }
  if (source.toLowerCase() === source) {
    return replacement.toLowerCase();
  }
  if (source[0] === source[0].toUpperCase()) {
    return replacement.charAt(0).toUpperCase() + replacement.slice(1);
  }
  return replacement;
}

function applyContractions(sentence: string, probability: number, random: () => number): { text: string; applied: number } {
  let result = sentence;
  let applied = 0;
  for (const rule of CONTRACTION_RULES) {
    if (random() > probability) {
      continue;
    }
    const matcher = new RegExp(rule.matcher);
    const replaced = result.replace(matcher, match => {
      applied += 1;
      return applyCaseFromSource(match, rule.replacement);
    });
    result = replaced;
  }
  return { text: result, applied };
}

function maybeInjectVoiceMarker(
  sentence: string,
  voiceMarkers: readonly string[],
  probability: number,
  random: () => number,
  used: string[]
): string {
  if (voiceMarkers.length === 0 || random() > probability) {
    return sentence;
  }
  const marker = pickRandom(voiceMarkers, random);
  used.push(marker);
  const trimmed = sentence.trim();
  if (trimmed.length === 0) {
    return `${marker}, ${sentence}`;
  }
  if (trimmed.length <= 40) {
    return `${marker}, ${trimmed}`;
  }
  if (random() < 0.5) {
    return `${marker}, ${lowercaseFirst(trimmed)}`;
  }
  return `${trimmed} (${marker})`;
}

function ensureSentenceVariance(
  sentences: string[],
  fillerWords: readonly string[],
  fragmentProbability: number,
  random: () => number,
  used: string[]
): { sentences: string[]; fragmentsInserted: number } {
  const normalized = [...sentences];
  let fragmentsInserted = 0;

  const hasShort = normalized.some(sentence => sentence.trim().length <= 50);
  if (!hasShort && normalized.length > 0 && random() < clamp(fragmentProbability, 0, 1)) {
    const marker = used[0] ?? (fillerWords.length > 0 ? fillerWords[0] : 'honestly');
    const fragment = DEFAULT_FRAGMENT_TEMPLATE(marker.replace(/[, ]+$/u, ''));
    normalized.splice(1, 0, fragment);
    fragmentsInserted += 1;
  }

  const hasLong = normalized.some(sentence => sentence.trim().length >= 110);
  if (!hasLong && normalized.length >= 2) {
    const filler = fillerWords.length > 0 ? pickRandom(fillerWords, random) : 'and yeah,';
    const merged = `${normalized[0].trim()} ${filler} ${lowercaseFirst(normalized[1].trim())}`.replace(/\s+/gu, ' ');
    normalized.splice(0, 2, merged);
  }

  return { sentences: normalized, fragmentsInserted };
}

function splitIntoSentences(paragraph: string): string[] {
  return paragraph.split(/(?<=[.!?])\s+/u).filter(part => part.trim().length > 0);
}

function joinSentences(sentences: string[], original: string): string {
  const trailingWhitespaceMatch = original.match(/\s+$/u);
  const trailingWhitespace = trailingWhitespaceMatch ? trailingWhitespaceMatch[0] : '';
  return `${sentences.join(' ').replace(/\s+/gu, ' ').trim()}${trailingWhitespace}`;
}

export function applyConversationalTone(text: string, config: ConversationalToneConfig): ConversationalToneResult {
  if (text.trim().length === 0) {
    return {
      text,
      voiceMarkersUsed: [],
      contractionsApplied: 0,
      fragmentsInserted: 0
    };
  }

  const random = config.random ?? Math.random;
  const voiceMarkers = config.voiceMarkers.length > 0 ? config.voiceMarkers : BASE_VOICE_MARKERS;
  const fillerWords = config.fillerWords.length > 0 ? config.fillerWords : BASE_FILLERS;
  const voiceMarkersUsed: string[] = [];
  let contractionsApplied = 0;

  const paragraphs = text.split(/\n\n+/u);
  const processedParagraphs = paragraphs.map(paragraph => {
    const sentences = splitIntoSentences(paragraph);
    const processedSentences = sentences.map(sentence => {
      const contractionResult = applyContractions(sentence, clamp(config.contractionProbability, 0, 1), random);
      contractionsApplied += contractionResult.applied;
      const withVoiceMarker = maybeInjectVoiceMarker(
        contractionResult.text,
        voiceMarkers,
        clamp(config.voiceMarkerProbability, 0, 1),
        random,
        voiceMarkersUsed
      );
      return withVoiceMarker;
    });

    const varianceResult = ensureSentenceVariance(
      processedSentences,
      fillerWords,
      config.fragmentProbability,
      random,
      voiceMarkersUsed
    );
    return joinSentences(varianceResult.sentences, paragraph);
  });

  return {
    text: processedParagraphs.join('\n\n'),
    voiceMarkersUsed,
    contractionsApplied,
    fragmentsInserted: processedParagraphs.length - paragraphs.length
  };
}

export function buildConversationalToneConfig(
  communityPack: CommunityVoicePack,
  overrides: Partial<ConversationalToneConfig> | undefined,
  random: () => number,
  platform?: string
): ConversationalToneConfig {
  const baseMarkers = Array.from(new Set([
    ...BASE_VOICE_MARKERS,
    ...communityPack.voiceMarkers
  ]));

  const fillerWords = Array.from(new Set([
    ...BASE_FILLERS,
    ...communityPack.lexicon,
    ...communityPack.callouts
  ])).filter(entry => entry.trim().length > 0);

  return {
    platform,
    voiceMarkers: overrides?.voiceMarkers ?? baseMarkers,
    fillerWords: overrides?.fillerWords ?? fillerWords,
    contractionProbability: overrides?.contractionProbability ?? 0.55,
    voiceMarkerProbability: overrides?.voiceMarkerProbability ?? 0.6,
    fragmentProbability: overrides?.fragmentProbability ?? 0.35,
    allowImperfections: overrides?.allowImperfections ?? true,
    random: overrides?.random ?? random
  };
}
server/engagement-experiments.ts
New
+73-0
export interface ExperimentDefinition {
  readonly id: string;
  readonly description: string;
  readonly controlVariant: string;
  readonly variants: Record<string, number>;
  readonly primaryMetrics: readonly string[];
}

export interface ExperimentAssignment {
  readonly id: string;
  readonly variant: string;
  readonly isControl: boolean;
}

const experimentDefinitions: Record<string, ExperimentDefinition> = {
  'conversational-tone-v1': {
    id: 'conversational-tone-v1',
    description: 'Validates conversational Reddit-inspired voice markers for improved engagement.',
    controlVariant: 'control',
    variants: {
      control: 0.5,
      conversational: 0.5
    },
    primaryMetrics: ['upvoteRate', 'commentDepth', 'dwellTime']
  }
};

export function getExperimentDefinition(experimentId: string): ExperimentDefinition | undefined {
  return experimentDefinitions[experimentId];
}

export function assignExperimentVariant(
  experimentId: string,
  random: () => number = Math.random
): ExperimentAssignment {
  const definition = experimentDefinitions[experimentId];
  if (!definition) {
    return {
      id: experimentId,
      variant: 'control',
      isControl: true
    };
  }

  const weights = definition.variants;
  const totalWeight = Object.values(weights).reduce((accumulator, weight) => accumulator + weight, 0);
  const normalizedTotal = totalWeight > 0 ? totalWeight : 1;
  let roll = random() * normalizedTotal;

  for (const [variant, weight] of Object.entries(weights)) {
    roll -= weight;
    if (roll <= 0) {
      return {
        id: experimentId,
        variant,
        isControl: variant === definition.controlVariant
      };
    }
  }

  return {
    id: experimentId,
    variant: definition.controlVariant,
    isControl: true
  };
}

export function isTreatmentVariant(assignment: ExperimentAssignment | undefined): boolean {
  if (!assignment) {
    return false;
  }
  return !assignment.isControl;
}
server/story-persona.ts
New
+156-0
import type { CommunityVoicePack } from './community-voice-packs.js';

export type PersonaTone = 'confident' | 'playful' | 'mysterious' | 'authentic' | 'sassy';

export interface StoryPersona {
  readonly id: string;
  readonly tone: PersonaTone;
  readonly entryHooks: readonly string[];
  readonly vulnerabilityBeats: readonly string[];
  readonly callbacks: readonly string[];
  readonly closingAffirmations: readonly string[];
}

export interface StoryPersonaContext {
  readonly communityPack: CommunityVoicePack;
  readonly random?: () => number;
}

export interface StoryPersonaResult {
  segments: string[];
  callbacksUsed: string[];
}

const personaDefinitions: Record<PersonaTone, StoryPersona> = {
  confident: {
    id: 'persona-confident',
    tone: 'confident',
    entryHooks: [
      'Pulled you into my world because I know you can handle it.',
      'Checked the mirror, smirked, and hit record thinking of you.',
      'You keep showing up for me, so I keep turning the heat up for you.'
    ],
    vulnerabilityBeats: [
      'Truth is I still get butterflies sharing the raw takes with you.',
      'Even when I flex, it is because letting you see the real parts feels brave.',
      'Some days confidence is a costumeâ€”today it is a promise I made to you.'
    ],
    callbacks: ['Tell me you felt that rush too.', 'Promise me you will hype yourself the same way.'],
    closingAffirmations: ['You and me? Unstoppable energy.']
  },
  playful: {
    id: 'persona-playful',
    tone: 'playful',
    entryHooks: [
      'Started giggling halfway through and knew you had to see it.',
      'I swear I set the tripod up and instantly started clowning for you.',
      'Could not keep a straight face, so I leaned into the chaos just for you.'
    ],
    vulnerabilityBeats: [
      'Little secret: I do the goofy takes first so I can relax into the real ones.',
      'Promise you will laugh with me, not at me, okay?',
      'Sometimes playfulness is my way of saying I am nervous to disappoint.'
    ],
    callbacks: ['Drop your funniest comment so I do not feel alone here.'],
    closingAffirmations: ['Thanks for letting me be a dork and still feel adored.']
  },
  mysterious: {
    id: 'persona-mysterious',
    tone: 'mysterious',
    entryHooks: [
      'This one felt like a secret I owed you.',
      'Kept the lights low so you would lean in closer.',
      'I only share the hush moments with people who stay curious.'
    ],
    vulnerabilityBeats: [
      'Every shadow I reveal means I trust you more than the rest.',
      'Some mysteries are armorâ€”thanks for holding mine gently.',
      'You never push too hard, which is why I let you in this far.'
    ],
    callbacks: ['Tell me how you translate the silence.'],
    closingAffirmations: ['Stay close, there is more between the lines.']
  },
  authentic: {
    id: 'persona-authentic',
    tone: 'authentic',
    entryHooks: [
      'Pressed record right after I exhaled because I wanted zero polish.',
      'No glam squad, just me and the messy truth again.',
      'This is me grabbing the camera before I talk myself out of it.'
    ],
    vulnerabilityBeats: [
      'Hope you can feel how much I mean it when I say I appreciate you.',
      'Sharing the soft parts still makes my hands shake a little.',
      'I am not perfect, but I promised you real.'
    ],
    callbacks: ['Tell me what part felt the most like us.'],
    closingAffirmations: ['Thanks for letting me be this version of me.']
  },
  sassy: {
    id: 'persona-sassy',
    tone: 'sassy',
    entryHooks: [
      'Caught myself talking smack to the mirror and had to share.',
      'If I am serving attitude, you are definitely getting front-row seats.',
      'Tossed the script out and freestyled the spice just for you.'
    ],
    vulnerabilityBeats: [
      'Beneath the sass I still crave the ones who hype me up.',
      'I joke a lot but you know it is all because you see me.',
      'If I did not trust you, you would never witness this much edge.'
    ],
    callbacks: ['Drop your boldest line back at me.'],
    closingAffirmations: ['Stay bold with me.']
  }
};

function pickRandom<T>(values: readonly T[], random: () => number): T {
  if (values.length === 0) {
    throw new Error('Cannot pick from an empty list.');
  }
  const index = Math.floor(random() * values.length);
  return values[index] ?? values[0];
}

export function getStoryPersona(tone: PersonaTone): StoryPersona {
  return personaDefinitions[tone];
}

export function applyStoryPersonaSegments(
  baseSegments: string[],
  persona: StoryPersona,
  context: StoryPersonaContext
): StoryPersonaResult {
  const random = context.random ?? Math.random;
  const segments = [...baseSegments];
  const callbacksUsed: string[] = [];

  const hasFirstPerson = segments.some(segment => /\bI\b/iu.test(segment));
  if (!hasFirstPerson) {
    segments.unshift(pickRandom(persona.entryHooks, random));
  } else if (random() < 0.65) {
    segments.unshift(pickRandom(persona.entryHooks, random));
  }

  if (random() < 0.85) {
    const vulnerability = pickRandom(persona.vulnerabilityBeats, random);
    segments.splice(1, 0, vulnerability);
  }

  if (context.communityPack.storytellingPrompts.length > 0 && random() < 0.75) {
    const communityMoment = pickRandom(context.communityPack.storytellingPrompts, random);
    segments.splice(Math.min(segments.length, 2), 0, communityMoment);
  }

  const callback = pickRandom([...persona.callbacks, ...context.communityPack.callouts], random);
  callbacksUsed.push(callback);
  segments.push(callback);

  const affirmation = pickRandom(persona.closingAffirmations, random);
  segments.push(affirmation);

  return {
    segments,
    callbacksUsed
  };
}
tests/unit/server/advanced-content-generator.test.ts
+25-0
@@ -149,25 +149,50 @@ describe('generateAdvancedContent humanization', () => {
    humanization: {
      maxQuirks: 3
    }
  };

  it('keeps appended hashtags intact after applying humanization', () => {
    Math.random = createSeededRandom(42);

    const result = generateAdvancedContent(params);

    expect(result.content.endsWith(' #glow #mood')).toBe(true);
    expect(JSON.stringify(result)).toContain('#glow');
  });

  it('produces deterministic content when randomness is seeded', () => {
    Math.random = createSeededRandom(24);
    const first = generateAdvancedContent(params);

    Math.random = createSeededRandom(24);
    const second = generateAdvancedContent(params);

    expect(second.content).toBe(first.content);
    expect(second.titles).toEqual(first.titles);
  });
});

describe('generateAdvancedContent authenticity diagnostics', () => {
  const params: ContentParameters = {
    photoType: 'casual',
    textTone: 'authentic',
    style: 'community-style',
    includePromotion: false,
    selectedHashtags: [],
    platform: 'reddit',
    targetCommunity: 'r/fitness',
    experiment: { id: 'conversational-tone-v1', variant: 'conversational' }
  };

  it('returns authenticity metrics with reddit voice markers', () => {
    Math.random = createSeededRandom(77);

    const result = generateAdvancedContent(params);

    expect(result.content.toLowerCase()).toMatch(/ngl|honestly|fr/);
    expect(result.diagnostics).toBeDefined();
    expect(result.diagnostics?.authenticity.score).toBeGreaterThan(0.2);
    expect(result.diagnostics?.voiceMarkersUsed.length).toBeGreaterThan(0);
    expect(result.diagnostics?.experiment?.variant).toBe('conversational');
  });
});
