Add mandatory token enforcement in pipelineRewrite
Sep 22 · a1davida1/TPilot · main
+27-20
1. In `pipelineRewrite` (`server/caption/rewritePipeline.ts`), invoke `await enforceMandatoryTokens()` immediately after the first `rankAndSelect` call and after every subsequent `runRewrite` that might modify `out`.
2. Extend the rewrite tests (`tests/routes/caption-generation.test.ts`) to cover the no-platform-error path and confirm that required tokens survive without relying on the fallback branch.

Summary

    Updated pipelineRewrite to track ranked variants, enforce mandatory token retention immediately after the initial selection, and rerun rewrites with token enforcement during subsequent retries and coverage checks so Gemini outputs stay compliant without requiring platform errors.

Strengthened the rewrite test to assert that the Gemini path keeps required entities, emits the ABSOLUTE RULE hint, and avoids the OpenAI fallback when platform validation succeeds.

Testing

    ✅ npm run lint

⚠️ npm test *(fails because many suites require external services, environment variables, or optional test fixtures that are unavailable in the sandbox; see ENETUNREACH/ERR_INVALID_URL/module resolution errors in the log)*


server/caption/rewritePipeline.ts
+21-19
@@ -301,117 +301,119 @@ export async function rankAndSelect(

type RewritePipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  existingCaption:string;
  imageUrl?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

/**
 * Caption rewriting pipeline that enhances existing captions while preserving tone.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;
    const doNotDrop = extractKeyEntities(existingCaption);
    const tone = { style, mood };
    let variants = await variantsRewrite({ platform, voice, ...tone, existingCaption, facts, nsfw, doNotDrop });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;

    const retryHints = [
      'Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.',
      'Focus on expanding the middle section with vivid details or specific context.',
      'Add personality and character-specific phrasing while being more descriptive.'
    ];

    const enforceCoverage = async () => {
      if (!facts) return;
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        variants = await variantsRewrite({ platform, voice, ...tone, existingCaption, facts, hint: coverage.hint, nsfw, doNotDrop });
        ranked = await rankAndSelect(variants);
        out = ranked.final;
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };
    let variants: z.infer<typeof CaptionArray>;
    let ranked: z.infer<typeof RankResult>;
    let out: z.infer<typeof RankResult>["final"];

    const enforceMandatoryTokens = async (extraHint?: string) => {
      if (doNotDrop.length === 0) {
        return;
      }
      const missing = doNotDrop.filter((token) => !out.caption.includes(token));
      if (missing.length === 0) {
        return;
      }
      const messageParts = [
        extraHint,
        `ABSOLUTE RULE: Keep these tokens verbatim in the caption: ${doNotDrop.join(', ')}`,
        `Previous attempt removed: ${missing.join(', ')}`
      ].filter((part): part is string => Boolean(part && part.trim()));
      variants = await variantsRewrite({
        platform,
        voice,
        ...tone,
        existingCaption,
        facts,
        nsfw,
        doNotDrop,
        hint: messageParts.join(' ')
      });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
      const retryMissing = doNotDrop.filter((token) => !out.caption.includes(token));
      if (retryMissing.length > 0) {
        throw new Error(`Missing mandatory tokens after retry: ${retryMissing.join(', ')}`);
      }
    };

    const runRewrite = async (hint?: string) => {
    const runRewrite = async (hint?: string, enforceHint?: string) => {
      variants = await variantsRewrite({ platform, voice, existingCaption, facts, hint, nsfw, doNotDrop, ...tone });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
      await enforceMandatoryTokens(enforceHint);
    };

    const enforceCoverage = async () => {
      if (!facts) return;
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        await runRewrite(coverage.hint);
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    const ensureLongerCaption = async (baseHint?: string) => {
      if (out.caption.length > existingCaption.length) {
        return;
      }
      for (const hint of retryHints) {
        const combinedHint = baseHint ? `${baseHint} ${hint}` : hint;
        await runRewrite(combinedHint);
        if (out.caption.length > existingCaption.length) {
          return;
        }
      }
      throw new Error("rewrite-too-short");
    };

    variants = await variantsRewrite({ platform, voice, ...tone, existingCaption, facts, nsfw, doNotDrop });
    ranked = await rankAndSelect(variants);
    out = ranked.final;
    await enforceMandatoryTokens();
    await ensureLongerCaption();
    await enforceCoverage();

    const err = platformChecks(platform, out);
    if (err) {
      await runRewrite(`Fix: ${err}. Be specific and engaging.`);
      await runRewrite(`Fix: ${err}. Be specific and engaging.`, `Fix platform issue: ${err}.`);
      await ensureLongerCaption(`Fix: ${err}. Be specific and engaging.`);
      await enforceMandatoryTokens(`Fix platform issue: ${err}.`);
      await enforceCoverage();
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
tests/routes/caption-generation.test.ts
+6-1
@@ -556,51 +556,51 @@ describe('Caption Generation', () => {
              safety_level: 'normal',
              mood: 'engaging',
              style: 'authentic',
              cta: 'What do you think?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock.mockResolvedValue(mockResponse);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(result.final.caption).not.toBe(existingCaption);
      expect(result.final.caption).toContain('Enhanced');

      textGenerateMock.mockReset();
    });

    it('retries when mandatory tokens are dropped', async () => {
    it('retries when mandatory tokens are dropped without platform errors', async () => {
      const existingCaption = 'Launch day! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ #LaunchDay';
      const variantFactory = (caption: string) => ({
        caption,
        hashtags: ['#LaunchDay', '#EventTime', '#RSVPNow'],
        safety_level: 'normal',
        mood: 'excited',
        style: 'authentic',
        cta: 'Reserve your spot',
        alt: 'Detailed alt text describing the MegaCorp launch announcement in a complete sentence.',
        nsfw: false,
      });

      const missingVariants = {
        response: {
          text: () => JSON.stringify(
            Array.from({ length: 5 }, (_, index) =>
              variantFactory(`Variant ${index + 1} without mandatory tokens`)
            )
          ),
        },
      };

      const missingRank = {
        response: {
          text: () => JSON.stringify({
@@ -629,50 +629,55 @@ describe('Caption Generation', () => {
            winner_index: 0,
            scores: [5, 4, 3, 2, 1],
            reason: 'Retry keeps mandatory tokens',
            final: variantFactory(enforcedCaption),
          }),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce(missingVariants)
        .mockResolvedValueOnce(missingRank)
        .mockResolvedValueOnce(enforcedVariants)
        .mockResolvedValueOnce(enforcedRank);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');
      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(textGenerateMock).toHaveBeenCalledTimes(4);
      const promptCalls = [...textGenerateMock.mock.calls];
      expect(promptCalls[2]?.[0]?.[0]?.text).toContain('ABSOLUTE RULE: Keep these tokens verbatim in the caption');
      expect(promptCalls[2]?.[0]?.[0]?.text).not.toContain('Fix platform issue');
      expect(result.provider).toBe('gemini');
      expect(result.final.caption).toBe(enforcedCaption);
      expect(result.final.caption).toContain('https://example.com/launch');
      expect(result.final.caption).toContain('@LaunchHQ');
      expect(result.final.caption).toContain('#LaunchDay');
      expect(result.final.caption).toContain('12/25');
      expect(result.final.caption).toContain('"Mega Launch"');
      expect(result.final.caption).toContain('MegaCorp™');

      textGenerateMock.mockReset();
    });

    it('retries rewrite with hints when the first pass is too short', async () => {
      const existingCaption = 'Basic caption here';
      const longAltText =
        'A descriptive alt text that clearly explains the scene and exceeds the schema requirements for length.';

      const makeVariants = (caption: string) =>
        Array.from({ length: 5 }, () => ({
          caption,
          hashtags: ['#vibes', '#style', '#moments'],
          safety_level: 'normal',
          mood: 'engaging',
          style: 'authentic',
          cta: 'Tell me what you think',
          alt: longAltText,
          nsfw: false,
