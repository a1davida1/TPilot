Introduce caption helper and refactor variants
Sep 20 · a1davida1/TPilot · main
+609-44
1. Introduce a helper in `server/caption` (e.g., `inferFallbackFromFacts.ts`) that builds hashtags, CTA, and alt text from `facts`, `existingCaption`, or `theme` using noun extraction and platform limits.
2. Swap the current hard-coded assignments in `generateVariants`, `generateVariantsTextOnly`, and both `rankAndSelect` implementations for calls to the new helper so that even fallback data feels contextual.
3. Back this with unit tests covering various fact shapes (image with beach facts, text-only launch promo, etc.) to prove hashtags/CTA adapt to inputs.

Summary

    Added inferFallbackFromFacts utilities to extract contextual nouns from facts, themes, and captions, generate platform-bounded hashtags/CTA/alt text, and merge them with existing content while honoring safety checks.

Reworked the Gemini caption pipeline to apply the new helper when variants are sparse or padded so fallback captions, hashtags, and alt text stay grounded in extracted image facts through generation and ranking.

Updated the text-only pipeline to feed theme/context data into the helper for both variant generation and ranking, yielding launch- or campaign-aware metadata even when the model omits fields.

Added targeted unit tests for the helper plus new pipeline tests that prove beach imagery and launch promos receive adaptive hashtags, CTA copy, and descriptive alt text.

Testing

    ⚠️ npm run lint (passes with numerous pre-existing repository warnings).

⚠️ npm test (aborted after encountering existing failures in payment/auth/storage suites unrelated to caption changes).


server/caption/geminiPipeline.ts
+51-13
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { ensureFallbackCompliance, inferFallbackFromFacts } from "./inferFallbackFromFacts";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);
@@ -206,123 +207,160 @@ export async function generateVariants(params: {
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";

      const fallback = ensureFallbackCompliance(
        {
          caption: typeof variant.caption === 'string' ? variant.caption : undefined,
          hashtags: Array.isArray(variant.hashtags) ? variant.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
          cta: typeof variant.cta === 'string' ? variant.cta : undefined,
          alt: typeof variant.alt === 'string' ? variant.alt : undefined,
        },
        {
          platform: params.platform,
          facts: params.facts,
          existingCaption: typeof variant.caption === 'string' ? variant.caption : undefined,
        },
      );
      variant.hashtags = fallback.hashtags;
      variant.cta = fallback.cta;
      variant.alt = fallback.alt;
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      const templateCaption = typeof template.caption === 'string' ? template.caption : undefined;
      const fallback = inferFallbackFromFacts({
        platform: params.platform,
        facts: params.facts,
        existingCaption: templateCaption,
      });
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
        hashtags: fallback.hashtags,
        cta: fallback.cta,
        alt: fallback.alt,
        caption: `${templateCaption ?? 'Fresh perspective'} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
export async function rankAndSelect(
  variants: z.infer<typeof CaptionArray>,
  params: { platform: "instagram" | "x" | "reddit" | "tiktok"; facts?: Record<string, unknown> },
): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  // Accept any safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

    const fallback = ensureFallbackCompliance(
      {
        caption: typeof final.caption === 'string' ? final.caption : undefined,
        hashtags: Array.isArray(final.hashtags) ? final.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
        cta: typeof final.cta === 'string' ? final.cta : undefined,
        alt: typeof final.alt === 'string' ? final.alt : undefined,
      },
      {
        platform: params.platform,
        facts: params.facts,
        existingCaption: typeof final.caption === 'string' ? final.caption : undefined,
      },
    );
    final.hashtags = fallback.hashtags;
    final.cta = fallback.cta;
    final.alt = fallback.alt;
  }
  return RankResult.parse(json);
}

export async function pipeline({ imageUrl, platform, voice = "flirty_playful", style, mood, nsfw = false }: {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  style?: string;
  mood?: string;
  nsfw?: boolean;
}): Promise<CaptionResult> {
  try {
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, style, mood, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let ranked = await rankAndSelect(variants, { platform, facts });
    let out = ranked.final;

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({ platform, voice, facts, hint:`Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`, nsfw });
      ranked = await rankAndSelect(variants);
      ranked = await rankAndSelect(variants, { platform, facts });
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/inferFallbackFromFacts.ts
New
+354-0
import { platformChecks } from "./schema";

export type SupportedPlatform = "instagram" | "x" | "reddit" | "tiktok";

interface FallbackParams {
  platform: SupportedPlatform;
  facts?: Record<string, unknown>;
  existingCaption?: string;
  theme?: string;
}

export interface FallbackContent {
  hashtags: string[];
  cta: string;
  alt: string;
}

const STOP_WORDS = new Set([
  "a",
  "an",
  "and",
  "are",
  "be",
  "best",
  "by",
  "for",
  "from",
  "get",
  "give",
  "have",
  "here",
  "how",
  "in",
  "into",
  "is",
  "it",
  "let",
  "like",
  "make",
  "more",
  "of",
  "on",
  "our",
  "out",
  "see",
  "take",
  "that",
  "the",
  "this",
  "those",
  "through",
  "to",
  "up",
  "with",
  "your",
  "you",
  "we",
  "us",
  "photo",
  "image",
  "picture",
  "beautiful",
  "stunning",
  "awesome",
  "great",
  "amazing",
  "new",
  "today",
  "tonight",
  "now",
  "just",
]);

const PLATFORM_HASHTAG_LIMITS: Record<SupportedPlatform, { min: number; max: number }> = {
  instagram: { min: 3, max: 8 },
  x: { min: 1, max: 3 },
  reddit: { min: 1, max: 3 },
  tiktok: { min: 2, max: 5 },
};

const BANNED_TAGS = new Set(["#love", "#follow", "#like", "#instagood"]);

function collectStrings(value: unknown): string[] {
  if (typeof value === "string") return [value];
  if (typeof value === "number") return [String(value)];
  if (Array.isArray(value)) {
    return value.flatMap(item => collectStrings(item));
  }
  if (typeof value === "object" && value !== null) {
    return Object.values(value as Record<string, unknown>).flatMap(v => collectStrings(v));
  }
  return [];
}

function tokenize(phrases: string[]): string[] {
  const seen = new Set<string>();
  const tokens: string[] = [];
  phrases.forEach(phrase => {
    const cleaned = phrase
      .replace(/[\u{1F300}-\u{1FAFF}]/gu, " ")
      .replace(/[^\p{L}\p{N}\s]/gu, " ");
    cleaned
      .split(/\s+/)
      .map(word => word.trim().toLowerCase())
      .filter(word => word.length > 2 && !STOP_WORDS.has(word))
      .forEach(word => {
        if (!seen.has(word)) {
          seen.add(word);
          tokens.push(word);
        }
      });
  });
  return tokens;
}

function toHashtagWord(phrase: string): string {
  const segments = phrase
    .split(/\s+/)
    .map(segment => segment.replace(/[^\p{L}\p{N}]/gu, ""))
    .filter(segment => segment.length > 0);
  if (segments.length === 0) return "";
  return segments
    .map(segment => segment[0]?.toUpperCase() + segment.slice(1))
    .join("");
}

function renderList(parts: string[]): string {
  if (parts.length === 0) return "";
  if (parts.length === 1) return parts[0];
  if (parts.length === 2) return `${parts[0]} and ${parts[1]}`;
  return `${parts.slice(0, -1).join(", ")}, and ${parts[parts.length - 1]}`;
}

function dedupe<T>(values: T[]): T[] {
  const seen = new Set<string>();
  const result: T[] = [];
  values.forEach(value => {
    const key = typeof value === "string" ? value.toLowerCase() : JSON.stringify(value);
    if (!seen.has(key)) {
      seen.add(key);
      result.push(value);
    }
  });
  return result;
}

function buildHashtags(params: FallbackParams, tokens: string[], phrases: string[]): string[] {
  if (params.platform === "reddit") {
    const contextual = dedupe([
      ...phrases.map(phrase => phrase.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, " ").trim()).filter(Boolean),
      ...tokens,
      params.theme?.toLowerCase().trim() ?? "",
    ]).filter(Boolean);
    const usable = contextual.slice(0, PLATFORM_HASHTAG_LIMITS.reddit.max);
    if (usable.length > 0) return usable;
    return ["community spotlight"];
  }

  const limits = PLATFORM_HASHTAG_LIMITS[params.platform];
  const themedTokens = dedupe([
    ...tokens,
    ...(params.theme ? tokenize([params.theme]) : []),
  ]);
  const hashtags: string[] = [];
  themedTokens.forEach(token => {
    if (hashtags.length >= limits.max) return;
    const word = toHashtagWord(token);
    if (!word) return;
    const tag = `#${word}`;
    if (!BANNED_TAGS.has(tag.toLowerCase()) && !hashtags.some(existing => existing.toLowerCase() === tag.toLowerCase())) {
      hashtags.push(tag);
    }
  });

  const fallbackThemes: Record<SupportedPlatform, string[]> = {
    instagram: ["#BehindTheScenes", "#DailyInspo", "#VibeCheck"],
    x: ["#NowTrending", "#LetsDiscuss", "#HotTake"],
    reddit: [],
    tiktok: ["#ForYou", "#Trending", "#CreatorLife"],
  };

  const themeFallbacks = fallbackThemes[params.platform];
  let idx = 0;
  while (hashtags.length < limits.min && idx < themeFallbacks.length) {
    const fallbackTag = themeFallbacks[idx];
    idx += 1;
    if (!hashtags.some(existing => existing.toLowerCase() === fallbackTag.toLowerCase())) {
      hashtags.push(fallbackTag);
    }
  }

  const trimmed = hashtags.slice(0, limits.max);
  return trimmed.length > 0 ? trimmed : ["#StayTuned"];
}

function chooseCTA(params: FallbackParams, tokens: string[]): string {
  const joined = `${params.theme ?? ""} ${tokens.join(" ")}`.toLowerCase();
  const ctaRules: Array<{ keywords: string[]; cta: string }> = [
    { keywords: ["launch", "premiere", "debut"], cta: "Be part of the launch" },
    { keywords: ["sale", "deal", "discount", "shop"], cta: "Claim the offer" },
    { keywords: ["beach", "travel", "vacation", "sunset"], cta: "Plan your getaway" },
    { keywords: ["webinar", "event", "live", "meet"], cta: "Save your spot" },
    { keywords: ["recipe", "kitchen", "food", "bake"], cta: "Try it tonight" },
    { keywords: ["community", "join", "tips", "story"], cta: "Share your take" },
    { keywords: ["fitness", "workout", "training"], cta: "Start your session" },
  ];
  const match = ctaRules.find(rule => rule.keywords.some(keyword => joined.includes(keyword)));
  if (match) return match.cta;

  const platformDefault: Record<SupportedPlatform, string> = {
    instagram: "Tap to explore",
    x: "Join the conversation",
    reddit: "Add your perspective",
    tiktok: "Watch till the end",
  };
  return platformDefault[params.platform];
}

function getArrayOfStrings(value: unknown): string[] | undefined {
  if (Array.isArray(value) && value.every(item => typeof item === "string")) {
    return value;
  }
  return undefined;
}

function getString(value: unknown): string | undefined {
  if (typeof value === "string" && value.trim().length > 0) {
    return value.trim();
  }
  return undefined;
}

function summarizeFacts(facts?: Record<string, unknown>): string[] {
  if (!facts) return [];
  const highlights: string[] = [];
  const objects = getArrayOfStrings(facts["objects"]);
  if (objects) {
    const snippet = renderList(objects.slice(0, 3));
    if (snippet) highlights.push(`featuring ${snippet}`);
  }
  const colors = getArrayOfStrings(facts["colors"]);
  if (colors) {
    const snippet = renderList(colors.slice(0, 2));
    if (snippet) highlights.push(`with ${snippet} tones`);
  }
  const setting = getString(facts["setting"]);
  if (setting) {
    highlights.push(`set in ${setting}`);
  }
  const mood = getString(facts["mood"]);
  if (mood) {
    highlights.push(`${mood} mood`);
  }
  return highlights;
}

function buildAltText(params: FallbackParams, tokens: string[], phrases: string[]): string {
  const focus = renderList(tokens.slice(0, 3).map(token => token.replace(/-/g, " ")));
  const highlights = summarizeFacts(params.facts);
  const parts: string[] = [];
  if (focus) {
    parts.push(`Scene featuring ${focus}`);
  } else if (phrases.length > 0) {
    parts.push(`Scene inspired by ${phrases[0].trim()}`);
  }
  if (highlights.length > 0) {
    parts.push(...highlights.map(highlight => highlight.charAt(0).toUpperCase() + highlight.slice(1)));
  }
  if (params.theme) {
    parts.push(`Theme: ${params.theme.trim()}`);
  }
  if (params.existingCaption) {
    const trimmed = params.existingCaption.trim();
    if (trimmed.length > 0) {
      const shortened = trimmed.length > 80 ? `${trimmed.slice(0, 77).trimEnd()}…` : trimmed;
      parts.push(`Caption context: ${shortened}`);
    }
  }
  let alt = parts.join(". ");
  if (alt.length > 200) {
    alt = alt.slice(0, 200);
    const lastSpace = alt.lastIndexOf(" ");
    if (lastSpace > 160) {
      alt = `${alt.slice(0, lastSpace)}…`;
    }
  }
  if (alt.length < 20) {
    const extra = params.theme ? `Detailed look at ${params.theme}` : "Detailed visual story";
    alt = alt.length === 0 ? `${extra}.` : `${alt}. ${extra}.`;
  }
  return alt;
}

export function inferFallbackFromFacts(params: FallbackParams): FallbackContent {
  const factPhrases = params.facts ? collectStrings(params.facts) : [];
  const basePhrases = [
    ...factPhrases,
    params.theme ?? "",
    params.existingCaption ?? "",
  ].filter(phrase => phrase && phrase.trim().length > 0);
  const tokens = tokenize(basePhrases);
  const hashtags = buildHashtags(params, tokens, basePhrases);
  const cta = chooseCTA(params, tokens);
  const alt = buildAltText(params, tokens, basePhrases);

  return { hashtags, cta, alt };
}

export function mergeWithFallback(
  original: string[] | undefined,
  fallback: string[],
  platform: SupportedPlatform,
): string[] {
  if (!original || original.length === 0) return fallback;
  const normalizedOriginal = original.filter(item => typeof item === "string");
  if (normalizedOriginal.length === 0) return fallback;
  const combined = dedupe([...normalizedOriginal, ...fallback]);
  const limits = PLATFORM_HASHTAG_LIMITS[platform];
  const sanitized = combined
    .map(tag => (platform === "reddit" ? tag.replace(/#/g, "").trim() : tag))
    .filter(tag => tag.length > 0)
    .filter(tag => (platform === "reddit" ? true : !BANNED_TAGS.has(tag.toLowerCase())));
  if (sanitized.length < limits.min) {
    const needed = limits.min - sanitized.length;
    const extras = fallback.filter(tag => !sanitized.includes(tag)).slice(0, needed);
    return [...sanitized, ...extras].slice(0, limits.max);
  }
  return sanitized.slice(0, limits.max);
}

export function ensureFallbackCompliance(
  content: { caption?: string; hashtags?: string[]; cta?: string; alt?: string },
  params: FallbackParams,
): { hashtags: string[]; cta: string; alt: string } {
  const fallback = inferFallbackFromFacts(params);
  const hashtags = mergeWithFallback(content.hashtags, fallback.hashtags, params.platform);
  const cta = typeof content.cta === "string" && content.cta.trim().length > 2 ? content.cta : fallback.cta;
  let alt = typeof content.alt === "string" && content.alt.trim().length >= 20 ? content.alt : fallback.alt;
  const candidate = {
    caption: content.caption ?? "",
    hashtags,
    cta,
    alt,
    mood: "engaging",
    style: "authentic",
    safety_level: "normal",
    nsfw: false,
  };
  const violation = platformChecks(params.platform, candidate);
  if (violation) {
    alt = fallback.alt;
  }
  return { hashtags, cta, alt };
}
server/caption/textOnlyPipeline.ts
+55-25
import fs from "node:fs/promises";
import path from "node:path";
import { textModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { ensureFallbackCompliance, inferFallbackFromFacts } from "./inferFallbackFromFacts";

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function generateVariantsTextOnly(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, theme:string, context?:string, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants_textonly.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: "${params.theme}"\nCONTEXT: "${params.context||''}"\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  const raw=stripToJSON(res.response.text());
  const json=Array.isArray(raw)?raw:[raw];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 3) {
        if(params.platform === 'instagram') {
          variant.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
        } else {
          variant.hashtags=["#content", "#creative", "#amazing"];
        }
      }
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content!";

      const contextFacts = params.context ? { context: params.context } : undefined;
      const fallback = ensureFallbackCompliance(
        {
          caption: typeof variant.caption === 'string' ? variant.caption : undefined,
          hashtags: Array.isArray(variant.hashtags) ? variant.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
          cta: typeof variant.cta === 'string' ? variant.cta : undefined,
          alt: typeof variant.alt === 'string' ? variant.alt : undefined,
        },
        {
          platform: params.platform,
          facts: contextFacts,
          existingCaption: typeof variant.caption === 'string' ? variant.caption : undefined,
          theme: params.theme,
        },
      );
      variant.hashtags = fallback.hashtags;
      variant.cta = fallback.cta;
      variant.alt = fallback.alt;
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      const templateCaption = typeof template.caption === 'string' ? template.caption : undefined;
      const fallback = inferFallbackFromFacts({
        platform: params.platform,
        facts: params.context ? { context: params.context } : undefined,
        existingCaption: templateCaption,
        theme: params.theme,
      });
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
        hashtags: fallback.hashtags,
        cta: fallback.cta,
        alt: fallback.alt,
        caption: `${templateCaption ?? 'Fresh perspective'} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
export async function rankAndSelect(
  variants: z.infer<typeof CaptionArray>,
  params: { platform: "instagram" | "x" | "reddit" | "tiktok"; theme?: string; context?: string; nsfw?: boolean },
): Promise<z.infer<typeof RankResult>>{
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  // Fix safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags) || final.hashtags.length < 3) {
      if(params?.platform === 'instagram') {
        final.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
      } else {
        final.hashtags=["#content", "#creative", "#amazing"];
      }
    }
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

    const fallback = ensureFallbackCompliance(
      {
        caption: typeof final.caption === 'string' ? final.caption : undefined,
        hashtags: Array.isArray(final.hashtags) ? final.hashtags.filter((tag): tag is string => typeof tag === 'string') : undefined,
        cta: typeof final.cta === 'string' ? final.cta : undefined,
        alt: typeof final.alt === 'string' ? final.alt : undefined,
      },
      {
        platform: params.platform,
        facts: params.context ? { context: params.context } : undefined,
        existingCaption: typeof final.caption === 'string' ? final.caption : undefined,
        theme: params.theme,
      },
    );
    final.hashtags = fallback.hashtags;
    final.cta = fallback.cta;
    final.alt = fallback.alt;
  }
  return RankResult.parse(json);
}

export async function pipelineTextOnly({ platform, voice="flirty_playful", style, mood, theme, context, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, theme:string, context?:string, nsfw?:boolean }){
  let variants = await generateVariantsTextOnly({ platform, voice, style, mood, theme, context, nsfw });
  let ranked = await rankAndSelect(variants, { platform, nsfw });
  let ranked = await rankAndSelect(variants, { platform, theme, context, nsfw });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
    ranked = await rankAndSelect(variants);
    ranked = await rankAndSelect(variants, { platform, theme, context, nsfw });
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/caption/inferFallbackFromFacts.test.ts
New
+63-0
import { describe, it, expect } from 'vitest';
import { ensureFallbackCompliance, inferFallbackFromFacts } from '../../server/caption/inferFallbackFromFacts.js';

describe('inferFallbackFromFacts', () => {
  it('builds beach-specific fallback assets for instagram imagery', () => {
    const fallback = inferFallbackFromFacts({
      platform: 'instagram',
      facts: {
        objects: ['surfer', 'board', 'palms'],
        colors: ['turquoise', 'golden'],
        setting: 'sunset beach',
      },
      existingCaption: 'Catching waves at golden hour',
    });

    expect(fallback.hashtags.length).toBeGreaterThanOrEqual(3);
    expect(fallback.hashtags.length).toBeLessThanOrEqual(8);
    expect(fallback.hashtags.join(' ')).toMatch(/Surfer/i);
    expect(fallback.hashtags.join(' ')).toMatch(/Sunset/i);
    expect(fallback.cta).toBe('Plan your getaway');
    expect(fallback.alt.toLowerCase()).toContain('sunset beach');
    expect(fallback.alt.toLowerCase()).toContain('turquoise');
  });

  it('creates launch-focused copy with platform limits for X', () => {
    const fallback = inferFallbackFromFacts({
      platform: 'x',
      theme: 'AI assistant launch',
      existingCaption: 'We are going live with our AI assistant tomorrow.',
      facts: { context: 'Product launch promo' },
    });

    expect(fallback.hashtags.length).toBeGreaterThanOrEqual(1);
    expect(fallback.hashtags.length).toBeLessThanOrEqual(3);
    expect(fallback.hashtags.some(tag => tag.toLowerCase().includes('launch'))).toBe(true);
    expect(fallback.cta).toBe('Be part of the launch');
    expect(fallback.alt.toLowerCase()).toContain('ai assistant');
  });
});

describe('ensureFallbackCompliance', () => {
  it('pads instagram hashtags without losing launch context', () => {
    const result = ensureFallbackCompliance(
      {
        caption: 'Launch day',
        hashtags: ['#Launch'],
        cta: '',
        alt: 'Short text',
      },
      {
        platform: 'instagram',
        theme: 'Launch promo',
        facts: { context: 'Launch promo' },
        existingCaption: 'Launch day',
      },
    );

    expect(result.hashtags.length).toBeGreaterThanOrEqual(3);
    expect(result.hashtags.join(' ')).toMatch(/Launch/i);
    expect(result.cta).toBe('Be part of the launch');
    expect(result.alt.length).toBeGreaterThanOrEqual(20);
  });
});
tests/routes/caption-generation.test.ts
+86-6
import type { Mock } from 'vitest';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { pipeline } from '../../server/caption/geminiPipeline.js';
import { pipelineRewrite } from '../../server/caption/rewritePipeline.js';
import { pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';

// Mock dependencies
vi.mock('../../server/lib/gemini.js', () => ({
  textModel: {
    generateContent: vi.fn(),
  },
  visionModel: {
    generateContent: vi.fn(),
  },
}));

vi.mock('../../server/caption/openaiFallback.js', () => ({
  openAICaptionFallback: vi.fn().mockResolvedValue({
    caption: 'Fallback caption',
    hashtags: ['#fallback1', '#fallback2', '#fallback3'],
    safety_level: 'normal',
    alt: 'Fallback alt text that is sufficiently long',
    mood: 'neutral',
    style: 'informative',
    cta: 'Check this out',
    nsfw: false,
@@ -76,144 +77,223 @@ describe('Caption Generation', () => {
        },
      };

      const mockRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected based on engagement potential',
              final: {
                caption: 'Feeling gorgeous tonight ✨',
                hashtags: ['#lingerie', '#confidence', '#style'],
                safety_level: 'spicy_safe',
                mood: 'confident',
                style: 'authentic',
                cta: 'What do you think?',
                alt: 'A glamorous example alt text to satisfy schema',
                nsfw: false,
              },
            }),
        },
      };

      const { textModel, visionModel } = await import('../../server/lib/gemini.js');
      (visionModel.generateContent as any).mockResolvedValueOnce(mockFactsResponse);
      (textModel.generateContent as any)
      const visionMock = visionModel.generateContent as Mock;
      visionMock.mockResolvedValueOnce(mockFactsResponse);
      const textMock = textModel.generateContent as Mock;
      textMock
        .mockResolvedValueOnce(mockVariantsResponse)
        .mockResolvedValueOnce(mockRankResponse);

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');

      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(result.final).toMatchObject({
        caption: expect.any(String),
        safety_level: expect.stringMatching(/safe|low|spicy_safe/),
      });
    });

    it('should handle safety level normalization', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Test caption',
              hashtags: ['#test'],
              safety_level: 'spicy_safe', // Should be normalized to spicy_safe
              mood: 'confident',
              style: 'authentic',
              cta: 'Check it out',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);
      const textMock = textModel.generateContent as Mock;
      textMock.mockResolvedValue(mockResponse);

      // This would normally be called as part of the pipeline
      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      expect(result[0].safety_level).toBe('spicy_safe');
    });

    it('fills contextual fallback data when variants omit fields', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Sunset surf session',
              hashtags: [],
              cta: '',
              alt: '',
              mood: '',
              style: '',
              safety_level: 'normal',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textMock = textModel.generateContent as Mock;
      textMock.mockResolvedValue(mockResponse);

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'adventurous',
        facts: {
          setting: 'sunset beach',
          objects: ['surfer', 'board'],
          colors: ['golden'],
        },
      });

      const first = result[0];
      expect(first.hashtags.some(tag => /Sunset/i.test(tag))).toBe(true);
      expect(first.cta).toBe('Plan your getaway');
      expect(first.alt.toLowerCase()).toContain('sunset beach');
    });
  });

  describe('Text-Only Pipeline', () => {
    it('should generate content without image context', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Motivational content for today!',
              hashtags: ['#motivation', '#mindset'],
              safety_level: 'normal',
              mood: 'inspiring',
              style: 'authentic',
              cta: 'What motivates you?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);
      const textMock = textModel.generateContent as Mock;
      textMock.mockResolvedValue(mockResponse);

      const result = await pipelineTextOnly({
        platform: 'instagram',
        voice: 'inspiring',
        theme: 'motivation',
        context: 'morning motivation post',
      });

      expect(result.final).toMatchObject({
        caption: expect.stringContaining('Motivational'),
        safety_level: 'normal',
      });
    });

    it('injects launch-specific fallback assets when needed', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Launch coming soon',
              hashtags: [],
              cta: '',
              alt: '',
              mood: '',
              style: '',
              safety_level: 'normal',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textMock = textModel.generateContent as Mock;
      textMock.mockResolvedValue(mockResponse);

      const { generateVariantsTextOnly } = await import('../../server/caption/textOnlyPipeline.js');
      const variants = await generateVariantsTextOnly({
        platform: 'x',
        voice: 'professional',
        theme: 'AI assistant launch',
        context: 'Product launch promo',
      });

      const first = variants[0];
      expect(first.hashtags.length).toBeLessThanOrEqual(3);
      expect(first.hashtags.some(tag => /launch/i.test(tag))).toBe(true);
      expect(first.cta).toBe('Be part of the launch');
      expect(first.alt.toLowerCase()).toContain('product launch promo');
    });
  });

  describe('Rewrite Pipeline', () => {
    it('should improve existing captions', async () => {
      const existingCaption = 'Basic caption here';
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Enhanced and engaging caption! ✨',
              hashtags: ['#enhanced', '#content'],
              safety_level: 'normal',
              mood: 'engaging',
              style: 'authentic',
              cta: 'What do you think?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const genSpy = vi.spyOn(textModel, 'generateContent').mockResolvedValue(mockResponse as any);
      const textMock = textModel.generateContent as Mock;
      textMock.mockResolvedValue(mockResponse);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(result.final.caption).not.toBe(existingCaption);
      expect(result.final.caption).toContain('Enhanced');

      genSpy.mockRestore();
      textMock.mockReset();
    });
  });
});
