diff --git a/server/routes/upload.ts b/server/routes/upload.ts
@@
-import express from 'express';
-import type { Request } from 'express';
+import express, { type Request, type Response } from 'express';
@@
-import { uploadRequestSchema, type ProtectionLevel, type UploadRequest } from '@shared/schema.js';
+import { uploadRequestSchema, type ProtectionLevel, type UploadRequest as UploadRequestBody } from '@shared/schema.js';
@@
-interface UploadRequest extends Request {
+interface AuthRequest extends Request {
   user: { id: number; tier?: string };
   streamingFiles?: { path: string; filename?: string; length?: number }[];
   uploadProgress?: unknown;
   file?: {
     path: string;
     mimetype: string;
     originalname: string;
     filename: string;
     size: number;
-  } | null;
+  };
 }
@@
-router.post('/stream', uploadLimiter, tierProtectionLimiter, authenticateToken, cleanupUploadedFiles, imageStreamingUpload, async (req: unknown, res) => {
-  let processedFilePath: string | null = null;
+router.post('/stream', uploadLimiter, tierProtectionLimiter, authenticateToken, cleanupUploadedFiles, imageStreamingUpload, async (req: AuthRequest, res: Response) => {
+  let processedFilePath = '';
@@
-    let validatedRequest: UploadRequest;
+    let validatedRequest: UploadRequestBody;
@@
-    const protect = () => applyImageShieldProtection(
-      tempFilePath,
-      processedFilePath,
-      validatedRequest.protectionLevel,
-      validatedRequest.watermark,
-      req.user?.id
-    );
+    const protect = () => applyImageShieldProtection(
+      tempFilePath,
+      processedFilePath!,
+      validatedRequest.protectionLevel,
+      validatedRequest.watermark,
+      req.user?.id
+    );
@@
-    logger.error('Streaming upload processing error', {
-      userId: req.user?.id,
-      error: error.message,
-      stack: error.stack
-    });
+    logger.error('Streaming upload processing error', {
+      userId: req.user?.id,
+      error: error instanceof Error ? error.message : String(error),
+      stack: error instanceof Error ? error.stack : undefined
+    });
@@
-    } catch (cleanupError) {
-      logger.warn('File cleanup failed', { error: cleanupError.message });
-    }
+    } catch (cleanupError) {
+      logger.warn('File cleanup failed', { error: cleanupError instanceof Error ? cleanupError.message : String(cleanupError) });
+    }
@@
-router.post('/image', uploadLimiter, tierProtectionLimiter, authenticateToken, upload.single('image'), async (req: unknown, res) => {
-  let tempFilePath: string | null = null;
-  let protectedFilePath: string | null = null;
+router.post('/image', uploadLimiter, tierProtectionLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res: Response) => {
+  let tempFilePath = '';
+  let protectedFilePath = '';
@@
-    let validatedRequest: UploadRequest;
+    let validatedRequest: UploadRequestBody;
@@
-    const protectedFileName = `protected_${req.file.filename}`;
-    protectedFilePath = path.join(path.dirname(tempFilePath), protectedFileName);
+    const protectedFileName = `protected_${req.file.filename}`;
+    protectedFilePath = path.join(path.dirname(tempFilePath), protectedFileName);
@@
-    await applyImageShieldProtection(
-      tempFilePath,
-      protectedFilePath,
-      protectionLevel as 'light' | 'standard' | 'heavy',
-      addWatermark,
-      req.user.id
-    );
+    await applyImageShieldProtection(
+      tempFilePath,
+      protectedFilePath,
+      protectionLevel as 'light' | 'standard' | 'heavy',
+      addWatermark,
+      req.user.id
+    );
@@
-    await fs.unlink(tempFilePath);
-    tempFilePath = null;
+    await fs.unlink(tempFilePath);
+    tempFilePath = '';
@@
-    logger.error('Upload error:', error);
+    logger.error('Upload error:', { error: error instanceof Error ? error.message : String(error) });
@@
-    if (tempFilePath) {
-      try { await fs.unlink(tempFilePath); } catch (e) { /* ignore cleanup errors */ }
-    }
-    if (protectedFilePath) {
-      try { await fs.unlink(protectedFilePath); } catch (e) { /* ignore cleanup errors */ }
+    if (tempFilePath) {
+      try { await fs.unlink(tempFilePath); } catch (e) { /* ignore cleanup errors */ }
+    }
+    if (protectedFilePath) {
+      try { await fs.unlink(protectedFilePath); } catch (e) { /* ignore cleanup errors */ }
