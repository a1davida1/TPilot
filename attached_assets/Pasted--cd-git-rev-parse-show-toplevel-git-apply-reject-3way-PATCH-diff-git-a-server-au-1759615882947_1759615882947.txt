(cd "$(git rev-parse --show-toplevel)" && git apply --reject --3way <<'PATCH'
diff --git a/server/auth.ts b/server/auth.ts
--- a/server/auth.ts
+++ b/server/auth.ts
@@ -1,40 +1,47 @@
 import { Express, Request, Response } from 'express';
 import bcrypt from 'bcrypt';
 import jwt from 'jsonwebtoken';
 import { storage } from './storage';
 import { emailService } from './services/email-service';
 import { db } from './db';
 import { creatorAccounts } from '@shared/schema';
 import { eq, and } from 'drizzle-orm';
 import crypto from 'crypto';
 import { safeLog } from './lib/logger-utils.js';
 import { FRONTEND_URL } from './config.js';
 import { verificationLimiter, passwordResetLimiter, loginLimiter, signupLimiter, passwordChangeLimiter } from './middleware/simple-rate-limit.js';
 import { authMetrics } from './services/basic-metrics.js';
 import { logger } from './bootstrap/logger.js';
 import { validate, loginValidationSchema, signupValidationSchema, passwordChangeValidationSchema, passwordResetValidationSchema } from './middleware/validation.js';
 import { extractAuthToken } from './middleware/extract-token.js';
 import { API_PREFIX, prefixApiPath } from './lib/api-prefix.js';
 import { assertExists } from '../helpers/assert';
+import { ensureAdminAccount } from './lib/admin-auth.js';
 
 // Auth validation schemas removed - handled by middleware
 
 const JWT_SECRET = process.env.JWT_SECRET;
 if (!JWT_SECRET || /changeme|placeholder/i.test(JWT_SECRET)) {
   throw new Error('JWT_SECRET environment variable is required and must not be a placeholder');
 }
 // Type assertion after validation
 const JWT_SECRET_VALIDATED: string = JWT_SECRET;
 
-export function setupAuth(app: Express, apiPrefix: string = API_PREFIX) {
+export async function setupAuth(app: Express, apiPrefix: string = API_PREFIX) {
   const route = (path: string) => prefixApiPath(path, apiPrefix);
 
   logger.info('Setting up auth routes', {
     apiPrefix,
     signupRoute: route('/auth/signup'),
     loginRoute: route('/auth/login')
   });
 
+  // Ensure the bootstrap admin account exists before routes become live.
+  // Uses ADMIN_EMAIL and ADMIN_PASSWORD_HASH (or ADMIN_PASSWORD) env vars.
+  try {
+    await ensureAdminAccount();
+  } catch (err) {
+    logger.error('Failed to ensure admin account exists', { err });
+  }
+
   // Regular signup
   app.post(route('/auth/signup'), signupLimiter, validate(signupValidationSchema), async (req, res) => {
     const startTime = Date.now();
     try {
       // Input already validated by middleware
       const { username, password, email } = req.body;
diff --git a/server/app.ts b/server/app.ts
--- a/server/app.ts
+++ b/server/app.ts
@@ -1,999 +1,999 @@
@@
-  if (app.get('authRoutesConfigured') !== true) {
-    setupAuth(app, API_PREFIX);
-    app.set('authRoutesConfigured', true);
-  }
+  if (app.get('authRoutesConfigured') !== true) {
+    await setupAuth(app, API_PREFIX);
+    app.set('authRoutesConfigured', true);
+  }
@@
-  if (app.get('socialAuthConfigured') !== true) {
+  if (app.get('socialAuthConfigured') !== true) {
     setupSocialAuth(app, API_PREFIX);
     app.set('socialAuthConfigured', true);
   }
diff --git a/server/routes.ts b/server/routes.ts
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -900,20 +900,20 @@
-  if (app.get('authRoutesConfigured') !== true) {
-    setupAuth(app, apiPrefix);
-    app.set('authRoutesConfigured', true);
-  }
+  if (app.get('authRoutesConfigured') !== true) {
+    await setupAuth(app, apiPrefix);
+    app.set('authRoutesConfigured', true);
+  }
 
   setupAdminRoutes(app);
 
-  if (app.get('socialAuthConfigured') !== true) {
+  if (app.get('socialAuthConfigured') !== true) {
     setupSocialAuth(app, apiPrefix);
     app.set('socialAuthConfigured', true);
   }
 
-  if (app.get('billingRoutesConfigured') !== true) {
+  if (app.get('billingRoutesConfigured') !== true) {
     mountBillingRoutes(app, apiPrefix);
     app.set('billingRoutesConfigured', true);
   }
diff --git a/server/scripts/create-admin.ts b/server/scripts/create-admin.ts
--- a/server/scripts/create-admin.ts
+++ b/server/scripts/create-admin.ts
@@ -1,70 +1,49 @@
-import bcrypt from 'bcrypt';
-import { db } from '../db.js';
-import { users } from '@shared/schema';
-import { eq } from 'drizzle-orm';
+import { ensureAdminAccount } from '../lib/admin-auth.js';
 
 async function createAdmin() {
-  const email = process.env.ADMIN_EMAIL || 'admin@thottopilot.com';
-  const username = process.env.ADMIN_USERNAME || 'admin';
-  const passwordHashFromEnv = process.env.ADMIN_PASSWORD_HASH ?? null;
-  const passwordForLocalBootstrap = process.env.ADMIN_PASSWORD ?? null;
-
-  if (!passwordHashFromEnv && !passwordForLocalBootstrap) {
-    throw new Error(
-      'ADMIN_PASSWORD_HASH (preferred) or ADMIN_PASSWORD must be set before running create-admin.ts'
-    );
-  }
-
-  const existing = await db.select().from(users).where(eq(users.email, email)).limit(1);
-  if (existing.length > 0) {
-    console.error('✅ Admin user already exists');
-    return;
-  }
-
-  let hashedPassword: string;
-  if (passwordHashFromEnv) {
-    hashedPassword = passwordHashFromEnv;
-  } else if (passwordForLocalBootstrap) {
-    hashedPassword = await bcrypt.hash(passwordForLocalBootstrap, 10);
-  } else {
-    throw new Error('Unable to resolve admin password hash');
-  }
-
-  await db.insert(users).values({
-    email,
-    username,
-    password: hashedPassword,
-    isAdmin: true,
-    role: 'admin',
-    emailVerified: true,
-    tier: 'admin'
-  });
-
-  console.error(`✅ Admin user created with email ${email}`);
+  const result = await ensureAdminAccount();
+  if (result.created) {
+    console.error(`✅ Admin user created with email ${result.email}`);
+  } else {
+    console.error(`✅ Admin user already exists with email ${result.email}`);
+  }
 }
 
 createAdmin()
   .then(() => process.exit(0))
   .catch((err) => {
     console.error('Failed to create admin user:', err);
     process.exit(1);
   });
diff --git a/server/lib/admin-auth.ts b/server/lib/admin-auth.ts
new file mode 100644
--- /dev/null
+++ b/server/lib/admin-auth.ts
@@ -0,0 +1,115 @@
+import bcrypt from 'bcrypt';
+import { eq } from 'drizzle-orm';
+import { db } from '../db.js';
+import { users } from '@shared/schema';
+
+export interface AdminCredentials {
+  email: string | null;
+  passwordHash: string | null;
+}
+
+export interface EnsureAdminAccountResult {
+  created: boolean;
+  email: string;
+}
+
+export const getAdminCredentials = (): AdminCredentials => {
+  return {
+    email: process.env.ADMIN_EMAIL ?? null,
+    passwordHash: process.env.ADMIN_PASSWORD_HASH ?? null,
+  };
+};
+
+const DEFAULT_ADMIN_EMAIL = 'admin@thottopilot.com';
+const DEFAULT_ADMIN_USERNAME = 'admin';
+
+async function resolveAdminPasswordHash(passwordHashFromEnv: string | null): Promise<string> {
+  if (passwordHashFromEnv) {
+    return passwordHashFromEnv;
+  }
+  const fallbackPassword = process.env.ADMIN_PASSWORD ?? null;
+  if (!fallbackPassword) {
+    throw new Error(
+      'ADMIN_PASSWORD_HASH (preferred) or ADMIN_PASSWORD must be set to bootstrap the admin account',
+    );
+  }
+  return bcrypt.hash(fallbackPassword, 10);
+}
+
+export const ensureAdminAccount = async (): Promise<EnsureAdminAccountResult> => {
+  const { email, passwordHash } = getAdminCredentials();
+  const resolvedEmail = email ?? DEFAULT_ADMIN_EMAIL;
+
+  const existing = await db
+    .select({ id: users.id })
+    .from(users)
+    .where(eq(users.email, resolvedEmail))
+    .limit(1);
+
+  if (existing.length > 0) {
+    return { created: false, email: resolvedEmail };
+  }
+
+  const username = process.env.ADMIN_USERNAME ?? DEFAULT_ADMIN_USERNAME;
+  const hashedPassword = await resolveAdminPasswordHash(passwordHash);
+
+  await db.insert(users).values({
+    email: resolvedEmail,
+    username,
+    password: hashedPassword,
+    isAdmin: true,
+    role: 'admin',
+    emailVerified: true,
+    tier: 'admin',
+  });
+
+  return { created: true, email: resolvedEmail };
+};
+
+export const verifyAdminCredentials = async (
+  identifier: string | undefined,
+  password: string | undefined
+): Promise<string | null> => {
+  const { email, passwordHash } = getAdminCredentials();
+
+  if (!email || !passwordHash || typeof identifier !== 'string' || typeof password !== 'string') {
+    return null;
+  }
+
+  if (identifier !== email) {
+    return null;
+  }
+
+  const matches = await bcrypt.compare(password, passwordHash);
+  return matches ? email : null;
+};
PATCH
))
