You are refactoring and extending an existing Next.js 14 + TypeScript app named **ThottoPilot** (NSFW promo assistant). Implement the ENTIRE spec below end-to-end in small, safe, incremental diffs with typed code and basic tests. If the repo stack differs, adapt cleanly (same features, idiomatic for the stack). Keep auth intact.

## TOP-LEVEL GOALS
1) Safer posting pipeline: preview-only gate, subreddit policy linter, time-of-day optimizer, telemetry, feature flags.
2) Adult-friendly billing + smart dunning (CCBill now; adapters ready for Segpay/Epoch/crypto).
3) Referral/ambassador revenue share.
4) AI promo generation: **Gemini-first** Image→Promo and Text→Promo with provider abstraction + caching + optional async jobs.
5) Secure, premium **Media Library** (upload, store, reuse), private by default with short-lived signed URLs and optional watermark previews.
6) Scalability: replace ad-hoc cron with **BullMQ** queues (Redis) for posting and metrics; batch AI calls where possible.

## TECH BASELINES (Install if missing)
- Next.js 14 (app router), React, TS
- Prisma + Postgres
- Auth (keep existing)
- Reddit API: snoowrap or native OAuth
- Queues: bullmq + ioredis
- Storage: S3 (private bucket) via AWS SDK v3
- Images: sharp
- AI: @google/generative-ai (Gemini 1.5/2.x)
- Email: Resend or SendGrid
- Validation: zod

## ENV (add zod validation)
DATABASE_URL
REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_REDIRECT_URI
GOOGLE_GENAI_API_KEY
AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION
S3_BUCKET_MEDIA                   # private bucket
S3_PUBLIC_CDN_DOMAIN             # optional (CloudFront); else omit
REDIS_URL
APP_BASE_URL
CRON_TZ="America/Chicago"

# Billing
CCBILL_CLIENT_ACCOUNT
CCBILL_SUBACCOUNT
CCBILL_FLEXFORM_ID
CCBILL_SALT

# Media quotas and security
MEDIA_MAX_BYTES_FREE=524288000      # 500MB
MEDIA_MAX_BYTES_PRO=10737418240     # 10GB
MEDIA_SIGNED_TTL_SECONDS=600
WATERMARK_ENABLED=true
WATERMARK_TEXT="ThottoPilot"
WATERMARK_OPACITY=0.18

## PRISMA SCHEMA (create/extend)
model User {
  id               String   @id @default(cuid())
  email            String   @unique
  name             String?
  createdAt        DateTime @default(now())
  Subscription     Subscription?
  ReferralCodes    ReferralCode[]
  ReferredBy       Referral? @relation("ReferralReceiver", fields: [referredById], references: [id])
  referredById     String?
  EventLogs        EventLog[]
  CreatorAccounts  CreatorAccount[]
}

model CreatorAccount {
  id            String   @id @default(cuid())
  userId        String
  platform      String
  handle        String
  oauthToken    String
  oauthRefresh  String
  status        String   // "ok" | "limited" | "banned"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

model SubredditRule {
  id        String   @id @default(cuid())
  subreddit String   @unique
  rulesJson Json
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

model PostTemplate {
  id        String   @id @default(cuid())
  userId    String
  name      String
  titleTpl  String
  bodyTpl   String
  variables Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model PostPreview {
  id           String   @id @default(cuid())
  userId       String
  subreddit    String
  titlePreview String
  bodyPreview  String
  policyState  String   // "ok" | "warn" | "block"
  warnings     Json
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id])
}

model PostJob {
  id          String   @id @default(cuid())
  userId      String
  subreddit   String
  titleFinal  String
  bodyFinal   String
  mediaKey    String?
  scheduledAt DateTime
  status      String   // "queued" | "sent" | "failed" | "paused"
  resultJson  Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])
}

model Subscription {
  id               String   @id @default(cuid())
  userId           String   @unique
  status           String   // "active" | "past_due" | "canceled"
  plan             String   // "free" | "pro"
  priceCents       Int
  processor        String   // "ccbill" | "segpay" | "epoch" | "crypto"
  processorSubId   String?
  currentPeriodEnd DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id])
}

model Invoice {
  id             String   @id @default(cuid())
  subscriptionId String
  amountCents    Int
  status         String   // "paid" | "failed" | "refunded"
  processor      String
  processorRef   String?
  createdAt      DateTime @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
}

model ReferralCode {
  id        String   @id @default(cuid())
  code      String   @unique
  ownerId   String
  sharePct  Int      @default(20)
  createdAt DateTime @default(now())
  owner     User     @relation(fields: [ownerId], references: [id])
  Referrals Referral[]
}

model Referral {
  id         String   @id @default(cuid())
  codeId     String
  referrerId String
  receiverId String?
  createdAt  DateTime @default(now())
  code       ReferralCode @relation(fields: [codeId], references: [id])
  referrer   User         @relation("ReferralReferrer", fields: [referrerId], references: [id])
  receiver   User?        @relation("ReferralReceiver", fields: [receiverId], references: [id])
}

model EventLog {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  meta      Json
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])
}

model FeatureFlag {
  key       String   @id
  enabled   Boolean  @default(true)
  threshold Float?
  meta      Json?
  updatedAt DateTime @updatedAt
}

model MediaAsset {
  id         String   @id @default(cuid())
  userId     String
  key        String   @unique
  filename   String
  bytes      Int
  mime       String
  sha256     String   @index
  visibility String   // "private" | "preview-watermarked"
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
  usages     MediaUsage[]
}

model MediaUsage {
  id         String   @id @default(cuid())
  mediaId    String
  usedInType String   // "template" | "post" | "ai-context"
  usedInId   String
  createdAt  DateTime @default(now())
  media      MediaAsset @relation(fields: [mediaId], references: [id])
}

model AiGeneration {
  id        String   @id @default(cuid())
  userId    String
  provider  String   // "gemini" | "openai"
  model     String
  inputHash String   @index
  inputJson Json
  outputJson Json
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

## FOLDERS TO ADD
src/lib/policyLinter.ts
src/lib/scheduling.ts
src/lib/payments/gateway.ts
src/lib/payments/ccbill.ts
src/lib/ai/PromoAIProvider.ts
src/lib/ai/geminiProvider.ts
src/lib/ai/cache.ts
src/lib/media/storage.ts
src/lib/media/signing.ts
src/lib/media/watermark.ts
src/lib/queue/index.ts
src/lib/queue/jobs.ts
src/lib/queue/workers/{postWorker.ts,metricsWorker.ts,aiPromoWorker.ts}

## CORE IMPLEMENTATIONS

### Preview Gate + Linter + Scheduler
- POST /api/preview -> lint caption; store PostPreview (policyState: ok/warn/block).
- GET  /api/user/previewStats -> count last 14d ok previews; require >=3 before enabling queueing.
- policyLinter: load SubredditRule.rulesJson else defaults (bannedWords, flair/tag regex, link policy). Return {state,warnings}.
- scheduling.chooseSendTime(subreddit,tz,day): default windows by sub; adjust using EventLog engagement stats.

### Posting + Telemetry + Flags
- POST /api/postJobs -> enqueue to postQ with chosen time; persist PostJob.
- postWorker: verify preview-gate, run linter, send to Reddit, log EventLog("post.sent" | "post.failed"), enqueue metricsQ for +1h fetch.
- metricsWorker: fetch upvotes/comments after 1h, update EventLog; if 5 straight low-engagement successes, mark account "limited".
- FeatureFlag keys: "autopost.enabled" (bool), "autopost.maxErrorRate" (float default 0.15), "policy.blockOnWarn" (bool).
- If error rate > threshold over last 100, pause autopost and surface admin alert.

### Payments + Dunning (CCBill)
- Implement PaymentGateway interface (create/cancel sub, checkout URL, webhooks).
- Webhook /api/webhooks/ccbill: verify signature with salt; update Subscription/Invoice states.
- Dunning job hourly: retry, email “Fix Payment”, offer one-click switch to alt processor (stub now), 5-day grace then pause.
- Log EventLog for "payment.failed" and "dunning.retry".

### Referrals
- POST /api/referral/code -> create code (default 20% share).
- Track ?ref=CODE on signup; create Referral; link receiver at first login.
- Each paid Invoice creates commission pending rows (simple accounting); basic /admin/referrals report.

### AI: Gemini-first Promo
- PromoAIProvider interface:
  type PromoRequest = { promptText?: string; imageKey?: string; platforms: ("reddit"|"x"|"of"|"fansly")[]; styleHints?: string[]; variants?: number }
  type PromoVariant = { title?: string; body: string; hashtags?: string[]; rationale?: string }
  generate(req): Promise<{ variants: PromoVariant[], tokensUsed?: number }>
- geminiProvider: if imageKey, fetch bytes from S3; craft safe NSFW-marketing prompt (avoid explicit content, respect Reddit formatting). Return N variants with rationales.
- cache.ts: sha256(model + imageSha? + normalizedPrompt + platforms + policyVersion). Reuse AiGeneration rows to avoid duplicate calls.
- API POST /api/ai/promo: auth; if sync=true return variants immediately; else enqueue aiPromoQ and return jobId; store AiGeneration.

### Media Library (secure)
- POST /api/media/upload-url { filename, mime, bytes } -> presigned PUT/POST; enforce per-plan quota before issuing.
- GET  /api/media/list -> user’s assets, paginated.
- POST /api/media/delete -> soft delete or mark inaccessible if referenced.
- GET  /api/media/signed-get?key=... -> short-lived signed GET for owner; if WATERMARK_ENABLED and visibility="preview-watermarked", return derived watermarked key (generate via sharp once, then cache).
- Track sha256; optionally dedupe identical uploads.

### Queues (BullMQ)
- aiPromoQ: background Gemini generations; emit EventLog("ai.generated").
- postQ: replaces cron for PostJobs; exponential backoff on 429/5xx; idempotency.
- metricsQ: delayed 1h fetch of engagement data.
- /admin/health: queue sizes, failure rates, last 20 EventLogs, current FeatureFlags.

### UI (light but functional)
- Composer: title/body with live linter warnings; AI tab with:
  - Image→Promo: pick from Library, choose platforms, Generate.
  - Text→Promo: enter idea, choose platforms, Generate.
  - Show N variants; “Use This” fills composer; save as PostTemplate (source="ai", link AiGeneration.id).
- Library page: upload (uses signed PUT), list, search, copy to composer.
- Billing page: status, renewal date, “Fix Payment” (CCBill portal), “Switch Processor” (stub).
- Ambassador page: show code, clicks, signups, active paid, MRR, pending commissions.

## TESTS (basic)
- policyLinter unit tests with sample SubredditRule fixtures.
- scheduling unit tests for window shifting from synthetic EventLogs.
- payments webhook signature verification test.
- ai/geminiProvider + cache tests (mock provider).
- media signing TTL tests; watermark derivation test with a tiny fixture.
- queue job happy-paths.

## SEED
- FeatureFlag defaults: autopost.enabled=true, autopost.maxErrorRate=0.15, policy.blockOnWarn=false
- SubredditRule sample rows with generic NSFW rules (no explicit content).
- A 1x1 image in dev for media/watermark tests.

## ACCEPTANCE CRITERIA (do not mark done until ALL true)
- [ ] Cannot queue posts until user has >=3 “ok” previews in last 14 days.
- [ ] Linter blocks hard violations; warns soft issues; warnings visible live.
- [ ] Scheduler auto-picks plausible windows and learns from telemetry (verified by tests).
- [ ] CCBill checkout + webhook create active sub; failed rebills go past_due; dunning retries + emails; grace then pause.
- [ ] Referrals track signups and commissions; ambassador dashboard shows counts & MRR.
- [ ] Media is private by default; only short-lived signed GETs; watermark previews available.
- [ ] /api/ai/promo returns Gemini variants (sync/async) and caches by inputHash.
- [ ] BullMQ drives posting & metrics; feature flag pauses posting when failure rate > threshold; /admin/health shows queue health.
- [ ] Test suite passes.
- [ ] Provide a concise summary of changed files and any manual env/setup steps still needed.
