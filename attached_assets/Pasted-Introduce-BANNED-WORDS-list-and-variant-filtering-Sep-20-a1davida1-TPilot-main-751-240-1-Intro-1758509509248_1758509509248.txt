Introduce BANNED_WORDS list and variant filtering
Sep 20 · a1davida1/TPilot · main
+751-240
1. Introduce a shared `BANNED_WORDS` list (e.g., `['ai', 'ai-generated', 'content', ...]`) in `server/caption`—consider a new helper like `bannedWords.ts` so all pipelines can import it.
2. In both `generateVariants` (`server/caption/geminiPipeline.ts`) and `variantsRewrite` (`server/caption/rewritePipeline.ts`), inspect each candidate’s `caption`, `cta`, and `hashtags`; if any banned token appears (case-insensitive, whole-word), discard the variant and re-issue the prompt with a `hint` such as `Avoid banned words: ${BANNED_WORDS.join(', ')}` until either clean variants are collected or retry limits are reached.
3. Update `prompts/guard.txt` and `prompts/rank.txt` to tell Gemini to disqualify any option containing the banned words and to justify the rejection in its reason.
4. After ranking, add a final safeguard in each `rankAndSelect` that re-runs ranking (or falls back to OpenAI) if the chosen caption still contains a banned word.
5. Backstop the change with unit coverage in `tests/routes/caption-generation.test.ts` (and the rewrite suite if one exists) that seeds variants containing “AI”/“content” and asserts the final selection stays clear of them.

Summary

    Introduced a shared BANNED_WORDS helper with reusable regex checks and a standardized hint string so every caption pipeline can detect and describe forbidden tokens, and updated the guard/rank prompts to explicitly disqualify banned language.

Hardened the Gemini generation and rewrite flows—both now loop until they collect five clean variants, append the banned-word hint on retries, and re-run ranking with that hint if the chosen result still contains a forbidden word; the text-only pipeline now shares the same defaults and final safeguard.

Expanded caption route tests to cover the new behavior, confirming that Gemini and rewrite pipelines discard AI/content-laden outputs, reissue prompts with the hint, and land on clean variants while keeping existing expectations intact.

Testing

    ✅ npm run lint

⚠️ npm test *(suite depends on external services and image processing; multiple integration/unit specs fail under the container’s limited environment, so the run was aborted after repeated infrastructure errors)*


prompts/guard.txt
+1-1
Never output: "generated content", "placeholder", "N/A", or meta-text. If info is missing, infer conservatively from IMAGE_FACTS (objects, colors, setting).
Never output: "generated content", "placeholder", "N/A", or meta-text. If info is missing, infer conservatively from IMAGE_FACTS (objects, colors, setting). Disqualify any option that includes banned words (ai, ai-generated, content) and explain which banned term caused the rejection.
prompts/rank.txt
+1-1
Rank the 5 for Relevance(40), Voice(25), Originality(20), CTA(10), Safety(5).
Rank the 5 for Relevance(40), Voice(25), Originality(20), CTA(10), Safety(5). Any option containing banned words (ai, ai-generated, content) must be disqualified and the reason should cite the offending term.
Return JSON:
{"winner_index":0,"scores":[0,0,0,0,0],"reason":"<240 chars","final":{"caption":"","alt":"","hashtags":[],"cta":"","mood":"","style":"","safety_level":""}}
Trim hashtags to platform limits.
server/caption/bannedWords.ts
New
+30-0
export const BANNED_WORDS = [
  "ai",
  "ai-generated",
  "content"
] as const;

const escapeRegExp = (value: string): string => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

const bannedPattern = new RegExp(`\\b(?:${BANNED_WORDS.map(escapeRegExp).join("|")})\\b`, "i");

export const BANNED_WORDS_HINT = `Avoid banned words: ${BANNED_WORDS.join(", ")}`;

export function containsBannedWord(text: unknown): boolean {
  if (typeof text !== "string" || text.trim().length === 0) return false;
  return bannedPattern.test(text);
}

export function variantContainsBannedWord(variant: {
  caption?: unknown;
  cta?: unknown;
  hashtags?: unknown;
}): boolean {
  if (!variant) return false;
  if (containsBannedWord(variant.caption)) return true;
  if (containsBannedWord(variant.cta)) return true;
  if (Array.isArray(variant.hashtags)) {
    return variant.hashtags.some(tag => containsBannedWord(tag));
  }
  return false;
}
server/caption/geminiPipeline.ts
+186-79
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);

    const ct = r.headers.get("content-type") || "";
    if (!ct.startsWith("image/"))
      throw new InvalidImageError(`unsupported content-type: ${ct}`);

    const b = Buffer.from(await r.arrayBuffer());
    const base64 = b.toString("base64");
    if (base64.length < 100) throw new InvalidImageError("image data too small");

    return { base64, mimeType: ct.split(";")[0] };
  } catch (err) {
    console.error("Error fetching image:", err);
    if (err instanceof InvalidImageError) throw err;
    throw new InvalidImageError(
      `Failed to fetch image: ${err instanceof Error ? err.message : String(err)}`
    );
  }
}
function stripToJSON(txt: string): unknown {
  const i = Math.min(...[txt.indexOf("{"), txt.indexOf("[")].filter(x => x >= 0));
  const j = Math.max(txt.lastIndexOf("}"), txt.lastIndexOf("]"));
  return JSON.parse((i >= 0 && j >= 0) ? txt.slice(i, j + 1) : txt);
}

const MAX_VARIANT_ATTEMPTS = 3;
const MAX_RANK_ATTEMPTS = 2;
const DEFAULT_CAPTION = "Check out this unforgettable moment!";
const DEFAULT_ALT = "A vibrant social media moment full of detail and energy.";
const DEFAULT_HASHTAGS = ["#creative", "#vibes", "#moments"] as const;
const DEFAULT_CTA = "Join the conversation";

const defaultHashtags = (): string[] => [...DEFAULT_HASHTAGS];

function normalizeVariantRecord(record: Record<string, unknown>): z.infer<typeof CaptionItem> {
  const caption =
    typeof record.caption === "string" && record.caption.trim().length > 0
      ? record.caption
      : DEFAULT_CAPTION;
  const alt =
    typeof record.alt === "string" && record.alt.trim().length >= 20
      ? record.alt
      : DEFAULT_ALT;
  const providedTags = Array.isArray(record.hashtags)
    ? record.hashtags.filter((tag): tag is string => typeof tag === "string" && tag.trim().length > 0)
    : undefined;
  const hashtags = providedTags && providedTags.length > 0 ? providedTags : defaultHashtags();
  const cta =
    typeof record.cta === "string" && record.cta.trim().length >= 2 ? record.cta : DEFAULT_CTA;
  const mood =
    typeof record.mood === "string" && record.mood.trim().length >= 2 ? record.mood : "engaging";
  const style =
    typeof record.style === "string" && record.style.trim().length >= 2 ? record.style : "authentic";
  const safetyInput = typeof record.safety_level === "string" ? record.safety_level : "normal";
  const safety_level = normalizeSafetyLevel(safetyInput);
  const nsfw = typeof record.nsfw === "boolean" ? record.nsfw : false;

  return CaptionItem.parse({
    caption,
    alt,
    hashtags,
    cta,
    mood,
    style,
    safety_level,
    nsfw,
  });
}

function composeVariantUserBlock(
  params: {
    platform: "instagram" | "x" | "reddit" | "tiktok";
    voice: string;
    style?: string;
    mood?: string;
    facts: Record<string, unknown>;
    nsfw?: boolean;
  },
  hint?: string
): string {
  const parts = [
    `PLATFORM: ${params.platform}`,
    `VOICE: ${params.voice}`,
    params.style ? `STYLE: ${params.style}` : null,
    params.mood ? `MOOD: ${params.mood}` : null,
    `IMAGE_FACTS: ${JSON.stringify(params.facts)}`,
    `NSFW: ${params.nsfw || false}`,
    hint ? `HINT:${hint}` : null,
  ].filter((part): part is string => Boolean(part));
  return parts.join("\n");
}

export async function extractFacts(imageUrl: string): Promise<Record<string, unknown>> {
  try {
    console.log('Starting fact extraction for image:', imageUrl.substring(0, 100) + '...');
    const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
    
    // Handle data URLs differently from regular URLs
    let imageData: string;
    let mimeType = "image/jpeg";
    
    if (imageUrl.startsWith('data:')) {
      // Extract base64 data from data URL - use indexOf to find first comma only
      const commaIndex = imageUrl.indexOf(',');
      if (commaIndex === -1) {
        throw new Error('Invalid data URL format - missing comma separator');
      }
      
      const header = imageUrl.substring(0, commaIndex);
      imageData = imageUrl.substring(commaIndex + 1);
      
      // Extract mime type from header
      const mimeMatch = header.match(/data:([^;]+)/);
      if (mimeMatch) {
        mimeType = mimeMatch[1];
      }
      
@@ -186,138 +254,177 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
          wardrobe: ['various'],
          angles: ['dynamic'],
          mood: 'playful',
          style: 'animated'
        };
      }
      
      throw error;
    }
  } catch (error) {
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

export async function generateVariants(params: {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  style?: string;
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";
    });
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt"),
  ]);

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
  const cleanVariants: Array<z.infer<typeof CaptionItem>> = [];
  let attempt = 0;
  let includeBannedHint = false;

  while (attempt < MAX_VARIANT_ATTEMPTS && cleanVariants.length < 5) {
    attempt += 1;
    const hint = includeBannedHint
      ? [params.hint, BANNED_WORDS_HINT].filter(Boolean).join(" ")
      : params.hint;
    const user = composeVariantUserBlock(params, hint);
    let res;
    try {
      res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` },
      ]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    const parsed = stripToJSON(res.response.text());
    const variants = Array.isArray(parsed) ? parsed : [parsed];
    let bannedDetected = false;

    for (const candidate of variants) {
      if (cleanVariants.length >= 5) break;
      const record =
        typeof candidate === "object" && candidate !== null
          ? (candidate as Record<string, unknown>)
          : {};

      if (variantContainsBannedWord(record)) {
        bannedDetected = true;
        continue;
      }

      const normalized = normalizeVariantRecord(record);
      if (variantContainsBannedWord(normalized)) {
        bannedDetected = true;
        continue;
      }

      cleanVariants.push(normalized);
    }

    if (bannedDetected) {
      includeBannedHint = true;
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  if (cleanVariants.length === 0) {
    throw new Error('No clean variants generated by Gemini');
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };

  while (cleanVariants.length < 5) {
    const template = cleanVariants[0];
    cleanVariants.push({
      ...template,
      caption: `${template.caption} (Variant ${cleanVariants.length + 1})`,
      hashtags: [...template.hashtags],
      alt: template.alt,
      cta: template.cta,
      mood: template.mood,
      style: template.style,
      safety_level: template.safety_level,
      nsfw: template.nsfw,
    });
  }
  
  // Accept any safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

  return CaptionArray.parse(cleanVariants.slice(0, 5));
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rank.txt"),
  ]);

  let attempt = 0;
  let hint: string | undefined;

  while (attempt < MAX_RANK_ATTEMPTS) {
    attempt += 1;
    let res;
    try {
      const hintBlock = hint ? `\nHINT:${hint}` : "";
      res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}${hintBlock}\n${JSON.stringify(variants)}` },
      ]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    let json = stripToJSON(res.response.text()) as unknown;

    if (Array.isArray(json)) {
      const winner = json[0] || variants[0];
      json = {
        winner_index: 0,
        scores: [5, 4, 3, 2, 1],
        reason: "Selected based on engagement potential",
        final: winner,
      };
    }

    if ((json as Record<string, unknown>).final) {
      const finalRecord = (json as { final: Record<string, unknown> }).final;
      (json as { final: z.infer<typeof CaptionItem> }).final = normalizeVariantRecord(finalRecord);
    }

    const ranked = RankResult.parse(json);
    if (!variantContainsBannedWord(ranked.final)) {
      return ranked;
    }

    hint = BANNED_WORDS_HINT;
  }
  return RankResult.parse(json);

  throw new Error('Ranked caption contains banned words');
}

export async function pipeline({ imageUrl, platform, voice = "flirty_playful", style, mood, nsfw = false }: {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  style?: string;
  mood?: string;
  nsfw?: boolean;
}): Promise<CaptionResult> {
  try {
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, style, mood, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({ platform, voice, facts, hint:`Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`, nsfw });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
server/caption/rewritePipeline.ts
+190-80
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { textModel, visionModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: unknown;
  facts?: unknown;
  variants?: unknown;
  ranked?: unknown;
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
async function b64(url:string){ const r=await fetch(url); if(!r.ok) throw new Error("fetch failed"); const b=Buffer.from(await r.arrayBuffer()); return b.toString("base64"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

const MAX_VARIANT_ATTEMPTS = 3;
const MAX_RANK_ATTEMPTS = 2;
const DEFAULT_CAPTION = "Check out this unforgettable moment!";
const DEFAULT_ALT = "A vibrant social media moment full of detail and energy.";
const DEFAULT_HASHTAGS = ["#creative", "#vibes", "#moments"] as const;
const DEFAULT_CTA = "Join the conversation";

const defaultHashtags = (): string[] => [...DEFAULT_HASHTAGS];

function normalizeVariantRecord(record: Record<string, unknown>): z.infer<typeof CaptionItem> {
  const caption =
    typeof record.caption === "string" && record.caption.trim().length > 0
      ? record.caption
      : DEFAULT_CAPTION;
  const alt =
    typeof record.alt === "string" && record.alt.trim().length >= 20
      ? record.alt
      : DEFAULT_ALT;
  const providedTags = Array.isArray(record.hashtags)
    ? record.hashtags.filter((tag): tag is string => typeof tag === "string" && tag.trim().length > 0)
    : undefined;
  const hashtags = providedTags && providedTags.length > 0 ? providedTags : defaultHashtags();
  const cta =
    typeof record.cta === "string" && record.cta.trim().length >= 2 ? record.cta : DEFAULT_CTA;
  const mood =
    typeof record.mood === "string" && record.mood.trim().length >= 2 ? record.mood : "engaging";
  const style =
    typeof record.style === "string" && record.style.trim().length >= 2 ? record.style : "authentic";
  const safetyInput = typeof record.safety_level === "string" ? record.safety_level : "normal";
  const safety_level = normalizeSafetyLevel(safetyInput);
  const nsfw = typeof record.nsfw === "boolean" ? record.nsfw : false;

  return CaptionItem.parse({
    caption,
    alt,
    hashtags,
    cta,
    mood,
    style,
    safety_level,
    nsfw,
  });
}

function composeRewriteUserBlock(
  params: {
    platform: "instagram" | "x" | "reddit" | "tiktok";
    voice: string;
    style?: string;
    mood?: string;
    existingCaption: string;
    facts?: Record<string, unknown>;
    nsfw?: boolean;
  },
  hint?: string
): string {
  const parts = [
    `PLATFORM: ${params.platform}`,
    `VOICE: ${params.voice}`,
    params.style ? `STYLE: ${params.style}` : null,
    params.mood ? `MOOD: ${params.mood}` : null,
    `EXISTING_CAPTION: "${params.existingCaption}"`,
    params.facts ? `IMAGE_FACTS: ${JSON.stringify(params.facts)}` : null,
    `NSFW: ${params.nsfw || false}`,
    hint ? `HINT:${hint}` : null,
  ].filter((part): part is string => Boolean(part));

  return parts.join("\n");
}

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

export async function variantsRewrite(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, existingCaption:string, facts?:Record<string, unknown>, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rewrite.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}EXISTING_CAPTION: "${params.existingCaption}"${params.facts?`\nIMAGE_FACTS: ${JSON.stringify(params.facts)}`:""}\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json=stripToJSON(res.response.text()) as unknown;
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags=["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content, you'll love it and want more!";
    });
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rewrite.txt"),
  ]);

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content, you'll love it and want more!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} This enhanced version provides much more engaging content and better call-to-action for your audience! (Variant ${json.length + 1})`
      });
  const cleanVariants: Array<z.infer<typeof CaptionItem>> = [];
  let attempt = 0;
  let includeBannedHint = false;

  while (attempt < MAX_VARIANT_ATTEMPTS && cleanVariants.length < 5) {
    attempt += 1;
    const hint = includeBannedHint
      ? [params.hint, BANNED_WORDS_HINT].filter(Boolean).join(" ")
      : params.hint;
    const user = composeRewriteUserBlock(params, hint);
    let res;
    try {
      res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` },
      ]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    const parsed = stripToJSON(res.response.text());
    const variants = Array.isArray(parsed) ? parsed : [parsed];
    let bannedDetected = false;

    for (const candidate of variants) {
      if (cleanVariants.length >= 5) break;
      const record =
        typeof candidate === "object" && candidate !== null
          ? (candidate as Record<string, unknown>)
          : {};

      if (variantContainsBannedWord(record)) {
        bannedDetected = true;
        continue;
      }

      const normalized = normalizeVariantRecord(record);
      if (variantContainsBannedWord(normalized)) {
        bannedDetected = true;
        continue;
      }

      cleanVariants.push(normalized);
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    if (bannedDetected) {
      includeBannedHint = true;
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[]){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  if (cleanVariants.length === 0) {
    throw new Error('No clean rewrite variants generated by Gemini');
  }
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };

  while (cleanVariants.length < 5) {
    const template = cleanVariants[0];
    cleanVariants.push({
      ...template,
      caption: `${template.caption} (Variant ${cleanVariants.length + 1})`,
      hashtags: [...template.hashtags],
      alt: template.alt,
      cta: template.cta,
      mood: template.mood,
      style: template.style,
      safety_level: template.safety_level,
      nsfw: template.nsfw,
    });
  }
  
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

  return CaptionArray.parse(cleanVariants.slice(0, 5));
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>>{
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rank.txt"),
  ]);

  let attempt = 0;
  let hint: string | undefined;

  while (attempt < MAX_RANK_ATTEMPTS) {
    attempt += 1;
    let res;
    try {
      const hintBlock = hint ? `\nHINT:${hint}` : "";
      res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}${hintBlock}\n${JSON.stringify(variants)}` },
      ]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    let json = stripToJSON(res.response.text()) as unknown;

    if(Array.isArray(json)) {
      const winner = json[0] || variants[0];
      json = {
        winner_index: 0,
        scores: [5, 4, 3, 2, 1],
        reason: "Selected based on engagement potential",
        final: winner
      };
    }

    if((json as Record<string, unknown>).final){
      const final = (json as { final: Record<string, unknown> }).final;
      (json as { final: z.infer<typeof CaptionItem> }).final = normalizeVariantRecord(final);
    }
    const ranked = RankResult.parse(json);
    if(!variantContainsBannedWord(ranked.final)){
      return ranked;
    }

    hint = BANNED_WORDS_HINT;
  }
  return RankResult.parse(json);
  throw new Error('Ranked caption contains banned words');
}

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;
    let variants = await variantsRewrite({ platform, voice, style, mood, existingCaption, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;
    
    // Ensure rewritten caption is longer and more engaging than original
    if(out.caption.length <= existingCaption.length) {
      out.caption = existingCaption + " ✨ Enhanced with engaging content and call-to-action that drives better engagement!";
      out.caption = existingCaption + " ✨ Enhanced with engaging storytelling and a call-to-action that drives better engagement!";
    }

    const err = platformChecks(platform, out);
    if (err) {
      variants = await variantsRewrite({ platform, voice, existingCaption, facts, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/textOnlyPipeline.ts
+121-77
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { textModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

const MAX_RANK_ATTEMPTS = 2;
const DEFAULT_CAPTION = "Check out this unforgettable moment!";
const DEFAULT_ALT = "A vibrant social media moment full of detail and energy.";
const DEFAULT_HASHTAGS = ["#creative", "#vibes", "#moments"] as const;
const DEFAULT_IG_HASHTAGS = ["#creative", "#vibes", "#moments", "#lifestyle"] as const;
const DEFAULT_CTA = "Join the conversation";

const defaultHashtags = (platform?: string): string[] =>
  platform === 'instagram' ? [...DEFAULT_IG_HASHTAGS] : [...DEFAULT_HASHTAGS];

function normalizeTextOnlyVariant(
  record: Record<string, unknown>,
  platform?: string
): z.infer<typeof CaptionItem> {
  const caption =
    typeof record.caption === 'string' && record.caption.trim().length > 0
      ? record.caption
      : DEFAULT_CAPTION;
  const alt =
    typeof record.alt === 'string' && record.alt.trim().length >= 20
      ? record.alt
      : DEFAULT_ALT;
  const minimumTagCount = platform === 'instagram' ? 4 : 3;
  let hashtags = Array.isArray(record.hashtags)
    ? record.hashtags.filter((tag): tag is string => typeof tag === 'string' && tag.trim().length > 0)
    : [];
  if (hashtags.length < minimumTagCount) {
    const fallback = defaultHashtags(platform);
    for (const tag of fallback) {
      if (!hashtags.includes(tag)) hashtags.push(tag);
    }
  }
  if (hashtags.length === 0) {
    hashtags = defaultHashtags(platform);
  }
  hashtags = hashtags.slice(0, 10);

  const cta =
    typeof record.cta === 'string' && record.cta.trim().length >= 2 ? record.cta : DEFAULT_CTA;
  const mood =
    typeof record.mood === 'string' && record.mood.trim().length >= 2 ? record.mood : 'engaging';
  const style =
    typeof record.style === 'string' && record.style.trim().length >= 2 ? record.style : 'authentic';
  const safetyInput = typeof record.safety_level === 'string' ? record.safety_level : 'normal';
  const safety_level = normalizeSafetyLevel(safetyInput);
  const nsfw = typeof record.nsfw === 'boolean' ? record.nsfw : false;

  return CaptionItem.parse({
    caption,
    alt,
    hashtags,
    cta,
    mood,
    style,
    safety_level,
    nsfw,
  });
}

export async function generateVariantsTextOnly(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, theme:string, context?:string, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants_textonly.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: "${params.theme}"\nCONTEXT: "${params.context||''}"\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  const raw=stripToJSON(res.response.text());
  const json=Array.isArray(raw)?raw:[raw];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 3) {
        if(params.platform === 'instagram') {
          variant.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
        } else {
          variant.hashtags=["#content", "#creative", "#amazing"];
        }
      }
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content!";
  const rawArray = Array.isArray(raw) ? raw : [raw];
  const normalized: Array<z.infer<typeof CaptionItem>> = rawArray.map(item => {
    const record = typeof item === 'object' && item !== null ? (item as Record<string, unknown>) : {};
    return normalizeTextOnlyVariant(record, params.platform);
  });

  while(normalized.length < 5) {
    const template = normalized[0] || normalizeTextOnlyVariant({}, params.platform);
    normalized.push({
      ...template,
      caption: `${template.caption} (Variant ${normalized.length + 1})`,
      hashtags: [...template.hashtags],
      alt: template.alt,
      cta: template.cta,
      mood: template.mood,
      style: template.style,
      safety_level: template.safety_level,
      nsfw: template.nsfw,
    });
  }

  if(normalized.length > 5) {
    normalized.splice(5);
  }

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
  return CaptionArray.parse(normalized);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rank.txt"),
  ]);

  let attempt = 0;
  let hint: string | undefined;

  while(attempt < MAX_RANK_ATTEMPTS) {
    attempt += 1;
    const hintBlock = hint ? `\nHINT:${hint}` : "";
    const res=await textModel.generateContent([{ text: `${sys}\n${guard}\n${prompt}${hintBlock}\n${JSON.stringify(variants)}` }]);
    let json=stripToJSON(res.response.text()) as unknown;

    if(Array.isArray(json)) {
      const winner = json[0] || variants[0];
      json = {
        winner_index: 0,
        scores: [5, 4, 3, 2, 1],
        reason: "Selected based on engagement potential",
        final: winner
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    if((json as Record<string, unknown>).final){
      const final = (json as { final: Record<string, unknown> }).final;
      (json as { final: z.infer<typeof CaptionItem> }).final = normalizeTextOnlyVariant(final, params?.platform);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  // Fix safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags) || final.hashtags.length < 3) {
      if(params?.platform === 'instagram') {
        final.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
      } else {
        final.hashtags=["#content", "#creative", "#amazing"];
      }
    const ranked = RankResult.parse(json);
    if(!variantContainsBannedWord(ranked.final)){
      return ranked;
    }
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

    hint = BANNED_WORDS_HINT;
  }
  return RankResult.parse(json);

  throw new Error('Ranked caption contains banned words');
}

export async function pipelineTextOnly({ platform, voice="flirty_playful", style, mood, theme, context, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, theme:string, context?:string, nsfw?:boolean }){
  let variants = await generateVariantsTextOnly({ platform, voice, style, mood, theme, context, nsfw });
  let ranked = await rankAndSelect(variants, { platform, nsfw });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
    ranked = await rankAndSelect(variants);
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/routes/caption-generation.test.ts
+222-2
@@ -125,95 +125,315 @@ describe('Caption Generation', () => {
            {
              caption: 'Test caption',
              hashtags: ['#test'],
              safety_level: 'spicy_safe', // Should be normalized to spicy_safe
              mood: 'confident',
              style: 'authentic',
              cta: 'Check it out',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);

      // This would normally be called as part of the pipeline
      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      expect(result[0].safety_level).toBe('spicy_safe');
    });

    it('filters banned words from Gemini variants and ranking results', async () => {
      const mockImageUrl =
        'data:image/jpeg;base64,' +
        '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAAAAAAAAAAAAAAAAAACP/EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAD8Af//Z';
      const mockPlatform = 'instagram';
      const mockVoice = 'flirty_playful';

      const mockFactsResponse = {
        response: {
          text: () => JSON.stringify({
            objects: ['model'],
            setting: 'studio',
            mood: 'bold',
          }),
        },
      };

      const bannedVariantResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'AI style takeover tonight',
                hashtags: ['#runway', '#content'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'Discover this AI look',
                alt: 'A striking look captured in a high-fashion studio setting that feels futuristic.',
                nsfw: false,
              },
            ]),
        },
      };

      const cleanVariantResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'City lights glamour tonight',
                hashtags: ['#runway', '#confidence', '#nightlife'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'Share your thoughts',
                alt: 'A confident pose in front of glowing city lights with vibrant evening energy everywhere.',
                nsfw: false,
              },
            ]),
        },
      };

      const bannedRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Initial ranking still chose an AI-themed option.',
              final: {
                caption: 'AI look of the night',
                hashtags: ['#runway', '#glow'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'Join the AI trend',
                alt: 'A bold stance framed by neon lighting that highlights metallic textures for dramatic flair.',
                nsfw: false,
              },
            }),
        },
      };

      const cleanRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected a clean caption without banned terminology.',
              final: {
                caption: 'City lights glamour tonight',
                hashtags: ['#runway', '#confidence', '#nightlife'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'Share your thoughts',
                alt: 'A confident pose in front of glowing city lights with vibrant evening energy everywhere.',
                nsfw: false,
              },
            }),
        },
      };

      const { textModel, visionModel } = await import('../../server/lib/gemini.js');
      (visionModel.generateContent as any).mockResolvedValueOnce(mockFactsResponse);
      (textModel.generateContent as any)
        .mockResolvedValueOnce(bannedVariantResponse)
        .mockResolvedValueOnce(cleanVariantResponse)
        .mockResolvedValueOnce(bannedRankResponse)
        .mockResolvedValueOnce(cleanRankResponse);

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      expect(result.final.caption.toLowerCase()).not.toContain('ai');
      expect(result.final.caption.toLowerCase()).not.toContain('content');
      expect(result.final.cta.toLowerCase()).not.toContain('ai');
      expect(result.final.hashtags.some(tag => /ai|content/i.test(tag))).toBe(false);

      const geminiCalls = (textModel.generateContent as any).mock.calls;
      expect(geminiCalls.length).toBe(4);
      expect(geminiCalls.some(call => call[0][0].text.includes('Avoid banned words: ai, ai-generated, content'))).toBe(true);
    });
  });

  describe('Text-Only Pipeline', () => {
    it('should generate content without image context', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Motivational content for today!',
              caption: 'Motivational message for today!',
              hashtags: ['#motivation', '#mindset'],
              safety_level: 'normal',
              mood: 'inspiring',
              style: 'authentic',
              cta: 'What motivates you?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);

      const result = await pipelineTextOnly({
        platform: 'instagram',
        voice: 'inspiring',
        theme: 'motivation',
        context: 'morning motivation post',
      });

      expect(result.final).toMatchObject({
        caption: expect.stringContaining('Motivational'),
        safety_level: 'normal',
      });
    });
  });

  describe('Rewrite Pipeline', () => {
    it('should improve existing captions', async () => {
      const existingCaption = 'Basic caption here';
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Enhanced and engaging caption! ✨',
              hashtags: ['#enhanced', '#content'],
              hashtags: ['#enhanced', '#story'],
              safety_level: 'normal',
              mood: 'engaging',
              style: 'authentic',
              cta: 'What do you think?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const genSpy = vi.spyOn(textModel, 'generateContent').mockResolvedValue(mockResponse as any);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(result.final.caption).not.toBe(existingCaption);
      expect(result.final.caption).toContain('Enhanced');

      genSpy.mockRestore();
    });

    it('retries rewrite variants and ranking to remove banned words', async () => {
      const bannedVariantsResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'AI boosted upgrade',
                hashtags: ['#revamp', '#content'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Explore this AI refresh',
                alt: 'An energetic rewrite concept with plenty of descriptive language for accessibility.',
                nsfw: false,
              },
            ]),
        },
      };

      const cleanVariantsResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'Bold new caption with confident energy',
                hashtags: ['#revamp', '#glow', '#moment'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Tell me how it lands',
                alt: 'A refreshed social media concept that feels vibrant and fully described in detail.',
                nsfw: false,
              },
            ]),
        },
      };

      const bannedRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Initial ranking still referenced AI terms.',
              final: {
                caption: 'AI powered rewrite success',
                hashtags: ['#revamp', '#shine'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Celebrate the AI upgrade',
                alt: 'A descriptive rewrite result that unfortunately keeps the AI phrasing front and center.',
                nsfw: false,
              },
            }),
        },
      };

      const cleanRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected the rewrite without banned terminology.',
              final: {
                caption: 'Bold new caption with confident energy',
                hashtags: ['#revamp', '#glow', '#moment'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Tell me how it lands',
                alt: 'A refreshed social media concept that feels vibrant and fully described in detail.',
                nsfw: false,
              },
            }),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any)
        .mockResolvedValueOnce(bannedVariantsResponse)
        .mockResolvedValueOnce(cleanVariantsResponse)
        .mockResolvedValueOnce(bannedRankResponse)
        .mockResolvedValueOnce(cleanRankResponse);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption: 'Original caption to improve',
      });

      expect(result.final.caption.toLowerCase()).not.toContain('ai');
      expect(result.final.cta.toLowerCase()).not.toContain('content');
      expect(result.final.hashtags.some(tag => /ai|content/i.test(tag))).toBe(false);

      const calls = (textModel.generateContent as any).mock.calls;
      expect(calls.length).toBe(4);
      expect(calls.some(call => call[0][0].text.includes('Avoid banned words: ai, ai-generated, content'))).toBe(true);
    });
  });
});
