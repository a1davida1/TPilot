Update admin panel to pass isAdmin prop
Sep 23 · a1davida1/TPilot · main
+5-3
1. Update `client/src/pages/admin.tsx` to pass `canManage={Boolean(user?.isAdmin)}` into `AdminCommunitiesPanel` (and ensure upstream auth data includes `isAdmin`).
2. Optionally extend admin-page tests (if/when they exist) to cover both admin and non-admin scenarios.

Summary

    Passed the boolean admin flag from the authenticated user state into AdminCommunitiesPanel, ensuring the communities UI respects server-provided administrator roles instead of tier heuristics.

Normalized /api/auth/user responses to always include an explicit isAdmin boolean, deriving it from stored role data so downstream clients can reliably gate admin features.

Addressed a lingering lint violation in the policy linter helper by switching a never-reassigned rules object to const.

Testing

    ✅ npm run lint

❌ npm test *(fails across many suites due to missing infrastructure/mocks; run interrupted after repeated environment-driven errors)*


client/src/pages/admin.tsx
+1-1
@@ -560,51 +560,51 @@ export function AdminDashboard() {

            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Service Costs</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold">${Math.floor(((stats as any)?.contentGenerated || 0) * 0.02) || '0'}</p>
                <p className="text-sm text-gray-400 mt-2">Estimated AI costs</p>
                <div className="mt-3 text-xs space-y-1">
                  <div className="flex justify-between">
                    <span className="text-gray-500">Gemini (Primary)</span>
                    <span className="text-green-400">85% savings</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Content Generated</span>
                    <span className="text-gray-900">{(stats as any)?.contentGenerated || 0}</span>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        {/* Communities Tab */}
        <TabsContent value="communities" className="space-y-6">
          <AdminCommunitiesPanel canManage={user?.tier === 'admin'} />
          <AdminCommunitiesPanel canManage={Boolean(user?.isAdmin)} />
        </TabsContent>

        {/* Compliance Tab */}
        <TabsContent value="compliance" className="space-y-6">
          <Card className="bg-white border-gray-200 shadow-lg">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Shield className="h-5 w-5 text-purple-600" />
                Compliance Dashboard
              </CardTitle>
              <CardDescription>
                Monitor subreddit compliance, shadowban status, and content moderation patterns
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Suspense fallback={
                <div className="flex items-center justify-center py-12">
                  <div className="flex items-center gap-3 text-gray-500">
                    <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-purple-600"></div>
                    <span>Loading compliance dashboard...</span>
                  </div>
                </div>
              }>
                <ComplianceStatusDashboard />
              </Suspense>
server/auth.ts
+3-1
@@ -386,53 +386,55 @@ export function setupAuth(app: Express) {
        
      try {
        const decoded = jwt.verify(token, JWT_SECRET_VALIDATED) as { userId?: number; id?: number; isAdmin?: boolean; };
        
        // CHECK IF IT'S ADMIN TOKEN
        if (decoded.id === 999 || decoded.isAdmin) {
          return res.json({
            id: 999,
            username: 'admin',
            email: process.env.ADMIN_EMAIL,
            tier: 'admin',
            isAdmin: true,
            role: 'admin',
            emailVerified: true
          });
        }
        
        // Regular user lookup
        const userId = decoded.userId || decoded.id;
        if (!userId) {
          return res.status(401).json({ message: 'Invalid token: missing user ID' });
        }
        const user = await storage.getUser(userId);
        if (user) {
          const { password: _, ...userResponse } = user;
          const isAdmin = Boolean(userResponse.isAdmin || userResponse.role === 'admin' || userResponse.id === 999);
          return res.json({
            ...userResponse,
            tier: userResponse.tier || 'free'
            tier: userResponse.tier || 'free',
            isAdmin
          });
        }

        return res.status(404).json({ message: 'User not found' });
      } catch (jwtError) {
        safeLog('error', 'JWT verification failed', { error: (jwtError as Error).message });
        return res.status(401).json({ message: 'Invalid token' });
      }
    } catch (error) {
      safeLog('error', 'Get user failed', { error: (error as Error).message });
      res.status(500).json({ message: 'Error fetching user data' });
    }
  });

  // Force password change endpoint (for temporary passwords)
  app.post('/api/auth/change-password', passwordChangeLimiter, validate(passwordChangeValidationSchema), async (req, res) => {
    try {
      const { userId, currentPassword, newPassword } = req.body;

      if (!userId || !currentPassword || !newPassword) {
        return res.status(400).json({ message: 'Missing required fields' });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ message: 'New password must be at least 6 characters long' });
server/lib/policy-linter.ts
+1-1
@@ -80,51 +80,51 @@ const DEFAULT_RULES: RuleSpec = {
  flairRequired: false, // Varies by subreddit
  manualFlags: {} // Only warn when communities explicitly specify requirements
};

/**
 * Coerce stored rule spec to ensure it has proper structure
 */
function coerceRuleSpec(rawRules: any): RuleSpec {
  // Handle legacy test format
  if ('titleRegex' in rawRules || 'prohibitedLinks' in rawRules || 'maxLength' in rawRules || 'minLength' in rawRules) {
    const testRules = rawRules as TestRuleSpec;
    return {
      bannedWords: testRules.bannedWords || [],
      titleRegexes: testRules.titleRegex || [],
      bodyRegexes: testRules.prohibitedLinks || [],
      maxTitleLength: testRules.maxLength,
      maxBodyLength: testRules.maxLength,
      requiredTags: [], // Remove context-dependent logic - will be handled in linter
      linkPolicy: 'one-link',
      flairRequired: false,
    };
  }

  // Handle new RuleSpec format or ensure it has proper structure
  const spec = rawRules as RuleSpec;
  let result: RuleSpec = {
  const result: RuleSpec = {
    bannedWords: spec.bannedWords || [],
    titleRegexes: spec.titleRegexes || [],
    bodyRegexes: spec.bodyRegexes || [],
    flairRequired: spec.flairRequired || false,
    linkPolicy: spec.linkPolicy || 'one-link',
    requiredTags: spec.requiredTags || [],
    maxTitleLength: spec.maxTitleLength,
    maxBodyLength: spec.maxBodyLength,
    manualFlags: spec.manualFlags || {},
    wikiNotes: spec.wikiNotes || [],
    source: spec.source,
    overrides: spec.overrides,
  };

  // Apply overrides if present (merge overrides onto base spec)
  if (spec.overrides) {
    Object.keys(spec.overrides).forEach(key => {
      const overrideValue = (spec.overrides as any)?.[key];
      if (overrideValue !== undefined && overrideValue !== null) {
        (result as any)[key] = overrideValue;
      }
    });
  }

  return result;
