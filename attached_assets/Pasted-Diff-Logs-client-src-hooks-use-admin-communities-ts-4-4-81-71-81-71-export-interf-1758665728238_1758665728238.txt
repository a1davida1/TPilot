Diff
Logs

client/src/hooks/use-admin-communities.ts
+4
-4

@@ -81,71 +81,71 @@ export interface CommunityPayload {

export interface CommunityFilters {
  search?: string;
  category?: string;
  promotionAllowed?: PromotionPolicy | 'all';
  verificationRequired?: 'all' | 'required' | 'not-required';
}

export function useAdminCommunities(filters?: CommunityFilters) {
  const queryParams = new URLSearchParams();

  if (filters?.search) {
    queryParams.set('search', filters.search);
  }
  if (filters?.category && filters.category !== 'all') {
    queryParams.set('category', filters.category);
  }
  if (filters?.promotionAllowed && filters.promotionAllowed !== 'all') {
    queryParams.set('promotionAllowed', filters.promotionAllowed);
  }
  if (filters?.verificationRequired && filters.verificationRequired !== 'all') {
    queryParams.set('verificationRequired', filters.verificationRequired === 'required' ? 'true' : 'false');
  }

  const queryString = queryParams.toString();
  const url = `/api/reddit/communities${queryString ? `?${queryString}` : ''}`;
  const url = `/api/admin/communities${queryString ? `?${queryString}` : ''}`;

  return useQuery<AdminCommunity[]>({
    queryKey: ['admin-communities', filters],
    queryFn: () => fetch(url).then(res => {
      if (!res.ok) throw new Error('Failed to fetch communities');
      return res.json();
    }),
  });
}

export function useCreateCommunity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CommunityPayload) => 
      apiRequest('POST', '/api/reddit/communities', payload),
      apiRequest('POST', '/api/admin/communities', payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
  });
}

export function useUpdateCommunity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: CommunityPayload }) => 
      apiRequest('PUT', `/api/reddit/communities/${id}`, payload),
      apiRequest('PUT', `/api/admin/communities/${id}`, payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
  });
}

export function useDeleteCommunity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => 
      apiRequest('DELETE', `/api/reddit/communities/${id}`),
      apiRequest('DELETE', `/api/admin/communities/${id}`),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-communities'] });
    },
  });
}
server/routes.ts
+2
-2

@@ -469,52 +469,52 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api'):
  // ==========================================
  
  // Setup authentication
  setupAuth(app);
  setupAdminRoutes(app);
  
  // Configure social authentication
  configureSocialAuth();

  // ==========================================
  // ROUTE REGISTRATION
  // ==========================================
  
  // Authentication routes - handled by setupAuth() in server/auth.ts
  // app.use('/api/auth', authRoutes); // Removed - duplicate auth system
  
  // Upload routes
  app.use('/api/upload', uploadRoutes);
  
  // Media routes
  app.use('/api/media', mediaRoutes);

  // Analytics routes
  app.use('/api/analytics', analyticsRouter);
  
  // Admin communities routes (mounted at reddit path for client compatibility)
  app.use('/api/reddit/communities', adminCommunitiesRouter);
  // Admin communities routes are exposed under a dedicated admin namespace
  app.use('/api/admin/communities', adminCommunitiesRouter);
  
  // Social auth routes
  app.get('/api/auth/google', socialAuthRoutes.googleAuth);
  app.get('/api/auth/google/callback', socialAuthRoutes.googleCallback);
  app.get('/api/auth/facebook', socialAuthRoutes.facebookAuth);
  app.get('/api/auth/facebook/callback', socialAuthRoutes.facebookCallback);
  app.get('/api/auth/reddit', socialAuthRoutes.redditAuth);
  app.get('/api/auth/reddit/callback', socialAuthRoutes.redditCallback);

  // Serve uploaded files securely
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // ==========================================
  // STRIPE PAYMENT ENDPOINTS
  // ==========================================
  
  // Create subscription payment intent
  app.post("/api/create-subscription", authenticateToken, async (req: AuthRequest, res) => {
    try {
      if (!stripe) {
        return res.status(503).json({ 
          message: "Payment system is not configured. Please try again later." 
        });
      }

tests/integration/admin-communities-auth.test.ts
+208
-69

import { describe, test, expect, beforeAll, afterAll, beforeEach, vi } from 'vitest';
import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach, vi } from 'vitest';
import express from 'express';
import session from 'express-session';
import session, { type Session, type SessionData } from 'express-session';
import cookieParser from 'cookie-parser';
import request from 'supertest';
import { adminCommunitiesRouter } from '../../server/routes/admin-communities.js';

// Mock the reddit-communities module
vi.mock('../../server/reddit-communities.js', () => ({
  listCommunities: vi.fn().mockResolvedValue([
    {
      id: '1',
      name: 'test_community',
      displayName: 'Test Community',
      description: 'A test community',
      category: 'Technology',
      members: 10000,
      verificationRequired: false,
      promotionAllowed: true,
      rules: { allowedTypes: ['text', 'image'], maxPostsPerDay: 10 },
      engagementRate: 0.85,
      postingLimits: { maxPerDay: 10, minInterval: 60 },
      averageUpvotes: 150,
      modActivity: 'active',
      tags: ['tech', 'programming'],
      successProbability: 0.75,
      competitionLevel: 'medium',
      growthTrend: 'increasing',
      bestPostingTimes: ['9:00', '15:00', '21:00']
    }
  ]),
  createCommunity: vi.fn().mockImplementation((data) => Promise.resolve({
  createCommunity: vi.fn().mockImplementation((data: Record<string, unknown>) => Promise.resolve({
    id: '2',
    ...data,
    rules: { allowedTypes: ['text'], maxPostsPerDay: 5 },
    engagementRate: 0.5,
    postingLimits: { maxPerDay: 5, minInterval: 120 },
    averageUpvotes: 100,
    modActivity: 'moderate',
    tags: [],
    successProbability: 0.6,
    competitionLevel: 'low',
    growthTrend: 'stable',
    bestPostingTimes: ['12:00']
  })),
  updateCommunity: vi.fn().mockImplementation((id, data) => Promise.resolve({
  updateCommunity: vi.fn().mockImplementation((id: string, data: Record<string, unknown>) => Promise.resolve({
    id,
    ...data,
    rules: data.rules || { allowedTypes: ['text'], maxPostsPerDay: 5 },
    rules: data.rules ?? { allowedTypes: ['text'], maxPostsPerDay: 5 },
    engagementRate: 0.6,
    postingLimits: { maxPerDay: 5, minInterval: 120 },
    averageUpvotes: 120,
    modActivity: 'moderate',
    tags: data.tags || [],
    tags: data.tags ?? [],
    successProbability: 0.65,
    competitionLevel: 'medium',
    growthTrend: 'stable',
    bestPostingTimes: ['12:00', '18:00']
  })),
  deleteCommunity: vi.fn().mockResolvedValue(undefined)
}));

// Mock the schema
vi.mock('@shared/schema', () => ({
  insertRedditCommunitySchema: {
    parse: vi.fn().mockImplementation((data) => data),
    parse: vi.fn().mockImplementation((data: unknown) => data),
    partial: vi.fn().mockReturnValue({
      parse: vi.fn().mockImplementation((data) => data)
      parse: vi.fn().mockImplementation((data: unknown) => data)
    })
  }
}));

type AdminSessionUser = {
  id: number;
  username: string;
  email: string;
  isAdmin: boolean;
  role: string;
  tier: string;
};

type RequestWithSession = express.Request & {
  session?: Session & Partial<SessionData> & { user?: AdminSessionUser };
  user?: AdminSessionUser;
  isAuthenticated?: () => boolean;
};

describe('Admin Communities Authentication Integration', () => {
  let app: express.Application;
  let agent: request.SuperAgentTest;
  let agent: request.SuperAgentTest | undefined;

  const adminUser: AdminSessionUser = {
    id: 1,
    username: 'admin',
    email: 'admin@test.com',
    isAdmin: true,
    role: 'admin',
    tier: 'pro'
  };

  const nonAdminUser: AdminSessionUser = {
    id: 2,
    username: 'member',
    email: 'member@test.com',
    isAdmin: false,
    role: 'member',
    tier: 'starter'
  };

  const loginAs = async (user: AdminSessionUser) => {
    if (!agent) {
      throw new Error('Agent not initialized');
    }
    await agent.post('/test/login').send(user).expect(204);
  };

  const logout = async () => {
    if (!agent) {
      return;
    }
    await agent.post('/test/logout').send({}).expect(204);
  };

  beforeAll(async () => {
    // Create Express app with session middleware (similar to production setup)
    app = express();
    app.use(express.json());
    app.use(cookieParser());
    
    // Session middleware setup
    app.use(session({
      secret: 'test-session-secret',
      resave: false,
      saveUninitialized: false,
      cookie: { 
        secure: false, // Allow non-HTTPS in tests
      cookie: {
        secure: false,
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
        maxAge: 24 * 60 * 60 * 1000
      }
    }));

    // Mock authentication by adding user to session
    app.use('/api/reddit/communities', (req: any, res, next) => {
      // Simulate authenticated admin user in session
      req.user = {
        id: 1,
        username: 'admin',
        email: 'admin@test.com',
        isAdmin: true,
        role: 'admin',
        tier: 'pro'
      };
      
      // Mock isAuthenticated function for Passport.js compatibility
      req.isAuthenticated = () => true;
      
    const redditCommunities = await import('../../server/reddit-communities.js');

    app.use((req, _res, next) => {
      const requestWithSession = req as RequestWithSession;
      const sessionUser = requestWithSession.session?.user;
      requestWithSession.isAuthenticated = () => Boolean(sessionUser);
      if (sessionUser) {
        requestWithSession.user = sessionUser;
      }
      next();
    });

    // Mount admin communities router
    app.use('/api/reddit/communities', adminCommunitiesRouter);
    app.get('/api/reddit/communities', async (_req, res) => {
      const communities = await redditCommunities.listCommunities();
      res.json(communities);
    });

    app.post('/test/login', (req, res) => {
      const requestWithSession = req as RequestWithSession;
      const sessionInstance = requestWithSession.session;

      if (!sessionInstance) {
        res.status(500).json({ message: 'Session not initialized' });
        return;
      }

      const sessionUser = req.body as AdminSessionUser;
      sessionInstance.user = sessionUser;
      res.status(204).send();
    });

    app.post('/test/logout', (req, res) => {
      const requestWithSession = req as RequestWithSession;
      const sessionInstance = requestWithSession.session;

      if (!sessionInstance) {
        res.status(204).send();
        return;
      }

      sessionInstance.destroy(error => {
        if (error) {
          res.status(500).json({ message: 'Failed to destroy session' });
          return;
        }
        res.status(204).send();
      });
    });

    app.use('/api/admin/communities', adminCommunitiesRouter);

    // Create persistent agent for session cookie handling
    agent = request.agent(app);
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(async () => {
    await logout();
  });

  afterAll(() => {
    vi.restoreAllMocks();
  });

  test('should list communities without Authorization header (session auth)', async () => {
    const response = await agent
  test('allows anonymous access to reddit communities listing', async () => {
    const response = await request(app)
      .get('/api/reddit/communities')
      .expect(200);

    expect(response.body).toBeDefined();
    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body.length).toBe(1);
    expect(response.body[0]).toMatchObject({
      id: '1',
      name: 'test_community',
      displayName: 'Test Community'
    });
  });

  test('should create community without Authorization header (session auth)', async () => {
  test('rejects admin communities access without authentication', async () => {
    await request(app)
      .get('/api/admin/communities')
      .expect(401);
  });

  test('rejects admin communities access for non-admin users', async () => {
    await loginAs(nonAdminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    await agent
      .get('/api/admin/communities')
      .expect(403);
  });

  test('rejects admin community modifications without authentication', async () => {
    await request(app)
      .post('/api/admin/communities')
      .send({ name: 'unauthorized' })
      .expect(401);

    await request(app)
      .put('/api/admin/communities/1')
      .send({ displayName: 'Unauthorized' })
      .expect(401);

    await request(app)
      .delete('/api/admin/communities/1')
      .expect(401);
  });

  test('lists communities for authenticated admin user', async () => {
    await loginAs(adminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    const response = await agent
      .get('/api/admin/communities')
      .expect(200);

    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body[0]).toMatchObject({
      id: '1',
      name: 'test_community',
      displayName: 'Test Community'
    });
  });

  test('creates community for authenticated admin user', async () => {
    await loginAs(adminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    const newCommunity = {
      name: 'new_community',
      displayName: 'New Community',
      description: 'A new test community',
      category: 'Gaming',
      members: 5000,
      verificationRequired: true,
      promotionAllowed: false
    };

    const response = await agent
      .post('/api/reddit/communities')
      .post('/api/admin/communities')
      .send(newCommunity)
      .expect(201);

    expect(response.body).toMatchObject({
      id: '2',
      name: 'new_community',
      displayName: 'New Community'
    });
  });

  test('should update community without Authorization header (session auth)', async () => {
  test('updates community for authenticated admin user', async () => {
    await loginAs(adminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    const updateData = {
      displayName: 'Updated Community',
      description: 'Updated description'
    };

    const response = await agent
      .put('/api/reddit/communities/1')
      .put('/api/admin/communities/1')
      .send(updateData)
      .expect(200);

    expect(response.body).toMatchObject({
      id: '1',
      displayName: 'Updated Community',
      description: 'Updated description'
    });
  });

  test('should delete community without Authorization header (session auth)', async () => {
    await agent
      .delete('/api/reddit/communities/1')
  test('deletes community for authenticated admin user', async () => {
    await loginAs(adminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    const response = await agent
      .delete('/api/admin/communities/1')
      .expect(200);

    expect(response => {
      expect(response.body.message).toBe('Community deleted successfully');
    });
    expect(response.body.message).toBe('Community deleted successfully');
  });

  test('should handle non-existent community update gracefully', async () => {
  test('handles non-existent community update gracefully', async () => {
    const { updateCommunity } = await import('../../server/reddit-communities.js');
    vi.mocked(updateCommunity).mockResolvedValueOnce(undefined);

    await loginAs(adminUser);

    if (!agent) {
      throw new Error('Agent not initialized');
    }

    const updateData = { displayName: 'Does Not Exist' };

    await agent
      .put('/api/reddit/communities/999')
      .put('/api/admin/communities/999')
      .send(updateData)
      .expect(404);
  });

  test('should handle non-existent community deletion gracefully', async () => {
  test('handles non-existent community deletion gracefully', async () => {
    const { listCommunities } = await import('../../server/reddit-communities.js');
    // Mock empty communities list to simulate non-existent community
    vi.mocked(listCommunities).mockResolvedValueOnce([]);

    await agent
      .delete('/api/reddit/communities/999')
      .expect(404);
  });
    await loginAs(adminUser);

  test('should work with plain fetch simulation (no special headers)', async () => {
    // This test simulates how the frontend makes requests without Authorization headers
    const response = await request(app)
      .get('/api/reddit/communities')
      // No Authorization header, no special session setup - just plain request
      .set('Accept', 'application/json')
      .set('Content-Type', 'application/json');
    if (!agent) {
      throw new Error('Agent not initialized');
    }

    // Note: This will work because our mock middleware sets req.user above
    // In real scenarios, the session middleware would handle this
    expect(response.status).toBe(200);
    expect(Array.isArray(response.body)).toBe(true);
    await agent
      .delete('/api/admin/communities/999')
      .expect(404);
  });
});
});
