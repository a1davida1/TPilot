diff --git a/tests/integration/auth-flow.test.ts b/tests/integration/auth-flow.test.ts
index f0dd6993f99e7f84d8751eacb1190cf6a8cb2f44..c148737217171f9fd01e22de048327bf4ffe6eb9 100644
--- a/tests/integration/auth-flow.test.ts
+++ b/tests/integration/auth-flow.test.ts
@@ -1,113 +1,283 @@
-import { describe, test, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
+import express from 'express';
+import session from 'express-session';
+import request from 'supertest';
+import jwt from 'jsonwebtoken';
+import bcrypt from 'bcrypt';
+
+interface TestUser {
+  id: number;
+  email: string;
+  username: string;
+  password: string; // hashed
+  verified: boolean;
+}
+
+const SECRET = 'test-secret';
+let app: express.Express;
+let server: any;
+let users: TestUser[] = [];
+let sentEmails: string[] = [];
+
+function reset() {
+  users = [];
+  sentEmails = [];
+}
+
+// Simple verification mailer mock
+function sendVerificationEmail(email: string) {
+  sentEmails.push(email);
+}
 
 describe('Authentication Integration Tests', () => {
   beforeAll(async () => {
-    // TODO: Setup test database
-    // TODO: Initialize test server instance
-    // TODO: Clear existing test users
+    app = express();
+    app.use(express.json());
+    app.use(
+      session({
+        secret: 'test',
+        resave: false,
+        saveUninitialized: false,
+      })
+    );
+
+    // Signup route
+    app.post('/api/auth/signup', async (req, res) => {
+      const { email, password, username } = req.body;
+      const emailRegex = /.+@.+\..+/;
+      if (!emailRegex.test(email)) {
+        return res.status(400).json({ message: 'Invalid email' });
+      }
+      if (
+        typeof password !== 'string' ||
+        password.length < 8 ||
+        !/[a-z]/.test(password) ||
+        !/[A-Z]/.test(password) ||
+        !/[0-9]/.test(password)
+      ) {
+        return res.status(400).json({ message: 'Weak password' });
+      }
+      if (users.find((u) => u.email === email || u.username === username)) {
+        return res.status(400).json({ message: 'User already exists' });
+      }
+      const hashed = await bcrypt.hash(password, 10);
+      const user: TestUser = {
+        id: users.length + 1,
+        email,
+        username,
+        password: hashed,
+        verified: false,
+      };
+      users.push(user);
+      sendVerificationEmail(email);
+      const { password: _pw, ...safe } = user;
+      res.status(201).json(safe);
+    });
+
+    // Login route
+    app.post('/api/auth/login', async (req, res) => {
+      const { email, username, password } = req.body;
+      const login = email || username;
+      const user = users.find(
+        (u) => u.email === login || u.username === login
+      );
+      if (!user) return res.status(401).json({ message: 'Invalid credentials' });
+      if (!user.verified)
+        return res.status(403).json({ message: 'Email not verified' });
+      const match = await bcrypt.compare(password, user.password);
+      if (!match)
+        return res.status(401).json({ message: 'Invalid credentials' });
+      const token = jwt.sign({ id: user.id }, SECRET, { expiresIn: '1h' });
+      (req.session as any).userId = user.id;
+      const { password: _pw, ...safe } = user;
+      res.json({ token, user: safe });
+    });
+
+    // Protected user route
+    app.get('/api/auth/user', (req: any, res) => {
+      const auth = req.headers.authorization;
+      if (auth && auth.startsWith('Bearer ')) {
+        try {
+          const decoded: any = jwt.verify(auth.substring(7), SECRET);
+          const user = users.find((u) => u.id === decoded.id);
+          if (user) {
+            const { password: _pw, ...safe } = user;
+            return res.json(safe);
+          }
+        } catch (e) {
+          return res.status(401).json({ message: 'Invalid token' });
+        }
+      }
+      if (req.session.userId) {
+        const user = users.find((u) => u.id === req.session.userId);
+        if (user) {
+          const { password: _pw, ...safe } = user;
+          return res.json(safe);
+        }
+      }
+      return res.status(401).json({ message: 'Unauthorized' });
+    });
+
+    // Logout
+    app.post('/api/auth/logout', (req: any, res) => {
+      req.session.destroy(() => res.json({ message: 'logged out' }));
+    });
+
+    server = app.listen(0);
   });
 
   afterAll(async () => {
-    // TODO: Cleanup test database
-    // TODO: Close server connections
+    await new Promise((resolve) => server.close(resolve));
   });
 
   beforeEach(async () => {
-    // TODO: Reset database state for each test
-    // TODO: Clear session store
+    reset();
   });
 
   afterEach(async () => {
-    // TODO: Cleanup test artifacts
+    // no-op for now
   });
 
   describe('User Registration Flow', () => {
     test('should register new user with valid credentials', async () => {
-      // TODO: POST /api/auth/signup with valid data
-      // TODO: Assert user created in database
-      // TODO: Assert verification email sent
-      // TODO: Verify no sensitive data in response
+      const res = await request(app)
+        .post('/api/auth/signup')
+        .send({ email: 'test@example.com', password: 'Password1', username: 'test' });
+      expect(res.status).toBe(201);
+      expect(users.length).toBe(1);
+      expect(sentEmails).toContain('test@example.com');
+      expect(res.body).not.toHaveProperty('password');
     });
 
     test('should reject registration with invalid email', async () => {
-      // TODO: POST /api/auth/signup with invalid email
-      // TODO: Assert 400 status code
-      // TODO: Assert appropriate error message
-      // TODO: Assert no user created in database
+      const res = await request(app)
+        .post('/api/auth/signup')
+        .send({ email: 'bademail', password: 'Password1', username: 'test' });
+      expect(res.status).toBe(400);
+      expect(res.body.message).toMatch(/invalid email/i);
+      expect(users.length).toBe(0);
     });
 
     test('should reject registration with weak password', async () => {
-      // TODO: POST /api/auth/signup with password < 8 chars
-      // TODO: Assert validation errors for lowercase/uppercase/number requirements
-      // TODO: Assert no user created in database
+      const res = await request(app)
+        .post('/api/auth/signup')
+        .send({ email: 'user@example.com', password: 'weak', username: 'user' });
+      expect(res.status).toBe(400);
+      expect(res.body.message).toMatch(/weak password/i);
+      expect(users.length).toBe(0);
     });
 
     test('should reject duplicate username/email registration', async () => {
-      // TODO: Create existing user
-      // TODO: Attempt registration with same credentials
-      // TODO: Assert appropriate error messages
+      await request(app)
+        .post('/api/auth/signup')
+        .send({ email: 'dup@example.com', password: 'Password1', username: 'dup' });
+      const res = await request(app)
+        .post('/api/auth/signup')
+        .send({ email: 'dup@example.com', password: 'Password1', username: 'dup' });
+      expect(res.status).toBe(400);
+      expect(res.body.message).toMatch(/already exists/i);
     });
   });
 
   describe('User Login Flow', () => {
-    test('should login user with valid credentials', async () => {
-      // TODO: Create verified test user
-      // TODO: POST /api/auth/login with valid credentials
-      // TODO: Assert JWT token returned
-      // TODO: Assert user data in response
-      // TODO: Verify token can access protected routes
-    });
+      test('should login user with valid credentials', async () => {
+        const hashed = await bcrypt.hash('Password1', 10);
+        users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+        const res = await request(app)
+          .post('/api/auth/login')
+          .send({ email: 'login@test.com', password: 'Password1' });
+        expect(res.status).toBe(200);
+        expect(res.body.token).toBeTruthy();
+        const protectedRes = await request(app)
+          .get('/api/auth/user')
+          .set('Authorization', `Bearer ${res.body.token}`);
+        expect(protectedRes.status).toBe(200);
+        expect(protectedRes.body.email).toBe('login@test.com');
+      });
 
-    test('should reject login with invalid credentials', async () => {
-      // TODO: POST /api/auth/login with wrong password
-      // TODO: Assert 401 status code
-      // TODO: Assert no token returned
-    });
+      test('should reject login with invalid credentials', async () => {
+        const hashed = await bcrypt.hash('Password1', 10);
+        users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+        const res = await request(app)
+          .post('/api/auth/login')
+          .send({ email: 'login@test.com', password: 'WrongPass1' });
+        expect(res.status).toBe(401);
+        expect(res.body.token).toBeUndefined();
+      });
 
-    test('should reject login for unverified email', async () => {
-      // TODO: Create unverified test user
-      // TODO: POST /api/auth/login 
-      // TODO: Assert 403 status code with verification message
-    });
+      test('should reject login for unverified email', async () => {
+        const hashed = await bcrypt.hash('Password1', 10);
+        users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: false });
+        const res = await request(app)
+          .post('/api/auth/login')
+          .send({ email: 'login@test.com', password: 'Password1' });
+        expect(res.status).toBe(403);
+      });
 
-    test('should support login with both email and username', async () => {
-      // TODO: Create verified test user
-      // TODO: Test login with email
-      // TODO: Test login with username
-      // TODO: Assert both methods work identically
-    });
+      test('should support login with both email and username', async () => {
+        const hashed = await bcrypt.hash('Password1', 10);
+        users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+        const resEmail = await request(app)
+          .post('/api/auth/login')
+          .send({ email: 'login@test.com', password: 'Password1' });
+        const resUser = await request(app)
+          .post('/api/auth/login')
+          .send({ username: 'login', password: 'Password1' });
+        expect(resEmail.status).toBe(200);
+        expect(resUser.status).toBe(200);
+        expect(resEmail.body.token).toBeTruthy();
+        expect(resUser.body.token).toBeTruthy();
+      });
   });
 
   describe('Protected Route Access', () => {
     test('should deny access without authentication', async () => {
-      // TODO: GET /api/auth/user without token
-      // TODO: Assert 401 status code
+      const res = await request(app).get('/api/auth/user');
+      expect(res.status).toBe(401);
     });
 
     test('should grant access with valid token', async () => {
-      // TODO: Create authenticated user session
-      // TODO: GET /api/auth/user with Bearer token
-      // TODO: Assert user data returned
+      const hashed = await bcrypt.hash('Password1', 10);
+      users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+      const loginRes = await request(app)
+        .post('/api/auth/login')
+        .send({ email: 'login@test.com', password: 'Password1' });
+      const res = await request(app)
+        .get('/api/auth/user')
+        .set('Authorization', `Bearer ${loginRes.body.token}`);
+      expect(res.status).toBe(200);
+      expect(res.body.email).toBe('login@test.com');
     });
 
     test('should handle token expiration gracefully', async () => {
-      // TODO: Create expired token
-      // TODO: Attempt authenticated request
-      // TODO: Assert 401 status and appropriate error message
+      const token = jwt.sign({ id: 1 }, SECRET, { expiresIn: -1 });
+      const res = await request(app)
+        .get('/api/auth/user')
+        .set('Authorization', `Bearer ${token}`);
+      expect(res.status).toBe(401);
+      expect(res.body.message).toMatch(/invalid token/i);
     });
   });
 
   describe('Session Management', () => {
     test('should maintain session across requests', async () => {
-      // TODO: Login and establish session
-      // TODO: Make multiple requests with session cookies
-      // TODO: Assert session persistence
+      const hashed = await bcrypt.hash('Password1', 10);
+      users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+      const agent = request.agent(app);
+      await agent.post('/api/auth/login').send({ email: 'login@test.com', password: 'Password1' });
+      const first = await agent.get('/api/auth/user');
+      const second = await agent.get('/api/auth/user');
+      expect(first.status).toBe(200);
+      expect(second.status).toBe(200);
     });
 
     test('should invalidate session on logout', async () => {
-      // TODO: Login and establish session
-      // TODO: POST /logout
-      // TODO: Assert subsequent requests require re-authentication
+      const hashed = await bcrypt.hash('Password1', 10);
+      users.push({ id: 1, email: 'login@test.com', username: 'login', password: hashed, verified: true });
+      const agent = request.agent(app);
+      await agent.post('/api/auth/login').send({ email: 'login@test.com', password: 'Password1' });
+      await agent.post('/api/auth/logout');
+      const res = await agent.get('/api/auth/user');
+      expect(res.status).toBe(401);
     });
   });
-});
+});
