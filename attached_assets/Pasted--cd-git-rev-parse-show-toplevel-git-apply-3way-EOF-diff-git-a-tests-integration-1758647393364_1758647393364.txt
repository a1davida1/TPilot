 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/integration/content-generation.test.ts b/tests/integration/content-generation.test.ts
index 420522402485562f16cbc205e235ffc78ec7f0da..90af4f802c55386f7ddaab35f0f5e0f27045781d 100644
--- a/tests/integration/content-generation.test.ts
+++ b/tests/integration/content-generation.test.ts
@@ -1,709 +1,298 @@
-import { eq } from "drizzle-orm";
 import request from 'supertest';
-import { describe, test, beforeAll, afterAll, beforeEach, afterEach, expect, vi } from 'vitest';
-import express from 'express';
-import { db } from '../../server/db';
-import { users, contentGenerations } from '../../shared/schema';
-import jwt from 'jsonwebtoken';
-import { safeLog } from '../../server/lib/logger-utils';
-
-// Mock AI providers - declare these at the top level
-const mockOpenAI = vi.fn();
-const mockGemini = vi.fn();
-const mockClaude = vi.fn();
-
-// Mock the AI provider modules before any imports
-vi.mock('openai', () => {
-  const mockOpenAILocal = mockOpenAI;
-  return {
-    default: class MockOpenAI {
-      constructor(config: any) {
-        // Do nothing
-      }
-      chat = {
-        completions: {
-          create: mockOpenAILocal
-        }
-      }
+import { describe, test, beforeAll, beforeEach, expect, vi } from 'vitest';
+import express, { type Request, type Response, type NextFunction } from 'express';
+
+process.env.NODE_ENV = process.env.NODE_ENV ?? 'test';
+process.env.JWT_SECRET = process.env.JWT_SECRET ?? 'integration-test-secret';
+process.env.GOOGLE_GENAI_API_KEY = process.env.GOOGLE_GENAI_API_KEY ?? 'integration-gemini-key';
+
+interface TestUser {
+  id: number;
+  email: string;
+}
+
+const authState: { user: TestUser | undefined } = {
+  user: { id: 42, email: 'user@example.com' }
+};
+
+const pipelineMock = vi.fn();
+const pipelineTextOnlyMock = vi.fn();
+const pipelineRewriteMock = vi.fn();
+const createGenerationMock = vi.fn();
+
+class MockInvalidImageError extends Error {}
+
+vi.mock('../../server/caption/geminiPipeline.js', () => ({
+  pipeline: pipelineMock,
+  InvalidImageError: MockInvalidImageError
+}));
+
+vi.mock('../../server/caption/textOnlyPipeline.js', () => ({
+  pipelineTextOnly: pipelineTextOnlyMock
+}));
+
+vi.mock('../../server/caption/rewritePipeline.js', () => ({
+  pipelineRewrite: pipelineRewriteMock
+}));
+
+vi.mock('../../server/storage.js', () => ({
+  storage: {
+    createGeneration: createGenerationMock
+  }
+}));
+
+vi.mock('../../server/middleware/auth.js', () => {
+  type AuthenticatedRequest = Request & { user?: TestUser };
+  const authenticateToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
+    const authHeader = req.headers.authorization;
+    if (!authHeader) {
+      res.status(401).json({ message: 'Access token required' });
+      return;
     }
-  };
-});
 
-vi.mock('@google/genai', () => {
-  const mockGeminiLocal = mockGemini;
-  return {
-    GoogleGenAI: class MockGemini {
-      constructor(config: any) {
-        // Do nothing
-      }
-      generate = mockGeminiLocal
+    const token = authHeader.replace('Bearer ', '').trim();
+    if (token !== 'valid-token') {
+      res.status(401).json({ message: 'Access token required' });
+      return;
     }
-  };
-});
 
-vi.mock('@anthropic-ai/sdk', () => {
-  const mockClaudeLocal = mockClaude;
-  return {
-    default: class MockClaude {
-      constructor(config: any) {
-        // Do nothing
-      }
-      messages = {
-        create: mockClaudeLocal
-      }
+    if (authState.user) {
+      req.user = authState.user;
     }
+
+    next();
   };
+
+  return { authenticateToken };
 });
 
-// Set environment variables BEFORE importing so providers are available
-process.env.OPENAI_API_KEY = 'test-key';
-process.env.GOOGLE_GENAI_API_KEY = 'test-key';
-process.env.ANTHROPIC_API_KEY = 'test-key';
+type MockCaption = {
+  caption: string;
+  alt?: string;
+  hashtags?: string[];
+  cta?: string;
+  mood?: string;
+  style?: string;
+};
+
+type MockPipelineResult = {
+  provider: string;
+  final?: MockCaption;
+  ranked?: Record<string, unknown>;
+  variants?: Array<Record<string, unknown>>;
+  facts?: Record<string, unknown>;
+};
+
+const createPipelineResult = (overrides?: Partial<MockPipelineResult>): MockPipelineResult => {
+  const baseFinal: MockCaption = {
+    caption: 'Generated caption from pipeline',
+    alt: 'Alt text for generated caption',
+    hashtags: ['#spark', '#glow'],
+    cta: 'Tap to explore more',
+    mood: 'confident',
+    style: 'playful'
+  };
 
-// Import these after mocking and setting env vars
-const { generateWithMultiProvider } = await import('../../server/services/multi-ai-provider');
-const { policyLint } = await import('../../server/lib/policy-linter');
+  const result: MockPipelineResult = {
+    provider: 'gemini',
+    final: { ...baseFinal },
+    ranked: { final: { ...baseFinal }, reason: 'Top pick' },
+    variants: [
+      { caption: 'Generated caption from pipeline', hashtags: ['#spark'] },
+      { caption: 'Second angle caption', hashtags: ['#glow'] }
+    ],
+    facts: { palette: ['sunset'], subject: 'creator' }
+  };
 
-describe('Content Generation Integration Tests', () => {
-  let testUser: { id: number; username: string; email: string | null };
-  let authToken: string;
-  let app: express.Application;
+  if (overrides) {
+    if (Object.prototype.hasOwnProperty.call(overrides, 'final')) {
+      result.final = overrides.final
+        ? { ...baseFinal, ...overrides.final }
+        : undefined;
+    }
+    if (overrides.provider) {
+      result.provider = overrides.provider;
+    }
+    if (overrides.ranked) {
+      result.ranked = overrides.ranked;
+    }
+    if (overrides.variants) {
+      result.variants = overrides.variants;
+    }
+    if (overrides.facts) {
+      result.facts = overrides.facts;
+    }
+  }
 
-  // Simple cache implementation for testing
-  const cache = new Map<string, any>();
+  return result;
+};
 
-  beforeAll(async () => {
-    // Create test app
-    app = express();
-    app.use(express.json());
+describe('Caption generation route contract', () => {
+  let app: express.Application;
+  let InvalidImageErrorCtor: new (message: string) => Error;
 
-    // Setup basic routes for testing (minimal setup)
-    app.post('/api/caption/generate', async (req, res) => {
-      try {
-        // Extract auth token
-        const authHeader = req.headers.authorization;
-        if (!authHeader) {
-          return res.status(401).json({ message: 'Authorization required' });
-        }
-
-        const token = authHeader.replace('Bearer ', '');
-        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'test-secret') as { userId: number };
-
-        // Get user for tier checking
-        const [user] = await db.select().from(users).where(eq(users.id, decoded.userId));
-        if (!user) {
-          return res.status(404).json({ message: 'User not found' });
-        }
-
-        // Check rate limits for free tier
-        if (user.tier === 'free') {
-          // For testing, always return rate limit error for free users
-          return res.status(429).json({ 
-            message: 'Daily rate limit exceeded',
-            upgradePrompt: 'Upgrade to Pro for unlimited generations'
-          });
-        }
-
-        // Check for explicit content policy violations
-        if (req.body.customPrompt?.includes('policy violations')) {
-          return res.status(400).json({
-            message: 'Content violates content policy',
-            flags: ['explicit_content']
-          });
-        }
-
-        // Check cache for identical requests
-        const cacheKey = JSON.stringify({
-          platform: req.body.platform,
-          customPrompt: req.body.customPrompt,
-          subreddit: req.body.subreddit,
-          userId: user.id
-        });
-
-        if (cache.has(cacheKey)) {
-          const cachedResult = cache.get(cacheKey);
-          return res.json({ ...cachedResult, cached: true });
-        }
-
-        // Use real provider orchestrator
-        const result = await generateWithMultiProvider({
-          user: { id: user.id, email: user.email || undefined, tier: user.tier },
-          platform: req.body.platform,
-          imageDescription: req.body.imageDescription,
-          customPrompt: req.body.customPrompt,
-          subreddit: req.body.subreddit,
-          allowsPromotion: req.body.allowsPromotion || 'no',
-          baseImageUrl: req.body.imageUrl
-        });
-
-        // Save to database
-        const [generation] = await db.insert(contentGenerations).values({
-          userId: user.id,
-          platform: req.body.platform || 'reddit',
-          style: 'default',
-          theme: 'default',
-          content: result.content,
-          titles: result.titles,
-          photoInstructions: result.photoInstructions,
-          prompt: req.body.customPrompt || '',
-          subreddit: req.body.subreddit || null,
-          allowsPromotion: req.body.allowsPromotion === 'yes',
-          generationType: 'ai'
-        }).returning();
-
-        // Handle special cases for testing
-        const response: any = {
-          ...result,
-          platform: req.body.platform || result.platform,
-          imageAnalyzed: !!req.body.imageDescription
-        };
-
-        // Add fallback indicators for testing
-        if (req.body.templateId === 'missing_template') {
-          response.fallbackUsed = true;
-        }
-
-        if (req.body.imageUrl?.endsWith('.bmp')) {
-          response.imageError = 'unsupported_format';
-          response.fallbackUsed = true;
-        }
-
-        // Cache the response
-        cache.set(cacheKey, response);
-
-        res.json(response);
-      } catch (error) {
-        const errorMessage = (error as Error).message;
-        safeLog('error', 'Caption generation failed in test', { error: errorMessage });
-
-        // Check if it's a database error
-        if (errorMessage.includes('Failed query') || errorMessage.includes('database')) {
-          res.status(500).json({ 
-            message: 'Database connection failed',
-            fallbackAvailable: true
-          });
-        } else if (errorMessage === 'All AI providers failed') {
-          // All providers failed - return a template response
-          res.status(200).json({
-            titles: ['Template Response 1', 'Template Response 2', 'Template Response 3'],
-            content: 'This is a template fallback response when all AI providers fail.',
-            photoInstructions: {
-              lighting: 'Natural lighting',
-              cameraAngle: 'Eye level',
-              composition: 'Center composition',
-              styling: 'Casual',
-              mood: 'Friendly',
-              technicalSettings: 'Auto'
-            },
-            provider: 'template',
-            platform: req.body.platform || 'reddit',
-            fallbackUsed: true
-          });
-        } else {
-          res.status(500).json({ message: 'Generation failed' });
-        }
-      }
-    });
+  const imageUrl = 'https://cdn.example.com/image.jpg';
 
-    app.get('/api/content/history', async (req, res) => {
-      // Extract auth token
-      const authHeader = req.headers.authorization;
-      if (!authHeader) {
-        return res.status(401).json({ message: 'Authorization required' });
-      }
+  const sendGenerateRequest = (body: Record<string, unknown>, token = 'valid-token') => {
+    const reqBuilder = request(app).post('/api/caption/generate');
+    if (token) {
+      reqBuilder.set('Authorization', `Bearer ${token}`);
+    }
+    return reqBuilder.send(body);
+  };
 
-      const token = authHeader.replace('Bearer ', '');
-      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'test-secret') as { userId: number };
+  beforeAll(async () => {
+    const routeModule = await import('../../server/routes/caption.js');
 
-      const generations = await db.select().from(contentGenerations).where(eq(contentGenerations.userId, decoded.userId));
-      res.json({ generations });
-    });
+    InvalidImageErrorCtor = MockInvalidImageError;
 
-    const unique = Date.now();
-    const [user] = await db
-      .insert(users)
-      .values({
-        username: `testuser_${unique}`,
-        email: `test_${unique}@example.com`,
-        password: 'hashedpassword',
-        tier: 'pro',
-      })
-      .returning();
-
-    testUser = user;
-    authToken = jwt.sign({ userId: user.id }, process.env.JWT_SECRET || 'test-secret');
+    app = express();
+    app.use(express.json());
+    app.use('/api/caption', routeModule.captionRouter);
   });
 
-  afterAll(async () => {
-    if (testUser) {
-      await db.delete(contentGenerations).where(eq(contentGenerations.userId, testUser.id));
-      await db.delete(users).where(eq(users.id, testUser.id));
-    }
-    // Clean up environment variables
-    delete process.env.OPENAI_API_KEY;
-    delete process.env.GOOGLE_GENAI_API_KEY;
-    delete process.env.ANTHROPIC_API_KEY;
+  beforeEach(() => {
+    vi.clearAllMocks();
+    pipelineMock.mockResolvedValue(createPipelineResult());
+    createGenerationMock.mockResolvedValue({ id: 'generation-1' });
+    authState.user = { id: 42, email: 'user@example.com' };
   });
 
-  beforeEach(async () => {
-    // Reset generation history for each test
-    await db.delete(contentGenerations).where(eq(contentGenerations.userId, testUser.id));
+  test('rejects requests without authentication', async () => {
+    const response = await sendGenerateRequest({ imageUrl, platform: 'instagram' }, '');
 
-    // Clear cache
-    cache.clear();
-
-    // Clear AI provider usage tracking
-    vi.clearAllMocks();
+    expect(response.status).toBe(401);
+    expect(response.body).toEqual({ message: 'Access token required' });
+    expect(pipelineMock).not.toHaveBeenCalled();
+    expect(createGenerationMock).not.toHaveBeenCalled();
   });
 
-  afterEach(async () => {
-    // Cleanup test generation records
-    await db.delete(contentGenerations).where(eq(contentGenerations.userId, testUser.id));
+  test('requires imageUrl in the payload', async () => {
+    const response = await sendGenerateRequest({ platform: 'instagram' });
+
+    expect(response.status).toBe(500);
+    expect(typeof response.body.error).toBe('string');
+    expect(pipelineMock).not.toHaveBeenCalled();
+    expect(createGenerationMock).not.toHaveBeenCalled();
   });
 
-  describe('AI Provider Fallback Flow', () => {
-    test('should use primary AI provider when available', async () => {
-      // Mock Gemini API success response
-      mockGemini.mockResolvedValueOnce({
-        text: JSON.stringify({
-          titles: ['Test Title 1', 'Test Title 2', 'Test Title 3'],
-          content: 'This is test content generated by Gemini',
-          photoInstructions: {
-            lighting: 'Natural lighting',
-            cameraAngle: 'Eye level',
-            composition: 'Center frame',
-            styling: 'Casual',
-            mood: 'Confident',
-            technicalSettings: 'Auto'
-          }
-        })
-      });
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Generate content about fitness motivation',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.provider).toBe('gemini-flash');
-      expect(response.body.titles).toHaveLength(3);
-      expect(response.body.content).toBeDefined();
-      expect(mockGemini).toHaveBeenCalledOnce();
-      expect(mockOpenAI).not.toHaveBeenCalled();
-      expect(mockClaude).not.toHaveBeenCalled();
-    });
+  test('invokes the pipeline with default nsfw value when not provided', async () => {
+    await sendGenerateRequest({ imageUrl, platform: 'instagram' });
 
-    test('should fallback to secondary provider on primary failure', async () => {
-      // Mock Gemini API failure, OpenAI success
-      mockGemini.mockRejectedValueOnce(new Error('Gemini API unavailable'));
-      mockClaude.mockRejectedValueOnce(new Error('Claude API unavailable'));
-      mockOpenAI.mockResolvedValueOnce({
-        choices: [{
-          message: {
-            content: JSON.stringify({
-              titles: ['OpenAI Title 1', 'OpenAI Title 2', 'OpenAI Title 3'],
-              content: 'This is content from OpenAI fallback',
-              photoInstructions: {
-                lighting: 'Studio lighting',
-                cameraAngle: 'Overhead',
-                composition: 'Rule of thirds',
-                styling: 'Professional',
-                mood: 'Dynamic',
-                technicalSettings: 'Manual'
-              }
-            })
-          }
-        }]
-      });
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Generate fitness content',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.provider).toBeDefined();
-      expect(response.body.content).toContain('OpenAI');
-      expect(mockGemini).toHaveBeenCalled();
-      expect(mockOpenAI).toHaveBeenCalled();
+    expect(pipelineMock).toHaveBeenCalledTimes(1);
+    expect(pipelineMock).toHaveBeenCalledWith({
+      imageUrl,
+      platform: 'instagram',
+      nsfw: false
     });
+  });
 
-    test('should use template fallback when all AI providers fail', async () => {
-      // Mock all AI provider failures
-      mockGemini.mockRejectedValueOnce(new Error('Gemini unavailable'));
-      mockClaude.mockRejectedValueOnce(new Error('Claude unavailable'));
-      mockOpenAI.mockRejectedValueOnce(new Error('OpenAI unavailable'));
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Generate content',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(['gemini-flash', 'template']).toContain(response.body.provider);
-      expect(response.body.content).toBeDefined();
-      expect(response.body.titles).toHaveLength(3);
-      expect(mockGemini).toHaveBeenCalled();
-      expect(mockClaude).toHaveBeenCalled();
-      expect(mockOpenAI).toHaveBeenCalled();
-    });
+  test('forwards persona options to the pipeline when present', async () => {
+    const personaRequest = {
+      imageUrl,
+      platform: 'instagram',
+      voice: 'bold_voice',
+      style: 'vibrant',
+      mood: 'dramatic',
+      nsfw: true
+    };
+
+    await sendGenerateRequest(personaRequest);
+
+    expect(pipelineMock).toHaveBeenCalledTimes(1);
+    expect(pipelineMock).toHaveBeenCalledWith(personaRequest);
   });
 
-  describe('Content Generation Flow', () => {
-    test('should generate platform-specific content', async () => {
-      mockGemini.mockResolvedValueOnce({
-        text: JSON.stringify({
-          titles: ['Reddit Title for r/fitness', 'Motivation Monday', 'Workout Wednesday'],
-          content: 'Reddit-specific content with proper formatting\n\n**Bold text** and *italic text*',
-          photoInstructions: {
-            lighting: 'Natural gym lighting',
-            cameraAngle: 'Action shot',
-            composition: 'Dynamic pose',
-            styling: 'Workout gear',
-            mood: 'Energetic',
-            technicalSettings: 'Fast shutter'
-          }
-        })
-      });
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          subreddit: 'fitness',
-          customPrompt: 'Workout motivation post',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.content).toContain('Reddit-specific');
-      expect(response.body.content).toMatch(/\*\*.*\*\*/); // Check for Reddit markdown
-      expect(response.body.platform).toBe('reddit');
+  test('returns the pipeline payload and persists the generation', async () => {
+    const pipelineResponse = createPipelineResult({
+      final: {
+        caption: 'Stored caption',
+        hashtags: ['#stored'],
+        alt: 'Stored alt text',
+        mood: 'confident',
+        style: 'studio'
+      }
     });
+    pipelineMock.mockResolvedValueOnce(pipelineResponse);
+
+    const response = await sendGenerateRequest({ imageUrl, platform: 'instagram', style: 'studio' });
+
+    expect(response.status).toBe(200);
+    expect(response.body).toMatchObject(pipelineResponse);
+    expect(createGenerationMock).toHaveBeenCalledTimes(1);
+    expect(createGenerationMock).toHaveBeenCalledWith(expect.objectContaining({
+      userId: 42,
+      platform: 'instagram',
+      style: 'studio',
+      theme: 'image_based',
+      titles: ['Stored caption'],
+      content: 'Stored caption',
+      allowsPromotion: false
+    }));
+  });
 
-    test('should respect user tier limitations', async () => {
-      // Create free tier user
-      const uniqueName = `freeuser_${Date.now()}`;
-      const [freeUser] = await db.insert(users).values({
-        username: uniqueName,
-        email: `${uniqueName}@example.com`,
-        password: 'hashedpassword',
-        tier: 'free'
-      }).returning();
-
-      const freeToken = jwt.sign({ userId: freeUser.id }, process.env.JWT_SECRET || 'test-secret');
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${freeToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Test content',
-          allowsPromotion: 'no'
-        });
-
-      expect([200, 429]).toContain(response.status);
-      expect(response.body.message || "").toContain('rate limit');
-      expect(response.body.upgradePrompt).toBeDefined();
-
-      // Cleanup
-      await db.delete(users).where(eq(users.id, freeUser.id));
+  test('falls back to the voice as style when no explicit style is provided', async () => {
+    const pipelineResponse = createPipelineResult({
+      final: {
+        caption: 'Voice guided caption'
+      }
     });
+    pipelineMock.mockResolvedValueOnce(pipelineResponse);
 
-    test('should save generation history', async () => {
-      mockGemini.mockResolvedValueOnce({
-        text: JSON.stringify({
-          titles: ['History Test Title'],
-          content: 'Content for history tracking',
-          photoInstructions: {
-            lighting: 'Natural',
-            cameraAngle: 'Eye level',
-            composition: 'Center',
-            styling: 'Casual',
-            mood: 'Happy',
-            technicalSettings: 'Auto'
-          }
-        })
-      });
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'History test',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-
-      // Check generation history was saved
-      const historyResponse = await request(app)
-        .get('/api/content/history')
-        .set('Authorization', `Bearer ${authToken}`);
-
-      expect(historyResponse.status).toBe(200);
-      expect(historyResponse.body.generations).toBeDefined();
-      expect(historyResponse.body.generations[0].content).toContain('history tracking');
-      expect(historyResponse.body.generations[0].generationType).toBe('ai');
-    });
+    const response = await sendGenerateRequest({ imageUrl, platform: 'tiktok', voice: 'moody_voice' });
 
-    test('should apply content filtering and safety checks', async () => {
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Explicit adult content request with policy violations',
-          allowsPromotion: 'no'
-        });
-
-      expect([200, 400]).toContain(response.status);
-      expect(response.body.message || "").toContain('content policy');
-      expect(response.body.flags).toContain('explicit_content');
-    });
+    expect(response.status).toBe(200);
+    expect(createGenerationMock).toHaveBeenCalledWith(expect.objectContaining({
+      platform: 'tiktok',
+      style: 'moody_voice'
+    }));
   });
 
-  describe('Template System Integration', () => {
-    test('should apply user personalization to templates', async () => {
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'instagram',
-          customPrompt: 'Wellness content',
-          allowsPromotion: 'yes'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.content).toContain('Wellness');
-    });
+  test('skips persistence when the authenticated user is not attached', async () => {
+    authState.user = undefined;
+    const pipelineResponse = createPipelineResult();
+    pipelineMock.mockResolvedValueOnce(pipelineResponse);
 
-    test('should handle missing template gracefully', async () => {
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'nonexistent_platform',
-          templateId: 'missing_template',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.fallbackUsed).toBe(true);
-      expect(['gemini-flash', 'template']).toContain(response.body.provider);
-    });
+    const response = await sendGenerateRequest({ imageUrl, platform: 'reddit' });
+
+    expect(response.status).toBe(200);
+    expect(response.body).toMatchObject(pipelineResponse);
+    expect(createGenerationMock).not.toHaveBeenCalled();
   });
 
-  describe('Image Analysis Integration', () => {
-    test('should analyze uploaded images for content generation', async () => {
-      mockGemini.mockResolvedValueOnce({
-        text: JSON.stringify({
-          titles: ['Fitness Photo Analysis', 'Workout Motivation', 'Gym Life'],
-          content: 'Great workout session! This photo shows dedication and strength. The lighting captures the intensity of the moment perfectly.',
-          photoInstructions: {
-            lighting: 'Gym fluorescent',
-            cameraAngle: 'Low angle',
-            composition: 'Power pose',
-            styling: 'Athletic wear',
-            mood: 'Intense',
-            technicalSettings: 'High ISO'
-          }
-        })
-      });
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'instagram',
-          imageDescription: 'Person doing deadlifts in gym with focused expression',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.content).toContain('workout');
-      expect(response.body.imageAnalyzed).toBe(true);
+  test('does not fail the response when storage.createGeneration throws', async () => {
+    const pipelineResponse = createPipelineResult({
+      final: {
+        caption: 'Resilient caption'
+      }
     });
+    pipelineMock.mockResolvedValueOnce(pipelineResponse);
+    createGenerationMock.mockRejectedValueOnce(new Error('database offline'));
 
-    test('should handle unsupported image formats', async () => {
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'instagram',
-          imageUrl: 'invalid_image_format.bmp',
-          allowsPromotion: 'no'
-        });
-
-      expect(response.status).toBe(200);
-      expect(response.body.imageError).toBe('unsupported_format');
-      expect(response.body.fallbackUsed).toBe(true);
-    });
+    const response = await sendGenerateRequest({ imageUrl, platform: 'instagram' });
+
+    expect(response.status).toBe(200);
+    expect(response.body).toMatchObject(pipelineResponse);
   });
 
-  describe('Performance and Caching', () => {
-    test('should cache AI responses appropriately', async () => {
-      const mockResponse = {
-        text: JSON.stringify({
-          titles: ['Cached Response Title'],
-          content: 'This response should be cached',
-          photoInstructions: {
-            lighting: 'Natural',
-            cameraAngle: 'Eye level',
-            composition: 'Center',
-            styling: 'Casual',
-            mood: 'Happy',
-            technicalSettings: 'Auto'
-          }
-        })
-      };
-
-      mockGemini.mockResolvedValue(mockResponse);
-
-      const request1 = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Cache test content',
-          allowsPromotion: 'no'
-        });
-
-      const startTime = Date.now();
-      const request2 = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Cache test content',
-          allowsPromotion: 'no'
-        });
-      const endTime = Date.now();
-
-      expect(request1.status).toBe(200);
-      expect(request2.status).toBe(200);
-      expect(request2.body.cached).toBe(true);
-      expect(endTime - startTime).toBeLessThan(100); // Should be faster due to cache
-      expect(mockGemini).toHaveBeenCalledTimes(1); // Only called once due to cache
-    });
+  test('surfaces unsupported image format errors as 422 responses', async () => {
+    const invalidError = new InvalidImageErrorCtor('unsupported content-type: text/plain');
+    pipelineMock.mockRejectedValueOnce(invalidError);
 
-    test('should handle concurrent generation requests', async () => {
-      mockGemini.mockResolvedValue({
-        text: JSON.stringify({
-          titles: ['Concurrent Test'],
-          content: 'Concurrent generation test',
-          photoInstructions: {
-            lighting: 'Natural',
-            cameraAngle: 'Eye level',
-            composition: 'Center',
-            styling: 'Casual',
-            mood: 'Happy',
-            technicalSettings: 'Auto'
-          }
-        })
-      });
-
-      const promises = Array.from({ length: 5 }, (_, i) =>
-        request(app)
-          .post('/api/caption/generate')
-          .set('Authorization', `Bearer ${authToken}`)
-          .send({
-            platform: 'reddit',
-            customPrompt: `Concurrent test ${i}`,
-            allowsPromotion: 'no'
-          })
-      );
-
-      const responses = await Promise.all(promises);
-
-      responses.forEach(response => {
-        expect(response.status).toBe(200);
-        expect(response.body.content).toBeDefined();
-      });
-    });
+    const response = await sendGenerateRequest({ imageUrl, platform: 'instagram' });
+
+    expect(response.status).toBe(422);
+    expect(response.body).toEqual({ error: 'unsupported content-type: text/plain' });
+    expect(createGenerationMock).not.toHaveBeenCalled();
   });
 
-  describe('Error Handling and Recovery', () => {
-    test('should handle database connection failures', async () => {
-      // Mock database connection failure
-      const originalDB = db;
-      (global as { db?: unknown }).db = undefined;
-
-      const response = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Database test',
-          allowsPromotion: 'no'
-        });
-
-      expect([200, 500]).toContain(response.status);
-      expect(response.body.message || "").toContain('database');
-      expect(response.body.fallbackAvailable).toBe(true);
-
-      // Restore database
-      (global as { db?: unknown }).db = originalDB;
-    });
+  test('returns a 500 error for unexpected pipeline failures', async () => {
+    pipelineMock.mockRejectedValueOnce(new Error('Gemini outage'));
 
-    test('should recover from temporary AI provider outages', async () => {
-      // Simulate temporary outage then recovery
-      mockGemini
-        .mockRejectedValueOnce(new Error('Service temporarily unavailable'))
-        .mockResolvedValueOnce({
-          text: JSON.stringify({
-            titles: ['Recovery Test'],
-            content: 'Service recovered successfully',
-            photoInstructions: {
-              lighting: 'Natural',
-              cameraAngle: 'Eye level',
-              composition: 'Center',
-              styling: 'Casual',
-              mood: 'Happy',
-              technicalSettings: 'Auto'
-            }
-          })
-        });
-
-      // First request should fail and use fallback
-      const response1 = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Outage test',
-          allowsPromotion: 'no'
-        });
-
-      // Second request should succeed
-      const response2 = await request(app)
-        .post('/api/caption/generate')
-        .set('Authorization', `Bearer ${authToken}`)
-        .send({
-          platform: 'reddit',
-          customPrompt: 'Recovery test',
-          allowsPromotion: 'no'
-        });
-
-      expect(response1.status).toBe(200);
-      expect(response1.body.provider).toBeDefined();
-      expect(response2.status).toBe(200);
-      expect(response2.body.provider).toBe('gemini-flash');
-      expect(response2.body.content).toContain('recovered');
-    });
+    const response = await sendGenerateRequest({ imageUrl, platform: 'instagram' });
+
+    expect(response.status).toBe(500);
+    expect(response.body).toEqual({ error: 'Gemini outage' });
+    expect(createGenerationMock).not.toHaveBeenCalled();
   });
-});
+});
 
EOF
)