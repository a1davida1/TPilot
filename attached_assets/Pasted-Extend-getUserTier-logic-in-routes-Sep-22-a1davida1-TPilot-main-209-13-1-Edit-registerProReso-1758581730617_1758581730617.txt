Extend getUserTier logic in routes
Sep 22 · a1davida1/TPilot · main
+209-13
1. Edit `registerProResourcesRoutes` in `server/routes.ts` to extend the existing `getUserTier` logic when the request’s session payload lacks `subscriptionTier`, e.g., load the user from `storage.getUserById` as a fallback.
2. Ensure the handler still returns 401 for unauthenticated users, 403 for non-pro tiers, 404 when a perk is missing, and 200 with the generated code otherwise.
3. Update/extend the pro-resources tests to cover the fallback path so regressions are caught in CI.

Summary

    Added a SessionUser type and asynchronous tier resolution helper that normalizes subscription tiers and falls back to persisted storage when session data omits subscriptionTier, ensuring pro-resource routes gate access consistently.

Hardened the pro-resources integration suite by priming required environment secrets, ensuring JSON content-type headers, and adding new cases that cover storage-driven tier fallback behaviour.

Testing

    ⚠️ npm run lint (fails because the repository has numerous pre-existing lint violations outside the touched files)

⚠️ npm test (fails due to many unrelated legacy test failures in the suite)

✅ npx vitest run tests/integration/pro-resources.test.ts


server/routes.ts
+56-12
@@ -24,166 +24,210 @@ import { registerExpenseRoutes } from "./expense-routes.js";

// Core imports
import { storage } from "./storage.js";
import { setupAuth } from "./auth.js";
import { setupAdminRoutes } from "./admin-routes.js";
import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
import { visitorAnalytics } from "./visitor-analytics.js";
import { makePaxum, makeCoinbase, makeStripe } from "./payments/payment-providers.js";
import { deriveStripeConfig } from "./payments/stripe-config.js";
// Analytics request type
interface AnalyticsRequest extends express.Request {
  sessionID: string;
}

// Import users table for type inference
import { users, type ContentGeneration } from "@shared/schema";

// AuthUser interface for passport serialization
interface AuthUser {
  id: number;
  username?: string;
  isAdmin?: boolean;
}

// Auth request interface that includes user  
type SessionUser = typeof users.$inferSelect & { subscriptionTier?: string | null };

interface AuthenticatedRequest extends express.Request {
  user?: typeof users.$inferSelect;
  user?: SessionUser;
}

// User tier type
type UserTier = 'free' | 'starter' | 'pro' | 'premium';

// ==========================================
// PRO RESOURCES ROUTES
// ==========================================

function registerProResourcesRoutes(app: Express) {
  const resolveTier = (tierValue: string | null | undefined): UserTier | undefined => {
    if (tierValue === 'pro' || tierValue === 'premium' || tierValue === 'starter') {
      return tierValue;
    }
    if (tierValue === 'free') {
      return 'free';
    }
    return undefined;
  };

  // Helper to get user tier
  const getUserTier = (user: any): UserTier => {
    if (!user) return 'free';
    if (user.subscriptionTier === 'pro' || user.subscriptionTier === 'premium') {
      return user.subscriptionTier as UserTier;
  const getUserTier = async (user: SessionUser | undefined): Promise<UserTier> => {
    if (!user?.id) {
      return 'free';
    }

    if (user.subscriptionTier !== undefined && user.subscriptionTier !== null) {
      return resolveTier(user.subscriptionTier) ?? 'free';
    }

    const tierFromUser = resolveTier(user.tier);
    if (tierFromUser) {
      return tierFromUser;
    }

    try {
      const persistedUser = await storage.getUserById(user.id);
      if (persistedUser) {
        const persistedTier = resolveTier(
          (persistedUser as SessionUser).subscriptionTier ?? persistedUser.tier
        );
        if (persistedTier) {
          return persistedTier;
        }
      }
    } catch (storageError) {
      logger.warn('Failed to resolve user tier from storage', {
        userId: user.id,
        error: storageError instanceof Error ? storageError.message : String(storageError)
      });
    }

    return 'free';
  };

  // GET /api/pro-resources - List all perks for authenticated users
  app.get('/api/pro-resources', authenticateToken, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(403).json({ 
          perks: [], 
          accessGranted: false,
          message: "Authentication required for pro resources" 
        });
      }

      const userTier = getUserTier(req.user);
      
      const userTier = await getUserTier(req.user);

      // Only pro/premium users get access
      if (userTier === 'free' || userTier === 'starter') {
        return res.status(403).json({
          perks: [],
          accessGranted: false,
          message: "Pro subscription required to access these resources"
        });
      }

      const availablePerks = getAvailablePerks(userTier === 'premium' ? 'pro' : userTier as 'free' | 'starter' | 'pro');
      const availablePerks = userTier === 'premium'
        ? getAvailablePerks('pro')
        : getAvailablePerks(userTier);
      
      res.json({
        perks: availablePerks,
        accessGranted: true
      });

    } catch (error) {
      logger.error("Pro resources error:", error);
      res.status(500).json({ 
        perks: [], 
        accessGranted: false,
        message: "Failed to load pro resources" 
      });
    }
  });

  // GET /api/pro-resources/:id/signup-instructions - Get detailed signup instructions
  app.get('/api/pro-resources/:id/signup-instructions', authenticateToken, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const userTier = getUserTier(req.user);
      const userTier = await getUserTier(req.user);
      if (userTier === 'free' || userTier === 'starter') {
        return res.status(403).json({ message: "Pro subscription required" });
      }

      const perkId = req.params.id;
      if (!perkId) {
        return res.status(400).json({ message: "Perk ID required" });
      }

      // Verify the perk exists and user has access
      const availablePerks = getAvailablePerks(userTier === 'premium' ? 'pro' : userTier as 'free' | 'starter' | 'pro');
      const availablePerks = userTier === 'premium'
        ? getAvailablePerks('pro')
        : getAvailablePerks(userTier);
      const perk = availablePerks.find(p => p.id === perkId);
      
      if (!perk) {
        return res.status(404).json({ message: "Perk not found or not accessible" });
      }

      const instructions = getSignupInstructions(perkId);
      
      res.json({
        instructions
      });

    } catch (error) {
      logger.error("Signup instructions error:", error);
      res.status(500).json({ message: "Failed to load signup instructions" });
    }
  });

  // POST /api/pro-resources/:id/referral-code - Generate referral code
  app.post('/api/pro-resources/:id/referral-code', authenticateToken, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const userTier = getUserTier(req.user);
      const userTier = await getUserTier(req.user);
      if (userTier === 'free' || userTier === 'starter') {
        return res.status(403).json({ message: "Pro subscription required" });
      }

      const perkId = req.params.id;
      if (!perkId) {
        return res.status(400).json({ message: "Perk ID required" });
      }

      // Verify the perk exists and user has access
      const availablePerks = getAvailablePerks(userTier === 'premium' ? 'pro' : userTier as 'free' | 'starter' | 'pro');
      const availablePerks = userTier === 'premium'
        ? getAvailablePerks('pro')
        : getAvailablePerks(userTier);
      const perk = availablePerks.find(p => p.id === perkId);
      
      if (!perk) {
        return res.status(404).json({ message: "Perk not found or not accessible" });
      }

      const referralCode = generateReferralCode(req.user.id, perkId);
      
      res.json({
        referralCode
      });

    } catch (error) {
      logger.error("Referral code generation error:", error);
      res.status(500).json({ message: "Failed to generate referral code" });
    }
  });
}

// Session interface with Reddit OAuth properties
interface RedditSessionData {
  redditOAuthState?: string;
  redditConnected?: boolean;
}

tests/integration/pro-resources.test.ts
+153-1
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll, vi } from 'vitest';
import request from 'supertest';
import express from 'express';
import type { Express } from 'express';
import { storage } from '../../server/storage.js';

// Mock auth module to simulate different authentication states
const mockUsers = new Map<number, any>();
let currentMockUser: any = null;

// Mock the auth middleware to simulate real behavior
const mockAuthMiddleware = vi.fn((req: any, res: any, next: any) => {
  if (currentMockUser) {
    req.user = currentMockUser;
  }
  next();
});

// Mock the pro-perks module
vi.mock('../../server/pro-perks.js', () => ({
  getAvailablePerks: vi.fn(() => [
    {
      id: 'onlyfans-referral',
      name: 'OnlyFans Creator Referral',
      category: 'affiliate',
      tier: 'pro',
      description: 'Earn 5% lifetime commission by referring new creators',
      commissionRate: '5% lifetime',
      signupProcess: 'Auto-approval with tracking link',
      estimatedEarnings: '$100-500/month potential',
      status: 'available',
      officialLink: 'https://onlyfans.com/refer',
      features: ['Lifetime 5% commission', 'Real-time tracking', 'Monthly payments']
    }
  ]),
  generateReferralCode: vi.fn((userId: number, perkId: string) => `TP${userId}${perkId.slice(-4).toUpperCase()}`),
  getSignupInstructions: vi.fn((perkId: string) => ({
    steps: ['Sign up with provided link', 'Complete profile verification', 'Start earning commissions'],
    requirements: ['Active ThottoPilot Pro subscription', 'Verified identity'],
    timeline: 'Instant approval for most creators',
    support: 'Contact support@thottopilot.com for assistance'
  }))
}));

// Mock the authenticateToken middleware
vi.mock('../../server/middleware/auth.js', () => ({
  authenticateToken: mockAuthMiddleware
}));

describe('Pro Resources Integration', () => {
  let app: Express;
  type StoredUser = NonNullable<Awaited<ReturnType<typeof storage.getUserById>>>;

  const originalOpenAiKey = process.env.OPENAI_API_KEY;
  const originalGeminiKey = process.env.GOOGLE_GENAI_API_KEY;
  const originalSessionSecret = process.env.SESSION_SECRET;
  const originalJwtSecret = process.env.JWT_SECRET;
  const originalDatabaseUrl = process.env.DATABASE_URL;

  beforeAll(() => {
    if (!process.env.OPENAI_API_KEY) {
      process.env.OPENAI_API_KEY = 'test-openai-key';
    }
    if (!process.env.GOOGLE_GENAI_API_KEY) {
      process.env.GOOGLE_GENAI_API_KEY = 'test-gemini-key';
    }
    if (!process.env.SESSION_SECRET || process.env.SESSION_SECRET.length < 32) {
      process.env.SESSION_SECRET = 'test-session-secret-key-1234567890abcd';
    }
    if (!process.env.JWT_SECRET || process.env.JWT_SECRET.length < 32) {
      process.env.JWT_SECRET = 'test-jwt-secret-key-1234567890abcd';
    }
    const defaultDatabaseUrl = 'postgres://user:pass@localhost:5432/testdb';
    if (!process.env.DATABASE_URL || !URL.canParse(process.env.DATABASE_URL)) {
      process.env.DATABASE_URL = defaultDatabaseUrl;
    }
  });

  afterAll(() => {
    if (originalOpenAiKey === undefined) {
      delete process.env.OPENAI_API_KEY;
    } else {
      process.env.OPENAI_API_KEY = originalOpenAiKey;
    }
    if (originalGeminiKey === undefined) {
      delete process.env.GOOGLE_GENAI_API_KEY;
    } else {
      process.env.GOOGLE_GENAI_API_KEY = originalGeminiKey;
    }
    if (originalSessionSecret === undefined) {
      delete process.env.SESSION_SECRET;
    } else {
      process.env.SESSION_SECRET = originalSessionSecret;
    }
    if (originalJwtSecret === undefined) {
      delete process.env.JWT_SECRET;
    } else {
      process.env.JWT_SECRET = originalJwtSecret;
    }
    if (originalDatabaseUrl === undefined) {
      delete process.env.DATABASE_URL;
    } else {
      process.env.DATABASE_URL = originalDatabaseUrl;
    }
  });

  const createStoredUser = (tierValue: 'free' | 'starter' | 'pro' | 'premium', overrides?: Partial<StoredUser>): StoredUser => {
    const now = new Date();
    return {
      id: overrides?.id ?? 42,
      username: overrides?.username ?? 'persisted-user',
      password: overrides?.password ?? 'hashed-password',
      email: overrides?.email ?? null,
      role: overrides?.role ?? 'user',
      isAdmin: overrides?.isAdmin ?? false,
      emailVerified: overrides?.emailVerified ?? false,
      firstName: overrides?.firstName ?? null,
      lastName: overrides?.lastName ?? null,
      tier: overrides?.tier ?? tierValue,
      mustChangePassword: overrides?.mustChangePassword ?? false,
      subscriptionStatus: overrides?.subscriptionStatus ?? 'active',
      trialEndsAt: overrides?.trialEndsAt ?? null,
      provider: overrides?.provider ?? null,
      providerId: overrides?.providerId ?? null,
      avatar: overrides?.avatar ?? null,
      bio: overrides?.bio ?? null,
      referralCodeId: overrides?.referralCodeId ?? null,
      referredBy: overrides?.referredBy ?? null,
      redditUsername: overrides?.redditUsername ?? null,
      redditAccessToken: overrides?.redditAccessToken ?? null,
      redditRefreshToken: overrides?.redditRefreshToken ?? null,
      redditId: overrides?.redditId ?? null,
      stripeCustomerId: overrides?.stripeCustomerId ?? null,
      stripeSubscriptionId: overrides?.stripeSubscriptionId ?? null,
      bannedAt: overrides?.bannedAt ?? null,
      suspendedUntil: overrides?.suspendedUntil ?? null,
      banReason: overrides?.banReason ?? null,
      suspensionReason: overrides?.suspensionReason ?? null,
      createdAt: overrides?.createdAt ?? now,
      updatedAt: overrides?.updatedAt ?? now,
      lastLogin: overrides?.lastLogin ?? null,
      passwordResetAt: overrides?.passwordResetAt ?? null,
      deletedAt: overrides?.deletedAt ?? null,
      isDeleted: overrides?.isDeleted ?? false,
    } satisfies StoredUser;
  };

  beforeEach(async () => {
    // Clear mocks and reset state
    vi.clearAllMocks();
    mockUsers.clear();
    currentMockUser = null;
    
    // Create Express app with real pro-resources routes
    app = express();
    app.use(express.json());
    
    // Import the real routes function
    const { registerRoutes } = await import('../../server/routes.js');
    
    // Call registerRoutes to mount all routes including pro-resources
    await registerRoutes(app, '/api');
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('GET /api/pro-resources', () => {
    it('should return 403 for unauthenticated requests', async () => {
      // No user set, should fail authentication
@@ -183,127 +279,183 @@ describe('Pro Resources Integration', () => {

      const response = await request(app)
        .get('/api/pro-resources/onlyfans-referral/signup-instructions')
        .set('Authorization', 'Bearer mock-pro-token')
        .expect(200);

      expect(response.body).toMatchObject({
        instructions: {
          steps: expect.any(Array),
          requirements: expect.any(Array),
          timeline: expect.any(String),
          support: expect.any(String)
        }
      });

      expect(response.body.instructions.steps.length).toBeGreaterThan(0);
    });
  });

  describe('POST /api/pro-resources/:id/referral-code', () => {
    it('should return 401 for unauthenticated requests', async () => {
      currentMockUser = null;
      
      await request(app)
        .post('/api/pro-resources/test-perk-id/referral-code')
        .set('Content-Type', 'application/json')
        .expect(401);
    });

    it('should return 403 for free tier users', async () => {
      currentMockUser = {
        id: 1,
        subscriptionTier: 'free',
        username: 'testuser'
      };

      await request(app)
        .post('/api/pro-resources/test-perk-id/referral-code')
        .set('Authorization', 'Bearer mock-free-token')
        .set('Content-Type', 'application/json')
        .expect(403);
    });

    it('should return 404 for non-existent perk', async () => {
      currentMockUser = {
        id: 2,
        subscriptionTier: 'pro',
        username: 'prouser'
      };

      await request(app)
        .post('/api/pro-resources/non-existent-perk/referral-code')
        .set('Authorization', 'Bearer mock-pro-token')
        .set('Content-Type', 'application/json')
        .expect(404);
    });

    it('should generate referral code for valid perk and pro user', async () => {
      currentMockUser = {
        id: 2,
        subscriptionTier: 'pro',
        username: 'prouser'
      };

      const response = await request(app)
        .post('/api/pro-resources/onlyfans-referral/referral-code')
        .set('Authorization', 'Bearer mock-pro-token')
        .set('Content-Type', 'application/json')
        .expect(200);

      expect(response.body).toMatchObject({
        referralCode: expect.any(String)
      });

      // Verify referral code format matches our mock implementation
      expect(response.body.referralCode).toMatch(/^TP2/);
    });

    it('should generate unique referral codes for different users', async () => {
      // First user
      currentMockUser = {
        id: 2,
        subscriptionTier: 'pro',
        username: 'prouser1'
      };

      const response1 = await request(app)
        .post('/api/pro-resources/onlyfans-referral/referral-code')
        .set('Authorization', 'Bearer mock-pro-token1')
        .set('Content-Type', 'application/json')
        .expect(200);

      // Second user
      currentMockUser = {
        id: 3,
        subscriptionTier: 'pro',
        username: 'prouser2'
      };

      const response2 = await request(app)
        .post('/api/pro-resources/onlyfans-referral/referral-code')
        .set('Authorization', 'Bearer mock-pro-token2')
        .set('Content-Type', 'application/json')
        .expect(200);

      // Referral codes should be different for different users
      expect(response1.body.referralCode).not.toBe(response2.body.referralCode);
    });

    it('should fall back to persisted tier when session lacks subscription data', async () => {
      const storedUser = createStoredUser('pro', { id: 55, username: 'fallback-pro' });
      const getUserByIdSpy = vi.spyOn(storage, 'getUserById').mockResolvedValue(storedUser);

      currentMockUser = {
        id: storedUser.id,
        username: storedUser.username
      };

      try {
        const response = await request(app)
          .post('/api/pro-resources/onlyfans-referral/referral-code')
          .set('Authorization', 'Bearer fallback-pro-token')
          .set('Content-Type', 'application/json')
          .expect(200);

        expect(response.body).toMatchObject({
          referralCode: expect.stringMatching(/^TP55/)
        });
        expect(getUserByIdSpy).toHaveBeenCalledWith(storedUser.id);
      } finally {
        getUserByIdSpy.mockRestore();
      }
    });

    it('should return 403 when persisted tier indicates non-pro access during fallback', async () => {
      const storedUser = createStoredUser('free', { id: 56, username: 'fallback-free' });
      const getUserByIdSpy = vi.spyOn(storage, 'getUserById').mockResolvedValue(storedUser);

      currentMockUser = {
        id: storedUser.id,
        username: storedUser.username
      };

      try {
        const response = await request(app)
          .post('/api/pro-resources/onlyfans-referral/referral-code')
          .set('Authorization', 'Bearer fallback-free-token')
          .set('Content-Type', 'application/json')
          .expect(403);

        expect(response.body).toMatchObject({
          message: expect.stringContaining('Pro subscription required')
        });
        expect(getUserByIdSpy).toHaveBeenCalledWith(storedUser.id);
      } finally {
        getUserByIdSpy.mockRestore();
      }
    });
  });

  describe('Data Validation', () => {
    it('should return perks with correct structure and required fields', async () => {
      currentMockUser = {
        id: 2,
        subscriptionTier: 'pro',
        username: 'prouser'
      };

      const response = await request(app)
        .get('/api/pro-resources')
        .set('Authorization', 'Bearer mock-pro-token')
        .expect(200);

      // Verify each perk has all required fields
      response.body.perks.forEach((perk: any) => {
        expect(perk).toMatchObject({
          id: expect.any(String),
          name: expect.any(String),
          category: expect.stringMatching(/^(affiliate|integration|tools|community|pro)$/),
          tier: expect.stringMatching(/^(starter|pro)$/),
          description: expect.any(String),
          signupProcess: expect.any(String),
          estimatedEarnings: expect.any(String),
