
 RUN  v3.2.4 /home/runner/workspace

stdout | tests/unit/policy-linter.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

stdout | tests/integration/content-generation.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stdout | tests/unit/expenses/expense-operations.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  enable debug logging with { debug: true }

 ❯ tests/unit/policy-linter.test.ts (9 tests | 7 failed) 746ms
   × Policy Linter > Blocked Content > blocks content with banned words 69ms
     → expected [ 'Contains banned terms', …(1) ] to include StringContaining "Contains banned terms"
   × Policy Linter > Blocked Content > blocks content matching title regex patterns 51ms
     → expected [ Array(2) ] to include StringContaining{…}
   × Policy Linter > Blocked Content > blocks content with prohibited links 46ms
     → expected [ …(2) ] to include StringContaining{…}
   × Policy Linter > Blocked Content > blocks content exceeding length limits 38ms
     → expected [ 'Missing required tags', 'too long' ] to include StringContaining "too long"
   × Policy Linter > Warning Content > warns on missing required tags 42ms
     → expected [ 'Missing required tags' ] to include StringContaining "Missing required tags"
   × Policy Linter > Warning Content > warns on short content 73ms
     → expected [ Array(2) ] to include StringContaining "too short"
   ✓ Policy Linter > Clean Content > approves clean content with required tags 41ms
   × Policy Linter > Clean Content > handles unknown subreddits with default rules 54ms
     → expected 'block' to be 'ok' // Object.is equality
   ✓ Policy Linter > Error Handling > gracefully handles database errors 48ms
stdout | tests/unit/expenses/expense-operations.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

stdout | tests/unit/expenses/expense-categories.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should handle expense creation error
Error creating expense: { error: "Cannot read properties of undefined (reading 'returning')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should create expense with optional fields
Error creating expense: { error: "Cannot read properties of undefined (reading 'returning')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > deleteExpense > should handle deletion error
Error deleting expense: { error: 'Expense not found' }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should calculate expense totals correctly
Error getting expense totals: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle empty expense list
Error getting expense totals: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should filter by tax year when specified
Error getting expense totals: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle partial deduction percentages
Error getting expense totals: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle database error in totals calculation
Error getting expense totals: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense with receipt information
Error updating expense: { error: "Cannot read properties of undefined (reading 'where')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense amount
Error updating expense: { error: "Cannot read properties of undefined (reading 'where')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should handle update error
Error updating expense: { error: "Cannot read properties of undefined (reading 'where')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch user expenses with category information
Error getting user expenses: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

stderr | tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch expenses without tax year filter
Error getting user expenses: { error: "Cannot read properties of undefined (reading 'leftJoin')" }

 ❯ tests/unit/expenses/expense-operations.test.ts (16 tests | 11 failed) 92ms
   ✓ Expense Operations Unit Tests > createExpense > should create expense with valid data 23ms
   × Expense Operations Unit Tests > createExpense > should handle expense creation error 22ms
     → expected [Function] to throw error including 'Database error' but got 'Cannot read properties of undefined (…'
   × Expense Operations Unit Tests > createExpense > should create expense with optional fields 17ms
     → Cannot read properties of undefined (reading 'returning')
   ✓ Expense Operations Unit Tests > deleteExpense > should delete expense with valid ID and userId 1ms
   ✓ Expense Operations Unit Tests > deleteExpense > should handle deletion error 4ms
   ✓ Expense Operations Unit Tests > deleteExpense > should only delete expense owned by user 1ms
   × Expense Operations Unit Tests > getExpenseTotals > should calculate expense totals correctly 7ms
     → expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 85000, …(2) }
   ✓ Expense Operations Unit Tests > getExpenseTotals > should handle empty expense list 1ms
   × Expense Operations Unit Tests > getExpenseTotals > should filter by tax year when specified 2ms
     → expected +0 to be 5000 // Object.is equality
   × Expense Operations Unit Tests > getExpenseTotals > should handle partial deduction percentages 2ms
     → expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 50000, …(2) }
   × Expense Operations Unit Tests > getExpenseTotals > should handle database error in totals calculation 2ms
     → promise resolved "{ total: +0, deductible: +0, …(1) }" instead of rejecting
   × Expense Operations Unit Tests > updateExpense > should update expense with receipt information 1ms
     → Cannot read properties of undefined (reading 'where')
   × Expense Operations Unit Tests > updateExpense > should update expense amount 1ms
     → Cannot read properties of undefined (reading 'where')
   × Expense Operations Unit Tests > updateExpense > should handle update error 2ms
     → expected [Function] to throw error including 'Update failed' but got 'Cannot read properties of undefined (…'
   × Expense Operations Unit Tests > getUserExpenses > should fetch user expenses with category information 3ms
     → expected "spy" to be called at least once
   × Expense Operations Unit Tests > getUserExpenses > should fetch expenses without tax year filter 2ms
     → expected [] to deeply equal [ …(2) ]
stdout | tests/integration/content-generation.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use primary AI provider when available
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:29.629Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use primary AI provider when available
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:29.632Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use primary AI provider when available
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:29.633Z"}

stdout | tests/integration/upload.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  specify custom .env file path with { path: '/custom/path/.env' }

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:29.863Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure
warn: Gemini generation failed {"error":"Gemini API unavailable","timestamp":"2025-09-17T16:30:29.864Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:29.864Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:29.865Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure
warn: AI provider failed, trying next {"error":"Claude API unavailable","provider":"claude-haiku","timestamp":"2025-09-17T16:30:29.875Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:29.875Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure
info: AI generation successful {"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:29.890Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.116Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
warn: Gemini generation failed {"error":"Gemini unavailable","timestamp":"2025-09-17T16:30:30.117Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.117Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:30.118Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
warn: AI provider failed, trying next {"error":"Claude unavailable","provider":"claude-haiku","timestamp":"2025-09-17T16:30:30.118Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:30.118Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
warn: AI provider failed, trying next {"error":"OpenAI unavailable","provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:30.118Z"}
error: All AI providers failed - no fallback available {"timestamp":"2025-09-17T16:30:30.118Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail
error: Caption generation failed in test {"error":"All AI providers failed","timestamp":"2025-09-17T16:30:30.119Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should generate platform-specific content
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.296Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should generate platform-specific content
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:30.298Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should generate platform-specific content
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.299Z"}

stdout | tests/unit/expenses/expense-categories.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: 🔐 encrypt with Dotenvx: https://dotenvx.com

 ❯ tests/unit/expenses/expense-categories.test.ts (12 tests | 12 failed) 81ms
   × Expense Categories Unit Tests > createExpenseCategory > should create expense category with valid data 44ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > createExpenseCategory > should handle category creation error 1ms
     → Cannot read properties of undefined (reading 'mockRejectedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategories > should fetch all active expense categories 5ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategories > should handle empty categories list 1ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategories > should handle database error 8ms
     → Cannot read properties of undefined (reading 'mockRejectedValueOnce')
   × Expense Categories Unit Tests > updateExpenseCategory > should update category successfully 11ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > updateExpenseCategory > should handle update error 1ms
     → Cannot read properties of undefined (reading 'mockRejectedValueOnce')
   × Expense Categories Unit Tests > deleteExpenseCategory > should soft delete category (set isActive to false) 1ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > deleteExpenseCategory > should handle deletion error 7ms
     → Cannot read properties of undefined (reading 'mockRejectedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategory > should fetch single category by ID 1ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategory > should return undefined for non-existent category 1ms
     → Cannot read properties of undefined (reading 'mockResolvedValueOnce')
   × Expense Categories Unit Tests > getExpenseCategory > should handle database error 1ms
     → Cannot read properties of undefined (reading 'mockRejectedValueOnce')
stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should save generation history
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.789Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should save generation history
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:30.790Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Content Generation Flow > should save generation history
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:30.790Z"}

stdout | tests/integration/session.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  suppress all logs with { quiet: true }

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.202Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
warn: Gemini provider returned empty response {"timestamp":"2025-09-17T16:30:31.203Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.203Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.203Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'content')","provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.204Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.204Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'choices')","provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.204Z"}
error: All AI providers failed - no fallback available {"timestamp":"2025-09-17T16:30:31.204Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
error: Caption generation failed in test {"error":"All AI providers failed","timestamp":"2025-09-17T16:30:31.205Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.354Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
warn: Gemini provider returned empty response {"timestamp":"2025-09-17T16:30:31.354Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.354Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.355Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'content')","provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.355Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.355Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'choices')","provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.355Z"}
error: All AI providers failed - no fallback available {"timestamp":"2025-09-17T16:30:31.355Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should handle missing template gracefully
error: Caption generation failed in test {"error":"All AI providers failed","timestamp":"2025-09-17T16:30:31.356Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should analyze uploaded images for content generation
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.479Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should analyze uploaded images for content generation
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:31.480Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should analyze uploaded images for content generation
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.481Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.633Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
warn: Gemini provider returned empty response {"timestamp":"2025-09-17T16:30:31.633Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.634Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.634Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'content')","provider":"claude-haiku","timestamp":"2025-09-17T16:30:31.634Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.635Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'choices')","provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:31.635Z"}
error: All AI providers failed - no fallback available {"timestamp":"2025-09-17T16:30:31.635Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
error: Caption generation failed in test {"error":"All AI providers failed","timestamp":"2025-09-17T16:30:31.636Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should cache AI responses appropriately
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.752Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should cache AI responses appropriately
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:31.752Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should cache AI responses appropriately
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.753Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.980Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:31.981Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:31.981Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.099Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.099Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.100Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.104Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.104Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.105Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.114Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.115Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.115Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.116Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.118Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.118Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should handle database connection failures
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.287Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should handle database connection failures
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.288Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should handle database connection failures
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.288Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.444Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
warn: Gemini generation failed {"error":"Service temporarily unavailable","timestamp":"2025-09-17T16:30:32.445Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
warn: AI provider returned empty result {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.445Z"}
info: AI provider attempt {"inputCost":0.8,"provider":"claude-haiku","timestamp":"2025-09-17T16:30:32.445Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'content')","provider":"claude-haiku","timestamp":"2025-09-17T16:30:32.446Z"}
info: AI provider attempt {"inputCost":5,"provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:32.446Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
warn: AI provider failed, trying next {"error":"Cannot read properties of undefined (reading 'choices')","provider":"openai-gpt4o","timestamp":"2025-09-17T16:30:32.446Z"}
error: All AI providers failed - no fallback available {"timestamp":"2025-09-17T16:30:32.446Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
error: Caption generation failed in test {"error":"All AI providers failed","timestamp":"2025-09-17T16:30:32.447Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
info: AI provider attempt {"inputCost":0.075,"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.492Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
info: Gemini generation completed successfully {"timestamp":"2025-09-17T16:30:32.493Z"}

stdout | tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages
info: AI generation successful {"provider":"gemini-flash","timestamp":"2025-09-17T16:30:32.493Z"}

 ❯ tests/integration/content-generation.test.ts (15 tests | 3 failed) 3478ms
   ✓ Content Generation Integration Tests > AI Provider Fallback Flow > should use primary AI provider when available 253ms
   ✓ Content Generation Integration Tests > AI Provider Fallback Flow > should fallback to secondary provider on primary failure 277ms
   ✓ Content Generation Integration Tests > AI Provider Fallback Flow > should use template fallback when all AI providers fail 152ms
   ✓ Content Generation Integration Tests > Content Generation Flow > should generate platform-specific content 241ms
   ✓ Content Generation Integration Tests > Content Generation Flow > should respect user tier limitations 276ms
   ✓ Content Generation Integration Tests > Content Generation Flow > should save generation history 264ms
   ✓ Content Generation Integration Tests > Content Generation Flow > should apply content filtering and safety checks 178ms
   × Content Generation Integration Tests > Template System Integration > should apply user personalization to templates 139ms
     → expected 'This is a template fallback response …' to contain 'Wellness'
   ✓ Content Generation Integration Tests > Template System Integration > should handle missing template gracefully 132ms
   ✓ Content Generation Integration Tests > Image Analysis Integration > should analyze uploaded images for content generation 160ms
   × Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats 119ms
     → expected undefined to be 'unsupported_format' // Object.is equality
   ✓ Content Generation Integration Tests > Performance and Caching > should cache AI responses appropriately 198ms
   ✓ Content Generation Integration Tests > Performance and Caching > should handle concurrent generation requests  334ms
   × Content Generation Integration Tests > Error Handling and Recovery > should handle database connection failures 158ms
     → expected '' to contain 'database'
   ✓ Content Generation Integration Tests > Error Handling and Recovery > should recover from temporary AI provider outages 216ms
stdout | tests/integration/auth-flow.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 version env with Radar: https://dotenvx.com/radar

 ✓ tests/integration/upload.test.ts (17 tests) 2603ms
 ✓ tests/integration/session.test.ts (5 tests) 2024ms
   ✓ Session Storage Integration > should create and retrieve session data  437ms
   ✓ Session Storage Integration > should persist session across requests  580ms
   ✓ Session Storage Integration > should destroy session correctly  500ms
   ✓ Session Storage Integration > should handle concurrent sessions correctly  496ms
stdout | tests/unit/preview-gate.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent building .env in docker: https://dotenvx.com/prebuild

stdout | tests/unit/auth/login-identifier.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 observe env with Radar: https://dotenvx.com/radar

 ✓ tests/integration/auth-flow.test.ts (13 tests) 1442ms
stdout | tests/unit/auth/login-identifier.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stdout | tests/unit/workers/queue-initialization.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent building .env in docker: https://dotenvx.com/prebuild

stdout | tests/unit/auth/login-identifier.test.ts > Login Identifier and Cookie Auth > Email Login with Cookies > should accept email login and set auth cookie
Using cookie authentication
Using token authentication

stdout | tests/unit/auth/login-identifier.test.ts > Login Identifier and Cookie Auth > Email Login with Cookies > should accept username login and set auth cookie
Using cookie authentication
Using token authentication

 ✓ tests/unit/preview-gate.test.ts (8 tests) 1505ms
 ✓ tests/unit/auth/login-identifier.test.ts (4 tests) 764ms
stdout | tests/auth/signup.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  override existing env vars with { override: true }

stdout | tests/unit/expenses/receipt-upload.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  override existing env vars with { override: true }

stdout | tests/unit/workers/queue-initialization.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply light protection for free tier users
2025-09-17T16:30:36.508Z [info] Applying ImageShield protection (light) to receipt for user 1, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply light protection for free tier users
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply light protection for free tier users
2025-09-17T16:30:36.537Z [info] Protected receipt uploaded: protected_1758126636537-test-receipt.jpg for expense 1

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply watermark for free users
2025-09-17T16:30:36.570Z [info] Applying ImageShield protection (light) to receipt for user 2, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply watermark for free users
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should apply watermark for free users
2025-09-17T16:30:36.572Z [info] Protected receipt uploaded: protected_1758126636572-test-receipt.jpg for expense 2

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should not apply watermark for pro users
2025-09-17T16:30:36.584Z [info] Applying ImageShield protection (light) to receipt for user 3, tier: pro

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should not apply watermark for pro users
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > ImageShield Protection Application > should not apply watermark for pro users
2025-09-17T16:30:36.585Z [info] Protected receipt uploaded: protected_1758126636585-test-receipt.jpg for expense 3

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use S3 when configured
2025-09-17T16:30:36.644Z [info] Applying ImageShield protection (light) to receipt for user 1, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use S3 when configured
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use S3 when configured
2025-09-17T16:30:36.650Z [info] Protected receipt uploaded: protected_test.jpg for expense 1

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use local storage when S3 not configured
2025-09-17T16:30:36.660Z [info] Applying ImageShield protection (light) to receipt for user 1, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use local storage when S3 not configured
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > S3 Upload Integration > should use local storage when S3 not configured
2025-09-17T16:30:36.661Z [info] Protected receipt uploaded: protected_1758126636661-test-receipt.jpg for expense 1

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle storage errors gracefully
2025-09-17T16:30:36.674Z [info] Applying ImageShield protection (light) to receipt for user 1, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle storage errors gracefully
Receipt ImageShield protection failed: Error: Input buffer has corrupt header: pngload_buffer: invalid chunk checksum
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle storage errors gracefully
Error uploading receipt: Error: Database error
    at /home/runner/workspace/tests/unit/expenses/receipt-upload.test.ts:252:51
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:155:11
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:752:26
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1897:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1863:10)
    at runTest (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1574:12)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runSuite (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1729:8)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle ImageShield protection errors
2025-09-17T16:30:36.702Z [info] Applying ImageShield protection (light) to receipt for user 1, tier: free

stderr | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle ImageShield protection errors
Receipt ImageShield protection failed: Error: Input buffer contains unsupported image format
    at Sharp.metadata (/home/runner/workspace/node_modules/sharp/lib/input.js:639:17)
    at applyReceiptImageShieldProtection (/home/runner/workspace/server/expense-routes.ts:89:39)
    at /home/runner/workspace/server/expense-routes.ts:275:37
    at Layer.handle [as handle_request] (/home/runner/workspace/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/runner/workspace/node_modules/express/lib/router/route.js:149:13)
    at done (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:59:7)
    at indicateDone (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:63:68)
    at Multipart.<anonymous> (/home/runner/workspace/node_modules/multer/lib/make-middleware.js:187:7)
    at Multipart.emit (node:events:524:28)
    at emitCloseNT (node:internal/streams/destroy:147:10)

stdout | tests/unit/expenses/receipt-upload.test.ts > Receipt Upload with ImageShield Protection > Error Handling > should handle ImageShield protection errors
2025-09-17T16:30:36.704Z [info] Protected receipt uploaded: protected_1758126636704-test-receipt.jpg for expense 1

 ✓ tests/unit/expenses/receipt-upload.test.ts (10 tests) 269ms
stdout | tests/auth/signup.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: ⚙️  suppress all logs with { quiet: true }

stdout | tests/auth/signup.test.ts > Signup and email verification > verifies email before allowing login
2025-09-17T16:30:37.027Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"11fb38e8...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/auth/signup.test.ts > Signup and email verification > verifies email before allowing login
2025-09-17T16:30:37.033Z [info] ✅ EMAIL VERIFICATION SUCCESSFUL {"user":"alice","email":"al***@example.com","responseMode":"REDIRECT"}

stdout | tests/unit/auth/email-verification.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🛠️  run anywhere with `dotenvx run -- yourcommand`

 ✓ tests/auth/signup.test.ts (1 test) 316ms
   ✓ Signup and email verification > verifies email before allowing login  314ms
stdout | tests/unit/moderation-utils.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  write to custom object with { processEnv: myObject }

 ✓ tests/unit/workers/queue-initialization.test.ts (6 tests) 633ms
   ✓ Worker Queue Initialization > Worker Initialization Logging > should log successful worker initialization  580ms
 ✓ tests/unit/moderation-utils.test.ts (4 tests) 343ms
   ✓ moderation utils > calculates similarity between content and posts  333ms
stdout | tests/integration/billing-flow.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

stdout | tests/unit/auth/email-verification.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject missing token
2025-09-17T16:30:37.979Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"No token","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}
2025-09-17T16:30:37.984Z [warn] ❌ EMAIL VERIFICATION FAILED: No token provided

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject empty token
2025-09-17T16:30:38.005Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"No token","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}
2025-09-17T16:30:38.005Z [warn] ❌ EMAIL VERIFICATION FAILED: No token provided

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject invalid token
2025-09-17T16:30:38.025Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"invalid-...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject invalid token
2025-09-17T16:30:38.026Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"invalid-..."}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject expired token
2025-09-17T16:30:38.035Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"expired-...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject expired token
2025-09-17T16:30:38.036Z [warn] ❌ EMAIL VERIFICATION FAILED: Token expired {"expiredAt":"2025-09-16T15:30:38.030Z","currentTime":"2025-09-17T16:30:38.036Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should accept valid unexpired token
2025-09-17T16:30:38.042Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"valid-to...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should accept valid unexpired token
2025-09-17T16:30:38.049Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.049Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.050Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should mark user as verified after successful token validation
2025-09-17T16:30:38.075Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"verifica...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should mark user as verified after successful token validation
2025-09-17T16:30:38.077Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.077Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.077Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should cleanup verification token after successful verification
2025-09-17T16:30:38.086Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"cleanup-...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should cleanup verification token after successful verification
2025-09-17T16:30:38.088Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.088Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.088Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle malformed tokens gracefully
2025-09-17T16:30:38.115Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"token wi...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle malformed tokens gracefully
2025-09-17T16:30:38.116Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"token wi..."}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle extremely long tokens
2025-09-17T16:30:38.142Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"aaaaaaaa...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle extremely long tokens
2025-09-17T16:30:38.145Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"aaaaaaaa..."}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle SQL injection attempts in token
2025-09-17T16:30:38.157Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"'; DROP ...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle SQL injection attempts in token
2025-09-17T16:30:38.157Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"'; DROP ..."}

stdout | tests/unit/payment-providers.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.227Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"concurre...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.228Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.228Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.229Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.239Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"concurre...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.240Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.240Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.241Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.242Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"concurre...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.243Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.243Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.243Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.244Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"concurre...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.245Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.245Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.245Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.247Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"concurre...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
2025-09-17T16:30:38.247Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.247Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.247Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should reject token that expires exactly now
2025-09-17T16:30:38.259Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"edge-exp...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should reject token that expires exactly now
2025-09-17T16:30:38.259Z [warn] ❌ EMAIL VERIFICATION FAILED: Token expired {"expiredAt":"2025-09-17T16:30:38.255Z","currentTime":"2025-09-17T16:30:38.259Z"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should accept token that expires in 1 minute
2025-09-17T16:30:38.266Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"soon-exp...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should accept token that expires in 1 minute
2025-09-17T16:30:38.267Z [error] ❌ EMAIL VERIFICATION ERROR {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","time":"2025-09-17T16:30:38.267Z"}
at /home/runner/workspace/server/auth.ts:579:28
error: Email verification error: {"error":"__vite_ssr_import_3__.emailService.sendWelcomeEmail is not a function","timestamp":"2025-09-17T16:30:38.267Z"}

 ❯ tests/unit/auth/email-verification.test.ts (13 tests | 13 failed) 321ms
   × Email Verification Unit Tests > Token Validation > should reject missing token 48ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Token Validation > should reject empty token 11ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Token Validation > should reject invalid token 21ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Token Validation > should reject expired token 10ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Token Validation > should accept valid unexpired token 24ms
     → expected 302 to be 200 // Object.is equality
   × Email Verification Unit Tests > User State Updates > should mark user as verified after successful token validation 19ms
     → expected "spy" to be called with arguments: [ 'verification-token-123' ]

Number of calls: 0

   × Email Verification Unit Tests > User State Updates > should cleanup verification token after successful verification 13ms
     → expected "spy" to be called with arguments: [ 'cleanup-test-token' ]

Number of calls: 0

   × Email Verification Unit Tests > Edge Cases > should handle malformed tokens gracefully 27ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Edge Cases > should handle extremely long tokens 31ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Edge Cases > should handle SQL injection attempts in token 8ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests 94ms
     → expected 302 to be 200 // Object.is equality
   × Email Verification Unit Tests > Token Expiration Edge Cases > should reject token that expires exactly now 7ms
     → expected [ 200, 400 ] to include 302
   × Email Verification Unit Tests > Token Expiration Edge Cases > should accept token that expires in 1 minute 7ms
     → expected 302 to be 200 // Object.is equality
stderr | tests/unit/payment-providers.test.ts > Payment Providers > Coinbase Provider > handles API errors properly
Coinbase Commerce checkout creation failed: Error: Failed to create Coinbase Commerce checkout session
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:106:17)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

 ✓ tests/integration/billing-flow.test.ts (13 tests) 256ms
stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Network Errors and API Failures > handles network timeout for Coinbase
Coinbase Commerce checkout creation failed: Error: Network timeout
    at global.fetch (/home/runner/workspace/tests/unit/payment-providers.test.ts:258:17)
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:81:26)
    at /home/runner/workspace/tests/unit/payment-providers.test.ts:262:9
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:752:20

stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Network Errors and API Failures > handles malformed JSON response from Coinbase
Coinbase Commerce checkout creation failed: Error: Unexpected end of JSON input
    at Object.json (/home/runner/workspace/tests/unit/payment-providers.test.ts:278:19)
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:111:37)

stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Network Errors and API Failures > handles missing hosted_url in Coinbase response
Coinbase Commerce checkout creation failed: Error: Invalid response from Coinbase Commerce API
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:115:17)
    at /home/runner/workspace/tests/unit/payment-providers.test.ts:308:9
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:752:20

stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Network Errors and API Failures > handles rate limiting responses
Coinbase Commerce checkout creation failed: Error: Failed to create Coinbase Commerce checkout session
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:106:17)

stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Input Validation > validates required fields for Paxum
Promise returned by `expect(actual).rejects.toThrow()` was not awaited. Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. Please remember to await the assertion.
    at /home/runner/workspace/tests/unit/payment-providers.test.ts:354:49

stderr | tests/unit/payment-providers.test.ts > Payment Providers > Edge Cases and Error Handling > Input Validation > validates required fields for Paxum
Promise returned by `expect(actual).rejects.toThrow()` was not awaited. Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. Please remember to await the assertion.
    at /home/runner/workspace/tests/unit/payment-providers.test.ts:348:49

 ✓ tests/unit/payment-providers.test.ts (27 tests) 164ms
stdout | tests/routes/admin.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 encrypt with Dotenvx: https://dotenvx.com

stdout | tests/unit/auth/email-verification-redirect.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 encrypt with Dotenvx: https://dotenvx.com

 ✓ tests/routes/admin.test.ts (3 tests) 67ms
stdout | tests/routes/health.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

 ✓ tests/routes/health.test.ts (1 test) 58ms
stdout | tests/unit/email-service.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  specify custom .env file path with { path: '/custom/path/.env' }

 ✓ tests/unit/email-service.test.ts (10 tests) 43ms
stdout | tests/unit/caption/nsfw-fallback.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

 ✓ tests/unit/caption/nsfw-fallback.test.ts (1 test) 38ms
stdout | tests/integration/workflow.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

stdout | tests/unit/auth/email-verification-redirect.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: 🔐 encrypt with Dotenvx: https://dotenvx.com

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should return JSON success response on valid token with explicit Accept header
2025-09-17T16:30:39.734Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"valid-to...","origin":"Unknown","responseMode":"JSON","preferredType":"json"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should return JSON success response on valid token with explicit Accept header
2025-09-17T16:30:39.739Z [info] ✅ EMAIL VERIFICATION SUCCESSFUL {"user":"testuser","email":"te***@example.com","responseMode":"JSON"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should redirect to frontend on valid token with browser Accept header
2025-09-17T16:30:39.761Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"valid-to...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should redirect to frontend on valid token with browser Accept header
2025-09-17T16:30:39.763Z [info] ✅ EMAIL VERIFICATION SUCCESSFUL {"user":"browseruser","email":"br***@example.com","responseMode":"REDIRECT"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should return JSON error for invalid token with explicit Accept header
2025-09-17T16:30:39.790Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"invalid-...","origin":"Unknown","responseMode":"JSON","preferredType":"json"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should return JSON error for invalid token with explicit Accept header
2025-09-17T16:30:39.791Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"invalid-..."}

stdout | tests/integration/workflow.test.ts > End-to-End Content Generation Workflow > Image-to-Content Pipeline > should complete full workflow from image to final content
Starting fact extraction for image: data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUSEhIVFRUVGBcWFRUVFRUVFRUVFRcWFhUVF...

stdout | tests/integration/workflow.test.ts > End-to-End Content Generation Workflow > Image-to-Content Pipeline > should complete full workflow from image to final content
Processing data URL with mime type: image/jpeg, data length: 11324
Base64 starts with: /9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUSEhIVFR...
Sending to Gemini for fact extraction...

stdout | tests/integration/workflow.test.ts > End-to-End Content Generation Workflow > Image-to-Content Pipeline > should complete full workflow from image to final content
Fact extraction completed successfully

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should redirect to error page for invalid token with browser Accept header
2025-09-17T16:30:39.818Z [info] 📧 EMAIL VERIFICATION WORKFLOW STARTED {"token":"invalid-...","origin":"Unknown","responseMode":"REDIRECT","preferredType":"html"}

stdout | tests/unit/auth/email-verification-redirect.test.ts > Email Verification Redirect Tests > should redirect to error page for invalid token with browser Accept header
2025-09-17T16:30:39.825Z [warn] ❌ EMAIL VERIFICATION FAILED: Token not found in database {"token":"invalid-..."}

 ✓ tests/unit/auth/email-verification-redirect.test.ts (4 tests) 121ms
 ✓ tests/integration/workflow.test.ts (7 tests) 32ms
stdout | tests/routes/caption-generation.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🛠️  run anywhere with `dotenvx run -- yourcommand`

stdout | tests/routes/caption-generation.test.ts > Caption Generation > Gemini Pipeline > should handle image-based caption generation
Starting fact extraction for image: data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAA...

stdout | tests/routes/caption-generation.test.ts > Caption Generation > Gemini Pipeline > should handle image-based caption generation
Processing data URL with mime type: image/jpeg, data length: 140
Base64 starts with: /9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////w...
Sending to Gemini for fact extraction...

stdout | tests/routes/caption-generation.test.ts > Caption Generation > Gemini Pipeline > should handle image-based caption generation
Fact extraction completed successfully

 ✓ tests/routes/caption-generation.test.ts (4 tests) 28ms
stdout | tests/unit/payment-providers-fixed.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  enable debug logging with { debug: true }

stdout | tests/unit/image-generator/generation-failure-paths.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent building .env in docker: https://dotenvx.com/prebuild

stderr | tests/unit/payment-providers-fixed.test.ts > Payment Providers - Fixed > Coinbase Provider Fixes > handles malformed JSON with specific error
Coinbase Commerce checkout creation failed: Error: Unexpected end of JSON input
    at Object.json (/home/runner/workspace/tests/unit/payment-providers-fixed.test.ts:59:17)
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:111:37)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stderr | tests/unit/payment-providers-fixed.test.ts > Payment Providers - Fixed > Coinbase Provider Fixes > handles missing hosted_url correctly
Coinbase Commerce checkout creation failed: Error: Invalid response from Coinbase Commerce API
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:115:17)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at /home/runner/workspace/tests/unit/payment-providers-fixed.test.ts:91:7
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:752:20

stderr | tests/unit/payment-providers-fixed.test.ts > Payment Providers - Fixed > Coinbase Provider Fixes > validates required fields
Coinbase Commerce checkout creation failed: Error: userId and planId are required
    at Object.createCheckout (/home/runner/workspace/server/payments/payment-providers.ts:75:17)
    at /home/runner/workspace/tests/unit/payment-providers-fixed.test.ts:122:29
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:155:11
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:752:26
    at file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1897:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1863:10)
    at runTest (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1574:12)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runSuite (file:///home/runner/workspace/node_modules/@vitest/runner/dist/chunk-hooks.js:1729:8)

 ✓ tests/unit/payment-providers-fixed.test.ts (8 tests) 25ms
 ✓ tests/unit/image-generator/generation-failure-paths.test.ts (5 tests) 8ms
stdout | tests/unit/caption/suggestive-safety-level.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  write to custom object with { processEnv: myObject }

 ✓ tests/unit/caption/suggestive-safety-level.test.ts (4 tests) 13ms
stdout | tests/theme-system.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

stdout | tests/unit/image-generator/enhanced-ai-service.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🛠️  run anywhere with `dotenvx run -- yourcommand`

 ✓ tests/theme-system.test.ts (19 tests) 19ms
 ✓ tests/unit/image-generator/enhanced-ai-service.test.ts (8 tests) 15ms
stdout | tests/categorizeContent.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  load multiple .env files with { path: ['.env.local', '.env'] }

 ✓ tests/categorizeContent.test.ts (4 tests) 10ms
stdout | tests/unit/image-generator/ai-service.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent building .env in docker: https://dotenvx.com/prebuild

stdout | tests/unit/server/services/multi-ai-provider.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 observe env with Radar: https://dotenvx.com/radar

 ✓ tests/unit/server/services/multi-ai-provider.test.ts (3 tests) 23ms
 ❯ tests/unit/image-generator/ai-service.test.ts (12 tests | 6 failed) 35ms
   × AI Service Unit Tests > Environment Variable Handling > should handle missing OPENAI_API_KEY gracefully 16ms
     → All AI providers failed
   ✓ AI Service Unit Tests > Environment Variable Handling > should handle missing GOOGLE_GENAI_API_KEY gracefully 2ms
   ✓ AI Service Unit Tests > Environment Variable Handling > should handle all API keys missing 2ms
   × AI Service Unit Tests > AI Provider Fallback Logic > should fallback from Gemini to OpenAI on quota error 3ms
     → expected "spy" to be called at least once
   × AI Service Unit Tests > AI Provider Fallback Logic > should fallback through all providers on consecutive failures 2ms
     → expected "spy" to be called at least once
   ✓ AI Service Unit Tests > Error Handling Edge Cases > should handle malformed JSON responses 1ms
   ✓ AI Service Unit Tests > Error Handling Edge Cases > should handle network timeout errors 1ms
   ✓ AI Service Unit Tests > Error Handling Edge Cases > should handle rate limit errors with exponential backoff simulation 0ms
   × AI Service Unit Tests > Cost Optimization > should prioritize cheapest provider (Gemini) when available 2ms
     → All AI providers failed
   ✓ AI Service Unit Tests > Cost Optimization > should track and report estimated costs accurately 1ms
   × AI Service Unit Tests > Platform-Specific Optimizations > should generate Instagram-optimized content 1ms
     → All AI providers failed
   × AI Service Unit Tests > Platform-Specific Optimizations > should generate Reddit-appropriate content without hashtags 1ms
     → All AI providers failed
stdout | tests/integration/reddit/posting-flow.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 version env with Radar: https://dotenvx.com/radar

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a link post successfully
Submitting post to r/test: "Test Link Post"

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a link post successfully
Updated rate limit for user 1 in r/test

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a link post successfully
Reddit submission succeeded: { userId: 1, subreddit: 'test', postId: 'test_link_post_id' }

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a text post successfully
Submitting post to r/test: "Test Text Post"

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a text post successfully
Updated rate limit for user 1 in r/test

stdout | tests/integration/reddit/posting-flow.test.ts > Reddit Integration > should submit a text post successfully
Reddit submission succeeded: { userId: 1, subreddit: 'test', postId: 'test_text_post_id' }

 ✓ tests/integration/reddit/posting-flow.test.ts (3 tests) 13ms
stdout | tests/routes/billing.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 encrypt with Dotenvx: https://dotenvx.com

stdout | tests/lib/storage.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 version env with Radar: https://dotenvx.com/radar

 ✓ tests/routes/billing.test.ts (6 tests) 10ms
stdout | tests/unit/image-generator/ai-failure-scenarios.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: ⚙️  override existing env vars with { override: true }

 ✓ tests/unit/image-generator/ai-failure-scenarios.test.ts (10 tests) 13ms
stdout | tests/lib/storage-quotas.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

 ✓ tests/lib/storage-quotas.test.ts (8 tests) 17ms
stdout | tests/unit/payment-providers-lib.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 observe env with Radar: https://dotenvx.com/radar

 ✓ tests/unit/payment-providers-lib.test.ts (2 tests) 7ms
stdout | tests/lib/storage.test.ts
[dotenv@17.2.2] injecting env (0) from .env -- tip: ⚙️  override existing env vars with { override: true }

 ✓ tests/lib/storage.test.ts (7 tests) 16ms
stdout | tests/unit/payments/stripe-config.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 🔐 prevent committing .env to code: https://dotenvx.com/precommit

 ✓ tests/unit/payments/stripe-config.test.ts (5 tests) 10ms
stdout | moderation/validateContent.test.ts
[dotenv@17.2.2] injecting env (2) from .env.test -- tip: 📡 auto-backup env with Radar: https://dotenvx.com/radar

 ✓ moderation/validateContent.test.ts (5 tests) 7ms

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Tests 52 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  tests/integration/content-generation.test.ts > Content Generation Integration Tests > Template System Integration > should apply user personalization to templates
AssertionError: expected 'This is a template fallback response …' to contain 'Wellness'

Expected: "Wellness"
Received: "This is a template fallback response when all AI providers fail."

 ❯ tests/integration/content-generation.test.ts:492:37
    490| 
    491|       expect(response.status).toBe(200);
    492|       expect(response.body.content).toContain('Wellness');
       |                                     ^
    493|     });
    494| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/52]⎯

 FAIL  tests/integration/content-generation.test.ts > Content Generation Integration Tests > Image Analysis Integration > should handle unsupported image formats
AssertionError: expected undefined to be 'unsupported_format' // Object.is equality

- Expected: 
"unsupported_format"

+ Received: 
undefined

 ❯ tests/integration/content-generation.test.ts:553:40
    551| 
    552|       expect(response.status).toBe(200);
    553|       expect(response.body.imageError).toBe('unsupported_format');
       |                                        ^
    554|       expect(response.body.fallbackUsed).toBe(true);
    555|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[2/52]⎯

 FAIL  tests/integration/content-generation.test.ts > Content Generation Integration Tests > Error Handling and Recovery > should handle database connection failures
AssertionError: expected '' to contain 'database'

- Expected
+ Received

- database

 ❯ tests/integration/content-generation.test.ts:656:43
    654| 
    655|       expect([200, 500]).toContain(response.status);
    656|       expect(response.body.message || "").toContain('database');
       |                                           ^
    657|       expect(response.body.fallbackAvailable).toBe(true);
    658| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[3/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Blocked Content > blocks content with banned words
AssertionError: expected [ 'Contains banned terms', …(1) ] to include StringContaining "Contains banned terms"
 ❯ tests/unit/policy-linter.test.ts:37:31
     35| 
     36|       expect(result.state).toBe('block');
     37|       expect(result.warnings).toContain(expect.stringContaining('Contains banned terms'));
       |                               ^
     38|     });
     39| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[4/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Blocked Content > blocks content matching title regex patterns
AssertionError: expected [ Array(2) ] to include StringContaining{…}
 ❯ tests/unit/policy-linter.test.ts:49:31
     47| 
     48|       expect(result.state).toBe('block');
     49|       expect(result.warnings).toContain(expect.stringContaining('Title violates pattern rules'));
       |                               ^
     50|     });
     51| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[5/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Blocked Content > blocks content with prohibited links
AssertionError: expected [ …(2) ] to include StringContaining{…}
 ❯ tests/unit/policy-linter.test.ts:61:31
     59| 
     60|       expect(result.state).toBe('block');
     61|       expect(result.warnings).toContain(expect.stringContaining('Content violates formatting rules'));
       |                               ^
     62|     });
     63| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[6/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Blocked Content > blocks content exceeding length limits
AssertionError: expected [ 'Missing required tags', 'too long' ] to include StringContaining "too long"
 ❯ tests/unit/policy-linter.test.ts:75:31
     73| 
     74|       expect(result.state).toBe('warn'); // Length limits are warnings, not blocks
     75|       expect(result.warnings).toContain(expect.stringContaining('too long'));
       |                               ^
     76|     });
     77|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[7/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Warning Content > warns on missing required tags
AssertionError: expected [ 'Missing required tags' ] to include StringContaining "Missing required tags"
 ❯ tests/unit/policy-linter.test.ts:89:31
     87| 
     88|       expect(result.state).toBe('warn');
     89|       expect(result.warnings).toContain(expect.stringContaining('Missing required tags'));
       |                               ^
     90|     });
     91| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[8/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Warning Content > warns on short content
AssertionError: expected [ Array(2) ] to include StringContaining "too short"
 ❯ tests/unit/policy-linter.test.ts:101:31
     99| 
    100|       expect(result.state).toBe('warn');
    101|       expect(result.warnings).toContain(expect.stringContaining('too short'));
       |                               ^
    102|     });
    103|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[9/52]⎯

 FAIL  tests/unit/policy-linter.test.ts > Policy Linter > Clean Content > handles unknown subreddits with default rules
AssertionError: expected 'block' to be 'ok' // Object.is equality

Expected: "ok"
Received: "block"

 ❯ tests/unit/policy-linter.test.ts:126:28
    124|       });
    125| 
    126|       expect(result.state).toBe('ok');
       |                            ^
    127|     });
    128|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[10/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject missing token
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:57:26
     55|         .get('/api/auth/verify-email');
     56|       
     57|       expect([200, 400]).toContain(response.status);
       |                          ^
     58|       expect(response.body.message || "").toBe('Token is required');
     59|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[11/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject empty token
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:65:26
     63|         .get('/api/auth/verify-email?token=');
     64|       
     65|       expect([200, 400]).toContain(response.status);
       |                          ^
     66|       expect(response.body.message || "").toBe('Token is required');
     67|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[12/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject invalid token
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:73:26
     71|         .get('/api/auth/verify-email?token=invalid-token-12345');
     72|       
     73|       expect([200, 400]).toContain(response.status);
       |                          ^
     74|       expect(response.body.message || "").toBe('Invalid or expired token');
     75|       expect(mockStorage.getVerificationToken).toHaveBeenCalledWith('invalid-token-12345');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[13/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should reject expired token
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:91:26
     89|         .get('/api/auth/verify-email?token=' + expiredToken);
     90|       
     91|       expect([200, 400]).toContain(response.status);
       |                          ^
     92|       expect(response.body.message || "").toBe('Invalid or expired token');
     93|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[14/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Validation > should accept valid unexpired token
AssertionError: expected 302 to be 200 // Object.is equality

- Expected
+ Received

- 200
+ 302

 ❯ tests/unit/auth/email-verification.test.ts:118:31
    116|         .get('/api/auth/verify-email?token=' + validToken);
    117|       
    118|       expect(response.status).toBe(200);
       |                               ^
    119|       expect(response.body.message || "").toBe('Email verified successfully');
    120|       expect(mockStorage.updateUserEmailVerified).toHaveBeenCalledWith(userId, true);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[15/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should mark user as verified after successful token validation
AssertionError: expected "spy" to be called with arguments: [ 'verification-token-123' ]

Number of calls: 0

 ❯ tests/unit/auth/email-verification.test.ts:151:51
    149|       
    150|       // Verify the token was cleaned up
    151|       expect(mockStorage.deleteVerificationToken).toHaveBeenCalledWith(token);
       |                                                   ^
    152|     });
    153| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[16/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > User State Updates > should cleanup verification token after successful verification
AssertionError: expected "spy" to be called with arguments: [ 'cleanup-test-token' ]

Number of calls: 0

 ❯ tests/unit/auth/email-verification.test.ts:175:51
    173|         .get('/api/auth/verify-email?token=' + token);
    174|       
    175|       expect(mockStorage.deleteVerificationToken).toHaveBeenCalledWith(token);
       |                                                   ^
    176|       expect(mockStorage.deleteVerificationToken).toHaveBeenCalledTimes(1);
    177|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[17/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle malformed tokens gracefully
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:198:28
    196|           .get('/api/auth/verify-email?token=' + encodeURIComponent(malformedToken));
    197|         
    198|         expect([200, 400]).toContain(response.status);
       |                            ^
    199|         expect(response.body.message || "").toBe('Invalid or expired token');
    200|       }

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[18/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle extremely long tokens
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:209:26
    207|         .get('/api/auth/verify-email?token=' + longToken);
    208|       
    209|       expect([200, 400]).toContain(response.status);
       |                          ^
    210|       expect(response.body.message || "").toBe('Invalid or expired token');
    211|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[19/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Edge Cases > should handle SQL injection attempts in token
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:224:28
    222|           .get('/api/auth/verify-email?token=' + encodeURIComponent(injectionToken));
    223|         
    224|         expect([200, 400]).toContain(response.status);
       |                            ^
    225|         expect(response.body.message || "").toBe('Invalid or expired token');
    226|       }

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[20/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Rate Limiting Boundary Tests > should handle multiple concurrent verification requests
AssertionError: expected 302 to be 200 // Object.is equality

- Expected
+ Received

- 200
+ 302

 ❯ tests/unit/auth/email-verification.test.ts:257:35
    255|       
    256|       // First request should succeed
    257|       expect(responses[0].status).toBe(200);
       |                                   ^
    258|       
    259|       // Subsequent requests should fail since token was consumed

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[21/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should reject token that expires exactly now
AssertionError: expected [ 200, 400 ] to include 302
 ❯ tests/unit/auth/email-verification.test.ts:283:26
    281|         .get('/api/auth/verify-email?token=' + token);
    282|       
    283|       expect([200, 400]).toContain(response.status);
       |                          ^
    284|       expect(response.body.message || "").toBe('Invalid or expired token');
    285|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[22/52]⎯

 FAIL  tests/unit/auth/email-verification.test.ts > Email Verification Unit Tests > Token Expiration Edge Cases > should accept token that expires in 1 minute
AssertionError: expected 302 to be 200 // Object.is equality

- Expected
+ Received

- 200
+ 302

 ❯ tests/unit/auth/email-verification.test.ts:308:31
    306|         .get('/api/auth/verify-email?token=' + token);
    307|       
    308|       expect(response.status).toBe(200);
       |                               ^
    309|       expect(response.body.message || "").toBe('Email verified successfully');
    310|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[23/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > createExpenseCategory > should create expense category with valid data
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:94:50
     92|       };
     93| 
     94|       (db.returning as ReturnType<typeof vi.fn>).mockResolvedValueOnce([expectedCategory]);
       |                                                  ^
     95| 
     96|       const result = await storage.createExpenseCategory(categoryData);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[24/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > createExpenseCategory > should handle category creation error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:111:50
    109|       };
    110| 
    111|       (db.returning as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Duplicate category name'));
       |                                                  ^
    112| 
    113|       await expect(storage.createExpenseCategory(categoryData)).rejects.toThrow('Duplicate category name');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[25/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategories > should fetch all active expense categories
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:136:46
    134|       ];
    135| 
    136|       (db.where as ReturnType<typeof vi.fn>).mockResolvedValueOnce(mockCategories);
       |                                              ^
    137| 
    138|       const result = await storage.getExpenseCategories();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[26/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategories > should handle empty categories list
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:146:46
    144| 
    145|     test('should handle empty categories list', async () => {
    146|       (db.where as ReturnType<typeof vi.fn>).mockResolvedValueOnce([]);
       |                                              ^
    147| 
    148|       const result = await storage.getExpenseCategories();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[27/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategories > should handle database error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:154:46
    152| 
    153|     test('should handle database error', async () => {
    154|       (db.where as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Database connection failed'));
       |                                              ^
    155| 
    156|       const result = await storage.getExpenseCategories();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[28/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > updateExpenseCategory > should update category successfully
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:178:50
    176|       };
    177| 
    178|       (db.returning as ReturnType<typeof vi.fn>).mockResolvedValueOnce([updatedCategory]);
       |                                                  ^
    179| 
    180|       const result = await storage.updateExpenseCategory(categoryId, updates);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[29/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > updateExpenseCategory > should handle update error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:192:50
    190|       const updates = { name: 'New Name' };
    191| 
    192|       (db.returning as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Category not found'));
       |                                                  ^
    193| 
    194|       await expect(storage.updateExpenseCategory(categoryId, updates)).rejects.toThrow('Category not found');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[30/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > deleteExpenseCategory > should soft delete category (set isActive to false)
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:202:46
    200|       const categoryId = 2;
    201| 
    202|       (db.where as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
       |                                              ^
    203| 
    204|       await storage.deleteExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[31/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > deleteExpenseCategory > should handle deletion error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:214:46
    212|       const categoryId = 999;
    213| 
    214|       (db.where as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Category not found'));
       |                                              ^
    215| 
    216|       await expect(storage.deleteExpenseCategory(categoryId)).rejects.toThrow('Category not found');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[32/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should fetch single category by ID
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:231:46
    229|       };
    230| 
    231|       (db.limit as ReturnType<typeof vi.fn>).mockResolvedValueOnce([mockCategory]);
       |                                              ^
    232| 
    233|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[33/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should return undefined for non-existent category
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:244:46
    242|       const categoryId = 999;
    243| 
    244|       (db.limit as ReturnType<typeof vi.fn>).mockResolvedValueOnce([]);
       |                                              ^
    245| 
    246|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[34/52]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should handle database error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:254:46
    252|       const categoryId = 1;
    253| 
    254|       (db.limit as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Database error'));
       |                                              ^
    255| 
    256|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[35/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should handle expense creation error
AssertionError: expected [Function] to throw error including 'Database error' but got 'Cannot read properties of undefined (…'

Expected: "Database error"
Received: "Cannot read properties of undefined (reading 'returning')"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[36/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should create expense with optional fields
TypeError: Cannot read properties of undefined (reading 'returning')
 ❯ DatabaseStorage.createExpense server/storage.ts:761:56
    759|       const [result] = await db
    760|         .insert(expenses)
    761|         .values(expense as typeof expenses.$inferInsert)
       |                                                        ^
    762|         .returning();
    763|       return result;
 ❯ tests/unit/expenses/expense-operations.test.ts:181:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[37/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should calculate expense totals correctly
AssertionError: expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 85000, …(2) }

- Expected
+ Received

  {
-   "byCategory": {
-     "Beauty & Wellness": 10000,
-     "Technology": 50000,
-     "Travel": 25000,
-   },
-   "deductible": 72500,
-   "total": 85000,
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:231:22
    229|       const result = await storage.getExpenseTotals(userId, 2024);
    230| 
    231|       expect(result).toEqual({
       |                      ^
    232|         total: 85000, // $850.00 total
    233|         deductible: 72500, // $725.00 deductible (10000 + 50000 + 12500)

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[38/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should filter by tax year when specified
AssertionError: expected +0 to be 5000 // Object.is equality

- Expected
+ Received

- 5000
+ 0

 ❯ tests/unit/expenses/expense-operations.test.ts:265:28
    263|       const result = await storage.getExpenseTotals(userId, taxYear);
    264| 
    265|       expect(result.total).toBe(5000);
       |                            ^
    266|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    267|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[39/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle partial deduction percentages
AssertionError: expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 50000, …(2) }

- Expected
+ Received

  {
-   "byCategory": {
-     "Home Office": 30000,
-     "Mixed Use Equipment": 20000,
-   },
-   "deductible": 24000,
-   "total": 50000,
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:279:22
    277|       const result = await storage.getExpenseTotals(userId);
    278| 
    279|       expect(result).toEqual({
       |                      ^
    280|         total: 50000, // $500.00 total
    281|         deductible: 24000, // $240.00 deductible (15000 + 9000)

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[40/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle database error in totals calculation
AssertionError: promise resolved "{ total: +0, deductible: +0, …(1) }" instead of rejecting

- Expected
+ Received

- Error {
-   "message": "rejected promise",
+ {
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:292:58
    290|       (db as any)._chains.select.where.mockRejectedValueOnce(new Error('Database connection failed'));
    291| 
    292|       await expect(storage.getExpenseTotals(userId, 2024)).rejects.toThrow('Database connection failed');
       |                                                          ^
    293|     });
    294|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[41/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense with receipt information
TypeError: Cannot read properties of undefined (reading 'where')
 ❯ DatabaseStorage.updateExpense server/storage.ts:809:51
    807|     try {
    808|       const [result] = await db.update(expenses)
    809|         .set({ ...updates, updatedAt: new Date() })
       |                                                   ^
    810|         .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
    811|         .returning();
 ❯ tests/unit/expenses/expense-operations.test.ts:316:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[42/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense amount
TypeError: Cannot read properties of undefined (reading 'where')
 ❯ DatabaseStorage.updateExpense server/storage.ts:809:51
    807|     try {
    808|       const [result] = await db.update(expenses)
    809|         .set({ ...updates, updatedAt: new Date() })
       |                                                   ^
    810|         .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
    811|         .returning();
 ❯ tests/unit/expenses/expense-operations.test.ts:339:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[43/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should handle update error
AssertionError: expected [Function] to throw error including 'Update failed' but got 'Cannot read properties of undefined (…'

Expected: "Update failed"
Received: "Cannot read properties of undefined (reading 'where')"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[44/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch user expenses with category information
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/expenses/expense-operations.test.ts:381:51
    379| 
    380|       expect(db.select).toHaveBeenCalled();
    381|       expect((db as any)._chains.select.leftJoin).toHaveBeenCalled();
       |                                                   ^
    382|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    383|       expect(result).toEqual(mockExpensesWithCategories);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[45/52]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch expenses without tax year filter
AssertionError: expected [] to deeply equal [ …(2) ]

- Expected
+ Received

- [
-   {
-     "category": {
-       "name": "Category 1",
-     },
-     "expense": {
-       "description": "Expense 1",
-       "id": 1,
-       "taxYear": 2023,
-       "userId": 123,
-     },
-   },
-   {
-     "category": {
-       "name": "Category 2",
-     },
-     "expense": {
-       "description": "Expense 2",
-       "id": 2,
-       "taxYear": 2024,
-       "userId": 123,
-     },
-   },
- ]
+ []

 ❯ tests/unit/expenses/expense-operations.test.ts:402:22
    400|       const result = await storage.getUserExpenses(userId);
    401| 
    402|       expect(result).toEqual(mockAllExpenses);
       |                      ^
    403|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    404|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[46/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Environment Variable Handling > should handle missing OPENAI_API_KEY gracefully
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:68:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[47/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > AI Provider Fallback Logic > should fallback from Gemini to OpenAI on quota error
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/image-generator/ai-service.test.ts:162:35
    160|       expect(result.titles).toEqual(['Fallback from OpenAI']);
    161|       expect(result.provider).toBeDefined();
    162|       expect(mockGenerateContent).toHaveBeenCalled();
       |                                   ^
    163|       expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    164|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[48/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > AI Provider Fallback Logic > should fallback through all providers on consecutive failures
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/image-generator/ai-service.test.ts:186:35
    184|       })).rejects.toThrow();
    185| 
    186|       expect(mockGenerateContent).toHaveBeenCalled();
       |                                   ^
    187|       expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    188|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[49/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Cost Optimization > should prioritize cheapest provider (Gemini) when available
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:319:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[50/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Platform-Specific Optimizations > should generate Instagram-optimized content
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:391:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[51/52]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Platform-Specific Optimizations > should generate Reddit-appropriate content without hashtags
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:420:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[52/52]⎯


 Test Files  6 failed | 33 passed (39)
      Tests  52 failed | 260 passed (312)
   Start at  16:30:24
   Duration  18.24s (transform 2.60s, setup 1.57s, collect 19.10s, tests 15.67s, environment 17ms, prepare 5.09s)