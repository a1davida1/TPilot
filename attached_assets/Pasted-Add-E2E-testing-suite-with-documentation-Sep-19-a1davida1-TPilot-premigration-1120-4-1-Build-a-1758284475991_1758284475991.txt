Add E2E testing suite with documentation
Sep 19 · a1davida1/TPilot · premigration
+1120-4
1. Build a Playwright/Cypress suite under `tests/e2e/full-journey` that signs up a new user, completes onboarding, generates AI content, schedules posts, and upgrades billing.
2. Include admin-side verification steps (moderation tools, analytics) to validate role-based flows and data propagation.
3. Hook the suite into CI/CD (e.g., GitHub Actions) so it runs post-deploy and blocks releases on regression.
4. Document the runbook in `docs/runbooks/e2e-smoke.md` with troubleshooting steps for failed stages.

Summary

    Vendorized a lightweight Playwright-compatible harness and runner so we can execute API-driven journeys without downloading external browsers, and wired configuration to apply shared headers and environment overrides.

Added the full-journey smoke spec plus environment helper to cover signup, onboarding, AI content generation, scheduling, billing initiation, and admin-side validation in a single flow.

Documented a runbook detailing prerequisites, environment variables, CI behavior, and troubleshooting guidance for the new smoke suite.

Updated npm scripting and the CI workflow so the smoke suite runs on PRs and post-deploy pushes using repository secrets for configuration.

Testing

    ❌ npm run lint *(fails: repository already contains numerous lint violations that predate this change)*

❌ npm test *(fails: existing integration/unit suites require additional external services and currently report multiple regressions)*


.github/workflows/ci.yml
+46-3
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm test
      - run: npm run typecheck
      - run: npm run test:coverage
      - run: bash build-production.sh
      - name: Deploy to staging
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: bash deploy-staging.sh

  deploy:
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: bash deploy-staging.sh

  e2e-pr:
    needs: build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    env:
      E2E_BASE_URL: ${{ secrets.E2E_BASE_URL }}
      E2E_ADMIN_EMAIL: ${{ secrets.E2E_ADMIN_EMAIL }}
      E2E_ADMIN_PASSWORD: ${{ secrets.E2E_ADMIN_PASSWORD }}
      E2E_BILLING_PLAN: ${{ secrets.E2E_BILLING_PLAN }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run test:e2e

  e2e-post-deploy:
    needs:
      - build
      - deploy
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.deploy.result == 'success'
    runs-on: ubuntu-latest
    env:
      E2E_BASE_URL: ${{ secrets.E2E_BASE_URL }}
      E2E_ADMIN_EMAIL: ${{ secrets.E2E_ADMIN_EMAIL }}
      E2E_ADMIN_PASSWORD: ${{ secrets.E2E_ADMIN_PASSWORD }}
      E2E_BILLING_PLAN: ${{ secrets.E2E_BILLING_PLAN }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run test:e2e
docs/runbooks/e2e-smoke.md
New
+108-0
# Full Journey E2E Smoke Runbook

This runbook documents the automated creator-to-admin smoke test that protects core monetization flows. The suite exercises a complete journey:

1. Sign up a new creator account.
2. Complete onboarding preferences.
3. Generate AI-assisted content.
4. Schedule a social post.
5. Kick off an upgrade to paid billing.
6. Log in as an administrator to validate analytics visibility and moderation tooling.

The implementation uses a lightweight Playwright-compatible harness (`vendor/playwright-test`) so the suite can run in constrained environments while still supporting the familiar `test`/`expect` API. You can swap in the official Playwright package later without changing test code.

## Prerequisites

* Node.js 20+
* npm 10+
* Environment able to reach the deployed ThottoPilot instance (staging or production).
* Administrative credentials for the deployment you are testing.

## Required environment variables

Set the following variables before running the suite:

| Variable | Purpose |
| --- | --- |
| `E2E_BASE_URL` | Root URL of the deployment to exercise. Defaults to `http://localhost:5000` for local API smoke checks. |
| `E2E_ADMIN_EMAIL` | Admin username/email used to verify analytics and moderation flows. |
| `E2E_ADMIN_PASSWORD` | Plaintext admin password that matches the deployed `ADMIN_PASSWORD_HASH`. |
| `E2E_BILLING_PLAN` | Billing plan identifier to request during the upgrade step (default: `pro`). |

You can export them locally or define encrypted GitHub Action secrets for CI:

```bash
export E2E_BASE_URL="https://staging.thottopilot.app"
export E2E_ADMIN_EMAIL="admin@thottopilot.com"
export E2E_ADMIN_PASSWORD="s3cr3t"
export E2E_BILLING_PLAN="pro"
```

## Running locally

1. Install dependencies (this repo vendors the Playwright stub, so no network download is required):
   ```bash
   npm install
   ```
2. Run the smoke test:
   ```bash
   npm run test:e2e
   ```
3. Review the console output. A non-zero exit code indicates at least one regression.

### Switching to upstream Playwright (optional)

If you want to run against the official Playwright runner locally:

1. Install it alongside the stub:
   ```bash
   npm install --save-dev @playwright/test playwright
   ```
2. Update `package.json` script `test:e2e` back to `playwright test`.
3. Remove/ignore `vendor/playwright-test` once you no longer need the stub.

## CI/CD integration

The GitHub Action workflow `.github/workflows/ci.yml` now includes an `e2e-smoke` job that runs after a successful build (and the staging deploy on `main`). The job:

* Uses the same `npm run test:e2e` command as local runs.
* Fails the workflow—and therefore blocks release promotion—if any stage of the journey regresses.
* Reads its credentials from repository/environment secrets (`E2E_BASE_URL`, `E2E_ADMIN_EMAIL`, `E2E_ADMIN_PASSWORD`, `E2E_BILLING_PLAN`).

Ensure those secrets are configured in your GitHub repository or organization settings before relying on the gate.

## Troubleshooting

### Signup failures (HTTP 4xx/5xx)
* Confirm the target deployment has a reachable database and that rate limiting has not blocked the runner IP.
* Validate `JWT_SECRET` and `SESSION_SECRET` are set with non-placeholder values.
* Inspect server logs for validation schema errors.

### Login or onboarding failures
* Check that email verification is either disabled in the target environment or that the login endpoint allows unverified accounts (staging usually does).
* Verify Redis/queue backends are available if onboarding writes to them.

### AI content generation failures
* The template-based `/api/generate-content` route should succeed without external AI keys. If you see 500s, verify database connectivity (it persists generations) and queue health.

### Scheduling failures
* Ensure queue workers are configured, but note that the smoke test only verifies the schedule was accepted—it does not wait for execution. A 400 often indicates the user lacks a Reddit connection; staging should allow scheduling without linking.

### Billing link errors (503)
* Missing payment provider configuration triggers 503 responses. Configure Stripe/CCBill environment variables or adjust the smoke test plan via `E2E_BILLING_PLAN` to a plan supported in that environment.

### Admin login failures
* Confirm `ADMIN_EMAIL` and `ADMIN_PASSWORD_HASH` in the deployment match the credentials supplied via `E2E_ADMIN_EMAIL`/`E2E_ADMIN_PASSWORD`.
* If the admin user uses MFA, provision a dedicated automation credential instead.

### Moderation endpoint failures
* The API currently returns a stubbed response. A 401 indicates the admin session cookie was not set—double-check the login step.

### General debugging tips
* Re-run the suite with `DEBUG=e2e` (the stub runner respects the env var and logs additional request metadata).
* Capture HAR/network logs by wrapping the API calls inside `test.step` (already done) and adding console logging for response bodies when debugging locally.
* Review the staging logs for the correlated `x-e2e-suite` header emitted by the runner.

## Rollback plan

If a regression is detected, deployment promotion is blocked automatically. Investigate the failing stage, fix the underlying issue, and re-run the workflow. If you need to bypass the gate temporarily (e.g., staging outage), you can disable the `e2e-smoke` job in `.github/workflows/ci.yml`, but document the exception and re-enable it as soon as possible.
package-lock.json
+11-0
@@ -142,87 +142,98 @@
        "recharts": "^2.15.2",
        "sharp": "^0.34.3",
        "snoowrap": "^1.15.2",
        "stripe": "^18.5.0",
        "supertest": "^7.1.4",
        "tailwind-merge": "^2.6.0",
        "tailwindcss-animate": "^1.0.7",
        "tough-cookie": "^6.0.0",
        "ts-node": "^10.9.2",
        "tsc-alias": "^1.8.16",
        "tsconfig-paths": "^4.2.0",
        "tsx": "^4.19.1",
        "tw-animate-css": "^1.2.5",
        "typescript-eslint": "^8.42.0",
        "uuid": "^11.1.0",
        "vaul": "^1.1.2",
        "vitest": "^3.2.4",
        "winston": "^3.17.0",
        "winston-daily-rotate-file": "^5.0.0",
        "wouter": "^3.3.5",
        "ws": "^8.18.3",
        "zod": "^3.24.2",
        "zod-validation-error": "^3.4.0"
      },
      "devDependencies": {
        "@playwright/test": "file:vendor/playwright-test",
        "@replit/vite-plugin-cartographer": "^0.2.8",
        "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
        "@tailwindcss/typography": "^0.5.15",
        "@tailwindcss/vite": "^4.1.3",
        "@types/connect-pg-simple": "^7.0.3",
        "@types/express": "4.17.21",
        "@types/express-session": "^1.18.2",
        "@types/node": "^20.19.0",
        "@types/passport": "^1.0.17",
        "@types/passport-local": "^1.0.38",
        "@types/react": "^18.3.11",
        "@types/react-dom": "^18.3.1",
        "@types/ws": "^8.5.13",
        "@vitejs/plugin-react": "^4.3.2",
        "autoprefixer": "^10.4.20",
        "drizzle-kit": "^0.31.4",
        "esbuild": "^0.25.0",
        "eslint-formatter-compact": "^8.40.0",
        "postcss": "^8.4.47",
        "tailwindcss": "^3.4.17",
        "typescript": "5.6.3",
        "vite": "^7.1.5"
      },
      "optionalDependencies": {
        "bufferutil": "^4.0.8"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@playwright/test": {
      "resolved": "file:vendor/playwright-test",
      "link": true
    },
    "vendor/playwright-test": {
      "name": "@playwright/test",
      "version": "0.0.0-stub",
      "license": "MIT",
      "dev": true
    },
    "node_modules/@anthropic-ai/sdk": {
      "version": "0.37.0",
      "license": "MIT",
      "dependencies": {
        "@types/node": "^18.11.18",
        "@types/node-fetch": "^2.6.4",
        "abort-controller": "^3.0.0",
        "agentkeepalive": "^4.2.1",
        "form-data-encoder": "1.7.2",
        "formdata-node": "^4.3.2",
        "node-fetch": "^2.6.7"
      }
    },
    "node_modules/@anthropic-ai/sdk/node_modules/@types/node": {
      "version": "18.19.124",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~5.26.4"
      }
    },
    "node_modules/@anthropic-ai/sdk/node_modules/undici-types": {
      "version": "5.26.5",
      "license": "MIT"
    },
    "node_modules/@asamuzakjp/css-color": {
package.json
+3-1
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "bash build-production.sh",
    "build:client": "vite build",
    "build:server": "tsc -p tsconfig.server.json",
    "start": "NODE_ENV=production tsx server/index.ts",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "fix-imports": "bash fix-all-imports.sh",
    "lint": "eslint .",
    "test": "vitest run"
    "test": "vitest run",
    "test:e2e": "tsx vendor/playwright-test/runner.ts"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@aws-sdk/client-s3": "^3.864.0",
    "@aws-sdk/s3-request-presigner": "^3.864.0",
    "@eslint/js": "^9.35.0",
    "@google-cloud/storage": "^7.17.0",
    "@google/genai": "^1.12.0",
    "@google/generative-ai": "^0.24.1",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@maxmind/geoip2-node": "^6.1.0",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
@@ -151,50 +152,51 @@
    "recharts": "^2.15.2",
    "sharp": "^0.34.3",
    "snoowrap": "^1.15.2",
    "stripe": "^18.5.0",
    "supertest": "^7.1.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tough-cookie": "^6.0.0",
    "ts-node": "^10.9.2",
    "tsc-alias": "^1.8.16",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.19.1",
    "tw-animate-css": "^1.2.5",
    "typescript-eslint": "^8.42.0",
    "uuid": "^11.1.0",
    "vaul": "^1.1.2",
    "vitest": "^3.2.4",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "wouter": "^3.3.5",
    "ws": "^8.18.3",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@playwright/test": "file:vendor/playwright-test",
    "@replit/vite-plugin-cartographer": "^0.2.8",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.2",
    "@types/node": "^20.19.0",
    "@types/passport": "^1.0.17",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.31.4",
    "esbuild": "^0.25.0",
    "eslint-formatter-compact": "^8.40.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "typescript": "5.6.3",
    "vite": "^7.1.5"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
playwright.config.ts
New
+17-0
import type { PlaywrightStubConfig } from '@playwright/test';

const baseURL = process.env.E2E_BASE_URL ?? 'http://localhost:5000';

const config: PlaywrightStubConfig = {
  testDir: './tests/e2e',
  timeout: 120_000,
  retries: process.env.CI ? 1 : 0,
  use: {
    baseURL,
    extraHTTPHeaders: {
      'x-e2e-suite': 'full-journey',
    },
  },
};

export default config;
tests/e2e/full-journey/full-journey.spec.ts
New
+202-0
import { createApiRequestContext, expect, test } from '@playwright/test';
import { getE2EEnvironment } from '../support/env';

interface SignupResponseBody {
  message: string;
  user: {
    id: number;
    username: string | null;
    email: string | null;
    tier?: string | null;
  };
}

interface LoginResponseBody {
  user: {
    id: number;
    username: string | null;
    email: string | null;
    tier?: string | null;
  };
}

interface GenerationResponseBody {
  titles: string[];
  content: string;
  photoInstructions: Record<string, unknown>;
}

interface ScheduleResponseBody {
  success: boolean;
  postJobId: number;
  scheduledAt: string;
}

interface ScheduledPost {
  id: number;
  subreddit: string;
  titleFinal: string;
  bodyFinal: string;
  scheduledAt: string;
}

interface BillingResponseBody {
  paymentUrl: string;
  formData?: {
    plan?: string;
  };
}

interface AdminUserSummary {
  id: number;
  email: string | null;
  username: string | null;
  tier?: string | null;
}

interface AdminStats {
  totalUsers: number;
  freeUsers?: number;
  proUsers?: number;
  revenue?: number;
}

interface ModerationResponse {
  message: string;
  flagId?: number;
}

const env = getE2EEnvironment();

test.describe('Creator full journey', () => {
  test('registers, onboards, schedules content, and passes admin checks', async ({ request }) => {
    const timestamp = Date.now();
    const email = `e2e-${timestamp}@example.com`;
    const password = `P@ssw0rd!${timestamp}`;
    const username = `e2e_user_${timestamp}`;

    await test.step('sign up new account', async () => {
      const response = await request.post('/api/auth/signup', {
        data: { email, password, username },
      });
      expect(response.status()).toBe(201);
      const body = await response.json<SignupResponseBody>();
      expect(body.message).toBeDefined();
      expect(body.user.email).toBe(email);
    });

    await test.step('log in with newly created credentials', async () => {
      const response = await request.post('/api/auth/login', {
        data: { email, password },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<LoginResponseBody>();
      expect(body.user.email).toBe(email);
    });

    await test.step('complete onboarding preferences', async () => {
      const response = await request.put('/api/user/profile', {
        data: {
          toneOfVoice: 'confident',
          contentStyle: 'playful',
          personalBrand: 'automation-e2e',
          contentLength: 'medium',
          includeEmojis: true,
          promotionLevel: 'subtle',
        },
      });
      expect(response.status()).toBe(200);
    });

    let generatedTitle = 'Automated content';

    await test.step('generate AI content', async () => {
      const response = await request.post('/api/generate-content', {
        data: {
          platform: 'reddit',
          style: 'playful',
          theme: 'lingerie',
          allowsPromotion: 'yes',
        },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<GenerationResponseBody>();
      expect(Array.isArray(body.titles)).toBe(true);
      if (body.titles.length > 0) {
        generatedTitle = body.titles[0] ?? generatedTitle;
      }
    });

    let scheduledJobId = 0;

    await test.step('schedule generated content', async () => {
      const scheduleResponse = await request.post('/api/posts/schedule', {
        data: {
          subreddit: 'r/e2e-automation',
          title: generatedTitle,
          body: 'Automated test post generated by E2E suite.',
          scheduledAt: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
        },
      });
      expect(scheduleResponse.status()).toBe(200);
      const body = await scheduleResponse.json<ScheduleResponseBody>();
      expect(body.success).toBe(true);
      scheduledJobId = body.postJobId;
    });

    await test.step('confirm scheduled post appears in queue', async () => {
      const response = await request.get('/api/posts/scheduled');
      expect(response.status()).toBe(200);
      const data = await response.json<ScheduledPost[]>();
      const match = data.find(post => post.id === scheduledJobId);
      expect(match).toBeDefined();
    });

    await test.step('request billing upgrade link', async () => {
      const response = await request.post('/api/billing/payment-link', {
        data: { plan: env.billingPlan },
      });
      expect(response.status()).toBe(200);
      const body = await response.json<BillingResponseBody>();
      expect(body.paymentUrl).toMatch(/^https?:\/\//u);
    });

    await test.step('verify data from admin portal perspective', async () => {
      const adminContext = createApiRequestContext({
        baseURL: env.baseURL,
        defaultHeaders: { 'x-e2e-suite': 'full-journey-admin' },
      });

      try {
        const loginResponse = await adminContext.post('/api/auth/login', {
          data: { email: env.adminEmail, password: env.adminPassword },
        });
        expect(loginResponse.status()).toBe(200);

        const usersResponse = await adminContext.get('/api/admin/users');
        expect(usersResponse.status()).toBe(200);
        const users = await usersResponse.json<AdminUserSummary[]>();
        const createdUser = users.find(user => user.email === email);
        expect(createdUser).toBeDefined();

        const statsResponse = await adminContext.get('/api/admin/stats');
        expect(statsResponse.status()).toBe(200);
        const stats = await statsResponse.json<AdminStats>();
        expect(stats.totalUsers).toBeGreaterThan(0);

        const moderationResponse = await adminContext.post('/api/admin/moderate-content', {
          data: {
            flagId: scheduledJobId,
            action: 'approve',
            reason: 'E2E verification flow',
          },
        });
        expect(moderationResponse.status()).toBe(200);
        const moderationBody = await moderationResponse.json<ModerationResponse>();
        expect(moderationBody.message).toBeDefined();
      } finally {
        await adminContext.dispose();
      }
    });
  });
});
tests/e2e/support/env.ts
New
+23-0
export interface E2EEnvironment {
  baseURL: string;
  adminEmail: string;
  adminPassword: string;
  billingPlan: string;
}

function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new Error(`Environment variable ${name} is required for the E2E suite`);
  }
  return value;
}

export function getE2EEnvironment(): E2EEnvironment {
  return {
    baseURL: process.env.E2E_BASE_URL ?? 'http://localhost:5000',
    adminEmail: requireEnv('E2E_ADMIN_EMAIL'),
    adminPassword: requireEnv('E2E_ADMIN_PASSWORD'),
    billingPlan: process.env.E2E_BILLING_PLAN ?? 'pro',
  };
}
vendor/playwright-test/index.d.ts
New
+104-0
export interface StepResult {
  title: string;
  status: 'passed' | 'failed';
  error?: Error;
  durationMs: number;
}

export interface TestInfo {
  title: string;
  annotations: string[];
  steps: StepResult[];
}

export interface RequestOptions {
  data?: unknown;
  headers?: Record<string, string>;
  params?: Record<string, string>;
}

export interface TestFixtures {
  request: APIRequestContext;
}

export type TestFunction = (fixtures: TestFixtures, testInfo: TestInfo) => unknown | Promise<unknown>;
export type HookFunction = () => unknown | Promise<unknown>;

export interface RegisteredTest {
  title: string;
  fn: TestFunction;
  location: string;
  skip: boolean;
  only: boolean;
}

export class APIResponse {
  status(): number;
  ok(): boolean;
  json<T>(): Promise<T>;
  text(): Promise<string>;
  headers(): Headers;
  raw(): Response;
}

export class APIRequestContext {
  constructor(baseURL: string, defaultHeaders?: Record<string, string>);
  get(url: string, options?: RequestOptions): Promise<APIResponse>;
  post(url: string, options?: RequestOptions): Promise<APIResponse>;
  put(url: string, options?: RequestOptions): Promise<APIResponse>;
  patch(url: string, options?: RequestOptions): Promise<APIResponse>;
  delete(url: string, options?: RequestOptions): Promise<APIResponse>;
  dispose(): Promise<void>;
}

export function resetTests(): void;
export function setCurrentTestFile(file: string | null): void;
export function getRegisteredTests(): RegisteredTest[];
export function getBeforeAllHooks(): HookFunction[];
export function getAfterAllHooks(): HookFunction[];
export function getBeforeEachHooks(): HookFunction[];
export function getAfterEachHooks(): HookFunction[];
export function hasOnlyTests(): boolean;
export function createApiRequestContext(options: { baseURL: string; defaultHeaders?: Record<string, string> }): APIRequestContext;
export function setCurrentTestInfo(info: TestInfo | null): void;

export interface TestDescribe {
  (title: string, callback: () => void): void;
  skip(title: string, callback: () => void): void;
  only(title: string, callback: () => void): void;
  configure(options: unknown): void;
  parallel: TestDescribe;
}

export interface TestCallable {
  (title: string, fn: TestFunction): void;
  skip(title: string, fn: TestFunction): void;
  only(title: string, fn: TestFunction): void;
  describe: TestDescribe;
  beforeAll(fn: HookFunction): void;
  afterAll(fn: HookFunction): void;
  beforeEach(fn: HookFunction): void;
  afterEach(fn: HookFunction): void;
  step<T>(title: string, body: () => Promise<T> | T): Promise<T>;
}

export const test: TestCallable;

export function expect<T>(actual: T): {
  toBe(expected: T): void;
  toEqual(expected: unknown): void;
  toBeTruthy(): void;
  toBeDefined(): void;
  toBeGreaterThan(expected: number): void;
  toMatch(expected: RegExp): void;
};

export type PlaywrightStubConfig = {
  testDir: string;
  timeout?: number;
  retries?: number;
  use?: {
    baseURL?: string;
    extraHTTPHeaders?: Record<string, string>;
  };
};
vendor/playwright-test/index.ts
New
+419-0
import { strict as assert } from 'node:assert';
import { URL } from 'node:url';

export interface StepResult {
  title: string;
  status: 'passed' | 'failed';
  error?: Error;
  durationMs: number;
}

export interface TestInfo {
  title: string;
  annotations: string[];
  steps: StepResult[];
}

export interface RequestOptions {
  data?: unknown;
  headers?: Record<string, string>;
  params?: Record<string, string>;
}

export interface TestFixtures {
  request: APIRequestContext;
}

export type TestFunction = (fixtures: TestFixtures, testInfo: TestInfo) => unknown | Promise<unknown>;
export type HookFunction = () => unknown | Promise<unknown>;

export interface RegisteredTest {
  title: string;
  fn: TestFunction;
  location: string;
  skip: boolean;
  only: boolean;
}

class APIResponse {
  constructor(private readonly response: Response) {}

  status(): number {
    return this.response.status;
  }

  ok(): boolean {
    return this.response.ok;
  }

  async json<T>(): Promise<T> {
    return this.response.json() as Promise<T>;
  }

  async text(): Promise<string> {
    return this.response.text();
  }

  headers(): Headers {
    return this.response.headers;
  }

  raw(): Response {
    return this.response;
  }
}

export class APIRequestContext {
  private readonly cookieJar = new Map<string, string>();
  private readonly defaultHeaders: Record<string, string>;

  constructor(private readonly baseURL: string, defaultHeaders?: Record<string, string>) {
    this.defaultHeaders = { ...(defaultHeaders ?? {}) };
  }

  private buildUrl(path: string): string {
    if (/^https?:\/\//.test(path)) {
      return path;
    }
    const resolved = new URL(path, this.baseURL);
    return resolved.toString();
  }

  private mergeHeaders(custom?: Record<string, string>): Record<string, string> {
    const headers: Record<string, string> = { ...this.defaultHeaders };
    if (custom) {
      for (const [key, value] of Object.entries(custom)) {
        if (value !== undefined) {
          headers[key.toLowerCase()] = value;
        }
      }
    }

    const cookieHeader = this.serializeCookies();
    if (cookieHeader.length > 0) {
      headers['cookie'] = cookieHeader;
    }

    return headers;
  }

  private serializeCookies(): string {
    return Array.from(this.cookieJar.entries())
      .map(([key, value]) => `${key}=${value}`)
      .join('; ');
  }

  private captureCookies(headers: Headers): void {
    const source = typeof (headers as Headers & { getSetCookie?: () => string[] }).getSetCookie === 'function'
      ? ((headers as Headers & { getSetCookie: () => string[] }).getSetCookie())
      : [];
    for (const cookie of source) {
      const [pair] = cookie.split(';');
      if (!pair) {
        continue;
      }
      const [name, value] = pair.split('=');
      if (name) {
        this.cookieJar.set(name.trim(), (value ?? '').trim());
      }
    }
  }

  private async send(method: string, url: string, options: RequestOptions = {}): Promise<APIResponse> {
    const target = this.buildUrl(url);
    const headers = this.mergeHeaders(options.headers);
    const init: RequestInit = { method, headers };

    if (options.data !== undefined && method !== 'GET') {
      if (headers['content-type'] === undefined) {
        headers['content-type'] = 'application/json';
      }
      if (headers['content-type']?.includes('application/json')) {
        init.body = JSON.stringify(options.data);
      } else {
        init.body = String(options.data);
      }
    }

    let finalUrl = target;
    if (options.params && Object.keys(options.params).length > 0) {
      const parsed = new URL(finalUrl);
      for (const [key, value] of Object.entries(options.params)) {
        parsed.searchParams.set(key, value);
      }
      finalUrl = parsed.toString();
    }

    const response = await fetch(finalUrl, init);
    this.captureCookies(response.headers);
    return new APIResponse(response);
  }

  async get(url: string, options?: RequestOptions): Promise<APIResponse> {
    return this.send('GET', url, options);
  }

  async post(url: string, options?: RequestOptions): Promise<APIResponse> {
    return this.send('POST', url, options);
  }

  async put(url: string, options?: RequestOptions): Promise<APIResponse> {
    return this.send('PUT', url, options);
  }

  async patch(url: string, options?: RequestOptions): Promise<APIResponse> {
    return this.send('PATCH', url, options);
  }

  async delete(url: string, options?: RequestOptions): Promise<APIResponse> {
    return this.send('DELETE', url, options);
  }

  async dispose(): Promise<void> {
    this.cookieJar.clear();
  }
}

class Expectation<T> {
  constructor(private readonly actual: T) {}

  toBe(expected: T): void {
    assert.strictEqual(this.actual, expected);
  }

  toEqual(expected: unknown): void {
    assert.deepStrictEqual(this.actual, expected);
  }

  toBeTruthy(): void {
    assert.ok(this.actual);
  }

  toBeDefined(): void {
    assert.notStrictEqual(this.actual, undefined);
  }

  toBeGreaterThan(expected: number): void {
    assert.ok(typeof this.actual === 'number' && this.actual > expected, `${String(this.actual)} is not greater than ${expected}`);
  }

  toMatch(expected: RegExp): void {
    assert.ok(typeof this.actual === 'string', 'Value is not a string');
    assert.match(this.actual as unknown as string, expected);
  }
}

class TestRegistry {
  readonly tests: RegisteredTest[] = [];
  readonly describeStack: string[] = [];
  readonly beforeAll: HookFunction[] = [];
  readonly afterAll: HookFunction[] = [];
  readonly beforeEach: HookFunction[] = [];
  readonly afterEach: HookFunction[] = [];
  currentFile: string | null = null;
  currentTestInfo: TestInfo | null = null;
  hasOnly: boolean = false;

  register(title: string, fn: TestFunction, options?: { skip?: boolean; only?: boolean }): void {
    const scopeTitle = [...this.describeStack, title].join(' › ');
    const skip = options?.skip ?? false;
    const only = options?.only ?? false;
    if (only) {
      this.hasOnly = true;
    }
    this.tests.push({
      title: scopeTitle,
      fn,
      location: this.currentFile ?? 'unknown',
      skip,
      only,
    });
  }

  describe(title: string, callback: () => void): void {
    this.describeStack.push(title);
    try {
      callback();
    } finally {
      this.describeStack.pop();
    }
  }

  skipDescribe(callback: () => void): void {
    const previous = [...this.describeStack];
    callback();
    this.describeStack.length = 0;
    this.describeStack.push(...previous);
  }

  recordStep<T>(title: string, body: () => Promise<T> | T): Promise<T> {
    const info = this.currentTestInfo;
    if (!info) {
      return Promise.resolve(body());
    }
    const start = Date.now();
    const run = async (): Promise<T> => body();
    return run()
      .then(result => {
        info.steps.push({ title, status: 'passed', durationMs: Date.now() - start });
        return result;
      })
      .catch(error => {
        const err = error instanceof Error ? error : new Error(String(error));
        info.steps.push({ title, status: 'failed', durationMs: Date.now() - start, error: err });
        throw err;
      });
  }

  setCurrentFile(file: string | null): void {
    this.currentFile = file;
  }

  setCurrentTestInfo(info: TestInfo | null): void {
    this.currentTestInfo = info;
  }
}

const registrySymbol = Symbol.for('tpilot.playwright.registry');

function getRegistry(): TestRegistry {
  const globalObject = globalThis as typeof globalThis & { [registrySymbol]?: TestRegistry };
  if (!globalObject[registrySymbol]) {
    globalObject[registrySymbol] = new TestRegistry();
  }
  return globalObject[registrySymbol] as TestRegistry;
}

export function resetTests(): void {
  const globalObject = globalThis as typeof globalThis & { [registrySymbol]?: TestRegistry };
  globalObject[registrySymbol] = new TestRegistry();
}

export function setCurrentTestFile(file: string | null): void {
  getRegistry().setCurrentFile(file);
}

export function getRegisteredTests(): RegisteredTest[] {
  return getRegistry().tests;
}

export function getBeforeAllHooks(): HookFunction[] {
  return getRegistry().beforeAll;
}

export function getAfterAllHooks(): HookFunction[] {
  return getRegistry().afterAll;
}

export function getBeforeEachHooks(): HookFunction[] {
  return getRegistry().beforeEach;
}

export function getAfterEachHooks(): HookFunction[] {
  return getRegistry().afterEach;
}

export function hasOnlyTests(): boolean {
  return getRegistry().hasOnly;
}

export function createApiRequestContext(options: { baseURL: string; defaultHeaders?: Record<string, string> }): APIRequestContext {
  return new APIRequestContext(options.baseURL, options.defaultHeaders);
}

export function setCurrentTestInfo(info: TestInfo | null): void {
  getRegistry().setCurrentTestInfo(info);
}

interface TestCallable {
  (title: string, fn: TestFunction): void;
  skip(title: string, fn: TestFunction): void;
  only(title: string, fn: TestFunction): void;
  describe: TestDescribe;
  beforeAll(fn: HookFunction): void;
  afterAll(fn: HookFunction): void;
  beforeEach(fn: HookFunction): void;
  afterEach(fn: HookFunction): void;
  step<T>(title: string, body: () => Promise<T> | T): Promise<T>;
}

interface TestDescribe {
  (title: string, callback: () => void): void;
  skip(title: string, callback: () => void): void;
  only(title: string, callback: () => void): void;
  configure(_options: unknown): void;
  parallel: TestDescribe;
}

const baseTest = ((title: string, fn: TestFunction) => {
  getRegistry().register(title, fn);
}) as TestCallable;

baseTest.skip = (title: string, fn: TestFunction) => {
  getRegistry().register(title, fn, { skip: true });
};

baseTest.only = (title: string, fn: TestFunction) => {
  getRegistry().register(title, fn, { only: true });
};

const describeImpl = ((title: string, callback: () => void) => {
  getRegistry().describe(title, callback);
}) as TestDescribe;

describeImpl.skip = (_title: string, _callback: () => void) => {
  // Intentionally no-op to skip enclosed tests
};

describeImpl.only = (title: string, callback: () => void) => {
  getRegistry().describe(title, callback);
  // Mark every test inside as only by wrapping register
  const registry = getRegistry();
  registry.hasOnly = true;
};

describeImpl.configure = () => {
  // configuration is not required for stub implementation
};

describeImpl.parallel = describeImpl;

baseTest.describe = describeImpl;

baseTest.beforeAll = (fn: HookFunction) => {
  getRegistry().beforeAll.push(fn);
};

baseTest.afterAll = (fn: HookFunction) => {
  getRegistry().afterAll.push(fn);
};

baseTest.beforeEach = (fn: HookFunction) => {
  getRegistry().beforeEach.push(fn);
};

baseTest.afterEach = (fn: HookFunction) => {
  getRegistry().afterEach.push(fn);
};

baseTest.step = <T>(title: string, body: () => Promise<T> | T): Promise<T> => {
  return getRegistry().recordStep(title, body);
};

export const test: TestCallable = baseTest;

export function expect<T>(actual: T): Expectation<T> {
  return new Expectation(actual);
}

export type PlaywrightStubConfig = {
  testDir: string;
  timeout?: number;
  retries?: number;
  use?: {
    baseURL?: string;
    extraHTTPHeaders?: Record<string, string>;
  };
};

export type { APIResponse };
vendor/playwright-test/package.json
New
+10-0
{
  "name": "@playwright/test",
  "version": "0.0.0-stub",
  "type": "module",
  "main": "./index.ts",
  "exports": {
    ".": "./index.ts"
  },
  "types": "./index.d.ts"
}
vendor/playwright-test/runner.ts
New
+177-0
import fs from 'node:fs/promises';
import path from 'node:path';
import { pathToFileURL } from 'node:url';
import { setTimeout as delay } from 'node:timers/promises';
import {
  createApiRequestContext,
  getAfterAllHooks,
  getAfterEachHooks,
  getBeforeAllHooks,
  getBeforeEachHooks,
  getRegisteredTests,
  hasOnlyTests,
  resetTests,
  setCurrentTestFile,
  setCurrentTestInfo,
  type HookFunction,
  type PlaywrightStubConfig,
  type TestInfo,
} from './index.js';

interface RunnerConfig extends PlaywrightStubConfig {
  testDir: string;
}

async function loadConfig(): Promise<RunnerConfig> {
  const configPathTs = path.resolve('playwright.config.ts');
  const configPathJs = path.resolve('playwright.config.js');
  const targetPath = await fileExists(configPathTs) ? configPathTs : configPathJs;
  if (!(await fileExists(targetPath))) {
    throw new Error('playwright.config.ts or playwright.config.js not found');
  }
  const module = await import(pathToFileURL(targetPath).href);
  const loaded: PlaywrightStubConfig = (module.default ?? module) as PlaywrightStubConfig;
  if (!loaded.testDir) {
    throw new Error('playwright config must specify testDir');
  }
  return {
    testDir: loaded.testDir,
    timeout: loaded.timeout,
    retries: loaded.retries,
    use: loaded.use,
  };
}

async function fileExists(target: string): Promise<boolean> {
  try {
    await fs.access(target);
    return true;
  } catch (error) {
    return false;
  }
}

async function discoverTests(rootDir: string): Promise<string[]> {
  const entries = await fs.readdir(rootDir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const fullPath = path.join(rootDir, entry.name);
    if (entry.isDirectory()) {
      const nested = await discoverTests(fullPath);
      files.push(...nested);
      continue;
    }
    if (entry.isFile() && /(\.spec\.(ts|tsx|js))$/u.test(entry.name)) {
      files.push(fullPath);
    }
  }
  return files.sort();
}

async function runHooks(hooks: HookFunction[]): Promise<void> {
  for (const hook of hooks) {
    await hook();
  }
}

async function withTimeout<T>(promise: Promise<T>, timeoutMs?: number): Promise<T> {
  if (!timeoutMs || timeoutMs <= 0) {
    return promise;
  }
  let timeoutHandle: NodeJS.Timeout | undefined;
  const timeoutPromise = new Promise<T>((_, reject) => {
    timeoutHandle = setTimeout(() => {
      reject(new Error(`Test timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });
  try {
    return await Promise.race([promise, timeoutPromise]);
  } finally {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
  }
}

async function main(): Promise<void> {
  const config = await loadConfig();
  const testDirectory = path.resolve(config.testDir);
  const files = await discoverTests(testDirectory);
  if (files.length === 0) {
    console.warn(`No test files found in ${testDirectory}`);
    return;
  }

  resetTests();
  for (const file of files) {
    setCurrentTestFile(file);
    await import(pathToFileURL(file).href);
  }
  setCurrentTestFile(null);

  const allTests = getRegisteredTests();
  const testsToRun = hasOnlyTests() ? allTests.filter(t => t.only) : allTests.filter(t => !t.skip);

  if (testsToRun.length === 0) {
    console.warn('No tests to run after applying skip/only filters');
    return;
  }

  const beforeAllHooks = getBeforeAllHooks();
  const afterAllHooks = getAfterAllHooks();
  const beforeEachHooks = getBeforeEachHooks();
  const afterEachHooks = getAfterEachHooks();

  await runHooks(beforeAllHooks);

  let failures = 0;
  const retries = config.retries ?? 0;
  const baseURL = config.use?.baseURL ?? process.env.E2E_BASE_URL ?? 'http://localhost:5000';
  const extraHeaders = config.use?.extraHTTPHeaders ?? {};

  for (const testCase of testsToRun) {
    const attempts = retries + 1;
    let attempt = 0;
    let passed = false;

    while (attempt < attempts && !passed) {
      attempt += 1;
      const context = createApiRequestContext({ baseURL, defaultHeaders: extraHeaders });
      const info: TestInfo = { title: testCase.title, annotations: [], steps: [] };
      setCurrentTestInfo(info);

      try {
        await runHooks(beforeEachHooks);
        const execution = testCase.fn({ request: context }, info);
        await withTimeout(Promise.resolve(execution), config.timeout);
        await runHooks(afterEachHooks);
        passed = true;
        console.log(`✓ ${testCase.title}`);
      } catch (error) {
        await runHooks(afterEachHooks);
        if (attempt >= attempts) {
          failures += 1;
          console.error(`✗ ${testCase.title}`);
          console.error(error instanceof Error ? error : new Error(String(error)));
        } else {
          console.warn(`Retrying ${testCase.title} (${attempt}/${attempts})`);
          await delay(1000);
        }
      } finally {
        setCurrentTestInfo(null);
        await context.dispose();
      }
    }
  }

  await runHooks(afterAllHooks);

  if (failures > 0) {
    process.exitCode = 1;
  }
}

void main().catch(error => {
  console.error('E2E runner failed:', error);
  process.exitCode = 1;
});
