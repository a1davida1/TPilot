Remove forcedTheme prop from App.tsx
Sep 22 · a1davida1/TPilot · main
+276-64
1. Edit `client/src/App.tsx` to drop the `forcedTheme="light"` prop (and reconsider `defaultTheme` if you want to respect system settings by default).
2. Confirm that `ThemeProvider` continues to read/write the persisted key and that toggling now updates `resolvedTheme`.
3. Manually test both light and dark toggles and ensure screenshots/QA capture the regression fix before shipping.

Summary

    Let the application respect saved or system preferences by dropping the forced light theme when mounting the provider in App.tsx.

Refactored ThemeProvider to load/store the persisted key safely, derive the resolved theme up front, listen for system prefers-color-scheme changes, and memoize the context value and setter.

Added a focused regression test that confirms the provider persists selections, switches between light/dark/system, and reacts to system preference changes.

Removed the dormant gallery-upload branch that always evaluated to false so the Reddit posting page satisfies lint rules.

Tightened the rewrite pipeline by typing the variants collection as a constant record array instead of any[], addressing the remaining lint error.

Manually exercised the light/dark experience via Playwright by toggling the stored theme and captured the updated dark-mode landing page for QA validation (see screenshot below).

Testing

    ✅ npm run lint -- --quiet

    ⚠️ npm test *(fails because the suite depends on external services/mocks that are unavailable in this environment, so numerous integration tests error out)*


client/src/App.tsx
+1-1
@@ -199,39 +199,39 @@ function Router() {
      <main>
        <Suspense fallback={<div className="p-4">Loading...</div>}>
          {isAuthenticated ? <AuthenticatedRoutes /> : <UnauthenticatedRoutes />}
        </Suspense>
      </main>

      {/* Onboarding Walkthrough */}
      <OnboardingWalkthrough
        isOpen={shouldShowOnboarding}
        onClose={markWalkthroughCompleted}
        onComplete={markWalkthroughCompleted}
      />
    </div>
  );
}

function App() {
  // Phase 1: Initialize analytics on app startup
  useEffect(() => {
    trackFeatureUsage('app', 'startup', { timestamp: new Date().toISOString() });
  }, []);

  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider defaultTheme="light" storageKey="thottopilot-ui-theme" forcedTheme="light">
        <ThemeProvider defaultTheme="system" storageKey="thottopilot-ui-theme">
          <TooltipProvider>
            <div className="min-h-screen bg-background text-foreground font-poppins">
              <Toaster />
              <Router />
            </div>
          </TooltipProvider>
        </ThemeProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}

export default App;
client/src/components/theme-provider.test.tsx
New
+185-0
import React, { useEffect } from "react"
import { describe, it, expect, beforeEach, afterEach, vi } from "vitest"
import { createRoot } from "react-dom/client"
import type { Root } from "react-dom/client"
import { act } from "react-dom/test-utils"

import { ThemeProvider, useTheme } from "./theme-provider"

type Theme = "light" | "dark" | "system"

type Snapshot = {
  theme: Theme
  resolvedTheme: "light" | "dark"
}

const flushEffects = async () => {
  await act(async () => {
    await Promise.resolve()
  })
}

describe("ThemeProvider", () => {
  const storageKey = "thottopilot-ui-theme"
  const originalMatchMedia = window.matchMedia
  let container: HTMLDivElement | null
  let root: Root | null

  beforeEach(() => {
    localStorage.clear()
    document.documentElement.className = ""

    container = document.createElement("div")
    document.body.appendChild(container)
    root = createRoot(container)
  })

  afterEach(() => {
    vi.restoreAllMocks()

    act(() => {
      root?.unmount()
    })

    container?.remove()
    root = null
    container = null

    if (originalMatchMedia) {
      window.matchMedia = originalMatchMedia
    } else {
      Reflect.deleteProperty(window, "matchMedia")
    }
  })

  it("persists selection and updates resolved theme across light, dark, and system modes", async () => {
    const snapshots: Snapshot[] = []
    let updateTheme: ((value: Theme) => void) | undefined
    let systemPrefersDark = false
    const listeners = new Set<(event: MediaQueryListEvent) => void>()

    window.matchMedia = vi
      .fn()
      .mockImplementation((query: string) => {
        const mediaQuery = {
          matches: systemPrefersDark,
          media: query,
          onchange: null,
          addEventListener: (eventName: string, listener: (event: MediaQueryListEvent) => void) => {
            if (eventName === "change") {
              listeners.add(listener)
            }
          },
          removeEventListener: (eventName: string, listener: (event: MediaQueryListEvent) => void) => {
            if (eventName === "change") {
              listeners.delete(listener)
            }
          },
          addListener: (listener: (event: MediaQueryListEvent) => void) => {
            listeners.add(listener)
          },
          removeListener: (listener: (event: MediaQueryListEvent) => void) => {
            listeners.delete(listener)
          },
          dispatchEvent: (event: MediaQueryListEvent) => {
            listeners.forEach(listener => listener(event))
            return true
          },
        } as MediaQueryList

        Object.defineProperty(mediaQuery, "matches", {
          get: () => systemPrefersDark,
        })

        return mediaQuery
      }) as unknown as typeof window.matchMedia

    const emitSystemChange = () => {
      const event = { matches: systemPrefersDark } as MediaQueryListEvent
      listeners.forEach(listener => listener(event))
    }

    const recordSnapshot = (snapshot: Snapshot) => {
      const last = snapshots[snapshots.length - 1]

      if (!last || last.theme !== snapshot.theme || last.resolvedTheme !== snapshot.resolvedTheme) {
        snapshots.push(snapshot)
      }
    }

    const requireSetTheme = () => {
      if (!updateTheme) {
        throw new Error("Theme updater is not available")
      }

      return updateTheme
    }

    const getLatestSnapshot = () => {
      const snapshot = snapshots[snapshots.length - 1]

      if (!snapshot) {
        throw new Error("No theme snapshot was recorded")
      }

      return snapshot
    }

    localStorage.setItem(storageKey, "dark")

    function Consumer() {
      const context = useTheme()

      useEffect(() => {
        updateTheme = context.setTheme
        recordSnapshot({ theme: context.theme, resolvedTheme: context.resolvedTheme })
      }, [context.theme, context.resolvedTheme, context.setTheme])

      return null
    }

    await act(async () => {
      root?.render(
        <ThemeProvider storageKey={storageKey} defaultTheme="system">
          <Consumer />
        </ThemeProvider>
      )
    })

    await flushEffects()

    expect(getLatestSnapshot()).toEqual({ theme: "dark", resolvedTheme: "dark" })
    expect(localStorage.getItem(storageKey)).toBe("dark")
    expect(document.documentElement.classList.contains("dark")).toBe(true)

    await act(async () => {
      requireSetTheme()("light")
    })

    await flushEffects()

    expect(getLatestSnapshot()).toEqual({ theme: "light", resolvedTheme: "light" })
    expect(localStorage.getItem(storageKey)).toBe("light")
    expect(document.documentElement.classList.contains("light")).toBe(true)

    systemPrefersDark = true

    await act(async () => {
      requireSetTheme()("system")
    })

    await flushEffects()

    expect(getLatestSnapshot()).toEqual({ theme: "system", resolvedTheme: "dark" })
    expect(localStorage.getItem(storageKey)).toBe("system")
    expect(document.documentElement.classList.contains("dark")).toBe(true)

    systemPrefersDark = false
    emitSystemChange()

    await flushEffects()

    expect(getLatestSnapshot()).toEqual({ theme: "system", resolvedTheme: "light" })
    expect(document.documentElement.classList.contains("light")).toBe(true)
  })
})
client/src/components/theme-provider.tsx
+89-24
import React, { createContext } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
  forcedTheme?: "light" | "dark"
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
  resolvedTheme: "dark" | "light"
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
  resolvedTheme: "light",
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

const isTheme = (value: string): value is Theme => value === "light" || value === "dark" || value === "system"

const getSystemPreference = () => {
  if (typeof window === "undefined" || typeof window.matchMedia !== "function") {
    return "light" as const
  }

  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
}

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "thottopilot-ui-theme",
  forcedTheme,
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = React.useState<Theme>(
    () => forcedTheme || (typeof localStorage !== 'undefined' ? localStorage.getItem(storageKey) as Theme : null) || defaultTheme
  const readStoredTheme = (): Theme | null => {
    if (typeof window === "undefined" || !("localStorage" in window)) {
      return null
    }

    try {
      const storedValue = window.localStorage.getItem(storageKey)

      if (storedValue && isTheme(storedValue)) {
        return storedValue
      }
    } catch {
      return null
    }

    return null
  }

  const initialTheme = forcedTheme ?? readStoredTheme() ?? defaultTheme

  const [theme, setThemeState] = React.useState<Theme>(initialTheme)
  const [resolvedTheme, setResolvedTheme] = React.useState<"dark" | "light">(
    forcedTheme ?? (initialTheme === "system" ? getSystemPreference() : initialTheme)
  )

  const setTheme = React.useCallback(
    (value: Theme) => {
      setThemeState(value)

      if (typeof window === "undefined" || !("localStorage" in window)) {
        return
      }

      try {
        window.localStorage.setItem(storageKey, value)
      } catch {
        // Ignore write errors such as private browsing restrictions
      }
    },
    [storageKey]
  )
  const [resolvedTheme, setResolvedTheme] = React.useState<"dark" | "light">(forcedTheme || "light")

  React.useEffect(() => {
    const root = window.document.documentElement
    setResolvedTheme(forcedTheme ?? (theme === "system" ? getSystemPreference() : theme))
  }, [theme, forcedTheme])

  React.useEffect(() => {
    if (typeof document === "undefined") {
      return
    }

    const root = document.documentElement
    root.classList.remove("light", "dark")
    root.classList.add(resolvedTheme)
  }, [resolvedTheme])

    let systemTheme: "dark" | "light" = "light"
    
    if (theme === "system") {
      systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"
  React.useEffect(() => {
    if (
      typeof window === "undefined" ||
      typeof window.matchMedia !== "function" ||
      forcedTheme ||
      theme !== "system"
    ) {
      return
    }

    const finalResolvedTheme = forcedTheme || (theme === "system" ? systemTheme : theme)
    setResolvedTheme(finalResolvedTheme)
    root.classList.add(finalResolvedTheme)
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)")

    const handleChange = (event: MediaQueryListEvent) => {
      setResolvedTheme(event.matches ? "dark" : "light")
    }

    if (typeof mediaQuery.addEventListener === "function") {
      mediaQuery.addEventListener("change", handleChange)
      return () => mediaQuery.removeEventListener("change", handleChange)
    }

    mediaQuery.addListener(handleChange)
    return () => mediaQuery.removeListener(handleChange)
  }, [theme, forcedTheme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem(storageKey, theme)
      }
      setTheme(theme)
    },
    resolvedTheme,
  }
  const value = React.useMemo(
    () => ({
      theme,
      setTheme,
      resolvedTheme,
    }),
    [theme, setTheme, resolvedTheme]
  )

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = React.useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
client/src/pages/reddit-posting.tsx
+0-38
@@ -625,88 +625,50 @@ export default function RedditPostingPage() {
                          <img 
                            src={imagePreview} 
                            alt="Preview" 
                            className="max-w-full h-auto max-h-64 mx-auto rounded" 
                            data-testid="img-preview"
                          />
                        </div>
                      </div>
                    )}
                  </div>
                )}

                {postType === 'gallery' && (
                  <MediaLibrarySelector
                    assets={mediaAssets}
                    selectedIds={selectedMediaIds}
                    onToggle={toggleMediaSelection}
                    captions={mediaCaptions}
                    onCaptionChange={handleCaptionChange}
                    maxSelection={20}
                    isLoading={mediaLoading}
                    showCaptions={true}
                  />
                )}

                {postType === 'gallery' && false && (
                  <div className="space-y-4">
                    <div className="space-y-2">
                      <Label htmlFor="gallery">Select Images (Max 20)</Label>
                      <Input
                        id="gallery"
                        type="file"
                        accept="image/*"
                        multiple
                        onChange={handleGallerySelect}
                        className="cursor-pointer"
                        data-testid="input-gallery-upload-old"
                      />
                    </div>
                    {galleryFiles.length > 0 && (
                      <div className="space-y-2">
                        <Label>Preview ({galleryFiles.length} images)</Label>
                        <div className="grid grid-cols-3 gap-2 p-4 border-2 border-dashed border-pink-300 rounded-lg">
                          {galleryFiles.slice(0, 9).map((file, index) => (
                            <div key={index} className="relative">
                              <img
                                src={URL.createObjectURL(file)}
                                alt={`Gallery ${index + 1}`}
                                className="w-full h-20 object-cover rounded"
                                data-testid={`img-gallery-preview-${index}`}
                              />
                              {index === 8 && galleryFiles.length > 9 && (
                                <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded text-white text-sm">
                                  +{galleryFiles.length - 9} more
                                </div>
                              )}
                            </div>
                          ))}\n                        </div>
                      </div>
                    )}
                  </div>
                )}

                {postType === 'text' && (
                  <div className="space-y-2">
                    <Label htmlFor="body">Content (Optional)</Label>
                    <Textarea
                      id="body"
                      value={body}
                      onChange={(e) => setBody(e.target.value)}
                      rows={6}
                      maxLength={10000}
                      data-testid="textarea-body"
                    />
                    <div className="text-xs text-gray-500 text-right">{body.length}/10,000</div>
                  </div>
                )}

                {postType === 'link' && (
                  <div className="space-y-2">
                    <Label htmlFor="url">URL</Label>
                    <Input
                      id="url"
                      value={url}
                      onChange={(e) => setUrl(e.target.value)}
                      type="url"
                      data-testid="input-url"
                    />
server/caption/rewritePipeline.ts
+1-1
@@ -156,51 +156,51 @@ export async function extractFacts(imageUrl:string){

type RewriteVariantsParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  existingCaption:string;
  facts?:Record<string, unknown>;
  hint?:string;
  nsfw?:boolean;
  doNotDrop?: string[];
  style?: string;
  mood?: string
};

const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 3;

export async function variantsRewrite(params: RewriteVariantsParams) {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rewrite.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  let variants: any[] = [];
  const variants: Array<Record<string, unknown>> = [];

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;
    
    const voiceContext = formatVoiceContext(params.voice);
    const user = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      voiceContext,
      params.style ? `STYLE: ${params.style}` : "",
      params.mood ? `MOOD: ${params.mood}` : "",
      `EXISTING_CAPTION: ${serializePromptField(params.existingCaption)}`,
      params.facts ? `IMAGE_FACTS: ${JSON.stringify(params.facts)}` : "",
      `NSFW: ${params.nsfw || false}`,
      currentHint ? `HINT:${serializePromptField(currentHint, { block: true })}` : "",
    ].filter((line): line is string => Boolean(line)).join("\n");
    
    const voiceGuide = buildVoiceGuideBlock(params.voice);
    const promptSections = [sys, guard, prompt, user];
    if (voiceGuide) promptSections.push(voiceGuide);
    
    let res;
    try {
      res = await textModel.generateContent([{ text: promptSections.join("\n") }]);
    } catch (error) {
