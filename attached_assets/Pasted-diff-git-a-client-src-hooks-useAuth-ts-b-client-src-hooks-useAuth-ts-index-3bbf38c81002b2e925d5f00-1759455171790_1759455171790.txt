diff --git a/client/src/hooks/useAuth.ts b/client/src/hooks/useAuth.ts
index 3bbf38c81002b2e925d5f009d8227e02dbbc067a..377b3a78bfcb573efea08dc7dbcbe8f0ae0f7c34 100644
--- a/client/src/hooks/useAuth.ts
+++ b/client/src/hooks/useAuth.ts
@@ -1,68 +1,71 @@
 import { useEffect } from 'react';
 import { useQuery, useQueryClient } from '@tanstack/react-query';
 
 interface User {
   id: number;
   email: string;
   username?: string;
   displayName?: string;
   tier?: 'free' | 'starter' | 'pro';
   subscription?: string;
   isAdmin?: boolean;
   subscription_status?: string;
   role?: string;
+  emailVerified?: boolean;
+  bannedAt?: string | null;
+  suspendedUntil?: string | null;
 }
 
 export function useAuth() {
   const queryClient = useQueryClient();
 
   // Check if we're on a public page that doesn't need auth
   const isPublicPage = () => {
     const path = window.location.pathname;
     const publicPaths = [
       '/forgot-password',
       '/reset-password',
       '/email-verification',
       '/change-password'
     ];
     return publicPaths.includes(path);
   };
 
-  const { data: user, isLoading, error: _error, refetch } = useQuery<User>({
+  const { data: user, isLoading, error: _error, refetch } = useQuery<User | null>({
     queryKey: ['/api/auth/user'],
     queryFn: async () => {
       // Use cookie-based authentication only
       const response = await fetch('/api/auth/user', {
         credentials: 'include' // Include cookies for session-based auth
       });
       
       if (response.ok) {
         const userData = await response.json();
-        return userData;
+        return userData ?? null;
       }
-      
+
       // Return null instead of throwing error to allow guest mode
       return null;
     },
     retry: false,
     // Skip request on public pages
     enabled: !isPublicPage(),
     refetchOnWindowFocus: false,
     refetchInterval: false,
   });
 
   const login = () => {
     // Cookie-based auth - just refetch user data
     setTimeout(() => refetch(), 100); // Small delay to ensure cookie is set
   };
 
   const logout = async () => {
     // Invalidate user cache immediately
     queryClient.removeQueries({ queryKey: ['/api/auth/user'] });
     
     // Ensure UI updates instantly
     queryClient.setQueryData(['/api/auth/user'], null);
     
     // Logout from session (clears HTTP-only cookie)
     try {
       const response = await fetch('/api/auth/logout', {
diff --git a/client/src/hooks/useAuth.ts b/client/src/hooks/useAuth.ts
index 3bbf38c81002b2e925d5f009d8227e02dbbc067a..377b3a78bfcb573efea08dc7dbcbe8f0ae0f7c34 100644
--- a/client/src/hooks/useAuth.ts
+++ b/client/src/hooks/useAuth.ts
@@ -132,35 +135,45 @@ export function useAuth() {
     }
     
     try {
       const email = import.meta.env.VITE_ADMIN_EMAIL;
       const password = import.meta.env.VITE_ADMIN_PASSWORD;
 
       if (!email || !password) {
         throw new Error('Admin credentials not configured');
       }
 
       const response = await fetch('/api/auth/login', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ email, password })
       });
       
       if (response.ok) {
         const _data = await response.json();
         login();
       }
     } catch (_error) {
       // Silent fail in production
     }
   };
 
+  const isVerified = Boolean(user?.emailVerified);
+  const isBanned = Boolean(user?.bannedAt);
+  const suspensionDate = user?.suspendedUntil ? new Date(user.suspendedUntil) : null;
+  const isSuspended = Boolean(
+    suspensionDate && !Number.isNaN(suspensionDate.getTime()) && suspensionDate.getTime() > Date.now()
+  );
+  const hasFullAccess = Boolean(user && isVerified && !isBanned && !isSuspended);
+
   return {
     user,
     isLoading,
     isAuthenticated: !!user,
+    isVerified,
+    hasFullAccess,
     login,
     logout,
     refetch,
     ...(import.meta.env.MODE === 'development' && { quickAdminLogin })
   };
 }
