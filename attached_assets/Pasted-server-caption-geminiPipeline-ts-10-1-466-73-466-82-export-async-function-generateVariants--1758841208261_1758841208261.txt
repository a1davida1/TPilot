server/caption/geminiPipeline.ts
+10-1
@@ -466,73 +466,82 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i

    const combinedHint = hintParts.filter(Boolean).join(" ");
    const serializedHint = serializePromptField(combinedHint, { block: true });
    lines.push(`HINT:${serializedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
      ]);
      const json = stripToJSON(res.response.text()) as unknown;
      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error("Gemini textModel.generateContent failed:", error);
      throw error;
    }
  };

  const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
  const existingCaptions: string[] = [];
  const duplicatesThisAttempt: string[] = [];
  let hasBannedWords = false;
  const isTest = process.env.NODE_ENV === 'test';
  const maxAttempts = isTest ? 2 : 5; // Allow 2 attempts in test for retry logic testing

  for (let attempt = 0; attempt < maxAttempts && uniqueVariants.length < 5; attempt += 1) {
    const needed = 5 - uniqueVariants.length;
    const varietyHint = attempt === 0
      ? params.hint
      : (() => {
          // Build complete base hint with variety clause first, then pass to buildRetryHint
          const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and imagery.`;
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
          const baseHintWithModeration = hasBannedWords
            ? `${baseHintWithVariety} ${BANNED_WORDS_HINT}`.trim()
            : baseHintWithVariety;
          return buildRetryHint(baseHintWithModeration, duplicatesThisAttempt, needed);
        })();

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      if (variantContainsBannedWord(sanitized as { caption?: unknown; cta?: unknown; hashtags?: unknown; alt?: unknown })) {
        hasBannedWords = true;
        continue;
      }

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Engaging social media content",
      alt: "Detailed alt text describing the scene",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
server/caption/textOnlyPipeline.ts
+10-1
@@ -258,73 +258,82 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P
    hintParts.push("Provide five options that vary tone, structure, and specific content themes.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    lines.push(`HINT: ${combinedHint}`);

    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
      ]);
      const json = stripToJSON(res.response.text());
      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error("Gemini textModel.generateContent failed:", error);
      throw error;
    }
  };

  const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
  const existingCaptions: string[] = [];
  const duplicatesThisAttempt: string[] = [];
  let hasBannedWords = false;
  const isTest = process.env.NODE_ENV === 'test';
  const maxAttempts = isTest ? 2 : 5; // Allow 2 attempts in test for retry logic testing

  for (let attempt = 0; attempt < maxAttempts && uniqueVariants.length < 5; attempt += 1) {
    const needed = 5 - uniqueVariants.length;
    const varietyHint = attempt === 0
      ? params.hint
      : (() => {
          // Build complete base hint with variety clause first, then pass to buildRetryHint
          const baseHintWithVariety = `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and themes.`;
          return buildRetryHint(baseHintWithVariety, duplicatesThisAttempt, needed);
          const baseHintWithModeration = hasBannedWords
            ? `${baseHintWithVariety} ${BANNED_WORDS_HINT}`.trim()
            : baseHintWithVariety;
          return buildRetryHint(baseHintWithModeration, duplicatesThisAttempt, needed);
        })();

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);
    duplicatesThisAttempt.length = 0; // Reset for this attempt

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      if (variantContainsBannedWord(sanitized as { caption?: unknown; cta?: unknown; hashtags?: unknown; alt?: unknown })) {
        hasBannedWords = true;
        continue;
      }

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        duplicatesThisAttempt.push(captionText); // Track duplicates for retry hint
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }

  // Pad variants if we don't have enough, instead of throwing in tests
  while (uniqueVariants.length < 5) {
    const baseVariant = uniqueVariants[0] || {
      caption: "Text-only social media content",
      alt: "Detailed alt text describing the theme",
      hashtags: ["#social", "#content"],
      cta: "Check it out",
      mood: "engaging",
      style: "authentic",
      safety_level: "normal",
      nsfw: false
    };

    // Create a slight variation by appending index
tests/routes/caption-generation.test.ts
+100-2
import { describe, it, expect, beforeEach, vi, type Mock } from 'vitest';
import { pipeline } from '../../server/caption/geminiPipeline.js';
import { generateVariants, pipeline } from '../../server/caption/geminiPipeline.js';
import { pipelineRewrite, extractKeyEntities } from '../../server/caption/rewritePipeline.js';
import { pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';
import { generateVariantsTextOnly, pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';
import { BANNED_WORDS_HINT, variantContainsBannedWord } from '../../server/caption/bannedWords.js';

// Mock dependencies
vi.mock('../../server/lib/gemini.js', () => ({
  textModel: {
    generateContent: vi.fn(),
  },
  visionModel: {
    generateContent: vi.fn(),
  },
}));

import { CaptionItem } from '../../server/caption/schema.js';

vi.mock('../../server/caption/openaiFallback.js', () => ({
  openAICaptionFallback: vi.fn().mockResolvedValue({
    caption: 'Fallback caption',
    hashtags: ['#fallback1', '#fallback2', '#fallback3'],
    safety_level: 'normal',
    alt: 'Fallback alt text that is sufficiently long',
    mood: 'neutral',
    style: 'informative',
    cta: 'Check this out',
    nsfw: false,
  }),
}));
@@ -1564,45 +1565,142 @@ describe('Caption Generation', () => {
      expect((result.final as CaptionResult).caption).toContain('"Mega Launch"');
      expect((result.final as CaptionResult).caption).toContain('MegaCorp™');

      textGenerateMock.mockReset();
    });

    it('enforces fact coverage when image context is available', async () => {
      // Simple test to verify the fact coverage feature exists and functions
      const { ensureFactCoverage } = await import('../../server/caption/ensureFactCoverage.js');
      const facts = { camera: 'Canon 5D', setting: 'rooftop at sunset' };
      const caption = 'Having fun today';
      const alt = 'Photo description';
      
      const result = ensureFactCoverage({ facts, caption, alt });
      
      // Test that ensureFactCoverage returns expected structure
      expect(result).toHaveProperty('ok');
      expect(typeof result.ok).toBe('boolean');
      
      if (!result.ok) {
        expect(result).toHaveProperty('hint');
        expect(typeof result.hint).toBe('string');
      }
    });
  });

  describe('Variant generation banned word handling', () => {
    it('filters banned words from Gemini image variants and requests rewrite', async () => {
      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);

      const bannedVariants = Array.from({ length: 5 }, (_, index) => ({
        caption: `AI glow ${index}`,
        hashtags: ['#style', '#evening'],
        safety_level: 'normal',
        mood: 'confident',
        style: 'modern',
        cta: `Check this AI look ${index}`,
        alt: 'Alt text describing AI styled lighting with detailed wardrobe highlights.',
        nsfw: false,
      }));

      const safeVariants = Array.from({ length: 5 }, (_, index) => ({
        caption: `Radiant runway energy ${index}`,
        hashtags: ['#runway', '#glow'],
        safety_level: 'normal',
        mood: 'confident',
        style: 'modern',
        cta: `Share the vibe ${index}`,
        alt: 'Alt text describing a confident model under warm lighting with runway styling cues.',
        nsfw: false,
      }));

      textGenerateMock
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(bannedVariants) } })
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(safeVariants) } });

      const result = await generateVariants({
        platform: 'instagram',
        voice: 'playful',
        facts: { scene: 'studio' },
        nsfw: false,
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const secondPromptCall = (textGenerateMock.mock.calls[1]?.[0] as Array<{ text: string }>)[0]?.text ?? '';
      expect(secondPromptCall).toContain(BANNED_WORDS_HINT);

      expect(result).toHaveLength(5);
      result.forEach((variant) => {
        expect(variantContainsBannedWord(variant)).toBe(false);
      });
    });

    it('filters banned words from text-only variants and requests rewrite', async () => {
      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);

      const bannedVariants = Array.from({ length: 5 }, (_, index) => ({
        caption: `AI inspiration ${index}`,
        hashtags: ['#daily', '#motivation'],
        safety_level: 'normal',
        mood: 'optimistic',
        style: 'uplifting',
        cta: `Discover this AI idea ${index}`,
        alt: 'Alt text capturing AI focused storytelling prompts in rich descriptive language.',
        nsfw: false,
      }));

      const safeVariants = Array.from({ length: 5 }, (_, index) => ({
        caption: `Morning momentum spark ${index}`,
        hashtags: ['#morning', '#momentum'],
        safety_level: 'normal',
        mood: 'optimistic',
        style: 'uplifting',
        cta: `Start strong today ${index}`,
        alt: 'Alt text describing motivational imagery cues with bright tones and encouraging language.',
        nsfw: false,
      }));

      textGenerateMock
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(bannedVariants) } })
        .mockResolvedValueOnce({ response: { text: () => JSON.stringify(safeVariants) } });

      const result = await generateVariantsTextOnly({
        platform: 'instagram',
        voice: 'playful',
        theme: 'Morning motivation',
        context: 'Share an encouraging note for followers',
        nsfw: false,
      });

      expect(textGenerateMock).toHaveBeenCalledTimes(2);
      const secondPromptCall = (textGenerateMock.mock.calls[1]?.[0] as Array<{ text: string }>)[0]?.text ?? '';
      expect(secondPromptCall).toContain(BANNED_WORDS_HINT);

      expect(result).toHaveLength(5);
      result.forEach((variant) => {
        expect(variantContainsBannedWord(variant)).toBe(false);
      });
    });
  });
});

describe('extractKeyEntities', () => {
  it('captures urls, handles, hashtags, numbers, quotes, and branded terms', () => {
    const caption = 'Launch day 2024! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ and NASA #LaunchDay';
    const entities = extractKeyEntities(caption);

    expect(entities).toEqual([
      '2024',
      'RSVP',
      'https://example.com/launch',
      '@LaunchHQ',
      '12/25',
      '"Mega Launch"',
      'MegaCorp',
      'NASA',
      '#LaunchDay',
    ]);
  });
});
