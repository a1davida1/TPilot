You are a release engineer. Fix the repeating deploy prompt:
“Development database changes detected → Is feature_flags created or renamed from saved_content?”

Goal: Inspect the live Postgres DB (via $DATABASE_URL), choose ONE deterministic path (RENAME or CREATE+COPY), write a single idempotent migration, run it, and verify so the prompt never reappears.

Environment assumptions:
- Postgres URL in $DATABASE_URL.
- Project may use Prisma (schema.prisma) or not.
- psql might or might not be installed.

--- PLAN ---

0) Detect project/ORM:
- If ./prisma/schema.prisma exists → Prisma mode.
- Else → Raw SQL mode.

1) Inspect DB (use psql if available; otherwise use a Node one-liner with the "pg" library):
- List tables:
  SELECT tablename FROM pg_tables WHERE schemaname='public' AND tablename IN ('saved_content','feature_flags');
- Row counts (guarded):
  DO $$
  BEGIN
    IF to_regclass('public.saved_content') IS NOT NULL THEN
      RAISE NOTICE 'saved_content rows=%', (SELECT count(*) FROM public.saved_content);
    ELSE
      RAISE NOTICE 'saved_content does not exist';
    END IF;

    IF to_regclass('public.feature_flags') IS NOT NULL THEN
      RAISE NOTICE 'feature_flags rows=%', (SELECT count(*) FROM public.feature_flags);
    ELSE
      RAISE NOTICE 'feature_flags does not exist';
    END IF;
  END $$;

- Column shapes:
  SELECT table_name, column_name, data_type, is_nullable
  FROM information_schema.columns
  WHERE table_schema='public' AND table_name IN ('saved_content','feature_flags')
  ORDER BY table_name, ordinal_position;

2) Decide path using these rules:
- Only saved_content exists → choose RENAME path.
- Only feature_flags exists → keep it; do no rename; ensure schema matches app; remove conflicting migrations.
- Both exist & feature_flags has 0 rows but saved_content has rows → choose CREATE+COPY (or drop empty feature_flags and RENAME).
- Both exist & feature_flags has rows → keep feature_flags, retire saved_content.

3) Prepare the SQL for the chosen path (edit column mappings only if needed based on inspection):

-- SQL_RENAME (idempotent):
BEGIN;
DO $$
BEGIN
  IF to_regclass('public.feature_flags') IS NULL
     AND to_regclass('public.saved_content') IS NOT NULL THEN
    ALTER TABLE public.saved_content RENAME TO feature_flags;
  END IF;
END $$;

ALTER TABLE public.feature_flags
  ADD COLUMN IF NOT EXISTS id BIGSERIAL PRIMARY KEY,
  ADD COLUMN IF NOT EXISTS key TEXT UNIQUE,
  ADD COLUMN IF NOT EXISTS enabled BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT now();
COMMIT;

-- SQL_CREATE_COPY (idempotent; adjust SELECT list if old column names differ):
BEGIN;
CREATE TABLE IF NOT EXISTS public.feature_flags (
  id BIGSERIAL PRIMARY KEY,
  key TEXT UNIQUE,
  enabled BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

DO $$
BEGIN
  IF to_regclass('public.saved_content') IS NOT NULL THEN
    INSERT INTO public.feature_flags (key, enabled, created_at)
    SELECT sc.key, COALESCE(sc.enabled, false), COALESCE(sc.created_at, now())
    FROM public.saved_content sc
    ON CONFLICT (key) DO NOTHING;
  END IF;
END $$;
COMMIT;

(If saved_content uses different column names, map likely synonyms:
- key ← (key|feature_key|flag|name)
- enabled ← (enabled|is_enabled|active)
- created_at ← (created_at|created|inserted_at|createdAt)
Adjust the SELECT accordingly.)

4) Implement ONE migration:

4a) Prisma mode:
- Create a migration folder prisma/migrations/20250820_feature_flags_fix/ with migration.sql containing the chosen SQL.
- Ensure schema.prisma model maps to @@map("feature_flags") and fields map to column names (@map).
- Remove or resolve earlier conflicting migrations that create/rename the same table:
  - If DB already matches but history doesn’t, run:
    npx prisma migrate resolve --applied 20250820_feature_flags_fix
- Apply:
  npx prisma migrate dev --name feature-flags-fix
- Verify:
  npx prisma studio (optional)
  and run the verification queries from step 1 again.

4b) Raw SQL mode:
- Create directory migrations/sql if needed.
- Write migrations/sql/20250820_feature_flags_fix.sql with the chosen SQL.
- Apply with psql:
  psql "$DATABASE_URL" -f migrations/sql/20250820_feature_flags_fix.sql
- Verify by re-running the queries in step 1.

5) (Optional) Retire old table safely:
- If we kept feature_flags and migrated data, rename old table to saved_content_old:
  ALTER TABLE IF EXISTS public.saved_content RENAME TO saved_content_old;
(Only if you’re certain the backfill/rename is correct. Do NOT DROP in the same migration.)

6) Output:
- Print which path was taken (RENAME vs CREATE+COPY), the migration file path, and the verification results:
  - SELECT tablename… → confirm feature_flags exists.
  - SELECT count(*) FROM public.feature_flags;
  - \d+ public.feature_flags (or info_schema) to show final columns.

Deliverables to show in the console at the end:
- Decision taken
- Migration file written
- Migration apply success
- Final row counts and schema summary
