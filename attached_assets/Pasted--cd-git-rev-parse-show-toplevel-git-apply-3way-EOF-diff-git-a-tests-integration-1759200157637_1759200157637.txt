 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/integration/csrf-smoke.test.ts b/tests/integration/csrf-smoke.test.ts
index fcf2e462ea9410763ddccf1ea96e41b781e3e6c6..8f72c2b7bd0ff47297a707faae04d26206d2c311 100644
--- a/tests/integration/csrf-smoke.test.ts
+++ b/tests/integration/csrf-smoke.test.ts
@@ -123,87 +123,101 @@ describe('Real route CSRF protection', () => {
     });
     app = createdApp;
     httpServer = server;
     agent = request.agent(app);
   });
 
   beforeEach(async () => {
     const response = await agent.get('/api/csrf-token').expect(200);
     csrfToken = response.body?.csrfToken as string;
   });
 
   afterAll(async () => {
     if (httpServer && httpServer.listening) {
       await new Promise<void>((resolve, reject) => {
         httpServer.close(error => {
           if (error) {
             reject(error);
             return;
           }
           resolve();
         });
       });
     }
   });
 
+  it('issues CSRF tokens without requiring an existing CSRF header', async () => {
+    const isolatedAgent = request.agent(app);
+    const response = await isolatedAgent.get('/api/csrf-token').expect(200);
+
+    expect(typeof response.body?.csrfToken).toBe('string');
+    expect((response.body?.csrfToken as string).length).toBeGreaterThan(10);
+  });
+
   it('rejects forged POST /api/reddit/submit requests without a CSRF token', async () => {
     const response = await agent
       .post('/api/reddit/submit')
       .send({
         subreddit: 'unit_tests',
         title: 'Forged CSRF attempt',
         kind: 'text',
         body: 'This should never reach the handler.'
       });
 
     expect(response.status).toBe(403);
-    expect(response.body).toHaveProperty('error');
-    expect(String(response.body.error)).toContain('invalid csrf token');
+    expect(response.body).toMatchObject({
+      message: 'Invalid CSRF token',
+      code: 'CSRF_TOKEN_INVALID'
+    });
   });
 
   it('rejects forged POST /api/auth/forgot-password requests without a CSRF token', async () => {
     const response = await agent
       .post('/api/auth/forgot-password')
       .send({ email: 'test-user@example.com' });
 
     expect(response.status).toBe(403);
-    expect(response.body).toHaveProperty('error');
-    expect(String(response.body.error)).toContain('invalid csrf token');
+    expect(response.body).toMatchObject({
+      message: 'Invalid CSRF token',
+      code: 'CSRF_TOKEN_INVALID'
+    });
   });
 
   it('allows POST /api/auth/login to proceed when a CSRF token is provided', async () => {
     const response = await agent
       .post('/api/auth/login')
       .send({ username: 'unknown-user', password: 'invalid-password', _csrf: csrfToken });
 
     expect(response.status).toBe(401);
     expect(response.body).toMatchObject({ message: 'Invalid credentials' });
   });
 
   it('allows POST /api/auth/forgot-password to reach its handler when a CSRF token is provided', async () => {
     const response = await agent
       .post('/api/auth/forgot-password')
       .send({ email: 'test-user@example.com', _csrf: csrfToken });
 
     expect(response.status).toBe(200);
     expect(response.body).toMatchObject({ message: expect.stringMatching(/reset/i) });
   });
 
   it('rejects forged POST /api/billing/checkout requests without a CSRF token', async () => {
     const response = await agent
       .post('/api/billing/checkout')
       .send({ priceId: 'price_test' });
 
     expect(response.status).toBe(403);
-    expect(response.body).toHaveProperty('error');
-    expect(String(response.body.error)).toContain('invalid csrf token');
+    expect(response.body).toMatchObject({
+      message: 'Invalid CSRF token',
+      code: 'CSRF_TOKEN_INVALID'
+    });
   });
 
   it('allows POST /api/billing/checkout to reach authentication when a CSRF token is provided', async () => {
     const response = await agent
       .post('/api/billing/checkout')
       .send({ priceId: 'price_test', _csrf: csrfToken });
 
     expect(response.status).toBe(401);
     expect(response.body).toMatchObject({ error: 'unauthorized' });
   });
 });
 
EOF
)