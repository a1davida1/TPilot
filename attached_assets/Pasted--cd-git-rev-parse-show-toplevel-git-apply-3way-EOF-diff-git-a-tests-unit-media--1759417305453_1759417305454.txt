 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/unit/media/media-manager.test.ts b/tests/unit/media/media-manager.test.ts
index 8b0002e8747affc63349d96be31fd22e02abe1f8..e7405379b07e3a62a974c31db40223483c513669 100644
--- a/tests/unit/media/media-manager.test.ts
+++ b/tests/unit/media/media-manager.test.ts
@@ -1,25 +1,26 @@
+import sharp from 'sharp';
 import { beforeEach, describe, expect, it, vi } from 'vitest';
 
 const mockDb = vi.hoisted(() => ({
   select: vi.fn(),
 }));
 
 const mockConfig = vi.hoisted(() => ({
   mediaQuotas: {
     free: 500,
     pro: 5_000,
     premium: 10_000,
   },
   watermark: {
     enabled: false,
     text: 'Test',
     opacity: 0.5,
   },
   signedUrlTTL: 900,
 }));
 
 vi.mock('../../../server/db.ts', () => ({
   db: mockDb,
 }));
 
 vi.mock('../../../server/lib/config.ts', () => ({
diff --git a/tests/unit/media/media-manager.test.ts b/tests/unit/media/media-manager.test.ts
index 8b0002e8747affc63349d96be31fd22e02abe1f8..e7405379b07e3a62a974c31db40223483c513669 100644
--- a/tests/unit/media/media-manager.test.ts
+++ b/tests/unit/media/media-manager.test.ts
@@ -63,26 +64,94 @@ describe('MediaManager.getUserStorageUsage', () => {
     expect(mockDb.select).toHaveBeenCalledTimes(2);
   });
 
   it('returns configured pro tier quota for pro users', async () => {
     const { MediaManager } = await import('../../../server/lib/media.ts');
 
     mockDb.select
       .mockImplementationOnce(() => ({
         from: () => ({
           where: () => Promise.resolve([{ totalBytes: 1_024 }]),
         }),
       }))
       .mockImplementationOnce(() => ({
         from: () => ({
           where: () => ({
             limit: () => Promise.resolve([{ tier: 'pro' }]),
           }),
         }),
       }));
 
     const usage = await MediaManager.getUserStorageUsage(2);
 
     expect(usage).toEqual({ used: 1_024, quota: mockConfig.mediaQuotas.pro });
     expect(mockDb.select).toHaveBeenCalledTimes(2);
   });
-});
+});
+
+describe('MediaManager.processImage', () => {
+  it('preserves transparency for PNG uploads', async () => {
+    const { MediaManager } = await import('../../../server/lib/media.ts');
+
+    const transparentPng = await sharp({
+      create: {
+        width: 2,
+        height: 2,
+        channels: 4,
+        background: { r: 0, g: 0, b: 255, alpha: 0 },
+      },
+    })
+      .png()
+      .toBuffer();
+
+    const result = await MediaManager.processImage(transparentPng, {
+      applyWatermark: false,
+      quality: 90,
+    });
+
+    expect(result.mime).toBe('image/png');
+    expect(result.extension).toBe('png');
+
+    const metadata = await sharp(result.buffer, { animated: true }).metadata();
+    expect(metadata.format).toBe('png');
+    expect(metadata.hasAlpha ?? false).toBe(true);
+  });
+
+  it('retains animation frames for GIF uploads', async () => {
+    const { MediaManager } = await import('../../../server/lib/media.ts');
+
+    const animatedGif = await sharp({
+      create: {
+        width: 1,
+        height: 2,
+        channels: 4,
+        background: { r: 255, g: 0, b: 0, alpha: 1 },
+      },
+    })
+      .composite([
+        {
+          input: Buffer.from([0, 255, 0, 255]),
+          raw: { width: 1, height: 1, channels: 4 },
+          top: 1,
+          left: 0,
+        },
+      ])
+      .gif({
+        loop: 0,
+        delay: [100, 100],
+        pageHeight: 1,
+      })
+      .toBuffer();
+
+    const result = await MediaManager.processImage(animatedGif, {
+      applyWatermark: false,
+      quality: 90,
+    });
+
+    expect(result.mime).toBe('image/gif');
+    expect(result.extension).toBe('gif');
+
+    const metadata = await sharp(result.buffer, { animated: true }).metadata();
+    expect(metadata.format).toBe('gif');
+    expect((metadata.pages ?? 1) > 1).toBe(true);
+  });
+});
 
EOF
)