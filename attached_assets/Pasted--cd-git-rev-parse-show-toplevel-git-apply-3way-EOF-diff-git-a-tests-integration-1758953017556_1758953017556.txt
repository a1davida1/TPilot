 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/integration/csrf-smoke.test.ts b/tests/integration/csrf-smoke.test.ts
index 23bd0baa7fbc9c1f9c01fb41fe4dadaa96e847d1..5100fabb217e8fea180191ca2c56dbca87e1fac5 100644
--- a/tests/integration/csrf-smoke.test.ts
+++ b/tests/integration/csrf-smoke.test.ts
@@ -1,33 +1,34 @@
 import express, { type Request, type Response, type NextFunction } from 'express';
+import type { Server } from 'http';
 import session from 'express-session';
 import cookieParser from 'cookie-parser';
 import csrf from 'csurf';
 import request from 'supertest';
-import { describe, it, beforeAll, beforeEach, expect } from 'vitest';
+import { describe, it, beforeAll, beforeEach, afterAll, expect } from 'vitest';
 
-import { csrfProtectedRoutes } from '../../server/routes.js';
+import { csrfProtectedRoutes, registerRoutes } from '../../server/routes.js';
 
 declare module 'express-session' {
   interface SessionData {
     userId?: number;
   }
 }
 
 type CsrfScenario = {
   method: 'post' | 'patch' | 'delete';
   path: string;
 };
 
 describe('CSRF smoke tests for sensitive routes', () => {
   const scenarios: CsrfScenario[] = [
     { method: 'post', path: '/api/generate-content' },
     { method: 'post', path: '/api/reddit/submit' },
     { method: 'delete', path: '/api/auth/delete-account' },
     { method: 'patch', path: '/api/user/settings' }
   ];
 
   it('includes renamed endpoints in the CSRF protection list', () => {
     scenarios.forEach(({ path }) => {
       expect(csrfProtectedRoutes).toContain(path);
     });
   });
diff --git a/tests/integration/csrf-smoke.test.ts b/tests/integration/csrf-smoke.test.ts
index 23bd0baa7fbc9c1f9c01fb41fe4dadaa96e847d1..5100fabb217e8fea180191ca2c56dbca87e1fac5 100644
--- a/tests/integration/csrf-smoke.test.ts
+++ b/tests/integration/csrf-smoke.test.ts
@@ -83,26 +84,67 @@ describe('CSRF smoke tests for sensitive routes', () => {
         if (typeof err === 'object' && err !== null && (err as { code?: string }).code === 'EBADCSRFTOKEN') {
           res.status(403).json({
             message: 'Invalid CSRF token',
             code: 'CSRF_TOKEN_INVALID',
             path: req.path
           });
           return;
         }
         next(err);
       });
     });
 
     beforeEach(async () => {
       agent = request.agent(app);
       await agent.get('/session-init').expect(200);
     });
 
     scenarios.forEach(({ method, path }) => {
       it(`rejects forged ${method.toUpperCase()} ${path} requests without a CSRF token`, async () => {
         const response = await agent[method](path).send({});
         expect(response.status).toBe(403);
         expect(response.body).toHaveProperty('code', 'CSRF_TOKEN_INVALID');
       });
     });
   });
-});
+});
+
+describe('Real Reddit submission route CSRF protection', () => {
+  let app: express.Express;
+  let agent: request.SuperTest<request.Test>;
+  let httpServer: Server | undefined;
+
+  beforeAll(async () => {
+    app = express();
+    httpServer = await registerRoutes(app);
+    agent = request.agent(app);
+    await agent.get('/api/csrf-token').expect(200);
+  });
+
+  afterAll(async () => {
+    if (httpServer) {
+      await new Promise<void>((resolve, reject) => {
+        httpServer?.close(error => {
+          if (error) {
+            reject(error);
+            return;
+          }
+          resolve();
+        });
+      });
+    }
+  });
+
+  it('rejects forged POST /api/reddit/submit requests without a CSRF token', async () => {
+    const response = await agent
+      .post('/api/reddit/submit')
+      .send({
+        subreddit: 'unit_tests',
+        title: 'Forged CSRF attempt',
+        kind: 'text',
+        body: 'This should never reach the handler.'
+      });
+
+    expect(response.status).toBe(403);
+    expect(response.body).toMatchObject({ code: 'CSRF_TOKEN_INVALID' });
+  });
+});
 
EOF
)