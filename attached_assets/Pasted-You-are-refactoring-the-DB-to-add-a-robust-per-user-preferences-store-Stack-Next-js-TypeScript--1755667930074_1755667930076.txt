You are refactoring the DB to add a robust per-user preferences store.
Stack: Next.js + TypeScript + Prisma + Postgres.

## What to do (minimal diffs)
1) Add a Prisma model mapped to a `user_preferences` table with a unique (userId,prefKey).
2) Create a raw SQL migration that is **idempotent**:
   - If `user_preferences` doesn't exist:
     - If a table `saved_content` exists AND it already looks like a preferences table
       (has user_id and either pref_key/pref_value OR key/value), then **rename** it to `user_preferences`,
       auto-rename columns `key`->`pref_key`, `value`->`pref_value` if present, add any missing columns, and add a unique index on (user_id,pref_key).
     - ELSE create a brand-new `user_preferences` table with the canonical schema.
   - Do not drop data.
3) Add a tiny verification script to print row counts and schema.

## Prisma schema changes
- Edit `prisma/schema.prisma` and add this model (keep existing User model):

model UserPreferences {
  id         String   @id @default(uuid())
  userId     String
  prefKey    String
  prefValue  Json     @default("{}")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, prefKey])
  @@map("user_preferences")
}

## Migration (raw SQL)
- Create a new folder `prisma/migrations/20250820_user_preferences/`
- Add file `prisma/migrations/20250820_user_preferences/migration.sql` with EXACT contents:

DO $$
BEGIN
  -- Only act if user_preferences is missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='user_preferences'
  ) THEN

    -- If saved_content exists and looks like prefs, rename it
    IF EXISTS (
      SELECT 1 FROM information_schema.tables
      WHERE table_schema='public' AND table_name='saved_content'
    )
    AND EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema='public' AND table_name='saved_content' AND column_name='user_id'
    )
    AND (
      (
        EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='saved_content' AND column_name='pref_key')
        AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='saved_content' AND column_name='pref_value')
      ) OR (
        EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='saved_content' AND column_name='key')
        AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='saved_content' AND column_name='value')
      )
    ) THEN
      -- Rename table
      EXECUTE 'ALTER TABLE public.saved_content RENAME TO user_preferences';

      -- Rename legacy columns if present
      IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='key') THEN
        EXECUTE 'ALTER TABLE public.user_preferences RENAME COLUMN "key" TO pref_key';
      END IF;
      IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='value') THEN
        EXECUTE 'ALTER TABLE public.user_preferences RENAME COLUMN value TO pref_value';
      END IF;

      -- Ensure required columns exist
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='pref_key') THEN
        EXECUTE 'ALTER TABLE public.user_preferences ADD COLUMN pref_key text';
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='pref_value') THEN
        EXECUTE 'ALTER TABLE public.user_preferences ADD COLUMN pref_value jsonb NOT NULL DEFAULT ''{}''::jsonb';
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='created_at') THEN
        EXECUTE 'ALTER TABLE public.user_preferences ADD COLUMN created_at timestamptz NOT NULL DEFAULT now()';
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='user_preferences' AND column_name='updated_at') THEN
        EXECUTE 'ALTER TABLE public.user_preferences ADD COLUMN updated_at timestamptz NOT NULL DEFAULT now()';
      END IF;

      -- Unique index on (user_id, pref_key)
      IF NOT EXISTS (
        SELECT 1 FROM pg_indexes WHERE schemaname='public' AND indexname='user_preferences_user_key_uniq'
      ) THEN
        EXECUTE 'CREATE UNIQUE INDEX user_preferences_user_key_uniq ON public.user_preferences (user_id, pref_key)';
      END IF;

    ELSE
      -- Create fresh table
      EXECUTE $ct$
        CREATE TABLE public.user_preferences (
          id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id uuid NOT NULL,
          pref_key text NOT NULL,
          pref_value jsonb NOT NULL DEFAULT '{}'::jsonb,
          created_at timestamptz NOT NULL DEFAULT now(),
          updated_at timestamptz NOT NULL DEFAULT now(),
          CONSTRAINT user_preferences_user_fk
            FOREIGN KEY (user_id) REFERENCES "User"(id) ON DELETE CASCADE
        )
      $ct$;

      EXECUTE 'CREATE UNIQUE INDEX user_preferences_user_key_uniq ON public.user_preferences (user_id, pref_key)';
    END IF;

  END IF;
END$$;

-- Optional: trigger to keep updated_at fresh on updates
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname='set_updated_at') THEN
    CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
    BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.triggers
    WHERE event_object_table='user_preferences' AND trigger_name='trg_user_preferences_updated_at'
  ) THEN
    CREATE TRIGGER trg_user_preferences_updated_at
    BEFORE UPDATE ON public.user_preferences
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END$$;

## Verification script
- Create `scripts/check-user-preferences.sql` with:
SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name IN ('user_preferences','saved_content');
SELECT column_name, data_type FROM information_schema.columns WHERE table_name='user_preferences' ORDER BY ordinal_position;
SELECT COUNT(*) AS total_rows, COUNT(DISTINCT user_id) AS users FROM public.user_preferences;

## Final note
Do not change any other tables. Print a short summary of files changed when done.
