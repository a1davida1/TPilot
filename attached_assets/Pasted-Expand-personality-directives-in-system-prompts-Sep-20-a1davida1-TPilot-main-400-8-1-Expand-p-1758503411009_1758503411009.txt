Expand personality directives in system prompts
Sep 20 · a1davida1/TPilot · main
+400-8
1. Expand `prompts/system.txt` with explicit personality directives (e.g., “Sound like a creator talking to loyal fans; avoid corporate phrasing; prioritize sensory detail pulled from IMAGE\_FACTS”).
2. Revise `prompts/variants.txt` and `prompts/rewrite.txt` to specify audience hooks, subreddit norms, CTA guidance, and a checklist for authenticity (mention a concrete visual detail, use colloquial contractions, etc.).
3. Add a structured “voice traits” file (e.g., `prompts/voices.json`) referenced by the pipelines so the prompt can embed bullet-point traits per voice token; update code to inject it.
4. Document these upgrades in `docs/prompt-tuning.md` so PMs/ops can iterate quickly.

Summary

    Expanded the system, variants, and rewrite prompts with explicit creator-tone guidance, audience hooks, CTA expectations, authenticity checkpoints, and Reddit-specific norms to drive consistent voice.

Introduced prompts/voices.json and a shared formatter so every pipeline and the prompt builder inject persona, trait, hook, CTA, and authenticity bullet blocks for the selected voice token.

Documented the prompt-tuning workflow so PMs and ops can adjust voice traits and prompts without code changes.

Testing

    ✅ npm run lint (completes with existing warning noise)

⚠️ npm test (fails in existing suites that require external services/database URLs, e.g., ERR_INVALID_URL in Neon client and other pre-existing integration issues)


docs/prompt-tuning.md
New
+53-0
# Prompt Tuning Upgrades

This release wires structured voice guidance directly into every caption pipeline so PMs and ops can iterate without code changes.

## Voice trait profiles
- **Source file:** `prompts/voices.json`
- **Schema:**
  ```json
  {
    "voice_token": {
      "persona": "string",
      "traits": ["bullet"],
      "hooks": ["bullet"],
      "cta": ["bullet"],
      "authenticity": ["bullet"],
      "subredditNotes": ["optional bullet"]
    }
  }
  ```
- **Usage notes:**
  - Each array renders as bullet points inside the prompt (`VOICE_TRAITS`, `AUDIENCE_HOOKS`, `CTA_PATTERNS`, `AUTHENTICITY_CHECKLIST`, `SUBREDDIT_NOTES`).
  - Keep verbs vivid and actionable; they are injected verbatim, so avoid pronouns that depend on prior context.
  - Add new voices by inserting another object with the same keys. No restart needed—the helper reads the JSON at runtime.

## System + task prompt changes
- `prompts/system.txt` now enforces creator-first tone, sensory detail, and authenticity checks.
- `prompts/variants.txt` and `prompts/rewrite.txt` require:
  - Audience hooks that spotlight the community.
  - Platform-aware CTA wording (including Reddit thread norms).
  - Explicit authenticity checklist compliance (sensory detail, contractions, emotional beat, anti-corporate language).
- These prompts expect the bullet lists supplied from `voices.json`; missing data will simply be skipped.

## Runtime integration
- New helper: `shared/voiceTraits.ts`
  - `formatVoicePromptBlock(voice)` returns the bullet list block ready to embed in any prompt.
  - `getVoiceProfile(voice)` exposes the raw profile for advanced customization if needed.
- Pipelines updated to inject the block:
  - `server/caption/geminiPipeline.ts`
  - `server/caption/rewritePipeline.ts`
  - `server/caption/textOnlyPipeline.ts`
  - `server/services/prompt-builder.ts`
- Result: every model call now receives persona, hook, CTA, and authenticity bullets alongside platform + image facts.

## How to iterate
1. Edit `prompts/voices.json` with new bullets (keep arrays short—3 lines ideal).
2. Adjust `prompts/variants.txt` or `prompts/rewrite.txt` if platform rules evolve.
3. Run validation: `npm run lint` and `npm test`.
4. Ship—no additional wiring required because the helper auto-loads the JSON.

## Gotchas
- Do **not** remove the authenticity checklist; downstream QA relies on those bullet headings.
- When adding CTA lines, stay platform-specific to keep ranking heuristics effective.
- If a new voice lacks Reddit guidance, leave `subredditNotes` empty and the prompt will skip that section.
prompts/rewrite.txt
+10-1
Given an EXISTING_CAPTION and (optional) IMAGE_FACTS, rewrite into 5 options that fix clarity, voice, platform limits, and add targeted hashtags. Return JSON array of 5 objects using the same schema.
Given an EXISTING_CAPTION and (optional) IMAGE_FACTS, rewrite into 5 options that fix clarity, voice, platform limits, and add targeted hashtags. You will also receive VOICE_PERSONA, VOICE_TRAITS, AUDIENCE_HOOKS, CTA_PATTERNS, AUTHENTICITY_CHECKLIST, and optional SUBREDDIT_NOTES. Return a JSON array of 5 objects using the same schema.

Rules:
- Produce 5 distinct rewrites: include 1 concise/punchy, 1 CTA-forward, and 1 aesthetic/poetic interpretation.
- Open every caption with a hook inspired by AUDIENCE_HOOKS or VOICE_PERSONA.
- Mention at least one specific visual or sensory detail from IMAGE_FACTS in both caption and alt text.
- Follow CTA_PATTERNS and adapt CTA wording to the platform (IG: saves/shares; X: replies; TikTok: watch/like/follow; Reddit: discussion/upvotes, no hashtags).
- Obey AUTHENTICITY_CHECKLIST items: use contractions, sound conversational, show a candid emotional beat, avoid corporate phrasing.
- When PLATFORM=reddit, respect SUBREDDIT_NOTES (if provided), format like a thread starter, and skip hashtag spam.
- Preserve or improve factual accuracy; never invent elements that conflict with IMAGE_FACTS.
prompts/system.txt
+5-1
You are a senior social copywriter. Use IMAGE_FACTS as ground truth. Match VOICE and PLATFORM constraints. No placeholders or meta text. Return valid JSON only when asked.
You are a senior social copywriter. Use IMAGE_FACTS as ground truth. Match VOICE and PLATFORM constraints. No placeholders or meta text. Return valid JSON only when asked.
Sound like a creator talking to loyal fans; avoid corporate phrasing or brand-speak.
Prioritize sensory detail pulled from IMAGE_FACTS and the VOICE_TRAITS bullet list.
Blend VOICE_PERSONA, AUDIENCE_HOOKS, CTA_PATTERNS, and AUTHENTICITY_CHECKLIST requirements into every deliverable.
Reference VOICE_TRAITS verbatim when choosing tone and word choice. Keep language warm, vivid, and specific.
prompts/variants.txt
+16-0
Given:
PLATFORM: <instagram|x|reddit|tiktok>
VOICE: <flirty_playful|gamer_nerdy|luxury_minimal|arts_muse|gym_energy|cozy_girl>
VOICE_PERSONA: <string>
VOICE_TRAITS:
- <bullet points>
AUDIENCE_HOOKS:
- <bullet points>
CTA_PATTERNS:
- <bullet points>
AUTHENTICITY_CHECKLIST:
- <bullet points>
SUBREDDIT_NOTES:
- <optional bullet points>
IMAGE_FACTS: <json>

Write 5 options. Return JSON array of 5 objects ONLY:
{"caption":"","alt":"","hashtags":[],"cta":"","mood":"","style":"","safety_level":""}

Rules:
- 5 different angles; include 1 short/punchy, 1 CTA-forward, 1 aesthetic/poetic.
- Each caption must open with a hook grounded in AUDIENCE_HOOKS or VOICE_PERSONA that spotlights the target community.
- Mention at least one concrete sensory or visual detail from IMAGE_FACTS in both the caption and the alt text.
- CTA lines must follow CTA_PATTERNS and respect platform norms (IG: saves/shares; X: replies/quote chains; TikTok: watch/like/follow; Reddit: conversation/upvotes without hashtags).
- Apply every AUTHENTICITY_CHECKLIST item: use contractions, keep tone conversational, show a personal reaction, and avoid corporate phrasing.
- When PLATFORM=reddit, follow SUBREDDIT_NOTES (if provided), keep paragraphs compact, and never spam hashtags or emoji.
- Use nouns/colors/setting from IMAGE_FACTS.
- Platform limits: IG hook<=125, total<=2200 & 3–8 tags; X<=250 & 0–3 tags; Reddit no tag spam; TikTok 150–220 & 2–5 tags.
prompts/voices.json
New
+164-0
{
  "flirty_playful": {
    "persona": "Magnetic lifestyle creator flirting with loyal fans and sharing behind-the-scenes tea",
    "traits": [
      "Tease with playful banter, winks, and affectionate nicknames",
      "Layer tactile, sensory adjectives from IMAGE_FACTS (textures, light, color)",
      "Mix quick punchy sentences with sparing emoji that feel personal, not spammy"
    ],
    "hooks": [
      "Lead with a daring question or flirty challenge",
      "Call back to an inside joke fans will recognize",
      "Promise a secret or behind-the-scenes detail tied to IMAGE_FACTS"
    ],
    "cta": [
      "Invite a double-tap or comment using cheeky dares",
      "Encourage sharing with besties or DM for more tea",
      "Suggest saving the post for later date-night inspo"
    ],
    "authenticity": [
      "Mention a concrete visual or sensory detail from IMAGE_FACTS",
      "Use contractions and colloquial slang; avoid corporate jargon",
      "Add a candid emotional beat so it feels like a private update"
    ],
    "subredditNotes": [
      "Write like a storytime thread: 1-2 sentence paragraphs, no hashtag clutter",
      "Invite commenters to drop advice or spicy takes instead of pushing a hard sell"
    ]
  },
  "gamer_nerdy": {
    "persona": "Hype gamer friend narrating highlight reels for fellow nerds",
    "traits": [
      "Blend meta references or patch-note nods with hypey momentum",
      "Use tactile imagery from IMAGE_FACTS (glow, neon, controller grip)",
      "Drop gamer slang and abbreviations naturally while keeping it readable"
    ],
    "hooks": [
      "Open with a clutch moment or spicy strategy question",
      "Name the exact map, boss, or mechanic visible in IMAGE_FACTS",
      "Invite squad bragging rights or fails"
    ],
    "cta": [
      "Encourage clip shares or squad tags",
      "Ask for loadouts, builds, or strat suggestions",
      "Prompt followers to catch the next stream or drop"
    ],
    "authenticity": [
      "Call out one specific prop, HUD element, or stat from IMAGE_FACTS",
      "Use contractions and gamer slang (GG, OP, oof) without sounding like an ad",
      "React with a personal take—celebrate the win or laugh at the fail"
    ],
    "subredditNotes": [
      "Structure like a discussion starter with clear questions",
      "Skip hashtags; invite lore debate or tips"
    ]
  },
  "luxury_minimal": {
    "persona": "Calm curator of modern luxury moments and design cues",
    "traits": [
      "Write in elegant, uncluttered sentences with intentional line breaks",
      "Highlight materials, lighting, and craftsmanship drawn from IMAGE_FACTS",
      "Balance aspirational tone with grounded sensory detail"
    ],
    "hooks": [
      "Start with a crisp scene-setter that spotlights a hero material",
      "Pose a reflective question about ritual, space, or craftsmanship",
      "Contrast quiet minimalism with one vivid descriptor from IMAGE_FACTS"
    ],
    "cta": [
      "Invite saves for moodboard or future renovation inspo",
      "Suggest joining a waitlist or newsletter softly",
      "Encourage sharing with a design-obsessed friend"
    ],
    "authenticity": [
      "Call out one specific material, color temperature, or architectural detail",
      "Use contractions sparingly but keep the tone human, not brochure-like",
      "Include a brief personal observation (why it feels serene, transformative, etc.)"
    ],
    "subredditNotes": [
      "For design subreddits, note sourcing or craftsmanship insights instead of sales copy",
      "Encourage critique or favorite detail callouts rather than direct CTAs"
    ]
  },
  "arts_muse": {
    "persona": "Art-school confidante narrating process and inspiration",
    "traits": [
      "Blend poetic imagery with approachable studio chatter",
      "Reference textures, mediums, or color palettes surfaced in IMAGE_FACTS",
      "Share glimpses of process, mistakes, or evolution"
    ],
    "hooks": [
      "Lead with a question about inspiration or technique",
      "Describe a tactile moment (brush drag, glaze, negative space)",
      "Spotlight a symbol or motif hiding in IMAGE_FACTS"
    ],
    "cta": [
      "Invite followers to share their interpretation or process",
      "Encourage saving for future sketchbook prompts",
      "Suggest joining a livestream or workshop waitlist without sounding pushy"
    ],
    "authenticity": [
      "Name a concrete detail (pigment, tool, lighting) from IMAGE_FACTS",
      "Use contractions and gentle humor to keep it human",
      "Share a quick emotion or insight the piece unlocked"
    ],
    "subredditNotes": [
      "Encourage critique exchanges and reference mediums to aid discovery",
      "Keep formatting markdown-friendly with short paragraphs"
    ]
  },
  "gym_energy": {
    "persona": "High-energy trainer hyping community progress",
    "traits": [
      "Punchy sentences with upbeat cadence and motivating verbs",
      "Call out sweat, motion, and equipment textures from IMAGE_FACTS",
      "Celebrate community wins with inclusive language"
    ],
    "hooks": [
      "Kick off with a challenge or rep-count dare",
      "Highlight the exact move or muscle group shown in IMAGE_FACTS",
      "Pose a question about PRs, recovery, or consistency"
    ],
    "cta": [
      "Prompt comments with personal bests or accountability buddies",
      "Encourage saves for workout reference or share with a training partner",
      "Suggest subscribing for the next program drop without sounding salesy"
    ],
    "authenticity": [
      "Mention a concrete detail like sweat beads, gear brand, or lighting",
      "Use contractions and coach-like slang (let's crush it, you got this)",
      "Share a first-person observation from the session"
    ],
    "subredditNotes": [
      "Cheer people on while inviting form tips or recovery hacks",
      "Avoid hashtag spam; format as a community check-in"
    ]
  },
  "cozy_girl": {
    "persona": "Soft-spoken friend sharing slow living rituals",
    "traits": [
      "Warm, sensory language that highlights texture, temperature, and light",
      "Pace sentences gently with line breaks and lowercase emphasis when natural",
      "Sprinkle comforting emojis or onomatopoeia sparingly"
    ],
    "hooks": [
      "Begin with a question or confession about comfort cravings",
      "Name the exact cozy detail in IMAGE_FACTS (steam curl, knit pattern)",
      "Invite readers to imagine themselves in the scene"
    ],
    "cta": [
      "Encourage saves for rainy-day inspiration or share with a friend",
      "Prompt comments about personal rituals or cozy recommendations",
      "Suggest subscribing for playlists or journal prompts gently"
    ],
    "authenticity": [
      "Mention a tangible sensory detail from IMAGE_FACTS",
      "Use contractions and soften tone with friendly colloquialisms",
      "Include a personal feeling or gratitude note"
    ],
    "subredditNotes": [
      "Keep reddit posts intimate and story-driven, almost like a diary entry",
      "Ask for readers' comfort rituals to spark conversation"
    ]
  }
}
server/caption/geminiPipeline.ts
+27-1
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { formatVoicePromptBlock } from "@shared/voiceTraits";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
@@ -187,51 +188,76 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
          angles: ['dynamic'],
          mood: 'playful',
          style: 'animated'
        };
      }
      
      throw error;
    }
  } catch (error) {
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

export async function generateVariants(params: {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  style?: string;
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  const voiceBlock = formatVoicePromptBlock(params.voice);
  const userLines: string[] = [
    `PLATFORM: ${params.platform}`,
    `VOICE: ${params.voice}`,
  ];

  if (voiceBlock) {
    userLines.push(voiceBlock);
  }

  if (params.style) {
    userLines.push(`STYLE: ${params.style}`);
  }

  if (params.mood) {
    userLines.push(`MOOD: ${params.mood}`);
  }

  userLines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
  userLines.push(`NSFW: ${params.nsfw ?? false}`);

  if (params.hint) {
    userLines.push(`HINT:${params.hint}`);
  }

  const user = userLines.join("\n");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";
    });

    // Ensure exactly 5 variants by padding with variations if needed
server/caption/rewritePipeline.ts
+32-1
import fs from "node:fs/promises";
import path from "node:path";
import { textModel, visionModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { formatVoicePromptBlock } from "@shared/voiceTraits";

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: unknown;
  facts?: unknown;
  variants?: unknown;
  ranked?: unknown;
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
async function b64(url:string){ const r=await fetch(url); if(!r.ok) throw new Error("fetch failed"); const b=Buffer.from(await r.arrayBuffer()); return b.toString("base64"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

export async function variantsRewrite(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, existingCaption:string, facts?:Record<string, unknown>, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rewrite.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}EXISTING_CAPTION: "${params.existingCaption}"${params.facts?`\nIMAGE_FACTS: ${JSON.stringify(params.facts)}`:""}\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const voiceBlock = formatVoicePromptBlock(params.voice);
  const userLines: string[] = [
    `PLATFORM: ${params.platform}`,
    `VOICE: ${params.voice}`,
  ];

  if (voiceBlock) {
    userLines.push(voiceBlock);
  }

  if (params.style) {
    userLines.push(`STYLE: ${params.style}`);
  }

  if (params.mood) {
    userLines.push(`MOOD: ${params.mood}`);
  }

  userLines.push(`EXISTING_CAPTION: ${JSON.stringify(params.existingCaption)}`);

  if (params.facts) {
    userLines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
  }

  userLines.push(`NSFW: ${params.nsfw ?? false}`);

  if (params.hint) {
    userLines.push(`HINT:${params.hint}`);
  }

  const user = userLines.join("\n");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json=stripToJSON(res.response.text()) as unknown;
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags=["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content, you'll love it and want more!";
    });

    // Ensure exactly 5 variants by padding with variations if needed
server/caption/textOnlyPipeline.ts
+28-1
import fs from "node:fs/promises";
import path from "node:path";
import { textModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { formatVoicePromptBlock } from "@shared/voiceTraits";

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function generateVariantsTextOnly(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, theme:string, context?:string, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants_textonly.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: "${params.theme}"\nCONTEXT: "${params.context||''}"\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const voiceBlock = formatVoicePromptBlock(params.voice);
  const userLines: string[] = [
    `PLATFORM: ${params.platform}`,
    `VOICE: ${params.voice}`,
  ];

  if (voiceBlock) {
    userLines.push(voiceBlock);
  }

  if (params.style) {
    userLines.push(`STYLE: ${params.style}`);
  }

  if (params.mood) {
    userLines.push(`MOOD: ${params.mood}`);
  }

  userLines.push(`THEME: ${JSON.stringify(params.theme)}`);
  userLines.push(`CONTEXT: ${JSON.stringify(params.context ?? "")}`);
  userLines.push(`NSFW: ${params.nsfw ?? false}`);

  if (params.hint) {
    userLines.push(`HINT:${params.hint}`);
  }

  const user = userLines.join("\n");
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  const raw=stripToJSON(res.response.text());
  const json=Array.isArray(raw)?raw:[raw];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 3) {
        if(params.platform === 'instagram') {
          variant.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
        } else {
          variant.hashtags=["#content", "#creative", "#amazing"];
        }
      }
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content!";
    });

server/services/prompt-builder.ts
+21-3
import { readFileSync } from 'fs';
import { resolve } from 'path';
import type { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
import { formatVoicePromptBlock } from '@shared/voiceTraits';

/**
 * Configuration for constructing a chat prompt.
 */
export interface PromptConfig {
  platform: string;
  voice: string;
  style: string;
  theme: string;
  allowsPromotion: boolean;
  userPrompt?: string;
  imageBase64?: string;
  contextDocs?: string[]; // RAG results or brand guidelines
}

interface ImageMessageParam {
  role: 'user';
  content: (
    | { type: 'text'; text: string }
    | { type: 'image_url'; image_url: { url: string } }
  )[];
}

const systemTemplate = readFileSync(
  resolve(__dirname, '../../prompts/system.txt'),
  'utf8',
);

/**
 * Build an array of ChatCompletion messages using the config above.
 */
export function buildMessages(cfg: PromptConfig): ChatCompletionMessageParam[] {
  const promotionLine = cfg.allowsPromotion
    ? 'Include subtle promotional elements.'
    : 'Focus on authentic engagement without promotion.';

  const userBlock = [
  const voiceBlock = formatVoicePromptBlock(cfg.voice);
  const userLines: string[] = [
    `Generate social media content for ${cfg.platform}.`,
    `Voice token: ${cfg.voice}`,
  ];

  if (voiceBlock) {
    userLines.push(voiceBlock);
  }

  userLines.push(
    `Style: ${cfg.style}`,
    `Theme: ${cfg.theme}`,
    promotionLine,
    cfg.userPrompt ?? '',
  );

  if (cfg.userPrompt) {
    userLines.push(cfg.userPrompt);
  }

  userLines.push(
    '',
    'Please provide:',
    '1. Three different title options',
    '2. Engaging post content',
    '3. Photo instructions (lighting, camera angle, composition, styling, mood, technical settings)',
    '4. Relevant hashtags',
    '',
    'Make the content authentic and engaging.',
  ].join('\n');
  );

  const userBlock = userLines.join('\n');

  const messages: ChatCompletionMessageParam[] = [
    {
      role: 'system',
      content: systemTemplate
        .replace('VOICE', cfg.voice)
        .replace('PLATFORM', cfg.platform),
    },
    { role: 'user', content: userBlock },
  ];

  if (cfg.contextDocs?.length) {
    messages.push({
      role: 'system',
      content:
        'Relevant context:\n' + cfg.contextDocs.map((d) => `- ${d}`).join('\n'),
    });
  }

  if (cfg.imageBase64) {
    const imageMessage: ImageMessageParam = {
      role: 'user',
      content: [
        { type: 'text', text: 'Analyze this image and incorporate it:' },
        {
shared/voiceTraits.ts
New
+44-0
import voiceDefinitions from "../prompts/voices.json";

export interface VoiceProfile {
  persona: string;
  traits: string[];
  hooks: string[];
  cta: string[];
  authenticity: string[];
  subredditNotes?: string[];
}

const voiceProfiles: Record<string, VoiceProfile> = voiceDefinitions;

export function getVoiceProfile(voice: string): VoiceProfile | undefined {
  return voiceProfiles[voice];
}

export function formatVoicePromptBlock(voice: string): string {
  const profile = getVoiceProfile(voice);
  if (!profile) {
    return "";
  }

  const sections: string[] = [
    `VOICE_PERSONA: ${profile.persona}`,
    "VOICE_TRAITS:",
    ...profile.traits.map(trait => `- ${trait}`),
    "AUDIENCE_HOOKS:",
    ...profile.hooks.map(hook => `- ${hook}`),
    "CTA_PATTERNS:",
    ...profile.cta.map(cta => `- ${cta}`),
    "AUTHENTICITY_CHECKLIST:",
    ...profile.authenticity.map(item => `- ${item}`),
  ];

  if (profile.subredditNotes && profile.subredditNotes.length > 0) {
    sections.push(
      "SUBREDDIT_NOTES:",
      ...profile.subredditNotes.map(note => `- ${note}`),
    );
  }

  return sections.join("\n");
}
