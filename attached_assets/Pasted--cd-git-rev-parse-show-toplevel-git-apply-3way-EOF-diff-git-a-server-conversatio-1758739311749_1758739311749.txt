 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/conversational-tone.ts b/server/conversational-tone.ts
index 75a91fbf9e09050c5787ee8da475887650b6b9ec..af48a128afedc3e2a9c3d907bbd3ca68ea1945e3 100644
--- a/server/conversational-tone.ts
+++ b/server/conversational-tone.ts
@@ -1,49 +1,57 @@
 
 import type { CommunityVoicePack } from './community-voice-packs.js';
 
 export interface ConversationalToneConfig {
   readonly platform?: string;
   readonly voiceMarkers: readonly string[];
   readonly fillerWords: readonly string[];
   readonly contractionProbability: number;
   readonly voiceMarkerProbability: number;
   readonly fragmentProbability: number;
   readonly allowImperfections?: boolean;
+  readonly vernacularProbability?: number;
   readonly random?: () => number;
 }
 
 export interface ConversationalToneResult {
   text: string;
   voiceMarkersUsed: string[];
   contractionsApplied: number;
   fragmentsInserted: number;
+  vernacularInsertions: number;
 }
 
 const BASE_VOICE_MARKERS: readonly string[] = ['tbh', 'honestly', 'ngl', 'fr', 'I mean'];
 const BASE_FILLERS: readonly string[] = ['and yeah,', 'so, like,', 'no lie,', 'for real,', 'not gonna lie,'];
 const DEFAULT_FRAGMENT_TEMPLATE = (marker: string): string => `${marker} not gonna lie.`;
+const RHYTHM_FRAGMENT_TEMPLATES: readonly ((seed: string) => string)[] = [
+  (seed: string) => DEFAULT_FRAGMENT_TEMPLATE(seed),
+  (seed: string) => `${seed} kinda hits different.`,
+  (seed: string) => `${seed} had me feeling some type of way.`,
+  (seed: string) => `${seed}, just saying.`
+];
 
 interface ContractionRule {
   readonly matcher: RegExp;
   readonly replacement: string;
 }
 
 const CONTRACTION_RULES: readonly ContractionRule[] = [
   { matcher: /\bI am\b/gi, replacement: "I'm" },
   { matcher: /\bare not\b/gi, replacement: "aren't" },
   { matcher: /\bis not\b/gi, replacement: "isn't" },
   { matcher: /\bwas not\b/gi, replacement: "wasn't" },
   { matcher: /\bwere not\b/gi, replacement: "weren't" },
   { matcher: /\bdo not\b/gi, replacement: "don't" },
   { matcher: /\bdid not\b/gi, replacement: "didn't" },
   { matcher: /\bdoes not\b/gi, replacement: "doesn't" },
   { matcher: /\bwill not\b/gi, replacement: "won't" },
   { matcher: /\bcan not\b/gi, replacement: "can't" },
   { matcher: /\bcannot\b/gi, replacement: "can't" },
   { matcher: /\bhave not\b/gi, replacement: "haven't" },
   { matcher: /\bhas not\b/gi, replacement: "hasn't" },
   { matcher: /\bhad not\b/gi, replacement: "hadn't" },
   { matcher: /\bshould have\b/gi, replacement: "should've" },
   { matcher: /\bcould have\b/gi, replacement: "could've" },
   { matcher: /\bwould have\b/gi, replacement: "would've" },
   { matcher: /\bI would\b/gi, replacement: "I'd" },
diff --git a/server/conversational-tone.ts b/server/conversational-tone.ts
index 75a91fbf9e09050c5787ee8da475887650b6b9ec..af48a128afedc3e2a9c3d907bbd3ca68ea1945e3 100644
--- a/server/conversational-tone.ts
+++ b/server/conversational-tone.ts
@@ -59,50 +67,57 @@ function clamp(value: number, min: number, max: number): number {
   }
   if (value < min) {
     return min;
   }
   if (value > max) {
     return max;
   }
   return value;
 }
 
 function pickRandom<T>(values: readonly T[], random: () => number): T {
   if (values.length === 0) {
     throw new Error('Attempted to pick from an empty collection');
   }
   const index = Math.floor(random() * values.length);
   return values[index] ?? values[0];
 }
 
 function lowercaseFirst(value: string): string {
   if (value.length === 0) {
     return value;
   }
   return value.charAt(0).toLowerCase() + value.slice(1);
 }
 
+function capitalizeFirst(value: string): string {
+  if (value.length === 0) {
+    return value;
+  }
+  return value.charAt(0).toUpperCase() + value.slice(1);
+}
+
 function applyCaseFromSource(source: string, replacement: string): string {
   if (source.toUpperCase() === source) {
     return replacement.toUpperCase();
   }
   if (source.toLowerCase() === source) {
     return replacement.toLowerCase();
   }
   if (source[0] === source[0].toUpperCase()) {
     return replacement.charAt(0).toUpperCase() + replacement.slice(1);
   }
   return replacement;
 }
 
 function applyContractions(sentence: string, probability: number, random: () => number): { text: string; applied: number } {
   let result = sentence;
   let applied = 0;
   for (const rule of CONTRACTION_RULES) {
     if (random() > probability) {
       continue;
     }
     const matcher = new RegExp(rule.matcher);
     const replaced = result.replace(matcher, match => {
       applied += 1;
       return applyCaseFromSource(match, rule.replacement);
     });
diff --git a/server/conversational-tone.ts b/server/conversational-tone.ts
index 75a91fbf9e09050c5787ee8da475887650b6b9ec..af48a128afedc3e2a9c3d907bbd3ca68ea1945e3 100644
--- a/server/conversational-tone.ts
+++ b/server/conversational-tone.ts
@@ -124,131 +139,285 @@ function maybeInjectVoiceMarker(
   const marker = pickRandom(voiceMarkers, random);
   used.push(marker);
   const trimmed = sentence.trim();
   if (trimmed.length === 0) {
     return `${marker}, ${sentence}`;
   }
   if (trimmed.length <= 40) {
     return `${marker}, ${trimmed}`;
   }
   if (random() < 0.5) {
     return `${marker}, ${lowercaseFirst(trimmed)}`;
   }
   return `${trimmed} (${marker})`;
 }
 
 function ensureSentenceVariance(
   sentences: string[],
   fillerWords: readonly string[],
   fragmentProbability: number,
   random: () => number,
   used: string[]
 ): { sentences: string[]; fragmentsInserted: number } {
   const normalized = [...sentences];
   let fragmentsInserted = 0;
 
-  const hasShort = normalized.some(sentence => sentence.trim().length <= 50);
-  if (!hasShort && normalized.length > 0 && random() < clamp(fragmentProbability, 0, 1)) {
-    const marker = used[0] ?? (fillerWords.length > 0 ? fillerWords[0] : 'honestly');
-    const fragment = DEFAULT_FRAGMENT_TEMPLATE(marker.replace(/[, ]+$/u, ''));
-    normalized.splice(1, 0, fragment);
-    fragmentsInserted += 1;
+  if (normalized.length === 0) {
+    return { sentences: normalized, fragmentsInserted };
+  }
+
+  const clampProbability = clamp(fragmentProbability, 0, 1);
+
+  const categorizeLength = (value: string): 'short' | 'medium' | 'long' => {
+    const length = value.trim().length;
+    if (length <= 55) {
+      return 'short';
+    }
+    if (length >= 130) {
+      return 'long';
+    }
+    return 'medium';
+  };
+
+  const sanitizeSeed = (seed: string): string => seed.replace(/^[,\s]+/u, '').replace(/[,\s]+$/u, '').trim();
+
+  const buildFragment = (): string => {
+    const seeds = [
+      ...used,
+      ...fillerWords.map(sanitizeSeed)
+    ].filter(entry => entry.trim().length > 0);
+    const seed = seeds.length > 0 ? pickRandom(seeds, random) : 'honestly';
+    const template = pickRandom(RHYTHM_FRAGMENT_TEMPLATES, random);
+    return template(sanitizeSeed(seed));
+  };
+
+  const splitSentenceForRhythm = (value: string): string[] | undefined => {
+    const trimmed = value.trim();
+    if (trimmed.length < 140) {
+      return undefined;
+    }
+    const normalized = trimmed.toLowerCase();
+    const midpoint = Math.floor(normalized.length / 2);
+    const separators = [',', ' — ', ' – ', ' - ', ';', ':', ' but ', ' because ', ' so ', ' and '];
+    let best: { index: number; length: number } | undefined;
+    let bestDistance = Number.POSITIVE_INFINITY;
+    for (const separator of separators) {
+      let startIndex = normalized.indexOf(separator);
+      while (startIndex !== -1) {
+        const distance = Math.abs(startIndex - midpoint);
+        const startValid = startIndex > 25;
+        const endValid = startIndex + separator.length < normalized.length - 25;
+        if (startValid && endValid && distance < bestDistance) {
+          best = { index: startIndex, length: separator.length };
+          bestDistance = distance;
+        }
+        startIndex = normalized.indexOf(separator, startIndex + separator.length);
+      }
+    }
+    if (!best) {
+      return undefined;
+    }
+    const first = trimmed.slice(0, best.index).trim();
+    const second = trimmed.slice(best.index + best.length).trim();
+    if (first.length <= 25 || second.length <= 25) {
+      return undefined;
+    }
+    const ensureTerminal = (segment: string): string => {
+      if (segment.length === 0) {
+        return segment;
+      }
+      if (/[.!?]$/u.test(segment)) {
+        return segment;
+      }
+      return `${segment}.`;
+    };
+    const firstSegment = ensureTerminal(first);
+    const secondSegment = ensureTerminal(capitalizeFirst(second));
+    return [firstSegment, secondSegment];
+  };
+
+  const mergeSentencesForFlow = (first: string, second: string): string => {
+    const connectorRaw = fillerWords.length > 0 ? pickRandom(fillerWords, random) : 'and yeah,';
+    const connector = connectorRaw.trim().length > 0 ? connectorRaw : 'and';
+    const firstCore = first.trim().replace(/([.!?])+$/u, '');
+    const secondCore = lowercaseFirst(second.trim());
+    const merged = `${firstCore} ${connector} ${secondCore}`.replace(/\s+/gu, ' ').trim();
+    const punctuation = /[.!?]$/u.test(second.trim()) ? '' : '.';
+    return `${merged}${punctuation}`;
+  };
+
+  const maybeAddFragment = () => {
+    if (random() <= clampProbability) {
+      normalized.splice(Math.min(1, normalized.length), 0, buildFragment());
+      fragmentsInserted += 1;
+    }
+  };
+
+  const lengths = normalized.map(sentence => categorizeLength(sentence));
+  const hasShort = lengths.includes('short');
+  const hasLong = lengths.includes('long');
+
+  if (!hasShort) {
+    const longestIndex = normalized.reduce((acc, sentence, index) => {
+      const currentLength = sentence.trim().length;
+      const longestLength = normalized[acc]?.trim().length ?? 0;
+      if (currentLength > longestLength) {
+        return index;
+      }
+      return acc;
+    }, 0);
+    const splitResult = splitSentenceForRhythm(normalized[longestIndex] ?? '');
+    if (splitResult) {
+      normalized.splice(longestIndex, 1, ...splitResult);
+    } else {
+      normalized.splice(Math.min(1, normalized.length), 0, buildFragment());
+      fragmentsInserted += 1;
+    }
   }
 
-  const hasLong = normalized.some(sentence => sentence.trim().length >= 110);
   if (!hasLong && normalized.length >= 2) {
-    const filler = fillerWords.length > 0 ? pickRandom(fillerWords, random) : 'and yeah,';
-    const merged = `${normalized[0].trim()} ${filler} ${lowercaseFirst(normalized[1].trim())}`.replace(/\s+/gu, ' ');
-    normalized.splice(0, 2, merged);
+    const mergeIndex = normalized.length >= 3 ? 1 : 0;
+    const merged = mergeSentencesForFlow(normalized[mergeIndex], normalized[mergeIndex + 1]);
+    normalized.splice(mergeIndex, 2, merged);
   }
 
+  maybeAddFragment();
+
   return { sentences: normalized, fragmentsInserted };
 }
 
+interface VernacularInjectionResult {
+  readonly text: string;
+  readonly inserted: boolean;
+}
+
+function injectVernacularAside(
+  sentence: string,
+  fillerWords: readonly string[],
+  probability: number,
+  random: () => number
+): VernacularInjectionResult {
+  if (fillerWords.length === 0 || random() > probability) {
+    return { text: sentence, inserted: false };
+  }
+  const pool = fillerWords
+    .map(entry => entry.replace(/^[,\s]+/u, '').replace(/[,\s]+$/u, '').trim())
+    .filter(entry => entry.length > 0);
+  if (pool.length === 0) {
+    return { text: sentence, inserted: false };
+  }
+  const token = pickRandom(pool, random);
+  const trimmed = sentence.trim();
+  if (trimmed.length === 0) {
+    return { text: `${capitalizeFirst(token)}.`, inserted: true };
+  }
+  const punctuationMatch = trimmed.match(/([.!?]+)$/u);
+  const punctuation = punctuationMatch ? punctuationMatch[0] : '';
+  const core = punctuation ? trimmed.slice(0, -punctuation.length) : trimmed;
+  const aside = random() < 0.5 ? `(${token})` : `—${token}`;
+  const spacing = core.length === 0 ? '' : ' ';
+  return { text: `${core}${spacing}${aside}${punctuation}`, inserted: true };
+}
+
 function splitIntoSentences(paragraph: string): string[] {
   return paragraph.split(/(?<=[.!?])\s+/u).filter(part => part.trim().length > 0);
 }
 
 function joinSentences(sentences: string[], original: string): string {
   const trailingWhitespaceMatch = original.match(/\s+$/u);
   const trailingWhitespace = trailingWhitespaceMatch ? trailingWhitespaceMatch[0] : '';
   return `${sentences.join(' ').replace(/\s+/gu, ' ').trim()}${trailingWhitespace}`;
 }
 
 export function applyConversationalTone(text: string, config: ConversationalToneConfig): ConversationalToneResult {
   if (text.trim().length === 0) {
     return {
       text,
       voiceMarkersUsed: [],
       contractionsApplied: 0,
-      fragmentsInserted: 0
+      fragmentsInserted: 0,
+      vernacularInsertions: 0
     };
   }
 
   const random = config.random ?? Math.random;
   const voiceMarkers = config.voiceMarkers.length > 0 ? config.voiceMarkers : BASE_VOICE_MARKERS;
   const fillerWords = config.fillerWords.length > 0 ? config.fillerWords : BASE_FILLERS;
   const voiceMarkersUsed: string[] = [];
   let contractionsApplied = 0;
+  let vernacularInsertions = 0;
+  let fragmentsInsertedTotal = 0;
 
   const paragraphs = text.split(/\n\n+/u);
   const processedParagraphs = paragraphs.map(paragraph => {
     const sentences = splitIntoSentences(paragraph);
     const processedSentences = sentences.map(sentence => {
       const contractionResult = applyContractions(sentence, clamp(config.contractionProbability, 0, 1), random);
       contractionsApplied += contractionResult.applied;
       const withVoiceMarker = maybeInjectVoiceMarker(
         contractionResult.text,
         voiceMarkers,
         clamp(config.voiceMarkerProbability, 0, 1),
         random,
         voiceMarkersUsed
       );
-      return withVoiceMarker;
+      const vernacularResult = injectVernacularAside(
+        withVoiceMarker,
+        fillerWords,
+        clamp(config.vernacularProbability ?? 0.4, 0, 1),
+        random
+      );
+      if (vernacularResult.inserted) {
+        vernacularInsertions += 1;
+      }
+      return vernacularResult.text;
     });
 
     const varianceResult = ensureSentenceVariance(
       processedSentences,
       fillerWords,
       config.fragmentProbability,
       random,
       voiceMarkersUsed
     );
+    fragmentsInsertedTotal += varianceResult.fragmentsInserted;
     return joinSentences(varianceResult.sentences, paragraph);
   });
 
   return {
     text: processedParagraphs.join('\n\n'),
     voiceMarkersUsed,
     contractionsApplied,
-    fragmentsInserted: processedParagraphs.length - paragraphs.length
+    fragmentsInserted: fragmentsInsertedTotal,
+    vernacularInsertions
   };
 }
 
 export function buildConversationalToneConfig(
   communityPack: CommunityVoicePack,
   overrides: Partial<ConversationalToneConfig> | undefined,
   random: () => number,
   platform?: string
 ): ConversationalToneConfig {
   const baseMarkers = Array.from(new Set([
     ...BASE_VOICE_MARKERS,
     ...communityPack.voiceMarkers
   ]));
 
   const fillerWords = Array.from(new Set([
     ...BASE_FILLERS,
     ...communityPack.lexicon,
     ...communityPack.callouts
   ])).filter(entry => entry.trim().length > 0);
 
   return {
     platform,
     voiceMarkers: overrides?.voiceMarkers ?? baseMarkers,
     fillerWords: overrides?.fillerWords ?? fillerWords,
     contractionProbability: overrides?.contractionProbability ?? 0.55,
     voiceMarkerProbability: overrides?.voiceMarkerProbability ?? 0.6,
     fragmentProbability: overrides?.fragmentProbability ?? 0.35,
     allowImperfections: overrides?.allowImperfections ?? true,
+    vernacularProbability: overrides?.vernacularProbability ?? 0.4,
     random: overrides?.random ?? random
   };
 }
 
EOF
)