Replace normalization defaults with safe helpers
Sep 22 · a1davida1/TPilot · main
+243-28
1. In `server/caption/geminiPipeline.ts` and `server/caption/textOnlyPipeline.ts`, replace the normalization defaults that set `next.hashtags = ["#content", "#creative", "#amazing"]` with a safer helper—either call `fallbackHashtags(params.platform)` or provide a new constant free of banned tokens. Do the same for any default captions that still contain the word “content.”
2. Update `server/caption/dedupeVariants.ts` so its padding `base` object also uses the new safe fallback hashtags/CTA, again avoiding “content.”
3. Extend caption-generation tests (see `tests/routes/caption-generation.test.ts`) with a scenario where Gemini returns caption variants missing hashtags; assert that the pipeline now pads them without tripping the banned-word guard and still returns five variants.

Summary

    Hardened Gemini variant normalization with safe CTA/alt text defaults and platform-aware hashtag fallbacks that now call fallbackHashtags, ensuring missing metadata no longer introduces banned “content” strings.

Mirrored the same safe defaults in the text-only pipeline so text-generated variants inherit compliant hashtags, captions, and calls-to-action even when Gemini omits them.

Updated variant deduplication padding to lean on rank guard fallbacks/HUMAN_CTA and sanitized fact-driven metadata, keeping synthesized variants free of banned tokens and aligned with platform minima.

Swapped the rewrite pipeline’s variant accumulator to const so eslint passes after the normalization changes.

Added an integration test proving the Gemini pipeline pads hashtag-less responses with safe defaults while still returning five clean variants.

Testing

    ✅ npm run lint

❌ npm test *(fails in this environment: extensive suites depend on external services such as OpenAI/Gemini, triggering numerous network and asset errors)*


server/caption/dedupeVariants.ts
+67-9
import { z } from "zod";
import { CaptionArray } from "./schema";
import { inferFallbackFromFacts } from "./inferFallbackFromFacts";
import { fallbackHashtags, HUMAN_CTA } from "./rankGuards";

const LENGTH_GAP_THRESHOLD = 8;
const SAFE_DEFAULT_CAPTION = "Sharing a moment that means a lot to me.";
const SAFE_DEFAULT_ALT = "Detailed description available for everyone.";
const REDDIT_FALLBACK_TAGS = ["community spotlight"];

function minimumHashtagCount(platform?: string): number {
  switch (platform) {
    case "instagram":
      return 3;
    case "tiktok":
      return 2;
    case "reddit":
      return 1;
    case "x":
    default:
      return 1;
  }
}

function resolveFallbackHashtags(platform?: string): string[] {
  const fallback = fallbackHashtags(platform);
  if (fallback.length > 0) {
    return [...fallback];
  }
  if (platform === "reddit") {
    return [...REDDIT_FALLBACK_TAGS];
  }
  return ["#thoughts"];
}

function sanitizeHashtagList(hashtags: string[] | undefined, min: number): string[] {
  if (!Array.isArray(hashtags)) return [];
  const sanitized = hashtags
    .map(tag => tag.trim())
    .filter(tag => tag.length > 0);
  return sanitized.length >= min ? sanitized : [];
}

type CaptionVariant = z.infer<typeof CaptionArray>[number];

function normalizeCaption(caption: string): string {
  return caption.trim().toLowerCase();
}

function isNearDuplicate(existing: string, candidate: string): boolean {
  if (existing === candidate) return true;

  const lengthGap = Math.abs(existing.length - candidate.length);
  if (lengthGap > LENGTH_GAP_THRESHOLD) return false;

  const shorter = existing.length <= candidate.length ? existing : candidate;
  const longer = existing.length > candidate.length ? existing : candidate;
  return shorter.length > 0 && longer.startsWith(shorter);
}

function buildFreshCaption(baseCaption: string, index: number): string {
  const cleaned = baseCaption.trim();
  const root = cleaned.length > 0 ? cleaned : "Check out this amazing content!";
  const root = cleaned.length > 0 ? cleaned : SAFE_DEFAULT_CAPTION;
  return `Fresh POV ${index}: ${root}`;
}

export function dedupeVariantsForRanking(
  variants: z.infer<typeof CaptionArray>,
  targetLength = 5,
  context?: {
    platform?: "instagram" | "x" | "reddit" | "tiktok";
    facts?: Record<string, unknown>;
    theme?: string;
    context?: string;
  }
): z.infer<typeof CaptionArray> {
  const uniques: CaptionVariant[] = [];
  const duplicates: CaptionVariant[] = [];

  for (const variant of variants) {
    const normalized = normalizeCaption(variant.caption);
    if (!normalized) {
      duplicates.push(variant);
      continue;
    }

    const hasMatch = uniques.some(existing =>
      isNearDuplicate(normalizeCaption(existing.caption), normalized)
    );

    if (hasMatch) {
      duplicates.push(variant);
    } else {
      uniques.push(variant);
    }
  }

  // Get contextual fallback data for padding if needed
  const fallbackData = context && context.platform ? inferFallbackFromFacts(context as Required<Pick<typeof context, 'platform'>> & typeof context) : null;
  const fallbackData = context?.platform
    ? inferFallbackFromFacts({
        platform: context.platform,
        facts: context.facts,
        theme: context.theme,
        context: context.context,
      })
    : null;
  const platform = context?.platform;
  const minHashtags = minimumHashtagCount(platform);
  const inferredHashtags = sanitizeHashtagList(fallbackData?.hashtags, minHashtags);
  const fallbackTags = inferredHashtags.length >= minHashtags
    ? inferredHashtags
    : resolveFallbackHashtags(platform);
  const fallbackAlt =
    typeof fallbackData?.alt === "string" && fallbackData.alt.trim().length >= 20
      ? fallbackData.alt.trim()
      : SAFE_DEFAULT_ALT;
  const fallbackCta =
    typeof fallbackData?.cta === "string" && fallbackData.cta.trim().length >= 2
      ? fallbackData.cta.trim()
      : HUMAN_CTA;
  const base = uniques[0] ?? duplicates[0] ?? {
    caption: "Check out this amazing content!",
    alt: fallbackData?.alt ?? "Engaging social media content",
    hashtags: fallbackData?.hashtags ?? ["#content", "#creative", "#amazing"],
    cta: fallbackData?.cta ?? "Check it out",
    caption: SAFE_DEFAULT_CAPTION,
    alt: fallbackAlt,
    hashtags: [...fallbackTags],
    cta: fallbackCta,
    mood: "engaging",
    style: "authentic",
    safety_level: "normal",
    nsfw: false,
  } as CaptionVariant;

  while (uniques.length < targetLength) {
    const source = duplicates.shift() ?? base;
    const index = uniques.length + 1;
    const freshCaption = buildFreshCaption(source.caption, index);
    uniques.push({
      ...source,
      caption: freshCaption,
      hashtags: fallbackData?.hashtags ?? source.hashtags,
      cta: fallbackData?.cta ?? source.cta,
      alt: fallbackData?.alt ?? source.alt,
      hashtags: [...fallbackTags],
      cta: fallbackCta,
      alt: fallbackAlt,
    });
  }

  if (uniques.length > targetLength) {
    uniques.length = targetLength;
  }

  return uniques;
}
server/caption/geminiPipeline.ts
+49-9
@@ -21,108 +21,148 @@ import {
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

const MAX_VARIANT_ATTEMPTS = 4;
const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 4;
const CAPTION_KEY_LENGTH = 80;
const SAFE_DEFAULT_CAPTION = "Sharing a moment that means a lot to me.";
const SAFE_DEFAULT_ALT = "Detailed description available for everyone.";
const REDDIT_FALLBACK_TAGS = ["community spotlight"];

function minimumHashtagCount(platform?: string): number {
  switch (platform) {
    case "instagram":
      return 3;
    case "tiktok":
      return 2;
    case "reddit":
      return 1;
    case "x":
    default:
      return 1;
  }
}

function resolveFallbackHashtags(platform?: string): string[] {
  const fallback = fallbackHashtags(platform);
  if (fallback.length > 0) {
    return [...fallback];
  }
  if (platform === "reddit") {
    return [...REDDIT_FALLBACK_TAGS];
  }
  return ["#thoughts"];
}

function captionKey(caption: string): string {
  return caption.trim().slice(0, 80).toLowerCase();
}

function hintSnippet(caption: string): string {
  const normalized = caption.trim().replace(/\s+/g, " ");
  return normalized.length > 60 ? `${normalized.slice(0, 57)}…` : normalized;
}

function uniqueCaptionKey(caption: string): string {
  return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
}

function truncateForHint(caption: string): string {
  const trimmed = caption.trim();
  if (trimmed.length <= 60) {
    return trimmed;
  }
  return `${trimmed.slice(0, 57)}...`;
}

function buildRetryHint(
  baseHint: string | undefined,
  duplicates: string[],
  needed: number
): string {
  const parts: string[] = [];
  if (baseHint && baseHint.trim().length > 0) {
    parts.push(baseHint.trim());
  }
  if (duplicates.length > 0) {
    const lastDuplicate = duplicates[duplicates.length - 1];
    parts.push(
      `You already wrote "${truncateForHint(lastDuplicate)}". Deliver a fresh angle and add ${needed} more unique caption${needed > 1 ? "s" : ""}.`
    );
  } else {
    parts.push(
      `Need ${needed} more unique caption${needed > 1 ? "s" : ""}. Explore a different perspective with new imagery details.`
    );
  }
  return parts.join(" ").trim();
}

function normalizeVariantFields(variant: Record<string, unknown>): z.infer<typeof CaptionItem> {
function normalizeVariantFields(
  variant: Record<string, unknown>,
  platform?: string
): z.infer<typeof CaptionItem> {
  const next: Record<string, unknown> = { ...variant };
  next.safety_level = normalizeSafetyLevel(
    typeof next.safety_level === "string" ? next.safety_level : "normal"
  );
  if (typeof next.mood !== "string" || next.mood.trim().length < 2) next.mood = "engaging";
  if (typeof next.style !== "string" || next.style.trim().length < 2) next.style = "authentic";
  if (typeof next.cta !== "string" || next.cta.trim().length < 2) next.cta = "Check it out";
  if (typeof next.alt !== "string" || next.alt.trim().length < 20)
    next.alt = "Engaging social media content";
  if (!Array.isArray(next.hashtags) || next.hashtags.length < 3)
    next.hashtags = ["#content", "#creative", "#amazing"];
  if (typeof next.caption !== "string" || next.caption.trim().length < 1)
    next.caption = "Check out this amazing content!";
  const trimmedCta = typeof next.cta === "string" ? next.cta.trim() : "";
  next.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof next.alt === "string" ? next.alt.trim() : "";
  next.alt = trimmedAlt.length >= 20 ? trimmedAlt : SAFE_DEFAULT_ALT;
  const minHashtags = minimumHashtagCount(platform);
  const fallbackTags = resolveFallbackHashtags(platform);
  if (Array.isArray(next.hashtags)) {
    const sanitized = next.hashtags
      .map(tag => (typeof tag === "string" ? tag.trim() : ""))
      .filter(tag => tag.length > 0);
    next.hashtags = sanitized.length >= minHashtags ? sanitized : fallbackTags;
  } else {
    next.hashtags = fallbackTags;
  }
  const trimmedCaption = typeof next.caption === "string" ? next.caption.trim() : "";
  next.caption = trimmedCaption.length > 0 ? trimmedCaption : SAFE_DEFAULT_CAPTION;
  return CaptionItem.parse(next);
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);

    const ct = r.headers.get("content-type") || "";
    if (!ct.startsWith("image/"))
      throw new InvalidImageError(`unsupported content-type: ${ct}`);

    const b = Buffer.from(await r.arrayBuffer());
    const base64 = b.toString("base64");
    if (base64.length < 100) throw new InvalidImageError("image data too small");

    return { base64, mimeType: ct.split(";")[0] };
  } catch (err) {
    console.error("Error fetching image:", err);
    if (err instanceof InvalidImageError) throw err;
    throw new InvalidImageError(
      `Failed to fetch image: ${err instanceof Error ? err.message : String(err)}`
@@ -301,51 +341,51 @@ export async function generateVariants(params: GeminiVariantParams): Promise<z.i
  let attempts = 0;
  let currentHint = params.hint;
  let variants: z.infer<typeof CaptionItem>[] = [];
  const keyIndex = new Map<string, number>();

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;
    const voiceContext = formatVoiceContext(params.voice);
    const user = `PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${voiceContext ? `${voiceContext}\n` : ''}${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}${currentHint ? `\nHINT:${currentHint}` : ''}`;

    let res;
    try {
      res = await textModel.generateContent([{ text: `${sys}\n${guard}\n${prompt}\n${user}` }]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    const raw = stripToJSON(res.response.text());
    const items = Array.isArray(raw) ? raw : [raw];
    const iterationDuplicates: string[] = [];
    let hasBannedWords = false;

    items.forEach(item => {
      const candidate = (typeof item === "object" && item !== null ? item : {}) as Record<string, unknown>;
      const normalized = normalizeVariantFields(candidate);
      const normalized = normalizeVariantFields(candidate, params.platform);
      
      // Check for banned words in the variant
      if (variantContainsBannedWord(normalized)) {
        hasBannedWords = true;
        return; // Skip this variant
      }
      
      const key = uniqueCaptionKey(normalized.caption);
      const existingIndex = keyIndex.get(key);

      if (existingIndex === undefined) {
        variants.push(normalized);
        keyIndex.set(key, variants.length - 1);
      } else {
        iterationDuplicates.push(normalized.caption);
        const existing = variants[existingIndex];
        if (normalized.caption.length > existing.caption.length) {
          variants[existingIndex] = normalized;
        }
      }
    });

    variants = dedupeCaptionVariants(variants as { caption: string }[]).slice(0, VARIANT_TARGET);
    keyIndex.clear();
    variants.forEach((variant, index) => {
server/caption/rewritePipeline.ts
+1-1
@@ -156,51 +156,51 @@ export async function extractFacts(imageUrl:string){

type RewriteVariantsParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  existingCaption:string;
  facts?:Record<string, unknown>;
  hint?:string;
  nsfw?:boolean;
  doNotDrop?: string[];
  style?: string;
  mood?: string
};

const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 3;

export async function variantsRewrite(params: RewriteVariantsParams) {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rewrite.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  let variants: any[] = [];
  const variants: any[] = [];

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;
    
    const voiceContext = formatVoiceContext(params.voice);
    const user = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
      voiceContext,
      params.style ? `STYLE: ${params.style}` : "",
      params.mood ? `MOOD: ${params.mood}` : "",
      `EXISTING_CAPTION: ${serializePromptField(params.existingCaption)}`,
      params.facts ? `IMAGE_FACTS: ${JSON.stringify(params.facts)}` : "",
      `NSFW: ${params.nsfw || false}`,
      currentHint ? `HINT:${serializePromptField(currentHint, { block: true })}` : "",
    ].filter((line): line is string => Boolean(line)).join("\n");
    
    const voiceGuide = buildVoiceGuideBlock(params.voice);
    const promptSections = [sys, guard, prompt, user];
    if (voiceGuide) promptSections.push(voiceGuide);
    
    let res;
    try {
      res = await textModel.generateContent([{ text: promptSections.join("\n") }]);
    } catch (error) {
server/caption/textOnlyPipeline.ts
+49-9
@@ -3,159 +3,199 @@ import * as path from "node:path";
import { z } from "zod";
import { textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import { extractToneOptions, ToneOptions } from "./toneOptions";
import { BANNED_WORDS_HINT, variantContainsBannedWord } from "./bannedWords";
import { buildVoiceGuideBlock } from "./stylePack";
import { formatVoiceContext } from "./voiceTraits";
import { serializePromptField } from "./promptUtils";
import { inferFallbackFromFacts } from "./inferFallbackFromFacts";
import { dedupeVariantsForRanking } from "./dedupeVariants";
import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
import {
  HUMAN_CTA,
  buildRerankHint,
  detectVariantViolations,
  fallbackHashtags,
  formatViolationSummary,
  sanitizeFinalVariant
} from "./rankGuards";

const MAX_VARIANT_ATTEMPTS = 4;
const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 4;
const CAPTION_KEY_LENGTH = 80;
const SAFE_DEFAULT_CAPTION = "Sharing a moment that means a lot to me.";
const SAFE_DEFAULT_ALT = "Detailed description available for everyone.";
const REDDIT_FALLBACK_TAGS = ["community spotlight"];

function minimumHashtagCount(platform?: string): number {
  switch (platform) {
    case "instagram":
      return 3;
    case "tiktok":
      return 2;
    case "reddit":
      return 1;
    case "x":
    default:
      return 1;
  }
}

function resolveFallbackHashtags(platform?: string): string[] {
  const fallback = fallbackHashtags(platform);
  if (fallback.length > 0) {
    return [...fallback];
  }
  if (platform === "reddit") {
    return [...REDDIT_FALLBACK_TAGS];
  }
  return ["#thoughts"];
}

function captionKey(caption: string): string {
  return caption.trim().slice(0, 80).toLowerCase();
}

function hintSnippet(caption: string): string {
  const normalized = caption.trim().replace(/\s+/g, " ");
  return normalized.length > 60 ? `${normalized.slice(0, 57)}…` : normalized;
}

function uniqueCaptionKey(caption: string): string {
  return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
}

function truncateForHint(caption: string): string {
  const trimmed = caption.trim();
  if (trimmed.length <= 60) {
    return trimmed;
  }
  return `${trimmed.slice(0, 57)}...`;
}

function buildRetryHint(
  baseHint: string | undefined,
  duplicates: string[],
  needed: number
): string {
  const parts: string[] = [];
  if (baseHint && baseHint.trim().length > 0) {
    parts.push(baseHint.trim());
  }
  if (duplicates.length > 0) {
    const lastDuplicate = duplicates[duplicates.length - 1];
    parts.push(
      `You already wrote "${truncateForHint(lastDuplicate)}". Deliver a fresh angle and add ${needed} more unique caption${needed > 1 ? "s" : ""}.`
    );
  } else {
    parts.push(
      `Need ${needed} more unique caption${needed > 1 ? "s" : ""}. Explore a different perspective with new imagery details.`
    );
  }
  return parts.join(" ").trim();
}

function normalizeVariantFields(variant: Record<string, unknown>): z.infer<typeof CaptionItem> {
function normalizeVariantFields(
  variant: Record<string, unknown>,
  platform?: string
): z.infer<typeof CaptionItem> {
  const next: Record<string, unknown> = { ...variant };
  next.safety_level = normalizeSafetyLevel(
    typeof next.safety_level === "string" ? next.safety_level : "normal"
  );
  if (typeof next.mood !== "string" || next.mood.trim().length < 2) next.mood = "engaging";
  if (typeof next.style !== "string" || next.style.trim().length < 2) next.style = "authentic";
  if (typeof next.cta !== "string" || next.cta.trim().length < 2) next.cta = "Check it out";
  if (typeof next.alt !== "string" || next.alt.trim().length < 20)
    next.alt = "Engaging social media content";
  if (!Array.isArray(next.hashtags) || next.hashtags.length < 3)
    next.hashtags = ["#content", "#creative", "#amazing"];
  if (typeof next.caption !== "string" || next.caption.trim().length < 1)
    next.caption = "Check out this amazing content!";
  const trimmedCta = typeof next.cta === "string" ? next.cta.trim() : "";
  next.cta = trimmedCta.length >= 2 ? trimmedCta : HUMAN_CTA;
  const trimmedAlt = typeof next.alt === "string" ? next.alt.trim() : "";
  next.alt = trimmedAlt.length >= 20 ? trimmedAlt : SAFE_DEFAULT_ALT;
  const minHashtags = minimumHashtagCount(platform);
  const fallbackTags = resolveFallbackHashtags(platform);
  if (Array.isArray(next.hashtags)) {
    const sanitized = next.hashtags
      .map(tag => (typeof tag === "string" ? tag.trim() : ""))
      .filter(tag => tag.length > 0);
    next.hashtags = sanitized.length >= minHashtags ? sanitized : fallbackTags;
  } else {
    next.hashtags = fallbackTags;
  }
  const trimmedCaption = typeof next.caption === "string" ? next.caption.trim() : "";
  next.caption = trimmedCaption.length > 0 ? trimmedCaption : SAFE_DEFAULT_CAPTION;
  return CaptionItem.parse(next);
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

type TextOnlyVariantParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  theme:string;
  context?:string;
  hint?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

export async function generateVariantsTextOnly(params:TextOnlyVariantParams){
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants_textonly.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  let variants: z.infer<typeof CaptionItem>[] = [];
  const keyIndex = new Map<string, number>();

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;
    const voiceContext = formatVoiceContext(params.voice);
    const user = `PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${voiceContext ? `${voiceContext}\n` : ''}${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: ${serializePromptField(params.theme)}\nCONTEXT: ${serializePromptField(params.context || "")}\nNSFW: ${params.nsfw || false}${currentHint ? `\nHINT:${currentHint}` : ''}`;

    let res;
    try {
      res = await textModel.generateContent([{ text: `${sys}\n${guard}\n${prompt}\n${user}` }]);
    } catch (error) {
      console.error('Gemini textModel.generateContent failed:', error);
      throw error;
    }

    const raw = stripToJSON(res.response.text());
    const items = Array.isArray(raw) ? raw : [raw];
    const iterationDuplicates: string[] = [];
    let hasBannedWords = false;

    items.forEach(item => {
      const candidate = (typeof item === "object" && item !== null ? item : {}) as Record<string, unknown>;
      const normalized = normalizeVariantFields(candidate);
      const normalized = normalizeVariantFields(candidate, params.platform);
      
      // Check for banned words in the variant
      if (variantContainsBannedWord(normalized)) {
        hasBannedWords = true;
        return; // Skip this variant
      }
      
      const key = uniqueCaptionKey(normalized.caption);
      const existingIndex = keyIndex.get(key);

      if (existingIndex === undefined) {
        variants.push(normalized);
        keyIndex.set(key, variants.length - 1);
      } else {
        iterationDuplicates.push(normalized.caption);
        const existing = variants[existingIndex];
        if (normalized.caption.length > existing.caption.length) {
          variants[existingIndex] = normalized;
        }
      }
    });

    variants = dedupeCaptionVariants(variants as { caption: string }[]).slice(0, VARIANT_TARGET);
    keyIndex.clear();
    variants.forEach((variant, index) => {
tests/routes/caption-generation.test.ts
+77-0
@@ -220,50 +220,127 @@ describe('Caption Generation', () => {
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected based on engagement potential',
              final: variantPayload[0],
            }),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce(mockVariantsResponse)
        .mockResolvedValueOnce(mockRankResponse);

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      // Verify all variants are unique by checking caption keys
      expect(new Set(result.map(v => v.caption.toLowerCase().slice(0, 80))).size).toBe(5);
    });

    it('pads missing hashtags without introducing banned tokens', async () => {
      const mockImageUrl =
        'data:image/jpeg;base64,' +
        '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAAAAAAAAAAAAAAAAAACP/EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAD8Af//Z';
      const mockPlatform = 'instagram';
      const mockVoice = 'flirty_playful';

      const mockFactsResponse = {
        response: {
          text: () => JSON.stringify({
            objects: ['lingerie'],
            setting: 'studio',
            mood: 'confident',
          }),
        },
      };

      const variantPayload = Array.from({ length: 5 }, (_, index) => ({
        caption: `Variant ${index + 1} celebrating lingerie style moments`,
        safety_level: 'normal',
        mood: 'confident',
        style: 'authentic',
        cta: 'Share your thoughts',
        alt: `Detailed descriptive alt text referencing lingerie for variant ${index + 1}.`,
        nsfw: false,
      }));

      const mockVariantsResponse = {
        response: {
          text: () => JSON.stringify(variantPayload),
        },
      };

      const mockRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected based on engagement potential',
              final: {
                caption: variantPayload[0].caption,
                hashtags: ['#lingerie', '#confidence', '#style'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'authentic',
                cta: 'What do you think?',
                alt: variantPayload[0].alt,
                nsfw: false,
              },
            }),
        },
      };

      const { textModel, visionModel } = await import('../../server/lib/gemini.js');
      const visionGenerateMock = asMock(visionModel.generateContent);
      visionGenerateMock.mockResolvedValueOnce(mockFactsResponse);
      const textGenerateMock = asMock(textModel.generateContent);
      textGenerateMock
        .mockResolvedValueOnce(mockVariantsResponse)
        .mockResolvedValueOnce(mockRankResponse);

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      expect(result.variants).toHaveLength(5);
      for (const variant of result.variants) {
        expect(variant.hashtags.length).toBeGreaterThanOrEqual(3);
        variant.hashtags.forEach(tag => {
          expect(tag.toLowerCase()).not.toContain('content');
        });
      }
    });

    it('retries when duplicate captions are returned', async () => {
      const duplicateVariant = {
        caption: 'Echoed glam look under neon lights',
        hashtags: ['#glam', '#neon', '#night'],
        safety_level: 'normal',
        mood: 'bold',
        style: 'authentic',
        cta: 'What catches your eye?',
        alt: 'Duplicate variant alt text satisfying the schema constraints for testing',
        nsfw: false,
      };
      const duplicateBatch = Array.from({ length: 5 }, () => ({ ...duplicateVariant }));
      const uniqueBatch = [
        {
          caption: 'Fresh spark under city glow tonight',
          hashtags: ['#city', '#spark', '#style'],
          safety_level: 'normal',
          mood: 'excited',
          style: 'vibrant',
          cta: 'Share your vibe',
          alt: 'Alt copy describing a lively city-inspired outfit for uniqueness',
          nsfw: false,
        },
        {
          caption: 'Silky shadows with a fearless smile',
