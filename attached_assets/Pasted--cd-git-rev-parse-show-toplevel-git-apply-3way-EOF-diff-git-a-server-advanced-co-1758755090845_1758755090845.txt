 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/advanced-content-generator.ts b/server/advanced-content-generator.ts
index 48d72be848919c61e0c4c02950ab3b79fc53d63a..a935a807d5b2543b75ee9cbae7a0ee53fa847550 100644
--- a/server/advanced-content-generator.ts
+++ b/server/advanced-content-generator.ts
@@ -833,57 +833,57 @@ function shuffleArray<T>(values: T[]): T[] {
   return values;
 }
 
 export const toneFragmentPools: Record<ContentParameters['textTone'], ToneFragmentPool> = {
   'confident': {
     fillers: ['honestly', 'not gonna lie', 'for real', 'straight up', 'seriously'],
     connectors: ['btw,', 'plus,', 'so here\'s the kicker:', 'and yeah,', 'because yeah,'],
     intro: [
       {
         weight: 3,
         builder: context => `${formatFiller(context.pickFiller())} I pulled together something ${context.pickDescriptor()} in the ${context.pickSetting()}.`
       },
       {
         builder: context => `I'm serving ${context.pickDescriptor()} energy with that ${context.pickTheme()} concept ${context.pickEmoji()}`
       },
       {
         builder: context => `Built this drop like a pro and it shows in every ${context.pickDescriptor()} detail.`
       },
       {
         builder: context => `That ${context.pickTheme()} moment turned into a ${context.pickDescriptor()} flex real quick.`
       }
     ],
     promo: [
       {
         weight: 2,
-        builder: context => `VIPs get the full ${context.pickDescriptor()} reel — it\'s stacked with ${context.pickTheme()} angles.`
+        builder: context => `VIPs get the full ${context.pickDescriptor()} reel — it's stacked with ${context.pickTheme()} angles.`
       },
       {
-        builder: () => `Slide into the premium tier if you want the complete story — I\'m not trimming the heat.`
+        builder: () => `Slide into the premium tier if you want the complete story — I'm not trimming the heat.`
       },
       {
-        builder: context => `Premium fam knows I don\'t play — the extras are straight ${context.pickDescriptor()} moments ${context.pickEmoji()}`
+        builder: context => `Premium fam knows I don't play — the extras are straight ${context.pickDescriptor()} moments ${context.pickEmoji()}`
       }
     ]
   },
   'playful': {
     fillers: ['kinda', 'honestly', 'not gonna lie', 'low-key', 'sorta'],
     connectors: ['btw,', 'so yeah,', 'and yup,', 'alsooo,', 'meanwhile,'],
     intro: [
       {
         weight: 3,
         builder: context => `${formatFiller(context.pickFiller())} I went ${context.pickDescriptor()} with this ${context.pickTheme()} idea.`
       },
       {
         builder: context => `I'm giggling because that ${context.pickSetting()} turned into something ${context.pickDescriptor()} real fast.`
       },
       {
         builder: context => `Tell me why I'm obsessed with this ${context.pickTheme()} moment ${context.pickEmoji()}`
       },
       {
         builder: context => `I kinda let the ${context.pickDescriptor()} vibes run wild today and I'm not sorry.`
       }
     ],
     promo: [
       {
         builder: context => `If you wanna peek at the rest, it's hiding in my VIP corner being all ${context.pickDescriptor()}.`
       },
diff --git a/server/advanced-content-generator.ts b/server/advanced-content-generator.ts
index 48d72be848919c61e0c4c02950ab3b79fc53d63a..a935a807d5b2543b75ee9cbae7a0ee53fa847550 100644
--- a/server/advanced-content-generator.ts
+++ b/server/advanced-content-generator.ts
@@ -1068,262 +1068,148 @@ export const photoTypeFragmentPools: Record<ContentParameters['photoType'], Phot
     connectors: ['no lie,', 'right when the heat rose,', 'and after that,', 'meanwhile,', 'between whispers,'],
     body: [
       {
         weight: 2,
         builder: context => `Silk, shadows, and a ${context.pickDescriptor()} smirk turned the ${context.pickSetting()} molten.`
       },
       {
         builder: context => `I rode that ${context.pickTheme()} wave until the room felt like embers.`
       },
       {
         builder: context => `The ${context.mood} tension snapped right as the shutter clicked.`
       },
       {
         builder: context => `We played with light so every highlight screamed ${context.pickDescriptor()}.`
       }
     ]
   },
   'very-spicy': {
     connectors: ['truth be told,', 'and yeah,', 'while the candles burned,', 'between heartbeats,', 'meanwhile,'],
     body: [
       {
         weight: 2,
         builder: context => `No filter, just ${context.pickDescriptor()} intensity draped across the ${context.pickSetting()}.`
       },
       {
-        builder: context => `Every ${context.pickTheme()} whisper turned louder and I didn\'t flinch.`
+        builder: context => `Every ${context.pickTheme()} whisper turned louder and I didn't flinch.`
       },
       {
         builder: context => `It's bare skin, raw edges, and a ${context.mood} surrender.`
       },
       {
-        builder: context => `I held the pose until the fire looked right back.`
+        builder: () => `I held the pose until the fire looked right back.`
       }
     ]
   },
   'all-xs': {
     connectors: ['full disclosure,', 'meanwhile,', 'when the limits fell,', 'after that,', 'between bold beats,'],
     body: [
       {
         weight: 2,
-        builder: context => `Pushed every boundary in that ${context.pickSetting()} — it\'s ${context.pickDescriptor()} freedom.`
+        builder: context => `Pushed every boundary in that ${context.pickSetting()} — it's ${context.pickDescriptor()} freedom.`
       },
       {
-        builder: context => `The ${context.pickTheme()} vision went all the way and I didn\'t look back.`
+        builder: context => `The ${context.pickTheme()} vision went all the way and I didn't look back.`
       },
       {
         builder: context => `We played with every angle until the art felt limitless and ${context.pickDescriptor()}.`
       },
       {
         builder: context => `It's wild, raw, and dripping in ${context.mood} abandon.`
       }
     ]
   },
   'needs_review': {
     connectors: ['keeping it safe,', 'in that locked room,', 'between us,', 'meanwhile,', 'carefully,'],
     body: [
       {
         builder: context => `There's explicit artistry here — ${context.pickDescriptor()} and unapologetic.`
       },
       {
         weight: 2,
         builder: context => `Every ${context.pickTheme()} scene pushes the frame with intent.`
       },
       {
         builder: context => `I'm curating what feels right, keeping the ${context.mood} promise intact.`
       },
       {
         builder: context => `Handled every shot carefully so it stays ${context.pickDescriptor()} and respectful.`
       }
     ]
   }
 };
 
 export const generalConnectors = ['btw,', 'so yeah,', 'and honestly,', 'plus,', 'meanwhile'];
 
-interface SectionOptions {
-  min?: number;
-  max?: number;
-  skipChance?: number;
-}
-
 function formatFiller(filler: string): string {
   const trimmed = filler.trim();
   if (trimmed.length === 0) {
     return '';
   }
   const capitalized = trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
   return /[ ,:;!?]$/.test(capitalized) ? capitalized : `${capitalized},`;
 }
 
-function cleanSpacing(text: string): string {
-  return text.replace(/\s+([,;:])/g, '$1').replace(/\s{2,}/g, ' ').trim();
-}
-
-function randomInt(min: number, max: number): number {
-  const minValue = Math.ceil(min);
-  const maxValue = Math.floor(max);
-  if (maxValue < minValue) {
-    return minValue;
-  }
-  return Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue;
-}
-
 function pickRandom<T>(items: readonly T[]): T {
   if (items.length === 0) {
     throw new Error('Cannot pick from an empty collection');
   }
   return items[Math.floor(Math.random() * items.length)];
 }
 
-function pickUniqueValue(values: string[], used: Set<string>): string {
-  if (values.length === 0) {
-    return '';
-  }
-  const available = values.filter(value => !used.has(value));
-  const pool = available.length > 0 ? available : values;
-  const choice = pickRandom(pool);
-  used.add(choice);
-  return choice;
-}
-
-function shuffleArrayInPlace<T>(values: T[]): T[] {
-  const copy = [...values];
-  for (let index = copy.length - 1; index > 0; index -= 1) {
-    const swapIndex = Math.floor(Math.random() * (index + 1));
-    const temp = copy[index];
-    copy[index] = copy[swapIndex];
-    copy[swapIndex] = temp;
-  }
-  return copy;
-}
-
 function pickWeightedIndex<T extends { weight?: number }>(items: T[]): number {
   const totalWeight = items.reduce((sum, item) => sum + (item.weight ?? 1), 0);
   if (totalWeight <= 0) {
     return 0;
   }
   let roll = Math.random() * totalWeight;
   for (let index = 0; index < items.length; index += 1) {
     roll -= items[index].weight ?? 1;
     if (roll <= 0) {
       return index;
     }
   }
   return items.length - 1;
 }
 
 export function selectWeightedUniqueFragments<T extends { weight?: number }>(items: T[], count: number): T[] {
   if (items.length === 0 || count <= 0) {
     return [];
   }
   const available = [...items];
   const maxCount = Math.min(count, available.length);
   const selections: T[] = [];
 
   for (let index = 0; index < maxCount; index += 1) {
     const selectionIndex = pickWeightedIndex(available);
     selections.push(available[selectionIndex]);
     available.splice(selectionIndex, 1);
   }
 
   return selections;
 }
 
-function buildSection(pool: FragmentDefinition[], context: FragmentRuntimeContext, options?: SectionOptions): string {
-  if (pool.length === 0) {
-    return '';
-  }
-
-  const sectionOptions: Required<SectionOptions> = {
-    min: options?.min ?? 2,
-    max: options?.max ?? 3,
-    skipChance: options?.skipChance ?? 0.2
-  };
-
-  const fragmentCount = randomInt(sectionOptions.min, sectionOptions.max);
-  const selectedFragments = selectWeightedUniqueFragments(pool, fragmentCount);
-
-  if (selectedFragments.length > 1 && Math.random() < sectionOptions.skipChance) {
-    selectedFragments.splice(Math.floor(Math.random() * selectedFragments.length), 1);
-  }
-
-  const builtFragments = selectedFragments
-    .map(fragment => fragment.builder(context).trim())
-    .filter(fragmentText => fragmentText.length > 0);
-
-  if (builtFragments.length === 0) {
-    return '';
-  }
-
-  return cleanSpacing(shuffleArrayInPlace(builtFragments).join(' '));
-}
-
-function createFragmentContext(
-  toneStyle: ToneStyle,
-  photoConfig: PhotoConfig,
-  fillers: string[],
-  photoType: ContentParameters['photoType']
-): FragmentRuntimeContext {
-  const descriptorUsage = new Set<string>();
-  const themeUsage = new Set<string>();
-  const settingUsage = new Set<string>();
-  const fillerPool = fillers.length > 0 ? fillers : ['honestly'];
-
-  return {
-    pickDescriptor: () => pickUniqueValue(toneStyle.descriptors, descriptorUsage),
-    pickTheme: () => pickUniqueValue(photoConfig.themes, themeUsage),
-    pickSetting: () => pickUniqueValue(photoConfig.settings, settingUsage),
-    pickEmoji: () => (toneStyle.emojis.length > 0 ? pickRandom(toneStyle.emojis) : ''),
-    pickFiller: () => pickRandom(fillerPool),
-    mood: photoConfig.mood,
-    photoType
-  };
-}
-
-function buildCustomPromptSegment(customPrompt: string, connectors: string[]): string {
-  const trimmedPrompt = customPrompt.trim();
-  if (trimmedPrompt.length === 0) {
-    return '';
-  }
-
-  const connectorPool = connectors.length > 0 ? connectors : generalConnectors;
-  const prefix = connectorPool.length > 0 && Math.random() < 0.9 ? pickRandom(connectorPool) : '';
-  const suffix = connectorPool.length > 0 && Math.random() < 0.35 ? pickRandom(connectorPool) : '';
-
-  const parts: string[] = [];
-  if (prefix) {
-    parts.push(prefix);
-  }
-  parts.push(trimmedPrompt);
-  if (suffix) {
-    parts.push(suffix);
-  }
-
-  return cleanSpacing(parts.join(' '));
-}
-
 // Helper functions for platform-specific processing
 function applyEmojiDensity(text: string, emojiPool: string[], targetDensity: number): string {
   const currentEmojis = (text.match(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu) || []).length;
   const emojisToAdd = Math.max(0, targetDensity - currentEmojis);
 
   if (emojisToAdd === 0 || emojiPool.length === 0) {
     return text;
   }
 
   let result = text;
   for (let i = 0; i < emojisToAdd; i++) {
     const emoji = pickRandom(emojiPool);
     const insertionPoint = Math.floor(Math.random() * (result.length + 1));
     result = `${result.slice(0, insertionPoint)}${emoji}${result.slice(insertionPoint)}`;
   }
 
   return result;
 }
 
 function clampSentenceLength(text: string, maxLengths: number[]): string {
   if (maxLengths.length === 0) {
     return text;
   }
 
   const maxLength = pickRandom(maxLengths);
diff --git a/server/advanced-content-generator.ts b/server/advanced-content-generator.ts
index 48d72be848919c61e0c4c02950ab3b79fc53d63a..a935a807d5b2543b75ee9cbae7a0ee53fa847550 100644
--- a/server/advanced-content-generator.ts
+++ b/server/advanced-content-generator.ts
@@ -1552,99 +1438,130 @@ export function generateAdvancedContent(params: ContentParameters): GeneratedCon
   const mainContent = generateMainContent(params, photoConfig, toneStyle, experimentAssignment);
   const photoInstructions = generatePhotoInstructions(params, photoConfig);
   const tags = generateTags(params, photoConfig);
 
   const authenticity = scoreAuthenticity({
     content: mainContent.content,
     titles,
     voiceMarkersUsed: mainContent.voiceMarkersUsed,
     callbacksUsed: mainContent.callbacksUsed,
     communityPack: mainContent.communityPack
   });
 
   return {
     titles,
     content: mainContent.content,
     photoInstructions,
     tags,
     diagnostics: {
       authenticity,
       experiment: experimentAssignment,
       voiceMarkersUsed: mainContent.voiceMarkersUsed
     }
   };
 }
 
+const BUILT_IN_PRESET_VARIATIONS: Record<string, PresetVariation[]> = {
+  'morning-coffee': [{
+    titles: [
+      'Morning coffee and cozy vibes ☕',
+      'Starting my day right',
+      'Coffee in hand, ready for anything'
+    ],
+    content:
+      "There's something magical about that first sip of coffee in the morning. Messy hair, cozy sweater, and that peaceful moment before the day begins. Just me and my thoughts in the quiet morning light.",
+    photoInstructions: {
+      lighting: 'Soft morning light, golden hour glow through windows',
+      angles: 'Candid morning shots, cozy intimate angles',
+      composition: 'Natural comfortable framing with coffee elements',
+      styling: 'Cozy morning wear, comfortable and relaxed',
+      technical: 'Natural lighting, soft focus, warm tones',
+      sceneSetup: 'Cozy morning setting with coffee and natural light'
+    }
+  }],
+  'workout-motivation': [{
+    titles: [
+      'Post-workout glow hits different 💪',
+      'Feeling strong and unstoppable',
+      'Sweat, determination, and pride'
+    ],
+    content:
+      "Just finished an intense workout and I'm feeling incredible. There's something about pushing your limits that makes you feel alive. Endorphins flowing, muscles burning in the best way, and that sense of accomplishment.",
+    photoInstructions: {
+      lighting: 'Bright energetic lighting, motivational atmosphere',
+      angles: 'Strong empowering angles, action documentation',
+      composition: 'Athletic framing showing strength and determination',
+      styling: 'Workout gear, athletic wear, fitness focused',
+      technical: 'Clear bright lighting, action-ready settings',
+      sceneSetup: 'Gym or workout space, fitness equipment visible'
+    }
+  }]
+};
+
 async function loadPresetVariations(): Promise<Record<string, PresetVariation[]>> {
   try {
     const presetPath = path.join(process.cwd(), 'prompts', 'preset-variations.json');
     const data = await fs.readFile(presetPath, 'utf-8');
     return JSON.parse(data);
   } catch (error) {
-    console.warn('No preset variations file found, using built-in presets');
-    return {
-      'morning-coffee': [{
-        titles: ["Morning coffee and cozy vibes ☕", "Starting my day right", "Coffee in hand, ready for anything"],
-        content: "There's something magical about that first sip of coffee in the morning. Messy hair, cozy sweater, and that peaceful moment before the day begins. Just me and my thoughts in the quiet morning light.",
-        photoInstructions: {
-          lighting: "Soft morning light, golden hour glow through windows",
-          angles: "Candid morning shots, cozy intimate angles",
-          composition: "Natural comfortable framing with coffee elements",
-          styling: "Cozy morning wear, comfortable and relaxed",
-          technical: "Natural lighting, soft focus, warm tones",
-          sceneSetup: "Cozy morning setting with coffee and natural light"
-        }
-      }],
-      'workout-motivation': [{
-        titles: ["Post-workout glow hits different 💪", "Feeling strong and unstoppable", "Sweat, determination, and pride"],
-        content: "Just finished an intense workout and I'm feeling incredible. There's something about pushing your limits that makes you feel alive. Endorphins flowing, muscles burning in the best way, and that sense of accomplishment.",
-        photoInstructions: {
-          lighting: "Bright energetic lighting, motivational atmosphere",
-          angles: "Strong empowering angles, action documentation",
-          composition: "Athletic framing showing strength and determination",
-          styling: "Workout gear, athletic wear, fitness focused",
-          technical: "Clear bright lighting, action-ready settings",
-          sceneSetup: "Gym or workout space, fitness equipment visible"
-        }
-      }]
-    };
+    console.warn('No preset variations file found, using built-in presets', error);
+    return BUILT_IN_PRESET_VARIATIONS;
   }
 }
 
 let presetVariationsCache: Record<string, PresetVariation[]> | null = null;
 
 async function getPresetVariations(): Promise<Record<string, PresetVariation[]>> {
   if (!presetVariationsCache) {
     presetVariationsCache = await loadPresetVariations();
   }
   return presetVariationsCache;
 }
 
 function getRandomPresetVariation(presetId: string): PresetVariation | null {
-  // This is a synchronous version that returns null for non-preset requests
-  // The async loading is handled elsewhere
-  return null;
+  if (!presetId) {
+    return null;
+  }
+
+  if (!presetVariationsCache) {
+    void getPresetVariations().catch(loadError => {
+      console.warn('Failed to preload preset variations', loadError);
+    });
+
+    const fallbackVariations = BUILT_IN_PRESET_VARIATIONS[presetId];
+    if (!fallbackVariations || fallbackVariations.length === 0) {
+      return null;
+    }
+    return pickRandom(fallbackVariations);
+  }
+
+  const variations = presetVariationsCache[presetId];
+  if (!variations || variations.length === 0) {
+    return null;
+  }
+
+  return pickRandom(variations);
 }
 
 function generateTitles(
   params: ContentParameters,
   photoConfig: PhotoConfig,
   toneStyle: ToneStyle,
   profiles: Record<string, PlatformProfile>
 ): string[] {
   const profile = profiles[params.platform] ?? profiles.default;
   const maxSentenceLengths = profile.maxSentenceLength;
   const emojiCount = pickRandom(profile.emojiDensity);
   const callToAction = pickRandom(profile.callToActions);
   const context: PlatformPostProcessContext = {
     emojiPool: toneStyle.emojis,
     emojiCount
   };
 
   const desiredTitleCount = Math.floor(Math.random() * (MAX_TITLES - MIN_TITLES + 1)) + MIN_TITLES;
   const themes = photoConfig.themes;
   const starters = toneStyle.starters;
   const emojis = toneStyle.emojis;
 
   const connectorPool = (toneStyle.connectors ?? []).filter(connector => connector.trim().length > 0);
   const connectors = connectorPool.length > 0 ? connectorPool : fallbackConnectors;
   const basePatterns = toneStyle.titlePatterns && toneStyle.titlePatterns.length > 0 ? toneStyle.titlePatterns : fallbackTitlePatterns;
 
EOF
)