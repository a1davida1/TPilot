diff --git a/server/routes/health.ts b/server/routes/health.ts
@@
-import { Router } from "express";
-
-export const healthRouter = Router();
-
-healthRouter.get("/health", (_req, res) => {
-  res.json({ status: "ok" });
-});
+import { Router } from "express";
+import { pool } from "../db";
+import Redis from "ioredis";
+import { storage } from "../storage";
+import { logger } from "../bootstrap/logger";
+
+const healthRouter = Router();
+const redis = new Redis(process.env.REDIS_URL);
+
+healthRouter.get("/health", async (_req, res) => {
+  const checks = { database: false, redis: false, storage: false };
+
+  try {
+    await pool.query("SELECT 1");
+    checks.database = true;
+  } catch (err) {
+    logger.error("Database health check failed", { error: err instanceof Error ? err.message : String(err) });
+  }
+
+  try {
+    await redis.ping();
+    checks.redis = true;
+  } catch (err) {
+    logger.error("Redis health check failed", { error: err instanceof Error ? err.message : String(err) });
+  }
+
+  try {
+    await storage.getTotalUserCount();
+    checks.storage = true;
+  } catch (err) {
+    logger.error("Storage health check failed", { error: err instanceof Error ? err.message : String(err) });
+  }
+
+  const healthy = Object.values(checks).every(Boolean);
+  res.status(healthy ? 200 : 503).json(checks);
+});
+
+export { healthRouter };
diff --git a/server/middleware/validation.ts b/server/middleware/validation.ts
@@
-export const passwordSchema = z.string()
-  .min(8, 'Password must be at least 8 characters')
-  .max(128, 'Password must be less than 128 characters')
-  .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/, 'Password must contain at least one lowercase letter, one uppercase letter, and one number');
+export const passwordSchema = z.string()
+  .min(12, 'Password must be at least 12 characters')
+  .max(128, 'Password must be less than 128 characters')
+  .regex(/[A-Z]/, 'Must contain uppercase')
+  .regex(/[a-z]/, 'Must contain lowercase')
+  .regex(/[0-9]/, 'Must contain number')
+  .regex(/[^A-Za-z0-9]/, 'Must contain special character');
diff --git a/server/lib/tokenBlacklist.ts b/server/lib/tokenBlacklist.ts
new file mode 100644
--- /dev/null
+++ b/server/lib/tokenBlacklist.ts
@@
+import Redis from 'ioredis';
+
+const redis = new Redis(process.env.REDIS_URL);
+
+function signatureFromToken(token: string): string | null {
+  const parts = token.split('.');
+  return parts.length === 3 ? parts[2] : null;
+}
+
+export async function blacklistToken(token: string, ttlSeconds: number): Promise<void> {
+  const sig = signatureFromToken(token);
+  if (!sig) return;
+  await redis.setex(`bl:${sig}`, ttlSeconds, '1');
+}
+
+export async function isTokenBlacklisted(token: string): Promise<boolean> {
+  const sig = signatureFromToken(token);
+  if (!sig) return false;
+  const exists = await redis.exists(`bl:${sig}`);
+  return exists === 1;
+}
diff --git a/server/middleware/auth.ts b/server/middleware/auth.ts
@@
-import { logger } from './security.js';
-import { db } from '../db.js';
-import { users } from '@shared/schema.js';
+import { logger } from './security.js';
+import { db } from '../db.js';
+import { users } from '@shared/schema.js';
+import { isTokenBlacklisted } from '../lib/tokenBlacklist';
@@
-const JWT_SECRET = process.env.JWT_SECRET!;
-if (!JWT_SECRET) {
-  throw new Error('JWT_SECRET environment variable is required');
-}
+const JWT_SECRET = process.env.JWT_SECRET;
+if (!JWT_SECRET) {
+  throw new Error('JWT_SECRET environment variable is required');
+}
@@
-  if (token) {
-    try {
-      const decoded = jwt.verify(token, JWT_SECRET) as { userId: number; email: string; iat: number; exp: number };
+  if (token) {
+    if (await isTokenBlacklisted(token)) {
+      return res.status(401).json({ message: 'Token revoked' });
+    }
+    try {
+      const decoded = jwt.verify(token, JWT_SECRET) as { userId: number; email: string; iat: number; exp: number };
diff --git a/server/social-auth.ts b/server/social-auth.ts
@@
-import { storage } from './storage';
+import { storage } from './storage';
+import jwt from 'jsonwebtoken';
+import { blacklistToken } from './lib/tokenBlacklist';
+import { logger } from './bootstrap/logger';
@@
-            console.error('Passport logout error:', err);
+            logger.error('Passport logout error', { error: err instanceof Error ? err.message : String(err) });
@@
-              if (destroyErr) {
-                console.error('Session destroy error:', destroyErr);
-              }
+              if (destroyErr) {
+                logger.error('Session destroy error', { error: destroyErr instanceof Error ? destroyErr.message : String(destroyErr) });
+              }
@@
-          res.json({ message: 'Logged out successfully' });
+          const authHeader = req.headers['authorization'];
+          const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
+          if (token) {
+            const decoded = jwt.decode(token) as { exp?: number } | null;
+            const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
+            await blacklistToken(token, ttl);
+          }
+          res.json({ message: 'Logged out successfully' });
@@
-            if (err) {
-              console.error('Session destroy error:', err);
-            }
+            if (err) {
+              logger.error('Session destroy error', { error: err instanceof Error ? err.message : String(err) });
+            }
@@
-          res.json({ message: 'Logged out successfully' });
+          const authHeader = req.headers['authorization'];
+          const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
+          if (token) {
+            const decoded = jwt.decode(token) as { exp?: number } | null;
+            const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
+            await blacklistToken(token, ttl);
+          }
+          res.json({ message: 'Logged out successfully' });
@@
-      console.error('Logout error:', error);
+      logger.error('Logout error', { error: error instanceof Error ? error.message : String(error) });
diff --git a/server/lib/billing.ts b/server/lib/billing.ts
@@
-import { db } from "../db.js";
-import { subscriptions, invoices } from "@shared/schema.js";
+import { db } from "../db.js";
+import { subscriptions, invoices } from "@shared/schema.js";
+import { logger } from "../bootstrap/logger";
@@
-        case 'RenewalFailure':
-          await this.updateSubscription(subscription_id as string, {
-            status: 'past_due',
-            reason: reason_desc as string,
-          });
-          break;
-
-        default:
-          console.warn(`Unhandled CCBill event: ${eventType}`);
+        case 'RenewalFailure':
+          await this.updateSubscription(subscription_id as string, {
+            status: 'past_due',
+            reason: reason_desc as string,
+          });
+          break;
+
+        default:
+          logger.warn('Unhandled CCBill event', { eventType });
       }
@@
-    } catch (error) {
-      console.error('CCBill webhook error:', error);
-      return { success: false, message: 'Internal server error' };
-    }
+    } catch (error: unknown) {
+      const message = error instanceof Error ? error.message : 'Unknown error';
+      logger.error('CCBill webhook error', { error: message });
+      return { success: false, message: 'Internal server error' };
+    }
   }
@@
-    await db.insert(subscriptions).values({
-      userId,
-      status: details.status as 'active' | 'canceled' | 'past_due',
-      plan: details.plan as 'free' | 'starter' | 'pro',
-      priceCents: details.priceCents,
-      processor: 'ccbill',
-      processorSubId,
-      currentPeriodEnd: details.nextBillDate,
-    });
-
-    await db.insert(invoices).values({
-      subscriptionId: (await this.getSubscriptionByProcessorId(processorSubId)).id,
-      amountCents: details.priceCents,
-      status: 'paid',
-      processor: 'ccbill',
-      processorRef: processorSubId,
-    });
+    await db.transaction(async (tx) => {
+      const [sub] = await tx.insert(subscriptions).values({
+        userId,
+        status: details.status as 'active' | 'canceled' | 'past_due',
+        plan: details.plan as 'free' | 'starter' | 'pro',
+        priceCents: details.priceCents,
+        processor: 'ccbill',
+        processorSubId,
+        currentPeriodEnd: details.nextBillDate,
+      }).returning();
+
+      await tx.insert(invoices).values({
+        subscriptionId: sub.id,
+        amountCents: details.priceCents,
+        status: 'paid',
+        processor: 'ccbill',
+        processorRef: processorSubId,
+      });
+    });
   }
diff --git a/server/routes.ts b/server/routes.ts
@@
-import { registerSocialMediaRoutes } from "./social-media-routes.js";
+import { registerSocialMediaRoutes } from "./social-media-routes.js";
+import Redis from "ioredis";
@@
-    registerExpenseRoutes(app);
-
-    const generationCache = new Map<string, { response: Record<string, unknown>; timestamp: number }>();
+    registerExpenseRoutes(app);
+
+    const redis = new Redis(process.env.REDIS_URL);
@@
-        const cacheKey = JSON.stringify({ platform, imageDescription, customPrompt, subreddit, allowsPromotion, imageUrl });
-        const cached = generationCache.get(cacheKey);
-        if (cached) {
-          return res.json({ ...cached.response, cached: true });
-        }
+        const cacheKey = JSON.stringify({ platform, imageDescription, customPrompt, subreddit, allowsPromotion, imageUrl });
+        const cached = await redis.get(cacheKey);
+        if (cached) {
+          return res.json({ ...JSON.parse(cached), cached: true });
+        }
@@
-          generationCache.set(cacheKey, { response: result, timestamp: Date.now() });
-          res.json({ ...result, cached: false });
+          await redis.setex(cacheKey, 3600, JSON.stringify(result));
+          res.json({ ...result, cached: false });
diff --git a/server/index.ts b/server/index.ts
@@
-import express, { type Request, Response, NextFunction, type RequestHandler } from "express";
+import express, { type Request, Response, NextFunction, type RequestHandler } from "express";
+import type { Server } from "http";
@@
-import { logger } from "./bootstrap/logger";
+import { logger } from "./bootstrap/logger";
+import Redis from "ioredis";
+import { pool } from "./db";
@@
-const API_PREFIX = '/api/v1';
+const API_PREFIX = '/api/v1';
+const cache = new Redis(process.env.REDIS_URL);
+
+let server: Server | undefined;
@@
-    const server = await registerRoutes(app, API_PREFIX);
+    server = await registerRoutes(app, API_PREFIX);
@@
     startServer(port);
   } catch (error) {
     logger.error('Failed to start application:', error);
     process.exit(1);
   }
 })();
+
+process.on('SIGTERM', async () => {
+  logger.info('SIGTERM received, shutting down');
+  server?.close(() => {
+    pool.end();
+    cache.disconnect();
+    process.exit(0);
+  });
+});
