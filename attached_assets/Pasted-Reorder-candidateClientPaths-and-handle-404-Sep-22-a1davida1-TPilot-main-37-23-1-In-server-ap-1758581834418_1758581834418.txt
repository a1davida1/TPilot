Reorder candidateClientPaths and handle 404
Sep 22 · a1davida1/TPilot · main
+37-23
1. In `server/app.ts`, reorder the `candidateClientPaths` array so the compiled paths (`dist/client`, `client/dist`) are probed before `../client`.
2. When none of the build paths contain `index.html`, short-circuit the SPA fallback to return a 404 (with the existing warning) instead of continuing on to serve from the source tree.
3. Keep the development fallback behind an explicit flag (e.g., only when `enableVite` is true) so automated checks see the 404 in CI.

Summary

    Reworked configureStaticAssets to prefer compiled bundles by scanning dist/client and client/dist before optionally falling back to the raw client tree when Vite dev mode is explicitly enabled, keeping the development shortcut behind the feature flag.

Removed the hard process exit, skipped static middleware when no build is found, and made the wildcard SPA handler return a 404 whenever index.html is missing so production probes fail fast instead of leaking the source tree.

Testing

    ✅ npm run lint

❌ npm test *(fails with numerous pre-existing integration/unit issues; suite eventually interrupted after extended failures)*


server/app.ts
+37-23
@@ -91,131 +91,145 @@ function applyRequestLogging(app: express.Express): void {
      if (path.startsWith('/api')) {
        let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
        const payload = prepareResponseLogPayload(capturedJsonResponse);
        if (payload) {
          logLine += ` :: ${payload}`;
        }

        logger.info(truncateLogLine(logLine), { requestId: req.id });
      }
    });

    next();
  });
}

async function configureStaticAssets(
  app: express.Express,
  server: import('http').Server,
  enableVite: boolean,
): Promise<void> {
  const path = await import('path');
  const { fileURLToPath } = await import('url');
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const fs = await import('fs');

  const candidateClientPaths = [
    path.resolve(__dirname, '..', 'client'),
  const isDevelopment = app.get('env') === 'development';
  const viteDevFlag = process.env.ENABLE_VITE_DEV?.toLowerCase();
  const isViteExplicitlyDisabled = viteDevFlag === 'false' || viteDevFlag === '0';
  const shouldEnableVite = enableVite && isDevelopment && !isViteExplicitlyDisabled;

  const compiledClientPaths = [
    path.resolve(__dirname, '..', '..', 'dist', 'client'),
    path.resolve(__dirname, '..', 'client', 'dist'),
  ];
  const sourceClientPath = path.resolve(__dirname, '..', 'client');

  let clientPath: string | null = null;

  for (const candidate of candidateClientPaths) {
  for (const candidate of compiledClientPaths) {
    const indexPath = path.join(candidate, 'index.html');
    if (!fs.existsSync(indexPath)) {
      logger.warn(`Client build not found at ${indexPath}`);
      continue;
    }

    clientPath = candidate;
    logger.info(`Serving client from: ${clientPath}`);
    break;
  }

  if (!clientPath && shouldEnableVite) {
    const indexPath = path.join(sourceClientPath, 'index.html');
    if (fs.existsSync(indexPath)) {
      clientPath = sourceClientPath;
      logger.info(`Serving client from: ${clientPath}`);
    } else {
      logger.warn(`Client build not found at ${indexPath}`);
    }
  }

  if (!clientPath) {
    if (process.env.NODE_ENV === 'production') {
      logger.error('CRITICAL: Production build missing client files!');
    }
    logger.error('Unable to locate compiled client assets in any known directory.');
    process.exit(1);
    return;
  }

  // Debug middleware to trace all requests
  app.use((req, res, next) => {
    if (req.path.startsWith('/assets/')) {
      logger.info(`Asset request received: ${req.method} ${req.path}`);
    }
    next();
  });

  // IMPORTANT: Serve static files BEFORE Vite setup to ensure they're accessible
  // Set index: false to prevent serving index.html for directory requests to avoid conflicts
  app.use(express.static(clientPath, {
    index: false,
    setHeaders: (res, path) => {
      logger.info(`Static file served: ${path}`);
      if (path.endsWith('.js')) {
        res.setHeader('Content-Type', 'application/javascript');
      } else if (path.endsWith('.css')) {
        res.setHeader('Content-Type', 'text/css');
  if (clientPath) {
    // IMPORTANT: Serve static files BEFORE Vite setup to ensure they're accessible
    // Set index: false to prevent serving index.html for directory requests to avoid conflicts
    app.use(express.static(clientPath, {
      index: false,
      setHeaders: (res, filePath) => {
        logger.info(`Static file served: ${filePath}`);
        if (filePath.endsWith('.js')) {
          res.setHeader('Content-Type', 'application/javascript');
        } else if (filePath.endsWith('.css')) {
          res.setHeader('Content-Type', 'text/css');
        }
      }
    }
  }));

  // Enable Vite in development by default; allow opt-out via ENABLE_VITE_DEV
  const isDevelopment = app.get('env') === 'development';
  const viteDevFlag = process.env.ENABLE_VITE_DEV?.toLowerCase();
  const isViteExplicitlyDisabled = viteDevFlag === 'false' || viteDevFlag === '0';
  const shouldEnableVite = enableVite && isDevelopment && !isViteExplicitlyDisabled;
    }));
  }

  if (shouldEnableVite) {
    try {
      const { setupVite } = await import('./vite.js');
      await setupVite(app, server);
      logger.info('Vite development server configured');
    } catch (error) {
      logger.warn('Could not setup Vite in development mode:', error);
    }
  } else if (enableVite && isDevelopment) {
    logger.info('Vite development server disabled via ENABLE_VITE_DEV flag. Remove or set to true to re-enable.');
  }

  // SPA fallback - serve index.html for all non-API routes
  app.get('*', (req, res, next) => {
    // Let API/auth/webhook/assets routes fall through to 404 handler or static middleware
    if (req.path.startsWith('/api/') ||
        req.path.startsWith('/auth/') ||
        req.path.startsWith('/webhook/') ||
        req.path.startsWith('/assets/')) {
      logger.debug(`Asset request bypassed SPA fallback: ${req.path}`);
      return next();
    }

    // Serve index.html for SPA routing
    if (!clientPath) {
      res.status(404).send('Client build not found');
      return;
    }

    const indexFile = path.join(clientPath, 'index.html');
    if (fs.existsSync(indexFile)) {
      res.type('html');
      res.sendFile(indexFile);
    } else {
      res.status(404).send('Client build not found');
    }
  });
}

export async function createApp(options: CreateAppOptions = {}): Promise<CreateAppResult> {
  const app = express();
  app.set('trust proxy', 1);
  app.use(generalLimiter);
  app.use(sanitize);

  configureCors(app);

  app.use((req, res, next) => {
    req.id = uuidv4();
    res.setHeader('X-Request-ID', req.id);
    next();
  });

  app.post(`${API_PREFIX}/webhooks/stripe`, express.raw({ type: 'application/json' }), (_req, _res, next) => next());
