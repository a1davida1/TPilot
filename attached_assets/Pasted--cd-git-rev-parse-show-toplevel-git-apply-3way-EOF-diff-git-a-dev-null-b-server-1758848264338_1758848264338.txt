 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a//dev/null b/server/caption/__tests__/fact-coverage.test.ts
index 0000000000000000000000000000000000000000..81c50fd7f67a1d7cf08df67e818c11d6dac74233 100644
--- a//dev/null
+++ b/server/caption/__tests__/fact-coverage.test.ts
@@ -0,0 +1,246 @@
+import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
+
+interface TestCaptionVariant {
+  caption: string;
+  alt: string;
+  hashtags: string[];
+  cta: string;
+  mood: string;
+  style: string;
+  safety_level: string;
+  nsfw: boolean;
+}
+
+interface TestRankResult {
+  winner_index: number;
+  scores: [number, number, number, number, number];
+  reason: string;
+  final: TestCaptionVariant;
+}
+
+const FACTS_FIXTURE: Record<string, unknown> = {
+  objects: ['boardwalk'],
+  colors: ['azure'],
+  setting: ['sunset'],
+  wardrobe: ['jacket']
+};
+
+const makeVariant = (
+  caption: string,
+  alt: string,
+  overrides?: Partial<Omit<TestCaptionVariant, 'caption' | 'alt'>>
+): TestCaptionVariant => ({
+  caption,
+  alt,
+  hashtags: ['#pierwalk', '#sunsettrail', '#cozyjacket'],
+  cta: 'Slide into the sunset with me',
+  mood: 'engaging',
+  style: 'authentic',
+  safety_level: 'normal',
+  nsfw: false,
+  ...overrides
+});
+
+const buildVariantsPayload = (captions: string[], alt: string): TestCaptionVariant[] =>
+  captions.map(caption => makeVariant(caption, alt));
+
+const buildRankResultPayload = (caption: string, alt: string): TestRankResult => ({
+  winner_index: 0,
+  scores: [5, 4, 3, 2, 1],
+  reason: 'Selected for coverage test',
+  final: makeVariant(caption, alt)
+});
+
+const createTextModelResponse = (payload: unknown) => ({
+  response: {
+    text: () => (typeof payload === 'string' ? payload : JSON.stringify(payload))
+  }
+});
+
+const ORIGINAL_ENV = process.env.NODE_ENV;
+
+describe('Gemini fact coverage enforcement', () => {
+  beforeEach(() => {
+    process.env.NODE_ENV = 'test';
+    vi.clearAllMocks();
+    vi.resetModules();
+    vi.unstubAllGlobals();
+  });
+
+  afterEach(() => {
+    process.env.NODE_ENV = ORIGINAL_ENV;
+    vi.restoreAllMocks();
+    vi.unstubAllGlobals();
+  });
+
+  it('re-prompts the gemini pipeline when variants miss image facts', async () => {
+    const fetchMock = vi.fn<typeof fetch>().mockResolvedValue(
+      new Response(Buffer.alloc(80), { headers: { 'content-type': 'image/png' } })
+    );
+    vi.stubGlobal('fetch', fetchMock as typeof fetch);
+
+    const visionModelMock = {
+      generateContent: vi.fn().mockResolvedValue({
+        response: { text: () => JSON.stringify(FACTS_FIXTURE) }
+      })
+    };
+
+    const firstVariants = buildVariantsPayload(
+      ['Generic day out 1', 'Generic day out 2', 'Generic day out 3', 'Generic day out 4', 'Generic day out 5'],
+      'A friendly group smiling in a bright open space with no specific setting mentioned anywhere.'
+    );
+    const secondVariants = buildVariantsPayload(
+      ['Pier walk 1', 'Pier walk 2', 'Pier walk 3', 'Pier walk 4', 'Pier walk 5'],
+      'A warm description that references the scenic walk yet remains high level without hard facts.'
+    );
+
+    const pipelineResponses: Array<ReturnType<typeof createTextModelResponse>> = [
+      createTextModelResponse(firstVariants),
+      createTextModelResponse(
+        buildRankResultPayload(
+          'Just enjoying the day with friends',
+          'Friends smiling in a bright open space without specific imagery mentioned at all for quite some time to meet the length requirement.'
+        )
+      ),
+      createTextModelResponse(secondVariants),
+      createTextModelResponse(
+        buildRankResultPayload(
+          'Sunset stroll on the pier in a cozy jacket',
+          'A person in a navy jacket strolls the seaside boardwalk at sunset, soaking in the azure sky while waves shimmer nearby.'
+        )
+      )
+    ];
+    const pipelineFallback = pipelineResponses[pipelineResponses.length - 1];
+    const textModelMock = vi.fn().mockImplementation(() => {
+      const next = pipelineResponses.shift() ?? pipelineFallback;
+      return Promise.resolve(next);
+    });
+
+    vi.doMock('../../lib/gemini', () => ({
+      visionModel: visionModelMock,
+      textModel: { generateContent: textModelMock }
+    }));
+
+    const module = await import('../geminiPipeline');
+
+    const result = await module.pipeline({
+      imageUrl: 'https://example.com/photo.jpg',
+      platform: 'instagram'
+    });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(visionModelMock.generateContent).toHaveBeenCalledTimes(1);
+    expect(textModelMock.mock.calls.length).toBeGreaterThanOrEqual(4);
+
+    const retryPromptCalls = textModelMock.mock.calls
+      .map(call => {
+        const firstArg = call[0];
+        if (Array.isArray(firstArg)) {
+          return firstArg[0]?.text ?? '';
+        }
+        return typeof firstArg?.text === 'string' ? firstArg.text : '';
+      })
+      .filter(text => typeof text === 'string' && text.includes('IMAGE_FACTS'));
+    expect(retryPromptCalls.some(text => text.includes('colors: azure'))).toBe(true);
+    expect(retryPromptCalls.some(text => text.includes('setting: sunset'))).toBe(true);
+    expect(retryPromptCalls.some(text => text.includes('wardrobe: jacket'))).toBe(true);
+
+    expect(result.final.caption).toBe('Sunset stroll on the pier in a cozy jacket');
+    expect(result.final.alt.toLowerCase()).toContain('boardwalk');
+    expect(result.final.alt.toLowerCase()).toContain('azure');
+    expect(result.final.alt.toLowerCase()).toContain('sunset');
+    expect(result.final.caption.toLowerCase()).toContain('jacket');
+  });
+
+  it('retries rewrite pipeline when coverage fails initially', async () => {
+    const fetchMock = vi.fn<typeof fetch>().mockResolvedValue(
+      new Response(Buffer.alloc(80), { headers: { 'content-type': 'image/png' } })
+    );
+    vi.stubGlobal('fetch', fetchMock as typeof fetch);
+
+    const visionModelMock = {
+      generateContent: vi.fn().mockResolvedValue({
+        response: { text: () => JSON.stringify(FACTS_FIXTURE) }
+      })
+    };
+
+    const firstRewriteVariants = buildVariantsPayload(
+      ['Chill rewrite 1', 'Chill rewrite 2', 'Chill rewrite 3', 'Chill rewrite 4', 'Chill rewrite 5'],
+      'Relaxed rewrite variant without references to wardrobe or the setting in the slightest way.'
+    );
+    const secondRewriteVariants = buildVariantsPayload(
+      ['Boardwalk glow 1', 'Boardwalk glow 2', 'Boardwalk glow 3', 'Boardwalk glow 4', 'Boardwalk glow 5'],
+      'Enhanced rewrite variant that still keeps things broad for alternate selections.'
+    );
+
+    const rewriteResponses: Array<ReturnType<typeof createTextModelResponse>> = [
+      createTextModelResponse(firstRewriteVariants),
+      createTextModelResponse(
+        buildRankResultPayload(
+          'Keeping things chill and conversational',
+          'A relaxed tone without mentioning anything about the setting or wardrobe pieces in view, remaining intentionally generic.'
+        )
+      ),
+      createTextModelResponse(secondRewriteVariants),
+      createTextModelResponse(
+        buildRankResultPayload(
+          'Sunset boardwalk glow with a cozy jacket',
+          'An excited friend in a jacket leans on the pier railing as the azure sky warms into sunset hues across the seaside boardwalk.'
+        )
+      )
+    ];
+    const rewriteFallback = rewriteResponses[rewriteResponses.length - 1];
+    const textModelMock = vi.fn().mockImplementation(() => {
+      const next = rewriteResponses.shift() ?? rewriteFallback;
+      return Promise.resolve(next);
+    });
+
+    vi.doMock('../../lib/gemini', () => ({
+      visionModel: visionModelMock,
+      textModel: { generateContent: textModelMock }
+    }));
+
+    vi.doMock('../schema', async () => {
+      const actual = await vi.importActual<typeof import('../schema')>('../schema');
+      return { ...actual, platformChecks: vi.fn().mockReturnValue(null) };
+    });
+    vi.doMock('../rankingGuards', async () => {
+      const actual = await vi.importActual<typeof import('../rankingGuards')>('../rankingGuards');
+      return {
+        ...actual,
+        detectRankingViolations: vi.fn().mockReturnValue([]),
+        safeFallbackHashtags: vi.fn().mockReturnValue(['#story', '#share', '#moments']),
+        formatViolations: vi.fn().mockReturnValue('')
+      };
+    });
+
+    const module = await import('../rewritePipeline');
+
+    const result = await module.pipelineRewrite({
+      platform: 'instagram',
+      existingCaption: 'Sunset memories',
+      imageUrl: 'https://example.com/photo.jpg'
+    });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(visionModelMock.generateContent).toHaveBeenCalledTimes(1);
+    expect(textModelMock.mock.calls.length).toBeGreaterThanOrEqual(4);
+
+    const rewriteRetryPrompts = textModelMock.mock.calls
+      .map(call => {
+        const firstArg = call[0];
+        if (Array.isArray(firstArg)) {
+          return firstArg[0]?.text ?? '';
+        }
+        return typeof firstArg?.text === 'string' ? firstArg.text : '';
+      })
+      .filter(text => typeof text === 'string' && text.includes('IMAGE_FACTS'));
+    expect(rewriteRetryPrompts.some(text => text.includes('nouns: boardwalk'))).toBe(true);
+
+    expect(result.final.caption).toBe('Sunset boardwalk glow with a cozy jacket');
+    expect(result.final.alt.toLowerCase()).toContain('pier');
+    expect(result.final.alt.toLowerCase()).toContain('azure');
+    expect(result.final.alt.toLowerCase()).toContain('sunset');
+    expect(result.final.caption.toLowerCase()).toContain('jacket');
+  });
+});
 
EOF
)