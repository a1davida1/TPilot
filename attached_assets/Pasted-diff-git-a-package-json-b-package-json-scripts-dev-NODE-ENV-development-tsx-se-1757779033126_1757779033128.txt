diff --git a/package.json b/package.json
@@
   "scripts": {
     "dev": "NODE_ENV=development tsx server/index.ts",
     "build": "bash build-production.sh",
+    "build:client": "vite build",
+    "build:server": "tsc -p tsconfig.server.json --skipLibCheck",
     "start": "NODE_ENV=production tsx server/index.ts",
     "db:generate": "drizzle-kit generate",
     "db:migrate": "drizzle-kit migrate",
     "db:studio": "drizzle-kit studio",
     "typecheck": "tsc -p tsconfig.json --noEmit",
diff --git a/server/utils/error.ts b/server/utils/error.ts
new file mode 100644
--- /dev/null
+++ b/server/utils/error.ts
@@
+export function getErrorMessage(err: unknown): string {
+  if (err instanceof Error) return err.message;
+  try {
+    return JSON.stringify(err);
+  } catch {
+    return String(err);
+  }
+}
diff --git a/server/api-routes.ts b/server/api-routes.ts
@@
-import { addJob } from './lib/queue';
+import { addJob, QueueNames } from './lib/queue';
+import { getErrorMessage } from './utils/error';
@@
-      await addJob<PostingJobPayload>('posting', {
+      await addJob<PostingJobPayload>('posting' as QueueNames, {
         userId: req.user.id,
         title,
         body
       });
@@
-  } catch (error) {
-    res.status(500).json({ error: error.message });
+  } catch (error: unknown) {
+    res.status(500).json({ error: getErrorMessage(error) });
   }
@@
-  } catch (error) {
-    res.status(500).json({ error: error.message });
+  } catch (error: unknown) {
+    res.status(500).json({ error: getErrorMessage(error) });
   }
@@
-  } catch (error) {
-    res.status(500).json({ error: error.message });
+  } catch (error: unknown) {
+    res.status(500).json({ error: getErrorMessage(error) });
   }
diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
@@
-      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
-        apiVersion: '2023-10-16',
-      });
+      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
+        apiVersion: Stripe.LatestApiVersion,
+      });
@@
-type AnalyticsEvent = z.infer<typeof analyticsEventSchema>;
+type AnalyticsEvent = z.infer<typeof analyticsEventSchema>;
@@
-async function processAnalyticsEvent(event: unknown, ipAddress: string) {
-  const deviceInfo = parseUserAgent(event.userAgent);
+async function processAnalyticsEvent(event: AnalyticsEvent, ipAddress: string) {
+  const deviceInfo = parseUserAgent(event.userAgent ?? '');
@@
-  switch (event.eventType) {
+  switch (event.eventType) {
diff --git a/server/bootstrap/logger.ts b/server/bootstrap/logger.ts
@@
-        if (event.request?.url?.includes('/_vite/')) {
+        if ((event as any).request?.url?.includes('/_vite/')) {
           return null;
         }
@@
-      const error = hint?.originalException;
+      const error = (hint as any)?.originalException;
@@
-    info: (message: string, meta?: unknown) => logger.info(message, { requestId, ...meta }),
-    warn: (message: string, meta?: unknown) => logger.warn(message, { requestId, ...meta }),
-    error: (message: string, meta?: unknown) => logger.error(message, { requestId, ...meta }),
-    debug: (message: string, meta?: unknown) => logger.debug(message, { requestId, ...meta })
+    info: (message: string, meta: Record<string, unknown> = {}) =>
+      logger.info(message, { requestId, ...meta }),
+    warn: (message: string, meta: Record<string, unknown> = {}) =>
+      logger.warn(message, { requestId, ...meta }),
+    error: (message: string, meta: Record<string, unknown> = {}) =>
+      logger.error(message, { requestId, ...meta }),
+    debug: (message: string, meta: Record<string, unknown> = {}) =>
+      logger.debug(message, { requestId, ...meta })
@@
-  logger.warn(event, { security: true, ...details });
+  logger.warn(event, { security: true, ...(details as Record<string, unknown>) });
diff --git a/server/caption/openaiFallback.ts b/server/caption/openaiFallback.ts
@@
-  const json = await response.json();
-  return {
-    caption: json.caption || 'Fallback caption',
-    hashtags: json.hashtags || [],
-    safety_level: json.safety_level || 'normal',
-    mood: json.mood || 'neutral',
-    style: json.style || 'fallback',
-    cta: json.cta || ''
-  };
+  const json: any = await response.json();
+  return {
+    caption: json?.caption ?? 'Fallback caption',
+    hashtags: json?.hashtags ?? [],
+    safety_level: json?.safety_level ?? 'normal',
+    mood: json?.mood ?? 'neutral',
+    style: json?.style ?? 'fallback',
+    cta: json?.cta ?? ''
+  };
diff --git a/server/caption/rewritePipeline.ts b/server/caption/rewritePipeline.ts
@@
-    variants.forEach(item => {
-      if(!item.safety_level) item.safety_level="suggestive";
-      else if(item.safety_level === 'suggestive') item.safety_level = 'spicy_safe';
-      if(!item.mood || item.mood.length<2) item.mood="engaging";
-      if(!item.style || item.style.length<2) item.style="authentic";
-      if(!item.cta || item.cta.length<2) item.cta="Check it out";
-      if(!item.alt || item.alt.length<20) item.alt="Engaging social media content";
-      if(!item.hashtags || !Array.isArray(item.hashtags)) item.hashtags=["#content", "#creative", "#amazing"];
-      if(!item.caption || item.caption.length<1) item.caption="Check out this amazing content, you'll love it and want more!";
-    });
+    variants.forEach((item: any) => {
+      if(!item.safety_level) item.safety_level="suggestive";
+      else if(item.safety_level === 'suggestive') item.safety_level = 'spicy_safe';
+      if(!item.mood || item.mood.length<2) item.mood="engaging";
+      if(!item.style || item.style.length<2) item.style="authentic";
+      if(!item.cta || item.cta.length<2) item.cta="Check it out";
+      if(!item.alt || item.alt.length<20) item.alt="Engaging social media content";
+      if(!item.hashtags || !Array.isArray(item.hashtags)) item.hashtags=["#content", "#creative", "#amazing"];
+      if(!item.caption || item.caption.length<1) item.caption="Check out this amazing content, you'll love it and want more!";
+    });
diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
@@
-    variants.forEach(item => {
-      if(!item.safety_level) item.safety_level="suggestive";
-      if(!item.mood || item.mood.length<2) item.mood="engaging";
-      if(!item.style || item.style.length<2) item.style="authentic";
-      if(!item.cta || item.cta.length<2) item.cta="Check it out";
-      if(!item.alt || item.alt.length<20) item.alt="Engaging social media content";
-      if(!item.hashtags || !Array.isArray(item.hashtags) || item.hashtags.length < 3) {
-        if(item.hashtags && item.hashtags.length >= 1) item.hashtags=["#content", "#creative", "#amazing"];
-        else item.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
-      }
-      if(!item.caption || item.caption.length<1) item.caption="Check out this amazing content!";
-    });
+    variants.forEach((item: any) => {
+      if(!item.safety_level) item.safety_level="suggestive";
+      if(!item.mood || item.mood.length<2) item.mood="engaging";
+      if(!item.style || item.style.length<2) item.style="authentic";
+      if(!item.cta || item.cta.length<2) item.cta="Check it out";
+      if(!item.alt || item.alt.length<20) item.alt="Engaging social media content";
+      if(!item.hashtags || !Array.isArray(item.hashtags) || item.hashtags.length < 3) {
+        if(item.hashtags && item.hashtags.length >= 1) item.hashtags=["#content", "#creative", "#amazing"];
+        else item.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
+      }
+      if(!item.caption || item.caption.length<1) item.caption="Check out this amazing content!";
+    });
diff --git a/server/lib/payment-providers.ts b/server/lib/payment-providers.ts
@@
-class SegPayProvider extends BasePaymentProvider {
-  async processWebhook(payload: unknown): Promise<unknown> {
-    return {
-      userId: payload.userId,
-      subscriptionType: payload.subscriptionType,
-      status: payload.status,
-      transactionId: payload.transactionId,
-    };
-  }
+class SegPayProvider extends BasePaymentProvider {
+  async processWebhook(payload: Record<string, unknown>) {
+    return {
+      userId: Number(payload.userId),
+      subscriptionType: String(payload.subscriptionType),
+      status: String(payload.status) as 'active' | 'failed' | 'cancelled',
+      transactionId: String(payload.transactionId),
+    };
+  }
 }
@@
-class EpochProvider extends BasePaymentProvider {
-  async processWebhook(payload: unknown): Promise<unknown> {
-    return {
-      userId: payload.userId,
-      subscriptionType: payload.subscriptionType,
-      status: payload.status,
-      transactionId: payload.transactionId,
-    };
-  }
+class EpochProvider extends BasePaymentProvider {
+  async processWebhook(payload: Record<string, unknown>) {
+    return {
+      userId: Number(payload.userId),
+      subscriptionType: String(payload.subscriptionType),
+      status: String(payload.status) as 'active' | 'failed' | 'cancelled',
+      transactionId: String(payload.transactionId),
+    };
+  }
 }
diff --git a/server/lib/billing.ts b/server/lib/billing.ts
@@
-      const userId = parseInt(customer_id);
+      const userId = parseInt(String(customer_id));
@@
-           await this.createSubscription(userId, subscription_id, {
+           await this.createSubscription(userId, String(subscription_id), {
@@
-             priceCents: Math.round(parseFloat(billing_amount) * 100),
+             priceCents: Math.round(parseFloat(String(billing_amount)) * 100),
@@
-             nextBillDate: next_billing_date ? new Date(next_billing_date) : new Date(),
+             nextBillDate: next_billing_date ? new Date(String(next_billing_date)) : new Date(),
@@
-           await this.updateSubscription(subscription_id, {
+           await this.updateSubscription(String(subscription_id), {
@@
-             amount: Math.round(parseFloat(billing_amount) * 100),
+             amount: Math.round(parseFloat(String(billing_amount)) * 100),
@@
-           await this.updateSubscription(subscription_id, {
+           await this.updateSubscription(String(subscription_id), {
@@
-    if (updates.status) updateData.status = updates.status;
+    if ((updates as Record<string, unknown>).status) {
+      updateData.status = (updates as Record<string, any>).status;
+    }
@@
-    if (updates.nextBillDate) updateData.currentPeriodEnd = new Date(updates.nextBillDate);
+    if ((updates as Record<string, unknown>).nextBillDate) {
+      updateData.currentPeriodEnd = new Date(String((updates as Record<string, any>).nextBillDate));
+    }
@@
-      .set(updateData)
+      .set(updateData as any)
diff --git a/server/middleware/auth.ts b/server/middleware/auth.ts
@@
-    req.user = (req.session as { user: UserType }).user;
+    req.user = (req.session as any).user as UserType;
diff --git a/server/routes/upload.ts b/server/routes/upload.ts
@@
-import type { Request } from 'express';
+import type { Request } from 'express';
@@
-interface AuthRequest extends express.Request {
-  user?: { id: number; tier?: string };
-}
+interface UploadRequest extends Request {
+  user: { id: number; tier?: string };
+  streamingFiles?: { path: string; filename?: string; length?: number }[];
+  uploadProgress?: unknown;
+  file?: {
+    path: string;
+    mimetype: string;
+    originalname: string;
+    filename: string;
+    size: number;
+  } | null;
+}
@@
-export async function uploadMedia(req: AuthRequest, res: express.Response) {
-  if (!req.streamingFiles || req.streamingFiles.length === 0) {
+export async function uploadMedia(req: Request, res: express.Response) {
+  const uploadReq = req as UploadRequest;
+  if (!uploadReq.streamingFiles || uploadReq.streamingFiles.length === 0) {
     return res.status(400).json({ error: "No files uploaded" });
   }
@@
-  const uploadedFile = req.streamingFiles[0];
+  const uploadedFile = uploadReq.streamingFiles[0];
@@
-    userId: req.user.id,
+    userId: uploadReq.user.id,
@@
-    const userTier = req.user.tier || 'free';
-    const protectedFileName = `protected_${req.file.filename}`;
-    logger.info(`Protected file uploaded: ${protectedFileName} by user ${req.user.id}, tier: ${userTier}`);
+    const userTier = uploadReq.user.tier || 'free';
+    const protectedFileName = `protected_${uploadReq.file!.filename}`;
+    logger.info(`Protected file uploaded: ${protectedFileName} by user ${uploadReq.user.id}, tier: ${userTier}`);
