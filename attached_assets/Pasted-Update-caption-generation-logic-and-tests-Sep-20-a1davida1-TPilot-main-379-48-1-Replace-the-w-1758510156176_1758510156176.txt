Update caption generation logic and tests
Sep 20 · a1davida1/TPilot · main
+379-48
1. Replace the `while(json.length < 5)` clone loop in `server/caption/geminiPipeline.ts` with logic that issues an additional `generateContent` call (or augments the prompt with a “need more variety” hint) until five distinct variants are obtained.
2. Introduce deduplication to prevent near-identical captions from slipping through (e.g., compare captions before pushing them to the array).
3. Extend tests to simulate short responses and assert that the retry mechanism returns five distinct, richly varied caption options.

Summary

    Added Unicode-aware normalization, Levenshtein distance, and token-similarity helpers, then reworked generateVariants to sanitize Gemini responses, feed prior captions back into progressively stricter hints, and keep requesting batches until five genuinely distinct options are collected before parsing.

Refreshed the caption-generation route tests with full five-option fixtures and introduced a multi-response scenario that simulates duplicate-heavy returns, asserting the retry loop issues a “need more variety” prompt and ultimately yields five unique captions with rich metadata.

Testing

    ✅ npm run lint

❌ npm test *(fails because numerous suites rely on unavailable external services such as Neon/Postgres, OpenAI, Coinbase, and email infrastructure in this containerized environment.)*


server/caption/geminiPipeline.ts
+178-45
@@ -31,50 +31,112 @@ async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);

    const ct = r.headers.get("content-type") || "";
    if (!ct.startsWith("image/"))
      throw new InvalidImageError(`unsupported content-type: ${ct}`);

    const b = Buffer.from(await r.arrayBuffer());
    const base64 = b.toString("base64");
    if (base64.length < 100) throw new InvalidImageError("image data too small");

    return { base64, mimeType: ct.split(";")[0] };
  } catch (err) {
    console.error("Error fetching image:", err);
    if (err instanceof InvalidImageError) throw err;
    throw new InvalidImageError(
      `Failed to fetch image: ${err instanceof Error ? err.message : String(err)}`
    );
  }
}
function stripToJSON(txt: string): unknown {
  const i = Math.min(...[txt.indexOf("{"), txt.indexOf("[")].filter(x => x >= 0));
  const j = Math.max(txt.lastIndexOf("}"), txt.lastIndexOf("]"));
  return JSON.parse((i >= 0 && j >= 0) ? txt.slice(i, j + 1) : txt);
}

function normalizeCaptionText(caption: string): string {
  return caption
    .normalize("NFKD")
    .toLowerCase()
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/[\u201c\u201d]/g, '"')
    .replace(/[^\p{L}\p{N}]+/gu, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function levenshtein(a: string, b: string): number {
  const rows = a.length + 1;
  const cols = b.length + 1;
  const dist: number[][] = Array.from({ length: rows }, (_, i) => {
    const row = new Array<number>(cols);
    row[0] = i;
    return row;
  });

  for (let j = 0; j < cols; j += 1) {
    dist[0][j] = j;
  }

  for (let i = 1; i < rows; i += 1) {
    for (let j = 1; j < cols; j += 1) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dist[i][j] = Math.min(
        dist[i - 1][j] + 1,
        dist[i][j - 1] + 1,
        dist[i - 1][j - 1] + cost
      );
    }
  }

  return dist[rows - 1][cols - 1];
}

function captionsAreSimilar(a: string, b: string): boolean {
  const normalizedA = normalizeCaptionText(a);
  const normalizedB = normalizeCaptionText(b);

  if (!normalizedA && !normalizedB) return true;
  if (!normalizedA || !normalizedB) return normalizedA === normalizedB;
  if (normalizedA === normalizedB) return true;

  const distance = levenshtein(normalizedA, normalizedB);
  const maxLen = Math.max(normalizedA.length, normalizedB.length);
  if (maxLen === 0) return true;

  const similarityScore = 1 - distance / maxLen;
  if (similarityScore > 0.9) return true;

  const tokensA = new Set(normalizedA.split(" ").filter(Boolean));
  const tokensB = new Set(normalizedB.split(" ").filter(Boolean));
  const intersectionSize = [...tokensA].filter(token => tokensB.has(token)).length;
  const unionSize = new Set([...tokensA, ...tokensB]).size || 1;
  const jaccard = intersectionSize / unionSize;

  return jaccard > 0.82;
}

export async function extractFacts(imageUrl: string): Promise<Record<string, unknown>> {
  try {
    console.log('Starting fact extraction for image:', imageUrl.substring(0, 100) + '...');
    const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
    
    // Handle data URLs differently from regular URLs
    let imageData: string;
    let mimeType = "image/jpeg";
    
    if (imageUrl.startsWith('data:')) {
      // Extract base64 data from data URL - use indexOf to find first comma only
      const commaIndex = imageUrl.indexOf(',');
      if (commaIndex === -1) {
        throw new Error('Invalid data URL format - missing comma separator');
      }
      
      const header = imageUrl.substring(0, commaIndex);
      imageData = imageUrl.substring(commaIndex + 1);
      
      // Extract mime type from header
      const mimeMatch = header.match(/data:([^;]+)/);
      if (mimeMatch) {
        mimeType = mimeMatch[1];
      }
      
@@ -186,100 +248,171 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
          wardrobe: ['various'],
          angles: ['dynamic'],
          mood: 'playful',
          style: 'animated'
        };
      }
      
      throw error;
    }
  } catch (error) {
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

export async function generateVariants(params: {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  style?: string;
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
      : "authentic";
    variant.cta = typeof variant.cta === "string" && variant.cta.trim().length >= 2
      ? variant.cta
      : "Check it out";

    const alt = typeof variant.alt === "string" && variant.alt.trim().length >= 20
      ? variant.alt
      : "Engaging social media content that highlights the visual story.";
    variant.alt = alt;

    const hashtags = Array.isArray(variant.hashtags)
      ? variant.hashtags
          .map(tag => (typeof tag === "string" ? tag.trim() : ""))
          .filter(tag => tag.length > 0)
      : [];
    variant.hashtags = hashtags.length > 0 ? hashtags.slice(0, 10) : ["#content", "#creative", "#amazing"];

    variant.nsfw = typeof variant.nsfw === "boolean" ? variant.nsfw : false;

    return variant;
  };

  const buildUserPrompt = (varietyHint: string | undefined, existingCaptions: string[]): string => {
    const lines = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`
    ];

    if (params.style) lines.push(`STYLE: ${params.style}`);
    if (params.mood) lines.push(`MOOD: ${params.mood}`);

    lines.push(`IMAGE_FACTS: ${JSON.stringify(params.facts)}`);
    lines.push(`NSFW: ${params.nsfw ?? false}`);

    const hintParts: string[] = [];
    if (varietyHint) {
      hintParts.push(varietyHint.trim());
    }
    if (existingCaptions.length > 0) {
      hintParts.push(
        `Avoid repeating or lightly editing these captions: ${existingCaptions.join(" | ")}.`
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }
    hintParts.push("Provide five options that vary tone, structure, and specific imagery.");

    const combinedHint = hintParts.filter(Boolean).join(" ");
    lines.push(`HINT: ${combinedHint}`);

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    return lines.join("\n");
  };

  const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
    const user = buildUserPrompt(varietyHint, existingCaptions);
    try {
      const res = await textModel.generateContent([
        { text: `${sys}\n${guard}\n${prompt}\n${user}` }
      ]);
      const json = stripToJSON(res.response.text());
      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error("Gemini textModel.generateContent failed:", error);
      throw error;
    }
  };

  const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
  const existingCaptions: string[] = [];
  const maxAttempts = 5;

  for (let attempt = 0; attempt < maxAttempts && uniqueVariants.length < 5; attempt += 1) {
    const varietyHint = attempt === 0
      ? params.hint
      : `${params.hint ? `${params.hint} ` : ""}Need much more variety across tone, structure, and imagery.`;

    const rawVariants = await fetchVariants(varietyHint, existingCaptions);

    for (const raw of rawVariants) {
      if (uniqueVariants.length >= 5) break;
      if (typeof raw !== "object" || raw === null) continue;

      const sanitized = sanitizeVariant(raw as Record<string, unknown>);
      const captionText = sanitized.caption as string;

      const isDuplicate = existingCaptions.some(existing => captionsAreSimilar(existing, captionText));
      if (isDuplicate) {
        continue;
      }

      uniqueVariants.push(sanitized as z.infer<typeof CaptionItem>);
      existingCaptions.push(captionText);
    }
  }
  return CaptionArray.parse(json);

  if (uniqueVariants.length < 5) {
    throw new Error("Failed to produce five unique caption variants from Gemini");
  }

  return CaptionArray.parse(uniqueVariants.slice(0, 5));
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  // Accept any safety_level in final result
tests/routes/caption-generation.test.ts
+201-3
@@ -47,51 +47,91 @@ describe('Caption Generation', () => {
      const mockPlatform = 'instagram';
      const mockVoice = 'flirty_playful';

      // Mock successful responses
      const mockFactsResponse = {
        response: {
          text: () => JSON.stringify({
            objects: ['woman', 'lingerie'],
            setting: 'bedroom',
            mood: 'seductive',
          }),
        },
      };

      const mockVariantsResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'Feeling gorgeous tonight ✨',
                hashtags: ['#lingerie', '#confidence', '#style'],
                safety_level: 'spicy_safe',
                mood: 'confident',
                style: 'authentic',
                cta: 'What do you think?',
                alt: 'A glamorous example alt text to satisfy schema',
                alt: 'A glamorous example alt text to satisfy schema and requirements here',
                nsfw: false,
              },
              {
                caption: 'Velvet energy with a slow-burn stare.',
                hashtags: ['#noir', '#mood', '#evening'],
                safety_level: 'normal',
                mood: 'mysterious',
                style: 'editorial',
                cta: 'Take a closer look',
                alt: 'Detailed description of a striking portrait with moody light and texture',
                nsfw: false,
              },
              {
                caption: 'Soft light, bold confidence, endless allure.',
                hashtags: ['#softlight', '#confidence', '#style'],
                safety_level: 'normal',
                mood: 'bold',
                style: 'luxury',
                cta: 'Slide into the vibe',
                alt: 'Soft lighting frames a confident pose with detailed textures and style cues',
                nsfw: false,
              },
              {
                caption: 'After-hours glam with a wink and a dare.',
                hashtags: ['#nightout', '#glam', '#boldmove'],
                safety_level: 'spicy_safe',
                mood: 'playful',
                style: 'bold',
                cta: 'Ready for the night?',
                alt: 'Moody evening styling with confident body language and shimmering fabrics described',
                nsfw: false,
              },
              {
                caption: 'Satin whispers and slow-burning sparks.',
                hashtags: ['#satin', '#allure', '#eveningmagic'],
                safety_level: 'spicy_safe',
                mood: 'romantic',
                style: 'sensual',
                cta: 'Can you feel it?',
                alt: 'Detailed mention of satin textures and inviting energy within a cozy setting',
                nsfw: false,
              },
            ]),
        },
      };

      const mockRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Selected based on engagement potential',
              final: {
                caption: 'Feeling gorgeous tonight ✨',
                hashtags: ['#lingerie', '#confidence', '#style'],
                safety_level: 'spicy_safe',
                mood: 'confident',
                style: 'authentic',
                cta: 'What do you think?',
                alt: 'A glamorous example alt text to satisfy schema',
                nsfw: false,
              },
            }),
        },
@@ -101,74 +141,232 @@ describe('Caption Generation', () => {
      (visionModel.generateContent as any).mockResolvedValueOnce(mockFactsResponse);
      (textModel.generateContent as any)
        .mockResolvedValueOnce(mockVariantsResponse)
        .mockResolvedValueOnce(mockRankResponse);

      const result = await pipeline({
        imageUrl: mockImageUrl,
        platform: mockPlatform,
        voice: mockVoice,
      });

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');

      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(result.final).toMatchObject({
        caption: expect.any(String),
        safety_level: expect.stringMatching(/safe|low|spicy_safe/),
      });
    });

    it('should handle safety level normalization', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Test caption',
              caption: 'Test caption primary',
              hashtags: ['#test'],
              safety_level: 'spicy_safe', // Should be normalized to spicy_safe
              safety_level: 'spicy_safe',
              mood: 'confident',
              style: 'authentic',
              cta: 'Check it out',
              alt: 'A well detailed alt description that should pass validation rules easily',
            },
            {
              caption: 'Supporting caption alpha',
              hashtags: ['#alpha'],
              safety_level: 'normal',
              mood: 'bright',
              style: 'casual',
              cta: 'Say hello',
              alt: 'Another descriptive alternative text that references key visual cues in detail',
            },
            {
              caption: 'Supporting caption beta',
              hashtags: ['#beta'],
              safety_level: 'normal',
              mood: 'calm',
              style: 'minimal',
              cta: 'Lean in',
              alt: 'Clear alt text describing colors, pose, and ambiance well beyond minimum length',
            },
            {
              caption: 'Supporting caption gamma',
              hashtags: ['#gamma'],
              safety_level: 'normal',
              mood: 'curious',
              style: 'editorial',
              cta: 'Discover more',
              alt: 'Thoughtful alt text that paints a vivid picture with plenty of sensory detail',
            },
            {
              caption: 'Supporting caption delta',
              hashtags: ['#delta'],
              safety_level: 'normal',
              mood: 'warm',
              style: 'elevated',
              cta: 'Join the moment',
              alt: 'Alt text describing the setting, outfits, and mood so the schema requirements pass',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);

      // This would normally be called as part of the pipeline
      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        facts: { objects: ['test'] },
      });

      expect(result[0].safety_level).toBe('spicy_safe');
    });

    it('retries until five unique variants with strong deduping', async () => {
      const shortResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'Bold shimmer for the midnight hour.',
                hashtags: ['#bold'],
                safety_level: 'normal',
                mood: 'bold',
                style: 'glam',
                cta: 'Lean in',
                alt: 'Alt text that meets schema rules with detailed description',
              },
              {
                caption: 'Bold shimmer for the midnight hour!!',
                hashtags: ['#bold'],
                safety_level: 'normal',
                mood: 'bold',
                style: 'glam',
                cta: 'Lean in again',
                alt: 'Alt text that meets schema rules with detailed description repeated',
              },
            ]),
        },
      };

      const secondResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'Velvet lounge energy, low lights, louder confidence.',
                hashtags: ['#velvet'],
                safety_level: 'normal',
                mood: 'confident',
                style: 'editorial',
                cta: 'Come closer',
                alt: 'Detailed alt text describing lounge textures, lighting, and confident expression',
              },
              {
                caption: 'Golden hour glow with a mischievous grin.',
                hashtags: ['#goldenhour'],
                safety_level: 'normal',
                mood: 'playful',
                style: 'sunlit',
                cta: 'Catch the glow',
                alt: 'Alt description calling out golden light, pose, and wardrobe sparkles in detail',
              },
              {
                caption: 'Bold shimmer for the midnight hour.',
                hashtags: ['#repeat'],
                safety_level: 'normal',
                mood: 'bold',
                style: 'glam',
                cta: 'Different CTA',
                alt: 'Another valid alt description but caption should dedupe',
              },
            ]),
        },
      };

      const thirdResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'City rooftop breeze with sparks in every glance.',
                hashtags: ['#rooftop'],
                safety_level: 'normal',
                mood: 'electric',
                style: 'urban',
                cta: 'Ride the skyline',
                alt: 'Detailed rooftop description referencing skyline lights and expressive movement',
              },
              {
                caption: 'Satin sheets, secret smiles, and a confident hush.',
                hashtags: ['#satin'],
                safety_level: 'spicy_safe',
                mood: 'intimate',
                style: 'sensual',
                cta: 'Tell me what you see',
                alt: 'Alt copy detailing satin fabric, soft lighting, and intimate atmosphere with clarity',
              },
              {
                caption: 'After-dark jazz notes with every pose.',
                hashtags: ['#jazz'],
                safety_level: 'normal',
                mood: 'smooth',
                style: 'retro',
                cta: 'Drop a note',
                alt: 'Alt text depicting jazz lounge ambiance, expressive pose, and warm brass lighting cues',
              },
            ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any)
        .mockResolvedValueOnce(shortResponse)
        .mockResolvedValueOnce(secondResponse)
        .mockResolvedValueOnce(thirdResponse);

      const { generateVariants } = await import('../../server/caption/geminiPipeline.js');
      const result = await generateVariants({
        platform: 'instagram',
        voice: 'flirty_playful',
        style: 'editorial',
        mood: 'confident',
        facts: { objects: ['model'], mood: 'bold', colors: ['gold'] },
      });

      expect(result).toHaveLength(5);
      const captions = result.map(item => item.caption);
      expect(new Set(captions).size).toBe(5);
      expect((textModel.generateContent as any).mock.calls.length).toBe(3);
      const secondCallPrompt = (textModel.generateContent as any).mock.calls[1][0][0].text as string;
      expect(secondCallPrompt).toContain('Need much more variety across tone, structure, and imagery.');
      expect(result.every(item => item.alt.length >= 20)).toBe(true);
    });
  });

  describe('Text-Only Pipeline', () => {
    it('should generate content without image context', async () => {
      const mockResponse = {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Motivational content for today!',
              hashtags: ['#motivation', '#mindset'],
              safety_level: 'normal',
              mood: 'inspiring',
              style: 'authentic',
              cta: 'What motivates you?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      (textModel.generateContent as any).mockResolvedValue(mockResponse);

      const result = await pipelineTextOnly({
        platform: 'instagram',
        voice: 'inspiring',
