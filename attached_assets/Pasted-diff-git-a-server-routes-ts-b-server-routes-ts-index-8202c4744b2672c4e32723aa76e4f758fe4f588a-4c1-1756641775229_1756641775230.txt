diff --git a/server/routes.ts b/server/routes.ts
index 8202c4744b2672c4e32723aa76e4f758fe4f588a..4c108e2544fabd31c8603032bcaec84f148329d3 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -52,50 +52,63 @@ import { captionRouter } from "./routes/caption.js";
 import { registerSocialMediaRoutes } from "./social-media-routes.js";
 
 // Schema imports
 import { insertContentGenerationSchema, insertUserImageSchema } from "@shared/schema";
 
 // Core dependencies
 import multer from 'multer';
 import fs from 'fs/promises';
 import crypto from 'crypto';
 import jwt from 'jsonwebtoken';
 import bcrypt from 'bcrypt';
 import csrf from 'csurf';
 
 // Get secure environment variables (no fallbacks)
 const SESSION_SECRET = process.env.SESSION_SECRET!;
 const IS_PRODUCTION = process.env.NODE_ENV === 'production';
 const DATABASE_URL = process.env.DATABASE_URL;
 const REDIS_URL = process.env.REDIS_URL;
 const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY;
 
 // Initialize Stripe if configured
 const stripe = STRIPE_SECRET_KEY ? new Stripe(STRIPE_SECRET_KEY, {
   apiVersion: '2025-08-27.basil' as any,
 }) : null;
 
+// Configure multer for optional image uploads
+const upload = multer({
+  dest: 'uploads/',
+  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
+  fileFilter: (req, file, cb) => {
+    if (file.mimetype.startsWith('image/')) {
+      cb(null, true);
+    } else {
+      cb(new Error('Only image files are allowed!'), false);
+    }
+  }
+});
+
 // Auth request interface
 interface AuthRequest extends express.Request {
   user?: unknown;
 }
 
 export async function registerRoutes(app: Express): Promise<Server> {
   // ==========================================
   // VALIDATE ENVIRONMENT & APPLY SECURITY
   // ==========================================
   
   // Set trust proxy securely for rate limiters
   app.set('trust proxy', (ip: string) => {
     // Trust localhost and private network ranges
     return ['127.0.0.1', '::1'].includes(ip) || ip.startsWith('10.') || ip.startsWith('192.168.');
   });
   
   // Validate required environment variables first
   validateEnvironment();
   
   // Apply security middleware
   app.use(securityMiddleware);
   
   // Apply IP logging middleware
   app.use(ipLoggingMiddleware);
 
diff --git a/server/routes.ts b/server/routes.ts
index 8202c4744b2672c4e32723aa76e4f758fe4f588a..4c108e2544fabd31c8603032bcaec84f148329d3 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -371,50 +384,142 @@ export async function registerRoutes(app: Express): Promise<Server> {
           : result.photoInstructions.styling || 'Casual styling',
         mood: (result.photoInstructions as any).mood || 'Confident and natural',
         technicalSettings: Array.isArray(result.photoInstructions.technical) 
           ? result.photoInstructions.technical[0] 
           : (result.photoInstructions as any).technicalSettings || 'Auto settings'
       };
 
       await storage.createContentGeneration({
         userId: req.user.id,
         titles: result.titles || [],
         content: result.content || '',
         photoInstructions,
         platform: platform || "reddit",
         style: style || 'playful',
         theme: theme || 'lingerie',
         createdAt: new Date()
       });
 
       res.json(result);
     } catch (error) {
       logger.error("Content generation error:", error);
       res.status(500).json({ message: "Failed to generate content" });
     }
   });
 
+  // Unified AI generation endpoint - handles both text and image workflows
+  app.post('/api/generate-unified', generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res) => {
+    try {
+      const { mode, prompt, platform, style, theme, includePromotion, customInstructions } = req.body as any;
+
+      // Check daily generation limit for authenticated users
+      if (req.user?.id) {
+        const user = await storage.getUser(req.user.id);
+        if (!user) {
+          return res.status(401).json({ error: 'User not found' });
+        }
+
+        const userTier = user.tier || 'free';
+        const dailyCount = await storage.getDailyGenerationCount(req.user.id);
+
+        let dailyLimit = 5;
+        if (userTier === 'pro') {
+          dailyLimit = 50;
+        } else if (userTier === 'premium') {
+          dailyLimit = -1;
+        }
+
+        if (dailyLimit !== -1 && dailyCount >= dailyLimit) {
+          return res.status(429).json({
+            error: 'Daily generation limit reached',
+            limit: dailyLimit,
+            used: dailyCount,
+            tier: userTier,
+            message: `You've reached your daily limit of ${dailyLimit} generations. ${userTier === 'free' ? 'Upgrade to Pro for 50 daily generations!' : 'Your limit resets tomorrow.'}`
+          });
+        }
+      }
+
+      let imageBase64: string | undefined;
+
+      // Handle image upload if present
+      if (mode === 'image' && req.file) {
+        if (!validateImageFormat(req.file.originalname)) {
+          return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
+        }
+        imageBase64 = imageToBase64(req.file.path);
+
+        // Clean up uploaded file after converting to base64
+        await fs.unlink(req.file.path).catch(console.error);
+      }
+
+      const result = await generateUnifiedAIContent({
+        mode: (mode as 'text' | 'image') || 'text',
+        prompt,
+        imageBase64,
+        platform: platform || 'reddit',
+        style: style || 'playful',
+        theme,
+        includePromotion: includePromotion === 'true' || includePromotion === true,
+        customInstructions
+      });
+
+      // Check if this is demo content and add metadata
+      const isDemoContent = result.titles[0]?.includes('[DEMO]') || result.content?.includes('[DEMO CONTENT]');
+
+      // Save to database if user is authenticated
+      if (req.user?.id) {
+        await storage.createContentGeneration({
+          userId: req.user.id,
+          platform: platform || 'reddit',
+          style: style || 'playful',
+          theme: theme || 'general',
+          titles: result.titles,
+          content: result.content,
+          photoInstructions: result.photoInstructions,
+          prompt: prompt || customInstructions,
+          allowsPromotion: includePromotion === 'true' || includePromotion === true
+        });
+      }
+
+      const response = {
+        ...result,
+        contentSource: isDemoContent ? 'demo' : 'ai',
+        isDemo: isDemoContent,
+        apiStatus: isDemoContent ? 'unavailable' : 'active'
+      };
+
+      res.json(response);
+    } catch (error) {
+      console.error('Unified AI generation error:', error);
+      res.status(500).json({
+        error: 'Failed to generate content',
+        message: error instanceof Error ? error.message : 'Unknown error'
+      });
+    }
+  });
+
   // Get user stats
   // Debug endpoint for Reddit OAuth troubleshooting (temporary)
   app.get('/api/debug/session', (req: unknown, res) => {
     res.json({
       sessionId: req.sessionID,
       hasSession: !!req.session,
       redditState: req.session?.redditOAuthState,
       redditConnected: req.session?.redditConnected,
       cookies: req.headers.cookie ? 'present' : 'missing'
     });
   });
 
   app.get("/api/user-stats", authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const generations = await storage.getGenerationsByUserId(req.user.id);
       const today = new Date();
       const todayGenerations = generations.filter(g => 
         g.createdAt && new Date(g.createdAt).toDateString() === today.toDateString()
       );
       
       const stats = {
