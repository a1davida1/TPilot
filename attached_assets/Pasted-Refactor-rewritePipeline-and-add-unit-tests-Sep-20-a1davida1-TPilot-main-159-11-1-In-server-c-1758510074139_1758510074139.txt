Refactor rewritePipeline and add unit tests
Sep 20 · a1davida1/TPilot · main
+159-11
1. In `server/caption/rewritePipeline.ts`, remove the length-check branch that concatenates the generic sparkle sentence and replace it with a loop that re-invokes `variantsRewrite` using a `hint` such as “Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.”
2. Allow one or two retries with progressively stronger hints (e.g., “rewrite with concrete imagery from IMAGE\_FACTS”) before falling back to OpenAI.
3. Add unit coverage in `tests/routes/caption-generation.test.ts` asserting that rewrites never include the old filler string and that length increases come from a fresh model pass.

Summary

    Replaced the sparkle fallback in the rewrite pipeline with iterative Gemini retries that escalate contextual hints, capture attempt metadata with typed helpers, and fall back to OpenAI only after exhausting longer rewrite attempts and platform-safe reruns.

Extended the rewrite route tests to verify the filler string never appears, confirm longer captions emerge from fresh model passes, and assert the expected hint is forwarded on retries.

Testing

    ✅ npm run lint

⚠️ npm test *(fails because many pre-existing integration/unit suites require external services, databases, or network access unavailable in this environment)*


server/caption/rewritePipeline.ts
+49-11
import fs from "node:fs/promises";
import path from "node:path";
import { textModel, visionModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { z } from "zod";
import { CaptionArray, RankResult, platformChecks, CaptionItem as CaptionItemSchema } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: unknown;
  facts?: unknown;
  variants?: unknown;
  ranked?: unknown;
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
async function b64(url:string){ const r=await fetch(url); if(!r.ok) throw new Error("fetch failed"); const b=Buffer.from(await r.arrayBuffer()); return b.toString("base64"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
@@ -98,52 +99,89 @@ export async function rankAndSelect(variants: unknown[]){
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";
  }
  return RankResult.parse(json);
}

type CaptionItem = z.infer<typeof CaptionItemSchema>;
type CaptionArrayResult = z.infer<typeof CaptionArray>;
type RankResultType = z.infer<typeof RankResult>;

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;
    let variants = await variantsRewrite({ platform, voice, style, mood, existingCaption, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;
    
    // Ensure rewritten caption is longer and more engaging than original
    if(out.caption.length <= existingCaption.length) {
      out.caption = existingCaption + " ✨ Enhanced with engaging content and call-to-action that drives better engagement!";
    const attemptHints: (string | undefined)[] = [
      undefined,
      "Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.",
      facts
        ? "Make it 25% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 25% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
    ];

    const baseParams = { platform, voice, style, mood, existingCaption, facts, nsfw } as const;

    const performAttempt = async (hint?: string): Promise<{ variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItem }> => {
      const attemptVariants = await variantsRewrite({ ...baseParams, hint });
      const attemptRanked = await rankAndSelect(attemptVariants);
      return { variants: attemptVariants, ranked: attemptRanked, final: attemptRanked.final };
    };

    let lastAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItem } | undefined;
    let successfulAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItem } | undefined;

    for (const hint of attemptHints) {
      const attempt = await performAttempt(hint);
      lastAttempt = attempt;
      if (attempt.final.caption.length > existingCaption.length) {
        successfulAttempt = attempt;
        break;
      }
    }

    const chosenAttempt = successfulAttempt ?? lastAttempt;

    if (!chosenAttempt || chosenAttempt.final.caption.length <= existingCaption.length) {
      throw new Error('Rewrite did not produce a longer caption');
    }

    let { variants, ranked, final: out } = chosenAttempt;

    const err = platformChecks(platform, out);
    if (err) {
      variants = await variantsRewrite({ platform, voice, existingCaption, facts, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
      const platformAttempt = await performAttempt(`Fix: ${err}. Be specific, human, and avoid clichés while staying platform safe.`);
      if (platformAttempt.final.caption.length <= existingCaption.length) {
        throw new Error('Platform-specific rewrite failed to improve length');
      }
      const platformErr = platformChecks(platform, platformAttempt.final);
      if (platformErr) {
        throw new Error(platformErr);
      }
      ({ variants, ranked, final: out } = platformAttempt);
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
tests/routes/caption-generation.test.ts
+110-0
@@ -190,30 +190,140 @@ describe('Caption Generation', () => {
        response: {
          text: () => JSON.stringify([
            {
              caption: 'Enhanced and engaging caption! ✨',
              hashtags: ['#enhanced', '#content'],
              safety_level: 'normal',
              mood: 'engaging',
              style: 'authentic',
              cta: 'What do you think?',
            },
          ]),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const genSpy = vi.spyOn(textModel, 'generateContent').mockResolvedValue(mockResponse as any);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(result.final.caption).not.toBe(existingCaption);
      expect(result.final.caption).toContain('Enhanced');
      expect(result.final.caption).not.toContain('✨ Enhanced with engaging content and call-to-action that drives better engagement!');

      genSpy.mockRestore();
    });

    it('retries with hints when the rewrite is not longer', async () => {
      const existingCaption = 'An engaging base caption';
      const shortVariantResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: 'Short update',
                hashtags: ['#tag1', '#tag2', '#tag3'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Check this out',
                alt: 'An example alt text that is comfortably longer than twenty characters',
                nsfw: false,
              },
            ]),
        },
      };

      const shortRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Short caption selected',
              final: {
                caption: 'Short update',
                hashtags: ['#tag1', '#tag2', '#tag3'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Check this out',
                alt: 'An example alt text that is comfortably longer than twenty characters',
                nsfw: false,
              },
            }),
        },
      };

      const longCaption = 'A richer, more detailed rewrite that adds sensory hooks and a compelling CTA to drive action now!';

      const longVariantResponse = {
        response: {
          text: () =>
            JSON.stringify([
              {
                caption: longCaption,
                hashtags: ['#tag1', '#tag2', '#tag3'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Check this out',
                alt: 'Another alt statement that comfortably exceeds the minimum character requirement for validation',
                nsfw: false,
              },
            ]),
        },
      };

      const longRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Longer caption selected',
              final: {
                caption: longCaption,
                hashtags: ['#tag1', '#tag2', '#tag3'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Check this out',
                alt: 'Another alt statement that comfortably exceeds the minimum character requirement for validation',
                nsfw: false,
              },
            }),
        },
      };

      const { textModel } = await import('../../server/lib/gemini.js');
      const generateSpy = vi.spyOn(textModel, 'generateContent');
      type GenerateReturn = Awaited<ReturnType<typeof textModel.generateContent>>;

      generateSpy
        .mockResolvedValueOnce(shortVariantResponse as GenerateReturn)
        .mockResolvedValueOnce(shortRankResponse as GenerateReturn)
        .mockResolvedValueOnce(longVariantResponse as GenerateReturn)
        .mockResolvedValueOnce(longRankResponse as GenerateReturn);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect(result.final.caption).toBe(longCaption);
      expect(result.final.caption.length).toBeGreaterThan(existingCaption.length);
      expect(result.final.caption).not.toContain('✨ Enhanced with engaging content and call-to-action that drives better engagement!');
      expect(generateSpy).toHaveBeenCalledTimes(4);

      const secondAttemptCall = generateSpy.mock.calls[2]?.[0]?.[0]?.text;
      expect(secondAttemptCall).toContain('HINT:Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.');

      generateSpy.mockRestore();
    });
  });
});
