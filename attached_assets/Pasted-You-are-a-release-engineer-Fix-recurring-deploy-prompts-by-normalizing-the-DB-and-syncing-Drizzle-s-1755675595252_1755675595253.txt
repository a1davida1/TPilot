You are a release engineer. Fix recurring deploy prompts by normalizing the DB and syncing Drizzle schema.

GOAL
- Since `user_samples` is empty, drop it so Drizzle can recreate it.
- Resolve `feature_flags` vs `saved_content` deterministically (no interactive prompts).
- Add `db:push` to package.json and run `drizzle-kit push` to sync.
- Verify results and print a concise summary.

ASSUMPTIONS
- Postgres available via $DATABASE_URL.
- Drizzle ORM project with schema files (if not, create minimal scaffolding).
- Node is available.

STEPS

0) Ensure dependencies and basic config
- If not present, install:
  npm i -D drizzle-kit
  npm i drizzle-orm pg
- Update/ensure package.json scripts include:
  {
    "scripts": {
      "db:push": "drizzle-kit push --config=drizzle.config.ts",
      "db:verify": "node ./scripts/db-verify.js"
    }
  }
- Create drizzle.config.ts if missing (adjust paths if project uses different structure):
  import 'dotenv/config';
  import { defineConfig } from 'drizzle-kit';
  export default defineConfig({
    out: './drizzle',
    schema: './src/db/schema.ts',
    dialect: 'postgresql',
    dbCredentials: { url: process.env.DATABASE_URL! },
    strict: true,
  });

- If ./src/db/schema.ts doesn’t exist, create a minimal placeholder (do not overwrite if it exists). Keep definitions minimal so push won’t fail:

  import { pgTable, serial, text, boolean, timestamp } from 'drizzle-orm/pg-core';

  // Feature flags (ensure table name matches app expectation)
  export const featureFlags = pgTable('feature_flags', {
    id: serial('id').primaryKey(),
    key: text('key').unique(),
    enabled: boolean('enabled').notNull().default(false),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  });

  // User samples (empty drop/recreate allowed)
  export const userSamples = pgTable('user_samples', {
    id: serial('id').primaryKey(),
    userId: text('user_id'),
    sample: text('sample'),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  });

1) Create helper scripts directory if missing:
- mkdir -p scripts

2) Add a Node script to run guarded SQL (so we don’t require psql on the image):
- Write ./scripts/db-guarded-fixes.js with the following content:

  import 'dotenv/config';
  import { Client } from 'pg';

  const sql = String.raw;

  const DROP_USER_SAMPLES_IF_EMPTY = sql`
  DO $$
  BEGIN
    IF to_regclass('public.user_samples') IS NOT NULL THEN
      IF (SELECT count(*) FROM public.user_samples) = 0 THEN
        EXECUTE 'DROP TABLE public.user_samples';
        RAISE NOTICE 'Dropped table user_samples (was empty)';
      ELSE
        RAISE NOTICE 'user_samples not empty; left intact';
      END IF;
    ELSE
      RAISE NOTICE 'user_samples does not exist';
    END IF;
  END $$;`;

  // Deterministic resolution for feature_flags vs saved_content.
  // If only saved_content exists => rename. If both exist and feature_flags empty => copy from saved_content.
  // If feature_flags has rows => keep it and leave saved_content (or rename to *_old).
  const RESOLVE_FEATURE_FLAGS = sql`
  DO $$
  DECLARE
    has_saved boolean := (to_regclass('public.saved_content') IS NOT NULL);
    has_flags boolean := (to_regclass('public.feature_flags') IS NOT NULL);
    flags_rows bigint := 0;
  BEGIN
    IF has_flags THEN
      SELECT count(*) INTO flags_rows FROM public.feature_flags;
    END IF;

    IF (NOT has_flags) AND has_saved THEN
      -- rename saved_content -> feature_flags
      EXECUTE 'ALTER TABLE public.saved_content RENAME TO feature_flags';
      RAISE NOTICE 'Renamed saved_content -> feature_flags';
    ELSIF has_flags AND has_saved AND flags_rows = 0 THEN
      -- backfill from saved_content into empty feature_flags
      EXECUTE $ins$INSERT INTO public.feature_flags (key, enabled, created_at)
              SELECT sc.key, COALESCE(sc.enabled, false), COALESCE(sc.created_at, now())
              FROM public.saved_content sc
              ON CONFLICT (key) DO NOTHING$ins$;
      RAISE NOTICE 'Backfilled feature_flags from saved_content';
    ELSE
      RAISE NOTICE 'feature_flags kept as-is (or both absent)';
    END IF;

    -- Ensure required columns on feature_flags (idempotent)
    IF to_regclass('public.feature_flags') IS NOT NULL THEN
      -- add columns if missing
      PERFORM 1 FROM information_schema.columns
        WHERE table_schema='public' AND table_name='feature_flags' AND column_name='id';
      IF NOT FOUND THEN EXECUTE 'ALTER TABLE public.feature_flags ADD COLUMN id BIGSERIAL PRIMARY KEY'; END IF;

      PERFORM 1 FROM information_schema.columns
        WHERE table_schema='public' AND table_name='feature_flags' AND column_name='key';
      IF NOT FOUND THEN EXECUTE 'ALTER TABLE public.feature_flags ADD COLUMN key TEXT UNIQUE'; END IF;

      PERFORM 1 FROM information_schema.columns
        WHERE table_schema='public' AND table_name='feature_flags' AND column_name='enabled';
      IF NOT FOUND THEN EXECUTE 'ALTER TABLE public.feature_flags ADD COLUMN enabled BOOLEAN NOT NULL DEFAULT FALSE'; END IF;

      PERFORM 1 FROM information_schema.columns
        WHERE table_schema='public' AND table_name='feature_flags' AND column_name='created_at';
      IF NOT FOUND THEN EXECUTE 'ALTER TABLE public.feature_flags ADD COLUMN created_at TIMESTAMPTZ NOT NULL DEFAULT now()'; END IF;
    END IF;
  END $$;`;

  // Optional: rename old saved_content after successful resolution (no drop to avoid risk)
  const OPTIONAL_RETIRE_SAVED = sql`
  DO $$
  BEGIN
    IF to_regclass('public.saved_content') IS NOT NULL
       AND to_regclass('public.feature_flags') IS NOT NULL THEN
      -- Keep a safety rename only if you want, else skip:
      -- EXECUTE 'ALTER TABLE public.saved_content RENAME TO saved_content_old';
      RAISE NOTICE 'saved_content still present (left intact)';
    END IF;
  END $$;`;

  const VERIFY = sql`
  SELECT tablename FROM pg_tables WHERE schemaname='public' AND tablename IN
    ('user_samples','feature_flags','saved_content','saved_content_old')
  ORDER BY tablename;

  SELECT
    'user_samples' AS table, COALESCE((SELECT count(*) FROM public.user_samples), 0) AS rows
  WHERE to_regclass('public.user_samples') IS NOT NULL
  UNION ALL
  SELECT 'feature_flags', COALESCE((SELECT count(*) FROM public.feature_flags), 0)
  WHERE to_regclass('public.feature_flags') IS NOT NULL
  UNION ALL
  SELECT 'saved_content', COALESCE((SELECT count(*) FROM public.saved_content), 0)
  WHERE to_regclass('public.saved_content') IS NOT NULL
  UNION ALL
  SELECT 'saved_content_old', COALESCE((SELECT count(*) FROM public.saved_content_old), 0)
  WHERE to_regclass('public.saved_content_old') IS NOT NULL;`;

  async function main() {
    const client = new Client({ connectionString: process.env.DATABASE_URL });
    await client.connect();

    // Drop empty user_samples
    await client.query(DROP_USER_SAMPLES_IF_EMPTY);

    // Resolve feature_flags vs saved_content
    await client.query(RESOLVE_FEATURE_FLAGS);

    // Optionally retire old table (no-op by default)
    // await client.query(OPTIONAL_RETIRE_SAVED);

    // Print verification
    console.log('--- TABLES PRESENT ---');
    const r1 = await client.query(VERIFY);
    console.table(r1.rows);

    await client.end();
  }

  main().catch((e) => { console.error(e); process.exit(1); });

- Add a tiny verify script for the npm script:
  Write ./scripts/db-verify.js:

  import 'dotenv/config';
  import { Client } from 'pg';
  const q = `
  SELECT tablename FROM pg_tables WHERE schemaname='public' ORDER BY tablename;
  `;
  (async () => {
    const c = new (require('pg').Client)({ connectionString: process.env.DATABASE_URL });
    await c.connect();
    const r = await c.query(q);
    console.table(r.rows);
    await c.end();
  })().catch(e => { console.error(e); process.exit(1); });

3) RUN the guarded fixes and push
- node ./scripts/db-guarded-fixes.js
- npm run db:push

4) FINAL VERIFICATION
- npm run db:verify
- Then run this ad-hoc check (in Node REPL or add a script) to confirm critical tables and row counts:

  node -e "import('dotenv/config');import('pg').then(async({Client})=>{const c=new Client({connectionString:process.env.DATABASE_URL});await c.connect();const {rows}=await c.query(`SELECT t.tablename, COALESCE(x.rows,0) rows
  FROM pg_tables t LEFT JOIN LATERAL (SELECT count(*)::int AS rows FROM pg_catalog.pg_class c2
    WHERE t.schemaname='public' AND t.tablename=c2.relname AND t.tablename IN ('feature_flags','user_samples')) x ON TRUE
  WHERE t.schemaname='public' AND t.tablename IN ('feature_flags','user_samples','saved_content','saved_content_old')
  ORDER BY t.tablename;`); console.table(rows); await c.end(); })"

OUTPUT
- Print a summary:
  * Whether user_samples was dropped (only if empty).
  * The chosen path for feature_flags (renamed, backfilled, or kept).
  * Confirmation that drizzle-kit push succeeded.
  * The final table list and row counts.
