diff --git a/server/lib/payment-providers.ts b/server/lib/payment-providers.ts
index 3674b7cc075755588441b709f849cbc3f9db16ce..653f629bb04121e19cb5fa6e9b5b296810764ae4 100644
--- a/server/lib/payment-providers.ts
+++ b/server/lib/payment-providers.ts
@@ -1,31 +1,32 @@
 /**
  * Phase 5: Multi-Payment Provider Rails
  * Scaffolds for additional payment processors beyond CCBill
  */
 
 import { env } from './config';
+import crypto from 'crypto';
 
 export interface PaymentProvider {
   name: string;
   isConfigured: boolean;
   supportedCurrencies: string[];
   features: {
     subscriptions: boolean;
     oneTime: boolean;
     cryptocurrencies?: boolean;
     regionalSupport?: string[];
   };
 }
 
 export interface PaymentLinkOptions {
   amount: number;
   currency: string;
   description: string;
   userId: number;
   subscriptionType?: 'pro' | 'pro_plus';
   isRecurring?: boolean;
   returnUrl?: string;
   cancelUrl?: string;
 }
 
 export interface PaymentResult {
diff --git a/server/lib/payment-providers.ts b/server/lib/payment-providers.ts
index 3674b7cc075755588441b709f849cbc3f9db16ce..653f629bb04121e19cb5fa6e9b5b296810764ae4 100644
--- a/server/lib/payment-providers.ts
+++ b/server/lib/payment-providers.ts
@@ -163,131 +164,173 @@ export class EpochProvider extends BasePaymentProvider {
     };
   }
 }
 
 /**
  * Paxum Payment Provider (Adult Industry & Crypto)
  */
 export class PaxumProvider extends BasePaymentProvider {
   name = 'Paxum';
   
   get isConfigured(): boolean {
     return !!(env.PAXUM_API_KEY && 
       typeof env.PAXUM_API_KEY === 'string' && env.PAXUM_API_KEY.length > 0);
   }
 
   async generatePaymentLink(options: PaymentLinkOptions): Promise<PaymentResult> {
     if (!this.isConfigured) {
       return {
         success: false,
         error: 'Paxum not configured',
         provider: this.name,
       };
     }
 
     try {
-      // Paxum API integration would go here
-      const paymentUrl = `https://paxum.com/payment?api_key=${env.PAXUM_API_KEY || ''}&amount=${options.amount}&user=${options.userId}`;
-      
+      const response = await fetch('https://www.paxum.com/payment/api/checkout', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+          Authorization: `Bearer ${env.PAXUM_API_KEY}`,
+        },
+        body: JSON.stringify({
+          amount: options.amount,
+          currency: options.currency,
+          description: options.description,
+          custom: options.userId,
+          return_url: options.returnUrl,
+          cancel_url: options.cancelUrl,
+        }),
+      });
+      if (!response.ok) {
+        throw new Error(`Paxum responded with ${response.status}`);
+      }
+      const data = await response.json();
       return {
         success: true,
-        paymentUrl,
-        transactionId: `paxum_${Date.now()}_${options.userId}`,
+        paymentUrl: data.url,
+        transactionId: data.transactionId,
         provider: this.name,
       };
     } catch (error) {
       return {
         success: false,
         error: error instanceof Error ? error.message : 'Paxum payment failed',
         provider: this.name,
       };
     }
   }
 
-  async verifyWebhook(signature: string, payload: unknown): Promise<boolean> {
-    return true; // Scaffold implementation
+  async verifyWebhook(signature: string, payload: Record<string, unknown>): Promise<boolean> {
+    const hmac = crypto.createHmac('sha256', env.PAXUM_API_KEY || '');
+    hmac.update(JSON.stringify(payload));
+    return hmac.digest('hex') === signature;
   }
 
-  async processWebhook(payload: unknown): Promise<unknown> {
+  async processWebhook(payload: Record<string, unknown>): Promise<{ userId: number; subscriptionType: string; status: 'active' | 'cancelled' | 'failed'; transactionId: string; }> {
     return {
-      userId: payload.userId,
-      subscriptionType: payload.subscriptionType,
-      status: payload.status,
-      transactionId: payload.transactionId,
+      userId: Number((payload as Record<string, unknown>).custom),
+      subscriptionType: String((payload as Record<string, unknown>).plan || ''),
+      status: (payload as Record<string, unknown>).status as 'active' | 'cancelled' | 'failed',
+      transactionId: String((payload as Record<string, unknown>).transactionId || ''),
     };
   }
 }
 
 /**
  * Coinbase Commerce Provider (Cryptocurrency)
  */
 export class CoinbaseProvider extends BasePaymentProvider {
   name = 'Coinbase Commerce';
   
   get isConfigured(): boolean {
     return !!(env.COINBASE_COMMERCE_KEY && 
       typeof env.COINBASE_COMMERCE_KEY === 'string' && env.COINBASE_COMMERCE_KEY.length > 0);
   }
 
   async generatePaymentLink(options: PaymentLinkOptions): Promise<PaymentResult> {
     if (!this.isConfigured) {
       return {
         success: false,
         error: 'Coinbase Commerce not configured',
         provider: this.name,
       };
     }
 
     try {
-      // Coinbase Commerce API integration would go here
-      const paymentUrl = `https://commerce.coinbase.com/checkout?key=${env.COINBASE_COMMERCE_KEY || ''}&amount=${options.amount}&user=${options.userId}`;
-      
+      const response = await fetch('https://api.commerce.coinbase.com/charges', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+          'X-CC-Api-Key': env.COINBASE_COMMERCE_KEY || '',
+          'X-CC-Version': '2018-03-22',
+        },
+        body: JSON.stringify({
+          name: 'Subscription',
+          description: options.description,
+          pricing_type: 'fixed_price',
+          local_price: { amount: options.amount, currency: options.currency },
+          metadata: { userId: options.userId, subscriptionType: options.subscriptionType },
+          redirect_url: options.returnUrl,
+          cancel_url: options.cancelUrl,
+        }),
+      });
+      if (!response.ok) {
+        throw new Error(`Coinbase responded with ${response.status}`);
+      }
+      const data = await response.json();
       return {
         success: true,
-        paymentUrl,
-        transactionId: `coinbase_${Date.now()}_${options.userId}`,
+        paymentUrl: data.data.hosted_url,
+        transactionId: data.data.id,
         provider: this.name,
       };
     } catch (error) {
       return {
         success: false,
         error: error instanceof Error ? error.message : 'Coinbase payment failed',
         provider: this.name,
       };
     }
   }
 
-  async verifyWebhook(signature: string, payload: unknown): Promise<boolean> {
-    return true; // Scaffold implementation
+  async verifyWebhook(signature: string, payload: Record<string, unknown>): Promise<boolean> {
+    const hmac = crypto.createHmac('sha256', env.COINBASE_COMMERCE_KEY || '');
+    hmac.update(JSON.stringify(payload));
+    return hmac.digest('hex') === signature;
   }
 
-  async processWebhook(payload: unknown): Promise<unknown> {
+  async processWebhook(payload: Record<string, unknown>): Promise<{ userId: number; subscriptionType: string; status: 'active' | 'cancelled' | 'failed'; transactionId: string; }> {
+    const event = (payload as { event?: { data?: Record<string, unknown>; } }).event;
+    const data = event?.data ?? {};
+    const timeline = (data as { timeline?: Array<{ status: string }> }).timeline || [];
+    const status = timeline.length ? timeline[timeline.length - 1].status : 'failed';
     return {
-      userId: payload.userId,
-      subscriptionType: payload.subscriptionType,
-      status: payload.status,
-      transactionId: payload.transactionId,
+      userId: Number((data as { metadata?: Record<string, unknown> }).metadata?.userId),
+      subscriptionType: String((data as { metadata?: Record<string, unknown> }).metadata?.subscriptionType || ''),
+      status: status as 'active' | 'cancelled' | 'failed',
+      transactionId: String((data as { id?: unknown }).id || ''),
     };
   }
 }
 
 /**
  * Payment Provider Manager
  */
 export class PaymentProviderManager {
   private providers: BasePaymentProvider[] = [
     new SegPayProvider(),
     new EpochProvider(), 
     new PaxumProvider(),
     new CoinbaseProvider(),
   ];
 
   /**
    * Get all available payment providers
    */
   getAvailableProviders(): PaymentProvider[] {
     return this.providers.map(p => ({
       name: p.name,
       isConfigured: p.isConfigured,
       supportedCurrencies: this.getSupportedCurrencies(p.name),
       features: this.getProviderFeatures(p.name),
     }));
