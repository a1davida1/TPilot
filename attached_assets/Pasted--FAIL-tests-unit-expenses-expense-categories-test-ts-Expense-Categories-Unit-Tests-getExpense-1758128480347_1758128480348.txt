
 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategories > should handle database error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:154:46
    152| 
    153|     test('should handle database error', async () => {
    154|       (db.where as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Database connection failed'));
       |                                              ^
    155| 
    156|       const result = await storage.getExpenseCategories();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[16/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > updateExpenseCategory > should update category successfully
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:178:50
    176|       };
    177| 
    178|       (db.returning as ReturnType<typeof vi.fn>).mockResolvedValueOnce([updatedCategory]);
       |                                                  ^
    179| 
    180|       const result = await storage.updateExpenseCategory(categoryId, updates);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[17/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > updateExpenseCategory > should handle update error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:192:50
    190|       const updates = { name: 'New Name' };
    191| 
    192|       (db.returning as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Category not found'));
       |                                                  ^
    193| 
    194|       await expect(storage.updateExpenseCategory(categoryId, updates)).rejects.toThrow('Category not found');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[18/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > deleteExpenseCategory > should soft delete category (set isActive to false)
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:202:46
    200|       const categoryId = 2;
    201| 
    202|       (db.where as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
       |                                              ^
    203| 
    204|       await storage.deleteExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[19/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > deleteExpenseCategory > should handle deletion error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:214:46
    212|       const categoryId = 999;
    213| 
    214|       (db.where as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Category not found'));
       |                                              ^
    215| 
    216|       await expect(storage.deleteExpenseCategory(categoryId)).rejects.toThrow('Category not found');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[20/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should fetch single category by ID
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:231:46
    229|       };
    230| 
    231|       (db.limit as ReturnType<typeof vi.fn>).mockResolvedValueOnce([mockCategory]);
       |                                              ^
    232| 
    233|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[21/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should return undefined for non-existent category
TypeError: Cannot read properties of undefined (reading 'mockResolvedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:244:46
    242|       const categoryId = 999;
    243| 
    244|       (db.limit as ReturnType<typeof vi.fn>).mockResolvedValueOnce([]);
       |                                              ^
    245| 
    246|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[22/40]⎯

 FAIL  tests/unit/expenses/expense-categories.test.ts > Expense Categories Unit Tests > getExpenseCategory > should handle database error
TypeError: Cannot read properties of undefined (reading 'mockRejectedValueOnce')
 ❯ tests/unit/expenses/expense-categories.test.ts:254:46
    252|       const categoryId = 1;
    253| 
    254|       (db.limit as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('Database error'));
       |                                              ^
    255| 
    256|       const result = await storage.getExpenseCategory(categoryId);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[23/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should handle expense creation error
AssertionError: expected [Function] to throw error including 'Database error' but got 'Cannot read properties of undefined (…'

Expected: "Database error"
Received: "Cannot read properties of undefined (reading 'returning')"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[24/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > createExpense > should create expense with optional fields
TypeError: Cannot read properties of undefined (reading 'returning')
 ❯ DatabaseStorage.createExpense server/storage.ts:761:56
    759|       const [result] = await db
    760|         .insert(expenses)
    761|         .values(expense as typeof expenses.$inferInsert)
       |                                                        ^
    762|         .returning();
    763|       return result;
 ❯ tests/unit/expenses/expense-operations.test.ts:190:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[25/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should calculate expense totals correctly
AssertionError: expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 85000, …(2) }

- Expected
+ Received

  {
-   "byCategory": {
-     "Beauty & Wellness": 10000,
-     "Technology": 50000,
-     "Travel": 25000,
-   },
-   "deductible": 72500,
-   "total": 85000,
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:240:22
    238|       const result = await storage.getExpenseTotals(userId, 2024);
    239| 
    240|       expect(result).toEqual({
       |                      ^
    241|         total: 85000, // $850.00 total
    242|         deductible: 72500, // $725.00 deductible (10000 + 50000 + 12500)

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[26/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should filter by tax year when specified
AssertionError: expected +0 to be 5000 // Object.is equality

- Expected
+ Received

- 5000
+ 0

 ❯ tests/unit/expenses/expense-operations.test.ts:274:28
    272|       const result = await storage.getExpenseTotals(userId, taxYear);
    273| 
    274|       expect(result.total).toBe(5000);
       |                            ^
    275|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    276|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[27/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle partial deduction percentages
AssertionError: expected { total: +0, deductible: +0, …(1) } to deeply equal { total: 50000, …(2) }

- Expected
+ Received

  {
-   "byCategory": {
-     "Home Office": 30000,
-     "Mixed Use Equipment": 20000,
-   },
-   "deductible": 24000,
-   "total": 50000,
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:288:22
    286|       const result = await storage.getExpenseTotals(userId);
    287| 
    288|       expect(result).toEqual({
       |                      ^
    289|         total: 50000, // $500.00 total
    290|         deductible: 24000, // $240.00 deductible (15000 + 9000)

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[28/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getExpenseTotals > should handle database error in totals calculation
AssertionError: promise resolved "{ total: +0, deductible: +0, …(1) }" instead of rejecting

- Expected
+ Received

- Error {
-   "message": "rejected promise",
+ {
+   "byCategory": {},
+   "deductible": 0,
+   "total": 0,
  }

 ❯ tests/unit/expenses/expense-operations.test.ts:301:58
    299|       (db as any)._chains.select.where.mockRejectedValueOnce(new Error('Database connection failed'));
    300| 
    301|       await expect(storage.getExpenseTotals(userId, 2024)).rejects.toThrow('Database connection failed');
       |                                                          ^
    302|     });
    303|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[29/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense with receipt information
TypeError: Cannot read properties of undefined (reading 'where')
 ❯ DatabaseStorage.updateExpense server/storage.ts:809:51
    807|     try {
    808|       const [result] = await db.update(expenses)
    809|         .set({ ...updates, updatedAt: new Date() })
       |                                                   ^
    810|         .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
    811|         .returning();
 ❯ tests/unit/expenses/expense-operations.test.ts:325:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[30/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should update expense amount
TypeError: Cannot read properties of undefined (reading 'where')
 ❯ DatabaseStorage.updateExpense server/storage.ts:809:51
    807|     try {
    808|       const [result] = await db.update(expenses)
    809|         .set({ ...updates, updatedAt: new Date() })
       |                                                   ^
    810|         .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
    811|         .returning();
 ❯ tests/unit/expenses/expense-operations.test.ts:348:36

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[31/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > updateExpense > should handle update error
AssertionError: expected [Function] to throw error including 'Update failed' but got 'Cannot read properties of undefined (…'

Expected: "Update failed"
Received: "Cannot read properties of undefined (reading 'where')"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[32/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch user expenses with category information
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/expenses/expense-operations.test.ts:390:51
    388| 
    389|       expect(db.select).toHaveBeenCalled();
    390|       expect((db as any)._chains.select.leftJoin).toHaveBeenCalled();
       |                                                   ^
    391|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    392|       expect(result).toEqual(mockExpensesWithCategories);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[33/40]⎯

 FAIL  tests/unit/expenses/expense-operations.test.ts > Expense Operations Unit Tests > getUserExpenses > should fetch expenses without tax year filter
AssertionError: expected [] to deeply equal [ …(2) ]

- Expected
+ Received

- [
-   {
-     "category": {
-       "name": "Category 1",
-     },
-     "expense": {
-       "description": "Expense 1",
-       "id": 1,
-       "taxYear": 2023,
-       "userId": 123,
-     },
-   },
-   {
-     "category": {
-       "name": "Category 2",
-     },
-     "expense": {
-       "description": "Expense 2",
-       "id": 2,
-       "taxYear": 2024,
-       "userId": 123,
-     },
-   },
- ]
+ []

 ❯ tests/unit/expenses/expense-operations.test.ts:411:22
    409|       const result = await storage.getUserExpenses(userId);
    410| 
    411|       expect(result).toEqual(mockAllExpenses);
       |                      ^
    412|       expect((db as any)._chains.select.where).toHaveBeenCalled();
    413|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[34/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Environment Variable Handling > should handle missing OPENAI_API_KEY gracefully
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:68:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[35/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > AI Provider Fallback Logic > should fallback from Gemini to OpenAI on quota error
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/image-generator/ai-service.test.ts:162:35
    160|       expect(result.titles).toEqual(['Fallback from OpenAI']);
    161|       expect(result.provider).toBeDefined();
    162|       expect(mockGenerateContent).toHaveBeenCalled();
       |                                   ^
    163|       expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    164|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[36/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > AI Provider Fallback Logic > should fallback through all providers on consecutive failures
AssertionError: expected "spy" to be called at least once
 ❯ tests/unit/image-generator/ai-service.test.ts:186:35
    184|       })).rejects.toThrow();
    185| 
    186|       expect(mockGenerateContent).toHaveBeenCalled();
       |                                   ^
    187|       expect(mockOpenAI.chat.completions.create).toHaveBeenCalled();
    188|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[37/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Cost Optimization > should prioritize cheapest provider (Gemini) when available
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:319:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[38/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Platform-Specific Optimizations > should generate Instagram-optimized content
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:391:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[39/40]⎯

 FAIL  tests/unit/image-generator/ai-service.test.ts > AI Service Unit Tests > Platform-Specific Optimizations > should generate Reddit-appropriate content without hashtags
Error: All AI providers failed
 ❯ Module.generateWithMultiProvider server/services/multi-ai-provider.ts:96:9
     94| 
     95|   safeLog('error', 'All AI providers failed - no fallback available', {});
     96|   throw new Error('All AI providers failed');
       |         ^
     97| }
     98| 
 ❯ tests/unit/image-generator/ai-service.test.ts:420:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[40/40]⎯


 Test Files  6 failed | 33 passed (39)
      Tests  39 failed | 260 passed (299)
   Start at  17:00:26
   Duration  14.96s (transform 1.88s, setup 1.48s, collect 12.98s, tests 15.51s, environment 12ms, prepare 5.30s)
