 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/routes/reddit-oauth-ip.test.ts b/tests/routes/reddit-oauth-ip.test.ts
index bbda490c0888c675db032dbb33858338f5bbbc8e..90124c374e8a5268fb23b03b85f4e2fc97e20946 100644
--- a/tests/routes/reddit-oauth-ip.test.ts
+++ b/tests/routes/reddit-oauth-ip.test.ts
@@ -179,55 +179,87 @@ describe('Reddit OAuth IP normalization', () => {
     const app = createTestApp();
     const connectResponse = await request(app)
       .get('/api/reddit/connect')
       .query({ intent: 'posting', queue: 'reddit-posting' });
 
     expect(connectResponse.status).toBe(200);
     const authUrl = connectResponse.body.authUrl as string;
     const state = new URL(authUrl).searchParams.get('state');
     expect(state).toBeTruthy();
 
     if (state) {
       lastStoredStateKey = `reddit_state:${state}`;
     }
 
     exchangeRedditCodeMock.mockResolvedValueOnce({
       accessToken: 'access-token',
       refreshToken: 'refresh-token',
     });
 
     const callbackResponse = await request(app)
       .get('/api/reddit/callback')
       .query({ state, code: 'oauth-code' });
 
     expect(callbackResponse.status).toBe(302);
     const redirectLocation = callbackResponse.headers['location'];
-    expect(redirectLocation).toContain('/reddit/posting?');
+    expect(redirectLocation).toContain('/reddit?');
     expect(redirectLocation).toContain('intent=posting');
     expect(redirectLocation).toContain('queue=reddit-posting');
   });
 
+  it('routes intelligence intents to the intelligence workflow after successful callback', async () => {
+    const app = createTestApp();
+    const connectResponse = await request(app)
+      .get('/api/reddit/connect')
+      .query({ intent: 'intelligence', queue: 'intelligence-dashboard' });
+
+    expect(connectResponse.status).toBe(200);
+    const authUrl = connectResponse.body.authUrl as string;
+    const state = new URL(authUrl).searchParams.get('state');
+    expect(state).toBeTruthy();
+
+    if (state) {
+      lastStoredStateKey = `reddit_state:${state}`;
+    }
+
+    exchangeRedditCodeMock.mockResolvedValueOnce({
+      accessToken: 'access-token',
+      refreshToken: 'refresh-token',
+    });
+
+    const callbackResponse = await request(app)
+      .get('/api/reddit/callback')
+      .query({ state, code: 'oauth-code' });
+
+    expect(callbackResponse.status).toBe(302);
+    const redirectLocation = callbackResponse.headers['location'];
+    expect(redirectLocation).toContain('/reddit?');
+    expect(redirectLocation).toContain('intent=intelligence');
+    expect(redirectLocation).toContain('tab=intelligence');
+    expect(redirectLocation).toContain('queue=intelligence-dashboard');
+  });
+
   it('routes account-link intents back to the dashboard when callback succeeds', async () => {
     const app = createTestApp();
     const connectResponse = await request(app)
       .get('/api/reddit/connect')
       .query({ intent: 'account-link' });
 
     expect(connectResponse.status).toBe(200);
     const authUrl = connectResponse.body.authUrl as string;
     const state = new URL(authUrl).searchParams.get('state');
     expect(state).toBeTruthy();
 
     if (state) {
       lastStoredStateKey = `reddit_state:${state}`;
     }
 
     exchangeRedditCodeMock.mockResolvedValueOnce({
       accessToken: 'access-token',
       refreshToken: 'refresh-token',
     });
 
     const callbackResponse = await request(app)
       .get('/api/reddit/callback')
       .query({ state, code: 'oauth-code' });
 
     expect(callbackResponse.status).toBe(302);
 
EOF
)