Create rules ingestor for subreddit rules
Sep 22 · a1davida1/TPilot · main
+1862-259
1. Create a rules ingestor (e.g., `server/scripts/sync-subreddit-rules.ts`) that fetches `/about/rules` and `/wiki/rules` for each subreddit, parsing outcomes into the `RuleSpec` shape defined in `server/lib/policy-linter.ts`.
2. Map structured Reddit responses to fields (`bannedWords`, `titleRegexes`, `linkPolicy`, etc.) and enrich with manual flags (karma min, verification required) when Reddit’s response lacks structure; persist to `subreddit_rules` with `insertSubredditRuleSchema`.
3. Retire or supplement `seedPolicyData` so production deployments call the new ingestor instead of inserting hard-coded examples.
4. Extend the admin UI (backed by `updateCommunity`) to edit rule overrides when moderators publish rule changes that automated parsing misses.

Summary

    Added a dedicated Reddit rule ingestion script that gathers /about/rules and wiki content, derives structured policies, reapplies overrides, and upserts them through the shared schema.

Extended the policy linter to coerce stored specs without any, preserve test-format behavior, and seeded production data by delegating to the new sync workflow.

Updated community persistence to clone automated bases, apply override payloads, and expose joined rule metadata to callers.

Refactored the admin dashboard to use strict typing, fetch structured analytics, and surface a manual override dialog and table for subreddit rules without relying on any casts.

Testing

    ✅ npm run lint

    ❌ npm test *(aborted; numerous suites require external AI/payment services and image tooling unavailable in the container)*


client/src/pages/admin.tsx
+843-158
import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/useAuth';
import { 
  Users, 
  DollarSign, 
  TrendingUp, 
  Settings, 
  Shield,
  Activity,
  Database,
  CreditCard,
  Eye,
  BarChart3,
  Ban,
  Clock3,
  Key,
  AlertCircle,
  CheckCircle,
  XCircle,
  Target,
  Smartphone,
  Calendar,
  VideoIcon,
  MessageSquare,
  Globe,
  Zap,
  Gift,
  Headphones,
  MonitorPlay,
  FileCheck
  FileCheck,
  FileText,
  Pencil
} from 'lucide-react';

interface AdminStats {
  totalUsers: number;
  revenue: number;
  activeUsers: number;
  contentGenerated: number;
  newUsersToday: number;
  trialUsers: number;
  freeUsers: number;
  proUsers: number;
  premiumUsers: number;
  starterUsers?: number;
  jwtConfigured: boolean;
  emailConfigured: boolean;
}

interface User {
  id: number;
  username: string;
  email: string;
  tier: string;
  isActive: boolean;
  isVerified: boolean;
  isActive?: boolean;
  isVerified?: boolean;
  createdAt?: string;
  lastLoginAt?: string;
  lastLogin?: string;
  contentCount?: number;
  trialEndsAt?: string | null;
}

interface UserActionData {
  action: string;
  userId?: number;
  tier?: string;
  newTier?: string;
  reason?: string;
  duration?: string;
}

interface UserActionResponse {
  message: string;
  tempPassword?: string;
  username?: string;
}

interface Provider {
  name: string;
  status: string;
  cost?: number;
  available: boolean;
  inputCost: number;
  outputCost: number;
  savings: number;
}

interface SystemHealth {
  status: string;
  database: {
    status: string;
    uptime: string;
    lastCheck: string;
  };
  services: {
    [key: string]: {
      status: string;
      message?: string;
    };
    gemini: boolean;
    openai: boolean;
    email: boolean;
  };
  performance: {
    avgResponseTime: string;
    errorRate: string;
    throughput: string;
  };
}

interface Analytics {
interface AnalyticsTopPage {
  path: string;
  views: number;
}

interface AnalyticsTrafficSource {
  source: string;
  visitors: number;
}

interface AnalyticsHourlyTrafficPoint {
  hour: number;
  visitors: number;
}

interface Analytics {
  uniqueVisitors: number;
  pageViews: number;
  sessions: number;
  conversionRate: number;
  bounceRate: number;
  averageSessionDuration: number;
  topPages: AnalyticsTopPage[];
  trafficSources: AnalyticsTrafficSource[];
  hourlyTraffic: AnalyticsHourlyTrafficPoint[];
}

interface Completeness {
  percentage: number;
  items: {
    name: string;
    status: boolean;
  }[];
  core: Record<string, boolean>;
  features: Record<string, boolean>;
  integrations: Record<string, boolean>;
  completionPercentage: number;
}

interface ManualRuleFlags {
  minKarma?: number;
  minAccountAgeDays?: number;
  verificationRequired?: boolean;
  notes?: string[];
}

interface RuleSpecBase {
  bannedWords?: string[];
  titleRegexes?: string[];
  bodyRegexes?: string[];
  flairRequired?: boolean;
  linkPolicy?: 'no-link' | 'one-link' | 'ok';
  requiredTags?: string[];
  maxTitleLength?: number;
  maxBodyLength?: number;
  manualFlags?: ManualRuleFlags;
  wikiNotes?: string[];
}

type RuleOverride = Partial<RuleSpecBase>;

interface RuleSpec extends RuleSpecBase {
  source?: {
    fetchedAt?: string;
    aboutRulesUrl?: string;
    wikiRulesUrl?: string;
    automatedBase?: RuleSpecBase;
  };
  overrides?: RuleOverride;
}

interface AdminCommunity {
  id: string;
  name: string;
  displayName: string;
  members: number;
  engagementRate: number;
  category: string;
  verificationRequired: boolean;
  promotionAllowed: string;
  postingLimits?: unknown;
  rules?: unknown;
  bestPostingTimes?: string[];
  averageUpvotes?: number;
  successProbability?: number;
  growthTrend?: string | null;
  modActivity?: string | null;
  description?: string | null;
  tags?: string[];
  competitionLevel?: string | null;
  policyRules?: RuleSpec | null;
  policyRulesUpdatedAt?: string | null;
}

interface UpdateCommunityResponse {
  community: AdminCommunity | null;
  policyRules: RuleSpec | null;
}

type TriStateOption = 'inherit' | 'true' | 'false';

interface RuleOverrideFormState {
  bannedWords: string;
  titleRegexes: string;
  bodyRegexes: string;
  requiredTags: string;
  linkPolicy: 'inherit' | 'no-link' | 'one-link' | 'ok';
  flairRequired: TriStateOption;
  maxTitleLength: string;
  maxBodyLength: string;
  minKarma: string;
  minAccountAgeDays: string;
  verificationRequired: TriStateOption;
  notes: string;
  wikiNotes: string;
}

export function AdminDashboard() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [selectedPeriod, setSelectedPeriod] = useState('7d');
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [actionType, setActionType] = useState<'ban' | 'suspend' | 'unban' | 'reset-password' | 'tier-management' | 'user-details' | null>(null);
  const [reason, setReason] = useState('');
  const [duration, setDuration] = useState('24');
  const [tempPassword, setTempPassword] = useState('');
  const [newTier, setNewTier] = useState('free');
  const [rulesDialogOpen, setRulesDialogOpen] = useState(false);
  const [selectedCommunityRules, setSelectedCommunityRules] = useState<AdminCommunity | null>(null);

  const emptyRuleForm: RuleOverrideFormState = {
    bannedWords: '',
    titleRegexes: '',
    bodyRegexes: '',
    requiredTags: '',
    linkPolicy: 'inherit',
    flairRequired: 'inherit',
    maxTitleLength: '',
    maxBodyLength: '',
    minKarma: '',
    minAccountAgeDays: '',
    verificationRequired: 'inherit',
    notes: '',
    wikiNotes: '',
  };

  const [ruleForm, setRuleForm] = useState<RuleOverrideFormState>(emptyRuleForm);

  const resetRuleDialogState = () => {
    setRulesDialogOpen(false);
    setSelectedCommunityRules(null);
    setRuleForm(emptyRuleForm);
  };

  const parseDelimitedList = (value: string): string[] =>
    value
      .split(/,|\n/)
      .map((entry) => entry.trim())
      .filter((entry) => entry.length > 0);

  const parseLineList = (value: string): string[] =>
    value
      .split(/\n/)
      .map((entry) => entry.trim())
      .filter((entry) => entry.length > 0);

  const parseNumberInput = (value: string): number | undefined => {
    const numeric = Number(value.trim());
    return Number.isFinite(numeric) && numeric > 0 ? numeric : undefined;
  };

  const toTriState = (value: boolean | undefined): TriStateOption =>
    value === true ? 'true' : value === false ? 'false' : 'inherit';

  const createRuleFormState = (community: AdminCommunity): RuleOverrideFormState => {
    const overrides = community.policyRules?.overrides;
    const manualFlags = overrides?.manualFlags;
    return {
      bannedWords: (overrides?.bannedWords ?? []).join(', '),
      titleRegexes: (overrides?.titleRegexes ?? []).join(', '),
      bodyRegexes: (overrides?.bodyRegexes ?? []).join(', '),
      requiredTags: (overrides?.requiredTags ?? []).join(', '),
      linkPolicy: overrides?.linkPolicy ?? 'inherit',
      flairRequired: toTriState(overrides?.flairRequired),
      maxTitleLength: overrides?.maxTitleLength !== undefined ? String(overrides.maxTitleLength) : '',
      maxBodyLength: overrides?.maxBodyLength !== undefined ? String(overrides.maxBodyLength) : '',
      minKarma: manualFlags?.minKarma !== undefined ? String(manualFlags.minKarma) : '',
      minAccountAgeDays: manualFlags?.minAccountAgeDays !== undefined ? String(manualFlags.minAccountAgeDays) : '',
      verificationRequired: toTriState(manualFlags?.verificationRequired),
      notes: manualFlags?.notes ? manualFlags.notes.join('\n') : '',
      wikiNotes: (overrides?.wikiNotes ?? []).join('\n'),
    };
  };

  // Authenticated API request helper (using cookies)
  const authenticatedFetch = async (url: string) => {
  const authenticatedFetch = async <T,>(url: string): Promise<T> => {
    const response = await fetch(url, {
      credentials: 'include' // Use cookie-based authentication
    });
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`);
    }
    return response.json();
    return (await response.json()) as T;
  };

  // Fetch admin stats
  const { data: stats } = useQuery<AdminStats>({
    queryKey: ['/api/admin/stats', selectedPeriod],
    queryFn: () => authenticatedFetch('/api/admin/stats')
    queryFn: () => authenticatedFetch<AdminStats>('/api/admin/stats')
  });

  // Fetch user data
  const { data: users } = useQuery<User[]>({
    queryKey: ['/api/admin/users'],
    queryFn: () => authenticatedFetch('/api/admin/users')
    queryFn: () => authenticatedFetch<User[]>('/api/admin/users')
  });

  // Fetch provider costs
  const { data: providers } = useQuery<Provider[]>({
    queryKey: ['/api/providers'],
    queryFn: () => authenticatedFetch('/api/providers')
    queryFn: () => authenticatedFetch<Provider[]>('/api/providers')
  });

  // Fetch system health
  const { data: systemHealth } = useQuery<SystemHealth>({
    queryKey: ['/api/admin/system-health'],
    queryFn: () => authenticatedFetch('/api/admin/system-health')
    queryFn: () => authenticatedFetch<SystemHealth>('/api/admin/system-health')
  });

  // Fetch visitor analytics
  const { data: analytics } = useQuery<Analytics>({
    queryKey: ['/api/admin/analytics', selectedPeriod],
    queryFn: () => authenticatedFetch('/api/admin/analytics')
    queryFn: () => authenticatedFetch<Analytics>(`/api/admin/analytics/${selectedPeriod}`)
  });

  // Fetch system completeness
  const { data: completeness } = useQuery<Completeness>({
    queryKey: ['/api/admin/completeness'],
    queryFn: () => authenticatedFetch('/api/admin/completeness')
    queryFn: () => authenticatedFetch<Completeness>('/api/admin/completeness')
  });

  const { data: communities = [] } = useQuery<AdminCommunity[]>({
    queryKey: ['/api/reddit/communities'],
    queryFn: () => authenticatedFetch<AdminCommunity[]>('/api/reddit/communities')
  });

  const displayedUsers = (users ?? []).slice(0, 5);
  const providerList = providers ?? [];

  // User action mutation for admin operations
  const actionMutation = useMutation<any, Error, UserActionData>({
    mutationFn: async (data: UserActionData) => {
  const actionMutation = useMutation<UserActionResponse, Error, UserActionData>({
    mutationFn: async (data: UserActionData): Promise<UserActionResponse> => {
      let endpoint = '/api/admin/user-action';
      if (data.action === 'reset-password') endpoint = '/api/admin/reset-password';
      else if (data.action === 'tier-management') endpoint = '/api/admin/upgrade-user';
      

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data),
        credentials: 'include' // Use cookie-based authentication
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || `Failed to ${data.action}`);
      }
      return response.json();
      return (await response.json()) as UserActionResponse;
    },
    onSuccess: (data, variables) => {
      if (variables.action === 'reset-password') {
        setTempPassword(data.tempPassword);
        setTempPassword(data.tempPassword ?? '');
        toast({ title: "Password Reset Successful", description: "Temporary password generated." });
      } else if (variables.action === 'tier-management') {
        toast({ title: "Tier Updated", description: `User tier changed to ${variables.newTier}` });
        setSelectedUser(null);
        setActionType(null);
      } else {
        toast({ title: `User ${variables.action} successful` });
        setSelectedUser(null);
        setActionType(null);
      }
    },
    onError: (error: Error) => {
      toast({ title: "Action Failed", description: error.message, variant: "destructive" });
    }
  });

  const communityMutation = useMutation<UpdateCommunityResponse, Error, { id: string; overrides: RuleOverride | null }>({
    mutationFn: async ({ id, overrides }) => {
      const response = await fetch(`/api/reddit/communities/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ ruleOverrides: overrides }),
        credentials: 'include'
      });
      if (!response.ok) {
        const message = await response.text();
        throw new Error(message || 'Failed to update community rules');
      }
      return response.json() as Promise<UpdateCommunityResponse>;
    },
    onSuccess: (data) => {
      const subredditName = data.community?.name || selectedCommunityRules?.name || 'community';
      toast({
        title: 'Rule overrides updated',
        description: `Saved policy overrides for r/${subredditName}`
      });
      queryClient.invalidateQueries({ queryKey: ['/api/reddit/communities'] });
      resetRuleDialogState();
    },
    onError: (error) => {
      toast({ title: 'Failed to update overrides', description: error.message, variant: 'destructive' });
    }
  });

  const closeRuleDialog = () => {
    resetRuleDialogState();
    communityMutation.reset();
  };

  const openRuleDialog = (community: AdminCommunity) => {
    setSelectedCommunityRules(community);
    setRuleForm(createRuleFormState(community));
    setRulesDialogOpen(true);
  };

  const buildOverridePayload = (): RuleOverride | null => {
    const override: RuleOverride = {};
    const bannedWords = parseDelimitedList(ruleForm.bannedWords);
    if (bannedWords.length > 0) {
      override.bannedWords = bannedWords;
    }
    const titleRegexes = parseDelimitedList(ruleForm.titleRegexes);
    if (titleRegexes.length > 0) {
      override.titleRegexes = titleRegexes;
    }
    const bodyRegexes = parseDelimitedList(ruleForm.bodyRegexes);
    if (bodyRegexes.length > 0) {
      override.bodyRegexes = bodyRegexes;
    }
    const requiredTags = parseDelimitedList(ruleForm.requiredTags);
    if (requiredTags.length > 0) {
      override.requiredTags = requiredTags;
    }
    if (ruleForm.linkPolicy !== 'inherit') {
      override.linkPolicy = ruleForm.linkPolicy;
    }
    if (ruleForm.flairRequired !== 'inherit') {
      override.flairRequired = ruleForm.flairRequired === 'true';
    }
    const titleLength = parseNumberInput(ruleForm.maxTitleLength);
    if (titleLength !== undefined) {
      override.maxTitleLength = titleLength;
    }
    const bodyLength = parseNumberInput(ruleForm.maxBodyLength);
    if (bodyLength !== undefined) {
      override.maxBodyLength = bodyLength;
    }

    const manualFlags: ManualRuleFlags = {};
    const minKarma = parseNumberInput(ruleForm.minKarma);
    if (minKarma !== undefined) {
      manualFlags.minKarma = minKarma;
    }
    const minAccountAge = parseNumberInput(ruleForm.minAccountAgeDays);
    if (minAccountAge !== undefined) {
      manualFlags.minAccountAgeDays = minAccountAge;
    }
    if (ruleForm.verificationRequired !== 'inherit') {
      manualFlags.verificationRequired = ruleForm.verificationRequired === 'true';
    }
    const manualNotes = parseLineList(ruleForm.notes);
    if (manualNotes.length > 0) {
      manualFlags.notes = manualNotes;
    }
    if (Object.keys(manualFlags).length > 0) {
      override.manualFlags = manualFlags;
    }

    const wikiNotes = parseLineList(ruleForm.wikiNotes);
    if (wikiNotes.length > 0) {
      override.wikiNotes = wikiNotes;
    }

    return Object.keys(override).length > 0 ? override : null;
  };

  const handleRuleOverrideSave = () => {
    if (!selectedCommunityRules) return;
    const overrides = buildOverridePayload();
    communityMutation.mutate({
      id: selectedCommunityRules.id,
      overrides: overrides ?? null,
    });
  };

  const handleRuleOverrideClear = () => {
    if (!selectedCommunityRules) return;
    communityMutation.mutate({
      id: selectedCommunityRules.id,
      overrides: null,
    });
  };

  const formatLinkPolicy = (value?: RuleSpecBase['linkPolicy']): string => {
    if (value === 'no-link') return 'No links';
    if (value === 'one-link') return 'One link limit';
    if (value === 'ok') return 'Links allowed';
    return 'Not specified';
  };

  const renderStringList = (items?: string[]) =>
    items && items.length > 0 ? (
      <div className="flex flex-wrap gap-1">
        {items.map((item) => (
          <Badge key={item} variant="secondary" className="text-xs">
            {item}
          </Badge>
        ))}
      </div>
    ) : (
      <p className="text-xs text-gray-500">None detected</p>
    );

  const handleAction = () => {
    if (!selectedUser || !actionType) return;
    if (actionType === 'reset-password') {
      actionMutation.mutate({ action: 'reset-password', userId: selectedUser.id });
    } else if (actionType === 'tier-management') {
      actionMutation.mutate({ action: 'tier-management', userId: selectedUser.id, tier: newTier });
    }
  };

  // Calculate real percentage changes
  const calculateChange = (current: number, previous: number) => {
    if (previous === 0) return current > 0 ? '+100%' : '0%';
    const change = ((current - previous) / previous) * 100;
    return `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
  };

  const adminStats = [
    { 
      label: 'Total Users', 
      value: stats?.totalUsers || 0, 
      change: calculateChange(stats?.totalUsers || 0, Math.max(1, (stats?.totalUsers || 0) - (stats?.newUsersToday || 1))),
      icon: <Users className="h-4 w-4" />,
      color: 'text-blue-500'
    },
    { 
@@ -273,474 +603,829 @@ export function AdminDashboard() {
          <Card key={index} className="bg-white border-gray-200 hover:bg-gray-50 transition-all duration-300 shadow-lg">
            <CardContent className="p-6">
              <div className="flex items-center justify-between mb-4">
                <div className={`p-3 rounded-xl bg-gradient-to-br ${
                  stat.color === 'text-blue-500' ? 'from-blue-500/20 to-blue-600/20' :
                  stat.color === 'text-green-500' ? 'from-green-500/20 to-green-600/20' :
                  stat.color === 'text-purple-500' ? 'from-purple-500/20 to-purple-600/20' :
                  'from-pink-500/20 to-pink-600/20'
                }`}>
                  <span className={`${stat.color} text-lg`}>{stat.icon}</span>
                </div>
                <Badge variant="secondary" className="bg-gray-100 text-gray-900 border-gray-300 text-xs font-medium">
                  {stat.change}
                </Badge>
              </div>
              <p className="text-3xl font-bold text-gray-900 mb-1">{stat.value}</p>
              <p className="text-sm text-gray-600">{stat.label}</p>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Main Content Tabs */}
      <Tabs defaultValue="overview" className="space-y-6">
        <TabsList className="bg-gray-100 border-gray-200 p-1 rounded-xl">
          <TabsTrigger value="overview" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Overview</TabsTrigger>
          <TabsTrigger value="analytics" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Analytics</TabsTrigger>
          <TabsTrigger value="users" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Users</TabsTrigger>
          <TabsTrigger value="providers" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Providers</TabsTrigger>
          <TabsTrigger value="revenue" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Revenue</TabsTrigger>
          <TabsTrigger value="roadmap" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Roadmap</TabsTrigger>
        <TabsTrigger value="overview" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Overview</TabsTrigger>
        <TabsTrigger value="analytics" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Analytics</TabsTrigger>
        <TabsTrigger value="users" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Users</TabsTrigger>
        <TabsTrigger value="communities" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Communities</TabsTrigger>
        <TabsTrigger value="providers" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Providers</TabsTrigger>
        <TabsTrigger value="revenue" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Revenue</TabsTrigger>
        <TabsTrigger value="roadmap" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Roadmap</TabsTrigger>
          <TabsTrigger value="system" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">System</TabsTrigger>
          <TabsTrigger value="status" className="data-[state=active]:bg-white data-[state=active]:text-purple-800 text-gray-600 rounded-lg transition-all duration-200">Status</TabsTrigger>
        </TabsList>

        {/* Overview Tab */}
        <TabsContent value="overview" className="space-y-6">
          <div className="grid lg:grid-cols-2 gap-6">
            {/* User Activity Chart */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>User Activity</CardTitle>
                <CardDescription>User registrations and activity trends</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="p-4 bg-white/5 rounded-lg">
                      <p className="text-sm text-gray-400">New Users Today</p>
                      <p className="text-2xl font-bold text-blue-400">{(stats as any)?.newUsersToday || 0}</p>
                      <p className="text-2xl font-bold text-blue-400">{stats?.newUsersToday ?? 0}</p>
                    </div>
                    <div className="p-4 bg-white/5 rounded-lg">
                      <p className="text-sm text-gray-400">Trial Users</p>
                      <p className="text-2xl font-bold text-purple-400">{(stats as any)?.trialUsers || 0}</p>
                      <p className="text-2xl font-bold text-purple-400">{stats?.trialUsers ?? 0}</p>
                    </div>
                  </div>
                  <div className="space-y-2">
                    <div className="flex justify-between text-sm">
                      <span className="text-gray-400">Free Users</span>
                      <span className="text-gray-900">{(stats as any)?.freeUsers || 0}</span>
                      <span className="text-gray-900">{stats?.freeUsers ?? 0}</span>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-gray-400">Pro Users</span>
                      <span className="text-green-400">{(stats as any)?.proUsers || 0}</span>
                      <span className="text-green-400">{stats?.proUsers ?? 0}</span>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-gray-400">Premium Users</span>
                      <span className="text-purple-400">{(stats as any)?.premiumUsers || 0}</span>
                      <span className="text-purple-400">{stats?.premiumUsers ?? 0}</span>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Content Generation Stats */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>System Status</CardTitle>
                <CardDescription>Service availability and configuration</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                    <div className="flex items-center gap-3">
                      <div className={`w-3 h-3 rounded-full ${(stats as any)?.jwtConfigured ? 'bg-green-500' : 'bg-red-500'}`} />
                      <div className={`w-3 h-3 rounded-full ${stats?.jwtConfigured ? 'bg-green-500' : 'bg-red-500'}`} />
                      <span className="text-sm">Authentication</span>
                    </div>
                    <Badge variant={(stats as any)?.jwtConfigured ? 'default' : 'destructive'}>
                      {(stats as any)?.jwtConfigured ? 'Active' : 'Inactive'}
                    <Badge variant={stats?.jwtConfigured ? 'default' : 'destructive'}>
                      {stats?.jwtConfigured ? 'Active' : 'Inactive'}
                    </Badge>
                  </div>
                  <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                    <div className="flex items-center gap-3">
                      <div className={`w-3 h-3 rounded-full ${(stats as any)?.emailConfigured ? 'bg-green-500' : 'bg-yellow-500'}`} />
                      <div className={`w-3 h-3 rounded-full ${stats?.emailConfigured ? 'bg-green-500' : 'bg-yellow-500'}`} />
                      <span className="text-sm">Email Service</span>
                    </div>
                    <Badge variant={(stats as any)?.emailConfigured ? 'default' : 'secondary'}>
                      {(stats as any)?.emailConfigured ? 'Configured' : 'Not Set'}
                    <Badge variant={stats?.emailConfigured ? 'default' : 'secondary'}>
                      {stats?.emailConfigured ? 'Configured' : 'Not Set'}
                    </Badge>
                  </div>
                  <div className="mt-4 p-3 bg-gradient-to-r from-purple-500/10 to-pink-500/10 rounded-lg">
                    <p className="text-sm text-gray-300">Total Content Generated</p>
                    <p className="text-3xl font-bold text-gray-900">{(stats as any)?.contentGenerated || 0}</p>
                    <p className="text-3xl font-bold text-gray-900">{stats?.contentGenerated ?? 0}</p>
                    <p className="text-xs text-gray-400 mt-1">Across all users and platforms</p>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        {/* Users Tab */}
        <TabsContent value="users" className="space-y-6">
          <Card className="bg-white border-gray-200 shadow-lg">
            <CardHeader>
              <CardTitle>User Management</CardTitle>
              <CardDescription>View and manage platform users</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead>
                    <tr className="border-b border-white/10">
                      <th className="text-left p-4">User</th>
                      <th className="text-left p-4">Tier</th>
                      <th className="text-left p-4">Joined</th>
                      <th className="text-left p-4">Content Created</th>
                      <th className="text-left p-4">Status</th>
                      <th className="text-left p-4">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {(users as any)?.slice(0, 5).map((user: unknown) => (
                      <tr key={(user as User).id} className="border-b border-white/5">
                        <td className="p-4">
                          <div>
                            <p className="font-medium">{(user as User).username}</p>
                            <p className="text-xs text-gray-500">{(user as User).email}</p>
                          </div>
                        </td>
                        <td className="p-4">
                          <Badge variant={(user as User).tier === 'premium' ? 'default' : 'secondary'}>
                            {(user as User).tier}
                          </Badge>
                        </td>
                        <td className="p-4 text-sm text-gray-400">
                          {new Date((user as User).createdAt || '').toLocaleDateString()}
                        </td>
                        <td className="p-4">{(user as User).contentCount || 0}</td>
                        <td className="p-4">
                          <Badge variant="outline" className="text-green-400 border-green-400">
                            Active
                          </Badge>
                        </td>
                        <td className="p-4">
                          <div className="flex gap-2">
                            <Button 
                              size="sm" 
                              variant="ghost"
                              onClick={() => { setSelectedUser(user as User); setActionType('user-details'); }}
                              data-testid={`button-user-details-${(user as User).id}`}
                            >
                              <Eye className="h-4 w-4" />
                            </Button>
                            <Button 
                              size="sm" 
                              variant="ghost"
                              onClick={() => { setSelectedUser(user as User); setActionType('tier-management'); setNewTier((user as User).tier); }}
                              data-testid={`button-tier-management-${(user as User).id}`}
                            >
                              <Settings className="h-4 w-4" />
                            </Button>
                            <Button 
                              size="sm" 
                              variant="outline"
                              onClick={() => { setSelectedUser(user as User); setActionType('reset-password'); }}
                              data-testid={`button-reset-password-${(user as User).id}`}
                              className="text-orange-600 hover:text-orange-700"
                            >
                              <Key className="h-4 w-4" />
                            </Button>
                          </div>
                        </td>
                      </tr>
                    ))}
                    {displayedUsers.map((user) => {
                      const joinedDate = user.createdAt ? new Date(user.createdAt).toLocaleDateString() : '—';
                      const isActive = user.isActive ?? true;
                      const activeBadgeClasses = isActive ? 'text-green-400 border-green-400' : 'text-gray-400 border-gray-300';
                      return (
                        <tr key={user.id} className="border-b border-white/5">
                          <td className="p-4">
                            <div>
                              <p className="font-medium">{user.username}</p>
                              <p className="text-xs text-gray-500">{user.email}</p>
                            </div>
                          </td>
                          <td className="p-4">
                            <Badge variant={user.tier === 'premium' ? 'default' : 'secondary'}>
                              {user.tier}
                            </Badge>
                          </td>
                          <td className="p-4 text-sm text-gray-400">{joinedDate}</td>
                          <td className="p-4">{user.contentCount ?? 0}</td>
                          <td className="p-4">
                            <Badge variant="outline" className={activeBadgeClasses}>
                              {isActive ? 'Active' : 'Inactive'}
                            </Badge>
                          </td>
                          <td className="p-4">
                            <div className="flex gap-2">
                              <Button
                                size="sm"
                                variant="ghost"
                                onClick={() => { setSelectedUser(user); setActionType('user-details'); }}
                                data-testid={`button-user-details-${user.id}`}
                              >
                                <Eye className="h-4 w-4" />
                              </Button>
                              <Button
                                size="sm"
                                variant="ghost"
                                onClick={() => { setSelectedUser(user); setActionType('tier-management'); setNewTier(user.tier); }}
                                data-testid={`button-tier-management-${user.id}`}
                              >
                                <Settings className="h-4 w-4" />
                              </Button>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => { setSelectedUser(user); setActionType('reset-password'); }}
                                data-testid={`button-reset-password-${user.id}`}
                                className="text-orange-600 hover:text-orange-700"
                              >
                                <Key className="h-4 w-4" />
                              </Button>
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="communities" className="space-y-6">
          <Card className="bg-white border-gray-200 shadow-lg">
            <CardHeader>
              <CardTitle>Subreddit Rule Sync</CardTitle>
              <CardDescription>Review automated parsing results and manage manual overrides</CardDescription>
            </CardHeader>
            <CardContent>
              {communities.length === 0 ? (
                <p className="text-sm text-gray-500">No communities available.</p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full divide-y divide-gray-200">
                    <thead>
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Community</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Members</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Link Policy</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Manual Flags</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Last Synced</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Status</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Actions</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-gray-200">
                      {communities.map((community) => {
                        const policy = community.policyRules;
                        const manualFlags = policy?.manualFlags;
                        const manualSummary = manualFlags
                          ? [
                              manualFlags.minKarma ? `${manualFlags.minKarma} karma` : null,
                              manualFlags.minAccountAgeDays ? `${manualFlags.minAccountAgeDays}d age` : null,
                              manualFlags.verificationRequired === true
                                ? 'Verification required'
                                : manualFlags.verificationRequired === false
                                  ? 'Verification optional'
                                  : null,
                            ]
                              .filter((item): item is string => Boolean(item))
                              .join(', ')
                          : '';
                        const lastSynced = policy?.source?.fetchedAt || community.policyRulesUpdatedAt;
                        const overrideActive = Boolean(policy?.overrides && Object.keys(policy.overrides).length > 0);
                        return (
                          <tr key={community.id} className="bg-white">
                            <td className="px-4 py-3 text-sm font-medium text-gray-900">
                              <div className="flex items-center gap-2">
                                <FileText className="h-4 w-4 text-purple-500" />
                                <span>r/{community.name}</span>
                              </div>
                            </td>
                            <td className="px-4 py-3 text-sm text-gray-600">{community.members.toLocaleString()}</td>
                            <td className="px-4 py-3 text-sm text-gray-600">{formatLinkPolicy(policy?.linkPolicy ?? policy?.source?.automatedBase?.linkPolicy)}</td>
                            <td className="px-4 py-3 text-sm text-gray-600">{manualSummary || '—'}</td>
                            <td className="px-4 py-3 text-sm text-gray-500">{lastSynced ? new Date(lastSynced).toLocaleString() : '—'}</td>
                            <td className="px-4 py-3">
                              <Badge variant={overrideActive ? 'default' : 'secondary'} className={overrideActive ? 'bg-purple-100 text-purple-700' : ''}>
                                {overrideActive ? 'Override' : 'Automated'}
                              </Badge>
                            </td>
                            <td className="px-4 py-3">
                              <Button
                                variant="outline"
                                size="sm"
                                onClick={() => openRuleDialog(community)}
                                disabled={communityMutation.isPending && selectedCommunityRules?.id === community.id}
                                className="flex items-center gap-2"
                                data-testid={`button-edit-rules-${community.id}`}
                              >
                                <Pencil className="h-4 w-4" />
                                Edit overrides
                              </Button>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {selectedCommunityRules && (
          <Dialog open={rulesDialogOpen} onOpenChange={(open) => { if (!open) closeRuleDialog(); }}>
            <DialogContent className="max-w-4xl">
              <DialogHeader>
                <DialogTitle>Manual overrides for r/{selectedCommunityRules.name}</DialogTitle>
                <DialogDescription>
                  Automated parsing pulls directly from Reddit. Use overrides when moderators change requirements.
                </DialogDescription>
              </DialogHeader>
              <div className="grid gap-6 lg:grid-cols-2">
                <div className="space-y-4">
                  <div className="space-y-2">
                    <h4 className="text-sm font-semibold text-gray-700 flex items-center gap-2">
                      <Shield className="h-4 w-4 text-purple-500" />
                      Automated Reddit rules
                    </h4>
                    <div className="space-y-3 text-sm text-gray-600">
                      <div>
                        <p className="font-medium text-gray-700">Banned words</p>
                        {renderStringList(selectedCommunityRules.policyRules?.source?.automatedBase?.bannedWords)}
                      </div>
                      <div>
                        <p className="font-medium text-gray-700">Title patterns</p>
                        {renderStringList(selectedCommunityRules.policyRules?.source?.automatedBase?.titleRegexes)}
                      </div>
                      <div>
                        <p className="font-medium text-gray-700">Body filters</p>
                        {renderStringList(selectedCommunityRules.policyRules?.source?.automatedBase?.bodyRegexes)}
                      </div>
                      <div>
                        <p className="font-medium text-gray-700">Required tags</p>
                        {renderStringList(selectedCommunityRules.policyRules?.source?.automatedBase?.requiredTags)}
                      </div>
                      <div>
                        <p className="font-medium text-gray-700">Manual flags</p>
                        {selectedCommunityRules.policyRules?.source?.automatedBase?.manualFlags ? (
                          <p className="text-xs text-gray-600">
                            {[selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.minKarma ? `${selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.minKarma} karma` : null,
                              selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.minAccountAgeDays ? `${selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.minAccountAgeDays}d age` : null,
                              selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.verificationRequired === true
                                ? 'Verification required'
                                : selectedCommunityRules.policyRules.source.automatedBase.manualFlags?.verificationRequired === false
                                  ? 'Verification optional'
                                  : null]
                              .filter((item): item is string => Boolean(item))
                              .join(', ') || 'None detected'}
                          </p>
                        ) : (
                          <p className="text-xs text-gray-500">None detected</p>
                        )}
                      </div>
                      <div className="text-xs text-gray-500">
                        <p>Link policy: {formatLinkPolicy(selectedCommunityRules.policyRules?.source?.automatedBase?.linkPolicy)}</p>
                        <p>Max title length: {selectedCommunityRules.policyRules?.source?.automatedBase?.maxTitleLength ?? '—'}</p>
                        <p>Max body length: {selectedCommunityRules.policyRules?.source?.automatedBase?.maxBodyLength ?? '—'}</p>
                      </div>
                    </div>
                  </div>
                  {selectedCommunityRules.policyRules?.overrides && (
                    <div className="space-y-2">
                      <h4 className="text-sm font-semibold text-gray-700 flex items-center gap-2">
                        <FileCheck className="h-4 w-4 text-purple-500" />
                        Active overrides
                      </h4>
                      <div className="space-y-3 text-sm text-gray-600">
                        <div>
                          <p className="font-medium text-gray-700">Banned words</p>
                          {renderStringList(selectedCommunityRules.policyRules?.overrides?.bannedWords)}
                        </div>
                        <div>
                          <p className="font-medium text-gray-700">Required tags</p>
                          {renderStringList(selectedCommunityRules.policyRules?.overrides?.requiredTags)}
                        </div>
                        <div>
                          <p className="font-medium text-gray-700">Wiki notes</p>
                          {renderStringList(selectedCommunityRules.policyRules?.overrides?.wikiNotes)}
                        </div>
                      </div>
                    </div>
                  )}
                  <div className="text-xs text-gray-500">
                    <p>
                      Last synced:{' '}
                      {selectedCommunityRules.policyRules?.source?.fetchedAt
                        ? new Date(selectedCommunityRules.policyRules.source.fetchedAt).toLocaleString()
                        : 'N/A'}
                    </p>
                    {selectedCommunityRules.policyRules?.source?.aboutRulesUrl && (
                      <p>About rules: {selectedCommunityRules.policyRules.source.aboutRulesUrl}</p>
                    )}
                    {selectedCommunityRules.policyRules?.source?.wikiRulesUrl && (
                      <p>Wiki rules: {selectedCommunityRules.policyRules.source.wikiRulesUrl}</p>
                    )}
                  </div>
                </div>
                <div className="space-y-4">
                  <div>
                    <Label htmlFor="override-banned-words">Banned words</Label>
                    <Textarea
                      id="override-banned-words"
                      placeholder="spam, self-promotion"
                      rows={3}
                      value={ruleForm.bannedWords}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, bannedWords: event.target.value }))}
                    />
                    <p className="text-xs text-gray-500 mt-1">Comma or newline separated list. Leave blank to inherit automated values.</p>
                  </div>
                  <div>
                    <Label htmlFor="override-title-regexes">Title regexes</Label>
                    <Textarea
                      id="override-title-regexes"
                      rows={2}
                      value={ruleForm.titleRegexes}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, titleRegexes: event.target.value }))}
                    />
                  </div>
                  <div>
                    <Label htmlFor="override-body-regexes">Body filters</Label>
                    <Textarea
                      id="override-body-regexes"
                      rows={2}
                      value={ruleForm.bodyRegexes}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, bodyRegexes: event.target.value }))}
                    />
                  </div>
                  <div>
                    <Label htmlFor="override-required-tags">Required tags</Label>
                    <Textarea
                      id="override-required-tags"
                      rows={2}
                      value={ruleForm.requiredTags}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, requiredTags: event.target.value }))}
                    />
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                      <Label htmlFor="override-link-policy">Link policy</Label>
                      <Select
                        value={ruleForm.linkPolicy}
                        onValueChange={(value: 'inherit' | 'no-link' | 'one-link' | 'ok') => setRuleForm((prev) => ({ ...prev, linkPolicy: value }))}
                      >
                        <SelectTrigger id="override-link-policy">
                          <SelectValue placeholder="Use automated policy" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="inherit">Use automated policy</SelectItem>
                          <SelectItem value="no-link">No links</SelectItem>
                          <SelectItem value="one-link">One link limit</SelectItem>
                          <SelectItem value="ok">Links allowed</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    <div>
                      <Label htmlFor="override-flair">Flair required</Label>
                      <Select
                        value={ruleForm.flairRequired}
                        onValueChange={(value: TriStateOption) => setRuleForm((prev) => ({ ...prev, flairRequired: value }))}
                      >
                        <SelectTrigger id="override-flair">
                          <SelectValue placeholder="Inherit" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="inherit">Use automated value</SelectItem>
                          <SelectItem value="true">Required</SelectItem>
                          <SelectItem value="false">Optional</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                      <Label htmlFor="override-max-title">Max title length</Label>
                      <Input
                        id="override-max-title"
                        type="number"
                        min={0}
                        value={ruleForm.maxTitleLength}
                        onChange={(event) => setRuleForm((prev) => ({ ...prev, maxTitleLength: event.target.value }))}
                      />
                    </div>
                    <div>
                      <Label htmlFor="override-max-body">Max body length</Label>
                      <Input
                        id="override-max-body"
                        type="number"
                        min={0}
                        value={ruleForm.maxBodyLength}
                        onChange={(event) => setRuleForm((prev) => ({ ...prev, maxBodyLength: event.target.value }))}
                      />
                    </div>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                      <Label htmlFor="override-min-karma">Minimum karma</Label>
                      <Input
                        id="override-min-karma"
                        type="number"
                        min={0}
                        value={ruleForm.minKarma}
                        onChange={(event) => setRuleForm((prev) => ({ ...prev, minKarma: event.target.value }))}
                      />
                    </div>
                    <div>
                      <Label htmlFor="override-min-age">Minimum account age (days)</Label>
                      <Input
                        id="override-min-age"
                        type="number"
                        min={0}
                        value={ruleForm.minAccountAgeDays}
                        onChange={(event) => setRuleForm((prev) => ({ ...prev, minAccountAgeDays: event.target.value }))}
                      />
                    </div>
                  </div>
                  <div>
                    <Label htmlFor="override-verification">Verification</Label>
                    <Select
                      value={ruleForm.verificationRequired}
                      onValueChange={(value: TriStateOption) => setRuleForm((prev) => ({ ...prev, verificationRequired: value }))}
                    >
                      <SelectTrigger id="override-verification">
                        <SelectValue placeholder="Inherit" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="inherit">Use automated value</SelectItem>
                        <SelectItem value="true">Required</SelectItem>
                        <SelectItem value="false">Optional</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div>
                    <Label htmlFor="override-notes">Manual notes</Label>
                    <Textarea
                      id="override-notes"
                      rows={2}
                      value={ruleForm.notes}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, notes: event.target.value }))}
                    />
                    <p className="text-xs text-gray-500 mt-1">One note per line.</p>
                  </div>
                  <div>
                    <Label htmlFor="override-wiki-notes">Wiki notes override</Label>
                    <Textarea
                      id="override-wiki-notes"
                      rows={2}
                      value={ruleForm.wikiNotes}
                      onChange={(event) => setRuleForm((prev) => ({ ...prev, wikiNotes: event.target.value }))}
                    />
                  </div>
                </div>
              </div>
              <div className="flex items-center justify-between pt-4">
                <Button variant="outline" onClick={handleRuleOverrideClear} disabled={communityMutation.isPending}>
                  Clear overrides
                </Button>
                <div className="flex gap-2">
                  <Button variant="outline" onClick={closeRuleDialog} disabled={communityMutation.isPending}>
                    Cancel
                  </Button>
                  <Button onClick={handleRuleOverrideSave} disabled={communityMutation.isPending}>
                    {communityMutation.isPending ? 'Saving…' : 'Save overrides'}
                  </Button>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        )}

        {/* Providers Tab */}
        <TabsContent value="providers" className="space-y-6">
          <Card className="bg-white border-gray-200 shadow-lg">
            <CardHeader>
              <CardTitle>Provider Costs & Status</CardTitle>
              <CardDescription>Monitor service usage and costs</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {(providers as any)?.map((provider: unknown) => {
                  const typedProvider = provider as {name?: string; available?: boolean; inputCost?: string; outputCost?: string; savings?: string};
                  return (
                  <div key={typedProvider.name} className="p-4 bg-white/5 rounded-lg">
                {providerList.map((provider) => (
                  <div key={provider.name} className="p-4 bg-white/5 rounded-lg">
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center gap-3">
                        <div className={`w-3 h-3 rounded-full ${typedProvider.available ? 'bg-green-500' : 'bg-red-500'}`} />
                        <h3 className="font-medium">{typedProvider.name}</h3>
                        <div className={`w-3 h-3 rounded-full ${provider.available ? 'bg-green-500' : 'bg-red-500'}`} />
                        <h3 className="font-medium">{provider.name}</h3>
                      </div>
                      <Badge variant={typedProvider.available ? 'default' : 'destructive'}>
                        {typedProvider.available ? 'Active' : 'Inactive'}
                      <Badge variant={provider.available ? 'default' : 'destructive'}>
                        {provider.available ? 'Active' : 'Inactive'}
                      </Badge>
                    </div>
                    <div className="grid grid-cols-3 gap-4 text-sm">
                      <div>
                        <p className="text-gray-500">Input Cost</p>
                        <p className="font-medium">${typedProvider.inputCost}/1M tokens</p>
                        <p className="font-medium">${provider.inputCost}/1M tokens</p>
                      </div>
                      <div>
                        <p className="text-gray-500">Output Cost</p>
                        <p className="font-medium">${typedProvider.outputCost}/1M tokens</p>
                        <p className="font-medium">${provider.outputCost}/1M tokens</p>
                      </div>
                      <div>
                        <p className="text-gray-500">Savings vs GPT-4</p>
                        <p className="font-medium text-green-400">{typedProvider.savings}%</p>
                        <p className="font-medium text-green-400">{provider.savings}%</p>
                      </div>
                    </div>
                  </div>
                  );
                })}
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Revenue Tab */}
        <TabsContent value="revenue" className="space-y-6">
          <div className="grid lg:grid-cols-3 gap-6">
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Monthly Revenue</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold">${(stats as any)?.revenue || '0'}</p>
                <p className="text-3xl font-bold">${(stats?.revenue ?? 0).toLocaleString()}</p>
                <p className="text-sm text-gray-400 mt-2">Total platform revenue</p>
              </CardContent>
            </Card>

            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Active Subscriptions</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  <div className="flex justify-between">
                    <span className="text-gray-400">Free</span>
                    <span>{(stats as any)?.freeUsers || 0}</span>
                    <span>{stats?.freeUsers ?? 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Pro ($20/mo)</span>
                    <span className="text-green-400">{(stats as any)?.proUsers || 0}</span>
                    <span className="text-green-400">{stats?.proUsers ?? 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Premium ($50/mo)</span>
                    <span className="text-purple-400">{(stats as any)?.premiumUsers || 0}</span>
                    <span className="text-purple-400">{stats?.premiumUsers ?? 0}</span>
                  </div>
                  <div className="border-t border-white/10 pt-2 mt-2">
                    <div className="flex justify-between font-medium">
                      <span className="text-gray-900">Monthly Revenue</span>
                      <span className="text-green-400">${((stats as any)?.proUsers || 0) * 20 + ((stats as any)?.premiumUsers || 0) * 50}</span>
                      <span className="text-green-400">${(((stats?.proUsers ?? 0) * 20) + ((stats?.premiumUsers ?? 0) * 50)).toLocaleString()}</span>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Service Costs</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold">${Math.floor(((stats as any)?.contentGenerated || 0) * 0.02) || '0'}</p>
                <p className="text-3xl font-bold">${Math.floor((stats?.contentGenerated ?? 0) * 0.02).toLocaleString()}</p>
                <p className="text-sm text-gray-400 mt-2">Estimated AI costs</p>
                <div className="mt-3 text-xs space-y-1">
                  <div className="flex justify-between">
                    <span className="text-gray-500">Gemini (Primary)</span>
                    <span className="text-green-400">85% savings</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Content Generated</span>
                    <span className="text-gray-900">{(stats as any)?.contentGenerated || 0}</span>
                    <span className="text-gray-900">{stats?.contentGenerated ?? 0}</span>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        {/* System Tab */}
        <TabsContent value="system" className="space-y-6">
          <Card className="bg-white border-gray-200 shadow-lg">
            <CardHeader>
              <CardTitle>System Health</CardTitle>
              <CardDescription>Monitor system status and performance</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Database className="h-5 w-5 text-blue-400" />
                    <span>Database</span>
                  </div>
                  <Badge variant="outline" className="text-green-400 border-green-400">
                  <Badge variant="outline" className={systemHealth?.database.status === 'healthy' ? 'text-green-400 border-green-400' : 'text-yellow-500 border-yellow-500'}>
                    <CheckCircle className="h-3 w-3 mr-1" />
                    {(systemHealth as any)?.database?.status === 'healthy' ? 'Healthy' : 'Issues'}
                    {systemHealth?.database.status === 'healthy' ? 'Healthy' : 'Issues'}
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Zap className="h-5 w-5 text-purple-400" />
                    <span>Gemini AI</span>
                  </div>
                  <Badge variant={((systemHealth as any)?.services?.gemini ? 'outline' : 'destructive')} className={((systemHealth as any)?.services?.gemini ? 'text-green-400 border-green-400' : '')}>
                    {(systemHealth as any)?.services?.gemini ? <CheckCircle className="h-3 w-3 mr-1" /> : <XCircle className="h-3 w-3 mr-1" />}
                    {(systemHealth as any)?.services?.gemini ? 'Active' : 'Inactive'}
                  <Badge variant={(systemHealth?.services.gemini ? 'outline' : 'destructive')} className={systemHealth?.services.gemini ? 'text-green-400 border-green-400' : ''}>
                    {systemHealth?.services.gemini ? <CheckCircle className="h-3 w-3 mr-1" /> : <XCircle className="h-3 w-3 mr-1" />}
                    {systemHealth?.services.gemini ? 'Active' : 'Inactive'}
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Activity className="h-5 w-5 text-blue-400" />
                    <span>OpenAI</span>
                  </div>
                  <Badge variant={((systemHealth as any)?.services?.openai ? 'outline' : 'destructive')} className={((systemHealth as any)?.services?.openai ? 'text-green-400 border-green-400' : '')}>
                    {(systemHealth as any)?.services?.openai ? <CheckCircle className="h-3 w-3 mr-1" /> : <XCircle className="h-3 w-3 mr-1" />}
                    {(systemHealth as any)?.services?.openai ? 'Active' : 'Inactive'}
                  <Badge variant={(systemHealth?.services.openai ? 'outline' : 'destructive')} className={systemHealth?.services.openai ? 'text-green-400 border-green-400' : ''}>
                    {systemHealth?.services.openai ? <CheckCircle className="h-3 w-3 mr-1" /> : <XCircle className="h-3 w-3 mr-1" />}
                    {systemHealth?.services.openai ? 'Active' : 'Inactive'}
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Headphones className="h-5 w-5 text-yellow-400" />
                    <span>Email Service</span>
                  </div>
                  <Badge variant={((systemHealth as any)?.services?.email ? 'outline' : 'secondary')} className={((systemHealth as any)?.services?.email ? 'text-green-400 border-green-400' : 'text-yellow-400 border-yellow-400')}>
                    {(systemHealth as any)?.services?.email ? <CheckCircle className="h-3 w-3 mr-1" /> : <AlertCircle className="h-3 w-3 mr-1" />}
                    {(systemHealth as any)?.services?.email ? 'Configured' : 'Not Set'}
                  <Badge variant={(systemHealth?.services.email ? 'outline' : 'secondary')} className={systemHealth?.services.email ? 'text-green-400 border-green-400' : 'text-yellow-400 border-yellow-400'}>
                    {systemHealth?.services.email ? <CheckCircle className="h-3 w-3 mr-1" /> : <AlertCircle className="h-3 w-3 mr-1" />}
                    {systemHealth?.services.email ? 'Configured' : 'Not Set'}
                  </Badge>
                </div>
                
                {/* Performance Metrics */}
                <div className="mt-6 p-4 bg-gradient-to-r from-blue-500/10 to-purple-500/10 rounded-lg">
                  <h4 className="text-sm font-medium text-gray-900 mb-3">Performance Metrics</h4>
                  <div className="grid grid-cols-3 gap-4 text-sm">
                    <div>
                      <p className="text-gray-400">Response Time</p>
                      <p className="font-medium text-blue-400">{(systemHealth as any)?.performance?.avgResponseTime || 'N/A'}</p>
                      <p className="font-medium text-blue-400">{systemHealth?.performance.avgResponseTime ?? 'N/A'}</p>
                    </div>
                    <div>
                      <p className="text-gray-400">Error Rate</p>
                      <p className="font-medium text-green-400">{(systemHealth as any)?.performance?.errorRate || 'N/A'}</p>
                      <p className="font-medium text-green-400">{systemHealth?.performance.errorRate ?? 'N/A'}</p>
                    </div>
                    <div>
                      <p className="text-gray-400">Throughput</p>
                      <p className="font-medium text-purple-400">{(systemHealth as any)?.performance?.throughput || 'N/A'}</p>
                      <p className="font-medium text-purple-400">{systemHealth?.performance.throughput ?? 'N/A'}</p>
                    </div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Visitor Analytics Tab */}
        <TabsContent value="analytics" className="space-y-6">
          <div className="grid lg:grid-cols-3 gap-6 mb-6">
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-2xl font-bold">{(analytics as any)?.uniqueVisitors || 0}</p>
                    <p className="text-2xl font-bold">{analytics?.uniqueVisitors ?? 0}</p>
                    <p className="text-sm text-gray-400">Unique Visitors</p>
                  </div>
                  <Eye className="h-8 w-8 text-blue-400" />
                </div>
              </CardContent>
            </Card>
            
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-2xl font-bold">{(analytics as any)?.pageViews || 0}</p>
                    <p className="text-2xl font-bold">{analytics?.pageViews ?? 0}</p>
                    <p className="text-sm text-gray-400">Page Views</p>
                  </div>
                  <BarChart3 className="h-8 w-8 text-green-400" />
                </div>
              </CardContent>
            </Card>
            
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-2xl font-bold">{(analytics as any)?.bounceRate?.toFixed(1) || 0}%</p>
                    <p className="text-2xl font-bold">{analytics ? analytics.bounceRate.toFixed(1) : '0.0'}%</p>
                    <p className="text-sm text-gray-400">Bounce Rate</p>
                  </div>
                  <TrendingUp className="h-8 w-8 text-purple-400" />
                </div>
              </CardContent>
            </Card>
          </div>

          <div className="grid lg:grid-cols-2 gap-6">
            {/* Top Pages */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Top Pages</CardTitle>
                <CardDescription>Most visited pages</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {(analytics as any)?.topPages?.slice(0, 5).map((page: unknown, index: number) => (
                    <div key={index} className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                      <span className="text-sm">{(page as {path?: string; views?: number})?.path}</span>
                      <Badge variant="secondary">{(page as {path?: string; views?: number})?.views} views</Badge>
                    </div>
                  )) || (
                  {analytics?.topPages?.length ? (
                    analytics.topPages.slice(0, 5).map((page, index) => (
                      <div key={index} className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                        <span className="text-sm">{page.path}</span>
                        <Badge variant="secondary">{page.views} views</Badge>
                      </div>
                    ))
                  ) : (
                    <div className="text-center text-gray-500 py-8">
                      No page data available yet
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Traffic Sources */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Traffic Sources</CardTitle>
                <CardDescription>Where visitors come from</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {(analytics as any)?.trafficSources?.slice(0, 5).map((source: unknown, index: number) => (
                    <div key={index} className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                      <span className="text-sm">{(source as {source?: string; visitors?: number})?.source}</span>
                      <Badge variant="secondary">{(source as {source?: string; visitors?: number})?.visitors} visitors</Badge>
                    </div>
                  )) || (
                  {analytics?.trafficSources?.length ? (
                    analytics.trafficSources.slice(0, 5).map((source, index) => (
                      <div key={index} className="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                        <span className="text-sm">{source.source}</span>
                        <Badge variant="secondary">{source.visitors} visitors</Badge>
                      </div>
                    ))
                  ) : (
                    <div className="text-center text-gray-500 py-8">
                      No traffic data available yet
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        {/* Development Roadmap Tab */}
        <TabsContent value="roadmap" className="space-y-6">
          <div className="grid lg:grid-cols-3 gap-6">
            {/* Immediate Priority (Q1) */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle className="text-red-400">🔥 Immediate Priority</CardTitle>
                <CardDescription>Q1 2025 - Critical features</CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="p-4 bg-red-500/10 border border-red-500/20 rounded-lg">
                  <div className="flex items-center gap-3 mb-2">
                    <Gift className="h-5 w-5 text-red-400" />
                    <p className="font-medium text-red-400">Referral System</p>
                  </div>
@@ -888,83 +1573,83 @@ export function AdminDashboard() {
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">Q1 2025 Goals</span>
                  <span className="text-sm text-gray-400">3 of 3 features</span>
                </div>
                <div className="w-full bg-gray-700 rounded-full h-2">
                  <div className="bg-gradient-to-r from-red-500 to-red-400 h-2 rounded-full" style={{width: '33%'}}></div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* System Status Tab */}
        <TabsContent value="status" className="space-y-6">
          <div className="grid lg:grid-cols-2 gap-6">
            {/* Platform Completeness */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Platform Completeness</CardTitle>
                <CardDescription>Feature implementation status</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <span className="text-sm">Overall Progress</span>
                    <span className="text-2xl font-bold text-purple-400">{(completeness as any)?.completionPercentage || 0}%</span>
                    <span className="text-2xl font-bold text-purple-400">{completeness?.completionPercentage ?? 0}%</span>
                  </div>
                  
                  <div className="space-y-3">
                    <div className="space-y-2">
                      <h4 className="text-sm font-medium text-purple-300">Core Features</h4>
                      {Object.entries((completeness as any)?.core || {}).map(([key, value]) => (
                      {Object.entries(completeness?.core ?? {}).map(([key, value]) => (
                        <div key={key} className="flex items-center justify-between text-sm">
                          <span className="text-gray-400 capitalize">{key.replace(/([A-Z])/g, ' $1')}</span>
                          <Badge variant={value ? 'default' : 'destructive'} className="text-xs">
                            {value ? <CheckCircle className="h-3 w-3 mr-1" /> : <XCircle className="h-3 w-3 mr-1" />}
                            {value ? 'Done' : 'Missing'}
                          </Badge>
                        </div>
                      ))}
                    </div>
                    
                    <div className="space-y-2">
                      <h4 className="text-sm font-medium text-blue-300">Advanced Features</h4>
                      {Object.entries((completeness as any)?.features || {}).map(([key, value]) => (
                      {Object.entries(completeness?.features ?? {}).map(([key, value]) => (
                        <div key={key} className="flex items-center justify-between text-sm">
                          <span className="text-gray-400 capitalize">{key.replace(/([A-Z])/g, ' $1')}</span>
                          <Badge variant={value ? 'default' : 'secondary'} className="text-xs">
                            {value ? <CheckCircle className="h-3 w-3 mr-1" /> : <AlertCircle className="h-3 w-3 mr-1" />}
                            {value ? 'Ready' : 'Planned'}
                          </Badge>
                        </div>
                      ))}
                    </div>
                    
                    <div className="space-y-2">
                      <h4 className="text-sm font-medium text-green-300">Integrations</h4>
                      {Object.entries((completeness as any)?.integrations || {}).map(([key, value]) => (
                      {Object.entries(completeness?.integrations ?? {}).map(([key, value]) => (
                        <div key={key} className="flex items-center justify-between text-sm">
                          <span className="text-gray-400 capitalize">{key.replace(/([A-Z])/g, ' $1')}</span>
                          <Badge variant={value ? 'default' : 'outline'} className="text-xs">
                            {value ? <CheckCircle className="h-3 w-3 mr-1" /> : <AlertCircle className="h-3 w-3 mr-1" />}
                            {value ? 'Connected' : 'Not Set'}
                          </Badge>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
            
            {/* Quick Actions */}
            <Card className="bg-white border-gray-200 shadow-lg">
              <CardHeader>
                <CardTitle>Admin Actions</CardTitle>
                <CardDescription>Quick management operations</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  <Button 
                    className="w-full justify-start bg-blue-100 hover:bg-blue-200 border-blue-300 text-blue-800"
                    onClick={() => {
server/lib/policy-linter.ts
+49-19
import { db } from "../db.js";
import { subredditRules } from "@shared/schema";
import { eq } from "drizzle-orm";
import { coerceRuleSpec } from "./subreddit-rule-utils.js";

export type PolicyResult = {
  state: "ok" | "warn" | "block";
  warnings: string[];
};

export type RuleSpec = {
export type ManualRuleFlags = {
  minKarma?: number;
  minAccountAgeDays?: number;
  verificationRequired?: boolean;
  notes?: string[];
};

export type RuleSpecBase = {
  bannedWords?: string[];
  titleRegexes?: string[];   // strings of regex
  bodyRegexes?: string[];
  flairRequired?: boolean;
  linkPolicy?: "no-link" | "one-link" | "ok";
  requiredTags?: string[];   // e.g. "[F]" etc
  maxTitleLength?: number;
  maxBodyLength?: number;
  manualFlags?: ManualRuleFlags;
  wikiNotes?: string[];
};

export type RuleSourceMetadata = {
  aboutRulesUrl?: string;
  wikiRulesUrl?: string;
  fetchedAt?: string;
  automatedBase?: RuleSpecBase;
};

export type RuleOverride = Partial<RuleSpecBase>;

export type RuleSpec = RuleSpecBase & {
  source?: RuleSourceMetadata;
  overrides?: RuleOverride;
};

// Test format compatibility  
export type TestRuleSpec = {
  bannedWords?: string[];
  titleRegex?: string[];  // Note: different from titleRegexes
  prohibitedLinks?: string[];
  maxLength?: number;
  minLength?: number;
};

// Default rules for NSFW content creation (safe and professional)
const DEFAULT_RULES: RuleSpec = {
  bannedWords: [
    // Professional content creation focused - avoiding explicit terms
    "underage", "minor", "child", "teen", "young", "school", "student",
    "illegal", "drugs", "violence", "harassment", "revenge",
    // Spam-related terms
    "click here", "free money", "guaranteed", "make money fast"
  ],
  titleRegexes: [
    // Common spam patterns
    "^(FREE|CLICK|URGENT|AMAZING)",
    "!!!+",
    "\\$\\$\\$"
  ],
  bodyRegexes: [
    // Links that look spammy
    "bit\\.ly|tinyurl|short\\.link",
    // All caps content (suggests spam)
    "^[A-Z\\s!?]{20,}"
  ],
  linkPolicy: "one-link", // Most NSFW subreddits allow one promotional link
  requiredTags: [], // Subreddit-specific, so empty by default
  maxTitleLength: 300, // Reddit's limit
  maxBodyLength: 10000, // Reddit's limit
  flairRequired: false // Varies by subreddit
};

// Helper function to normalize subreddit names
function normalizeSubredditName(name: string): string {
export function normalizeSubredditName(name: string): string {
  // Remove non-alphanumeric characters except underscores, then normalize
  return name.replace(/[^a-z0-9_]/gi, '').toLowerCase();
}

function extractTestMinLength(input: unknown): number | undefined {
  if (!input || typeof input !== 'object' || input === null) {
    return undefined;
  }
  if (!('minLength' in input)) {
    return undefined;
  }
  const candidate = (input as { minLength?: unknown }).minLength;
  return typeof candidate === 'number' ? candidate : undefined;
}

export async function lintCaption(input: {
  subreddit: string;
  title: string;
  body: string;
  hasLink: boolean;
}): Promise<PolicyResult> {
  const { subreddit, title, body, hasLink } = input;
  const warnings: string[] = [];
  let state: "ok" | "warn" | "block" = "ok";

  try {
    // Normalize the subreddit name for lookup
    const normalizedSubreddit = normalizeSubredditName(subreddit);
    
    // Load subreddit-specific rules
    const [subredditRule] = await db
      .select()
      .from(subredditRules)
      .where(eq(subredditRules.subreddit, normalizedSubreddit));

    // Handle both test format and normal format
    let rules: RuleSpec;
    
    let minLength: number | undefined;
    if (subredditRule?.rulesJson) {
      const rawRules = subredditRule.rulesJson as any;
      
      // Check if it's in test format and convert
      if ('titleRegex' in rawRules || 'prohibitedLinks' in rawRules || 'maxLength' in rawRules || 'minLength' in rawRules) {
        const testRules = rawRules as TestRuleSpec;
        rules = {
          bannedWords: testRules.bannedWords,
          titleRegexes: testRules.titleRegex,  // Map titleRegex to titleRegexes
          bodyRegexes: testRules.prohibitedLinks, // Map prohibitedLinks to bodyRegexes
          maxTitleLength: testRules.maxLength,
          maxBodyLength: testRules.maxLength,
          // Only set required tags if not testing clean content (where title has [F])
          requiredTags: testRules.minLength && !title.includes('[') ? ['[F]'] : []
        };
      const parsedSpec = coerceRuleSpec(subredditRule.rulesJson);
      if (parsedSpec) {
        rules = parsedSpec;
        minLength = extractTestMinLength(subredditRule.rulesJson);
      } else {
        rules = rawRules as RuleSpec;
        rules = DEFAULT_RULES;
      }
    } else {
      rules = DEFAULT_RULES;
    }

    if (minLength && !title.includes('[')) {
      const requiredTags = new Set(rules.requiredTags ?? []);
      requiredTags.add('[F]');
      rules.requiredTags = Array.from(requiredTags);
    }

    // Check banned words (blocking violation)
    if (rules.bannedWords?.length) {
      // For test compatibility: if bannedWords contains "banned terms", check if "banned" is in content
      if (rules.bannedWords.includes('banned terms')) {
        // Test expects to find "banned" in the content
        if (title.toLowerCase().includes('banned') || body.toLowerCase().includes('banned')) {
          warnings.push(`Contains banned terms`);
          state = "block";
        }
      } else {
        // Normal banned word checking
        const bannedFound = rules.bannedWords.filter(word =>
          title.toLowerCase().includes(word.toLowerCase()) ||
          body.toLowerCase().includes(word.toLowerCase())
        );
        
        if (bannedFound.length > 0) {
          warnings.push(`Contains banned terms: ${bannedFound.join(", ")}`);
          state = "block";
        }
      }
    }

    // Check title regexes (blocking violation)
    if (rules.titleRegexes?.length) {
@@ -203,52 +235,50 @@ export async function lintCaption(input: {
    }

    // Check length limits (warning)
    if (rules.maxTitleLength && title.length > rules.maxTitleLength) {
      warnings.push(`too long`);
      if (state !== "block") state = "warn";
    }

    if (rules.maxBodyLength && body.length > rules.maxBodyLength) {
      warnings.push(`too long`);
      if (state !== "block") state = "warn";
    }

    // Check flair requirement (warning)
    if (rules.flairRequired) {
      // Basic flair detection - look for common patterns
      const hasFlairPattern = /\[[^\]]+\]/.test(title) || /\([^)]+\)/.test(title);
      if (!hasFlairPattern) {
        warnings.push("This subreddit may require post flair or tags");
        if (state !== "block") state = "warn";
      }
    }

    // Additional content quality checks (warnings)
    // Check for minimum length if specified in test format
    const minLength = (subredditRule?.rulesJson as TestRuleSpec)?.minLength;
    
    // For test compatibility: use exact message "too short"
    if (minLength) {
      if (title.length < minLength) {
        warnings.push("too short");
        if (state !== "block") state = "warn";
      }
      if (body.length > 0 && body.length < minLength) {
        warnings.push("too short");
        if (state !== "block") state = "warn";
      }
    } else {
      // For non-test usage (when no minLength is specified)
      if (title.length < 10) {
        warnings.push("Title might be too short for engagement");
        if (state !== "block") state = "warn";
      }
      if (body.length > 0 && body.length < 20) {
        warnings.push("Body content might be too brief");
        if (state !== "block") state = "warn";
      }
    }

    // Check for common engagement killers (warnings)
    if (title.includes("upvote") || body.includes("upvote")) {
      warnings.push("Asking for upvotes may hurt engagement");
server/lib/subreddit-rule-utils.ts
New
+222-0
import type {
  ManualRuleFlags,
  RuleOverride,
  RuleSourceMetadata,
  RuleSpec,
  RuleSpecBase,
  TestRuleSpec,
} from './policy-linter.js';

function cloneManualFlags(flags?: ManualRuleFlags): ManualRuleFlags | undefined {
  if (!flags) {
    return undefined;
  }
  const cloned: ManualRuleFlags = {};
  if (typeof flags.minKarma === 'number') {
    cloned.minKarma = flags.minKarma;
  }
  if (typeof flags.minAccountAgeDays === 'number') {
    cloned.minAccountAgeDays = flags.minAccountAgeDays;
  }
  if (typeof flags.verificationRequired === 'boolean') {
    cloned.verificationRequired = flags.verificationRequired;
  }
  if (Array.isArray(flags.notes) && flags.notes.length > 0) {
    cloned.notes = [...flags.notes];
  }
  return Object.keys(cloned).length > 0 ? cloned : undefined;
}

export function cloneRuleSpecBase(base: RuleSpecBase): RuleSpecBase {
  const cloned: RuleSpecBase = {};
  if (Array.isArray(base.bannedWords) && base.bannedWords.length > 0) {
    cloned.bannedWords = [...base.bannedWords];
  }
  if (Array.isArray(base.titleRegexes) && base.titleRegexes.length > 0) {
    cloned.titleRegexes = [...base.titleRegexes];
  }
  if (Array.isArray(base.bodyRegexes) && base.bodyRegexes.length > 0) {
    cloned.bodyRegexes = [...base.bodyRegexes];
  }
  if (typeof base.flairRequired === 'boolean') {
    cloned.flairRequired = base.flairRequired;
  }
  if (base.linkPolicy) {
    cloned.linkPolicy = base.linkPolicy;
  }
  if (Array.isArray(base.requiredTags) && base.requiredTags.length > 0) {
    cloned.requiredTags = [...base.requiredTags];
  }
  if (typeof base.maxTitleLength === 'number') {
    cloned.maxTitleLength = base.maxTitleLength;
  }
  if (typeof base.maxBodyLength === 'number') {
    cloned.maxBodyLength = base.maxBodyLength;
  }
  const manualFlags = cloneManualFlags(base.manualFlags);
  if (manualFlags) {
    cloned.manualFlags = manualFlags;
  }
  if (Array.isArray(base.wikiNotes) && base.wikiNotes.length > 0) {
    cloned.wikiNotes = [...base.wikiNotes];
  }
  return cloned;
}

export function cloneRuleOverride(override: RuleOverride): RuleOverride {
  return cloneRuleSpecBase(override);
}

export function cloneRuleSpec(spec: RuleSpec): RuleSpec {
  const base = cloneRuleSpecBase(spec);
  const cloned: RuleSpec = { ...base };
  if (spec.source) {
    const source: RuleSourceMetadata = { ...spec.source };
    if (spec.source.automatedBase) {
      source.automatedBase = cloneRuleSpecBase(spec.source.automatedBase);
    }
    cloned.source = source;
  }
  if (spec.overrides) {
    cloned.overrides = cloneRuleOverride(spec.overrides);
  }
  return cloned;
}

export function extractBaseFromSpec(spec: RuleSpec): RuleSpecBase {
  return cloneRuleSpecBase(spec);
}

export function mergeManualFlags(
  existingFlags: ManualRuleFlags | undefined,
  incomingFlags: ManualRuleFlags | undefined,
): ManualRuleFlags | undefined {
  if (!existingFlags && !incomingFlags) {
    return undefined;
  }
  const merged: ManualRuleFlags = {};
  const candidateFlags: Array<ManualRuleFlags | undefined> = [existingFlags, incomingFlags];
  for (const candidate of candidateFlags) {
    if (!candidate) {
      continue;
    }
    if (typeof candidate.minKarma === 'number') {
      merged.minKarma = candidate.minKarma;
    }
    if (typeof candidate.minAccountAgeDays === 'number') {
      merged.minAccountAgeDays = candidate.minAccountAgeDays;
    }
    if (typeof candidate.verificationRequired === 'boolean') {
      merged.verificationRequired = candidate.verificationRequired;
    }
    if (Array.isArray(candidate.notes) && candidate.notes.length > 0) {
      merged.notes = [...candidate.notes];
    }
  }
  return Object.keys(merged).length > 0 ? merged : undefined;
}

export function buildSpecFromBase(
  base: RuleSpecBase,
  source?: RuleSourceMetadata,
): RuleSpec {
  const clonedBase = cloneRuleSpecBase(base);
  const spec: RuleSpec = { ...clonedBase };
  const nextSource: RuleSourceMetadata = {
    ...(source || {}),
    automatedBase: cloneRuleSpecBase(base),
  };
  if (nextSource.aboutRulesUrl === undefined && source?.aboutRulesUrl === undefined) {
    delete nextSource.aboutRulesUrl;
  }
  if (nextSource.wikiRulesUrl === undefined && source?.wikiRulesUrl === undefined) {
    delete nextSource.wikiRulesUrl;
  }
  if (nextSource.fetchedAt === undefined && source?.fetchedAt === undefined) {
    delete nextSource.fetchedAt;
  }
  spec.source = nextSource;
  return spec;
}

export function applyRuleOverrides(
  base: RuleSpec,
  overrides?: RuleOverride,
): RuleSpec {
  const result: RuleSpec = cloneRuleSpec(base);
  if (!overrides) {
    return result;
  }
  if (Array.isArray(overrides.bannedWords)) {
    result.bannedWords = [...overrides.bannedWords];
  }
  if (Array.isArray(overrides.titleRegexes)) {
    result.titleRegexes = [...overrides.titleRegexes];
  }
  if (Array.isArray(overrides.bodyRegexes)) {
    result.bodyRegexes = [...overrides.bodyRegexes];
  }
  if (typeof overrides.flairRequired === 'boolean') {
    result.flairRequired = overrides.flairRequired;
  }
  if (overrides.linkPolicy) {
    result.linkPolicy = overrides.linkPolicy;
  }
  if (Array.isArray(overrides.requiredTags)) {
    result.requiredTags = [...overrides.requiredTags];
  }
  if (typeof overrides.maxTitleLength === 'number') {
    result.maxTitleLength = overrides.maxTitleLength;
  }
  if (typeof overrides.maxBodyLength === 'number') {
    result.maxBodyLength = overrides.maxBodyLength;
  }
  const manualFlags = mergeManualFlags(result.manualFlags, overrides.manualFlags);
  if (manualFlags) {
    result.manualFlags = manualFlags;
  }
  if (Array.isArray(overrides.wikiNotes)) {
    result.wikiNotes = [...overrides.wikiNotes];
  }
  return result;
}

function isTestRuleFormat(input: Record<string, unknown>): boolean {
  return (
    Object.prototype.hasOwnProperty.call(input, 'titleRegex') ||
    Object.prototype.hasOwnProperty.call(input, 'prohibitedLinks') ||
    Object.prototype.hasOwnProperty.call(input, 'maxLength') ||
    Object.prototype.hasOwnProperty.call(input, 'minLength')
  );
}

function coerceTestRuleSpec(input: Record<string, unknown>): RuleSpec {
  const testRules = input as TestRuleSpec;
  const base: RuleSpecBase = {};
  if (Array.isArray(testRules.bannedWords)) {
    base.bannedWords = [...testRules.bannedWords];
  }
  if (Array.isArray(testRules.titleRegex)) {
    base.titleRegexes = [...testRules.titleRegex];
  }
  if (Array.isArray(testRules.prohibitedLinks)) {
    base.bodyRegexes = [...testRules.prohibitedLinks];
  }
  if (typeof testRules.maxLength === 'number') {
    base.maxTitleLength = testRules.maxLength;
    base.maxBodyLength = testRules.maxLength;
  }
  return buildSpecFromBase(base);
}

export function coerceRuleSpec(input: unknown): RuleSpec | null {
  if (!input || typeof input !== 'object') {
    return null;
  }
  const raw = input as Record<string, unknown>;
  if (isTestRuleFormat(raw)) {
    return coerceTestRuleSpec(raw);
  }
  const specLike = raw as RuleSpec;
  return cloneRuleSpec(specLike);
}
server/reddit-communities.ts
+178-11
import { db } from './db.js';
import {
  redditCommunities,
  subredditRules,
  insertSubredditRuleSchema,
  type RedditCommunity,
  insertRedditCommunitySchema,
  type InsertRedditCommunity
  type InsertRedditCommunity,
} from '@shared/schema';
import { eq, ilike, desc, or } from 'drizzle-orm';
import { z } from 'zod';
import {
  normalizeSubredditName,
  type RuleSpec,
  type RuleSpecBase,
} from './lib/policy-linter.js';
import {
  applyRuleOverrides,
  buildSpecFromBase,
  cloneRuleSpecBase,
  coerceRuleSpec,
  extractBaseFromSpec,
} from './lib/subreddit-rule-utils.js';

type CommunityWithRules = RedditCommunity & {
  policyRules?: RuleSpec | null;
  policyRulesUpdatedAt?: Date | null;
};

type UpdateCommunityResult = {
  community: RedditCommunity | null;
  policyRules: RuleSpec | null;
};

export async function listCommunities() {
  return db.select().from(redditCommunities).orderBy(desc(redditCommunities.members));
const manualFlagOverrideSchema = z.object({
  minKarma: z.number().int().nonnegative().optional(),
  minAccountAgeDays: z.number().int().nonnegative().optional(),
  verificationRequired: z.boolean().optional(),
  notes: z.array(z.string().min(1)).optional(),
});

const ruleOverrideSchema = z.object({
  bannedWords: z.array(z.string().min(1)).optional(),
  titleRegexes: z.array(z.string().min(1)).optional(),
  bodyRegexes: z.array(z.string().min(1)).optional(),
  flairRequired: z.boolean().optional(),
  linkPolicy: z.enum(['no-link', 'one-link', 'ok']).optional(),
  requiredTags: z.array(z.string().min(1)).optional(),
  maxTitleLength: z.number().int().positive().optional(),
  maxBodyLength: z.number().int().positive().optional(),
  manualFlags: manualFlagOverrideSchema.optional(),
  wikiNotes: z.array(z.string().min(1)).optional(),
});

const updateCommunitySchema = insertRedditCommunitySchema.partial().extend({
  ruleOverrides: ruleOverrideSchema.nullish(),
});

function formatCommunityRow(row: {
  community: RedditCommunity;
  rules: unknown;
  rulesUpdatedAt: Date | null;
}): CommunityWithRules {
  const policyRules = row.rules ? coerceRuleSpec(row.rules) : null;
  return {
    ...row.community,
    policyRules,
    policyRulesUpdatedAt: row.rulesUpdatedAt,
  };
}

export async function searchCommunities(query: string) {
async function loadRuleSpec(subreddit: string): Promise<RuleSpec | null> {
  const normalized = normalizeSubredditName(subreddit);
  const [row] = await db
    .select()
    .from(subredditRules)
    .where(eq(subredditRules.subreddit, normalized))
    .limit(1);
  return row ? coerceRuleSpec(row.rulesJson) : null;
}

async function upsertRuleOverrides(
  subreddit: string,
  overrides: z.infer<typeof ruleOverrideSchema> | null,
): Promise<RuleSpec | null> {
  const normalized = normalizeSubredditName(subreddit);
  const [existingRow] = await db
    .select()
    .from(subredditRules)
    .where(eq(subredditRules.subreddit, normalized))
    .limit(1);
  const existingSpec = existingRow ? coerceRuleSpec(existingRow.rulesJson) : null;
  const base: RuleSpecBase = existingSpec?.source?.automatedBase
    ? cloneRuleSpecBase(existingSpec.source.automatedBase)
    : existingSpec
      ? extractBaseFromSpec(existingSpec)
      : {};
  const source = existingSpec?.source;

  let nextSpec: RuleSpec;
  if (overrides === null) {
    nextSpec = buildSpecFromBase(base, source);
  } else {
    nextSpec = applyRuleOverrides(buildSpecFromBase(base, source), overrides);
    nextSpec.overrides = overrides;
  }

  const now = new Date();
  const payload = insertSubredditRuleSchema.parse({
    subreddit: normalized,
    rulesJson: nextSpec,
    updatedAt: now,
  });

  await db
    .insert(subredditRules)
    .values(payload)
    .onConflictDoUpdate({
      target: subredditRules.subreddit,
      set: {
        rulesJson: nextSpec,
        updatedAt: now,
      },
    });

  return nextSpec;
}

export async function listCommunities(): Promise<CommunityWithRules[]> {
  const rows = await db
    .select({
      community: redditCommunities,
      rules: subredditRules.rulesJson,
      rulesUpdatedAt: subredditRules.updatedAt,
    })
    .from(redditCommunities)
    .leftJoin(subredditRules, eq(subredditRules.subreddit, redditCommunities.name))
    .orderBy(desc(redditCommunities.members));

  return rows.map(formatCommunityRow);
}

export async function searchCommunities(query: string): Promise<CommunityWithRules[]> {
  const like = `%${query}%`;
  return db.select()
  const rows = await db
    .select({
      community: redditCommunities,
      rules: subredditRules.rulesJson,
      rulesUpdatedAt: subredditRules.updatedAt,
    })
    .from(redditCommunities)
    .leftJoin(subredditRules, eq(subredditRules.subreddit, redditCommunities.name))
    .where(
      or(
        ilike(redditCommunities.name, like),
        ilike(redditCommunities.displayName, like),
        ilike(redditCommunities.description, like)
      )
    );

  return rows.map(formatCommunityRow);
}

export async function createCommunity(data: unknown) {
  const value: InsertRedditCommunity = insertRedditCommunitySchema.parse(data) as InsertRedditCommunity;
  const [row] = await db.insert(redditCommunities).values(value).returning();
  return row;
}

export async function updateCommunity(id: string, data: unknown) {
  const value: Partial<InsertRedditCommunity> = insertRedditCommunitySchema
    .partial()
    .parse(data) as Partial<InsertRedditCommunity>;
  const [row] = await db.update(redditCommunities).set(value).where(eq(redditCommunities.id, id)).returning();
  return row;
export async function updateCommunity(id: string, data: unknown): Promise<UpdateCommunityResult> {
  const parsed = updateCommunitySchema.parse(data);
  const { ruleOverrides, ...communityData } = parsed;

  const communityUpdates = Object.fromEntries(
    Object.entries(communityData).filter(([, value]) => value !== undefined),
  ) as Partial<InsertRedditCommunity>;

  let updatedCommunity: RedditCommunity | null = null;
  if (Object.keys(communityUpdates).length > 0) {
    const [row] = await db
      .update(redditCommunities)
      .set(communityUpdates)
      .where(eq(redditCommunities.id, id))
      .returning();
    updatedCommunity = row ?? null;
  } else {
    const [row] = await db
      .select()
      .from(redditCommunities)
      .where(eq(redditCommunities.id, id))
      .limit(1);
    updatedCommunity = row ?? null;
  }

  let policyRules: RuleSpec | null = null;
  if (typeof ruleOverrides !== 'undefined') {
    policyRules = await upsertRuleOverrides(id, ruleOverrides ?? null);
  } else if (updatedCommunity) {
    policyRules = await loadRuleSpec(id);
  }

  return {
    community: updatedCommunity,
    policyRules,
  };
}

export async function deleteCommunity(id: string) {
  await db.delete(redditCommunities).where(eq(redditCommunities.id, id));
}

export async function getCommunityInsights(communityId: string): Promise<{
  bestTimes: string[];
  successTips: string[];
  warnings: string[];
}> {
  const [community] = await db
    .select()
    .from(redditCommunities)
    .where(eq(redditCommunities.id, communityId))
    .limit(1);
  if (!community) return { bestTimes: [], successTips: [], warnings: [] };

  const successTips: string[] = [];
  const warnings: string[] = [];

  if ((community.successProbability ?? 0) > 85) successTips.push('High success rate - great choice');
  if (community.growthTrend === 'up') successTips.push('Growing community - get in early');
  if (community.competitionLevel === 'low') successTips.push('Low competition - your content will stand out');

server/scripts/sync-subreddit-rules.ts
New
+567-0
import { db } from '../db.js';
import {
  insertSubredditRuleSchema,
  redditCommunities,
  subredditRules,
  type RedditCommunity,
} from '@shared/schema';
import {
  normalizeSubredditName,
  type ManualRuleFlags,
  type RuleSpec,
  type RuleSpecBase,
  type RuleSourceMetadata,
} from '../lib/policy-linter.js';
import {
  applyRuleOverrides,
  buildSpecFromBase,
  cloneRuleOverride,
  coerceRuleSpec,
  extractBaseFromSpec,
  mergeManualFlags,
} from '../lib/subreddit-rule-utils.js';

interface RedditAboutRule {
  short_name?: string;
  description?: string;
  violation_reason?: string;
}

interface RedditAboutRulesResponse {
  rules?: RedditAboutRule[];
}

interface RedditWikiRulesResponse {
  data?: {
    content_md?: string;
  };
}

interface CommunityRuleHints {
  requiredTags: string[];
  manualFlags?: ManualRuleFlags;
}

type LinkPolicy = 'no-link' | 'one-link' | 'ok';

const REDDIT_USER_AGENT =
  process.env.REDDIT_USER_AGENT || 'TPilotRuleSync/1.0 (community policy ingestor)';

async function fetchJson<T>(url: string): Promise<T | null> {
  try {
    const response = await fetch(url, {
      headers: { 'User-Agent': REDDIT_USER_AGENT },
    });
    if (!response.ok) {
      if (response.status !== 404) {
        console.warn(`⚠️  [rules] ${url} responded with ${response.status}`);
      }
      return null;
    }
    const data = (await response.json()) as T;
    return data;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.warn(`⚠️  [rules] Failed to fetch ${url}: ${message}`);
    return null;
  }
}

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function splitSegments(value: string): string[] {
  return value
    .split(/[,/]|\band\b|\bor\b|\+|\s+-\s+/i)
    .map((segment) => segment.trim())
    .filter((segment) => segment.length > 1);
}

function normalizeWord(value: string): string {
  return value
    .replace(/[.!?;:]/g, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();
}

function analyzeRuleTexts(texts: string[]): RuleSpecBase {
  const bannedWords = new Set<string>();
  const requiredTags = new Set<string>();
  const titleRegexes = new Set<string>();
  const bodyRegexes = new Set<string>();
  let flairRequired: boolean | undefined;
  let linkPolicy: LinkPolicy | undefined;
  let maxTitleLength: number | undefined;
  let maxBodyLength: number | undefined;
  const manualFlagsAccumulator: ManualRuleFlags = {};

  const domainsToFlag = ['bit.ly', 'tinyurl', 'shorturl', 'linktr.ee', 'onlyfans', 'fansly', 'cash.app', 'cashapp', 'venmo'];

  const tagRegex = /\[[a-z0-9]{1,6}\]/gi;

  const linkPolicyPriority: Record<LinkPolicy, number> = {
    'ok': 0,
    'one-link': 1,
    'no-link': 2,
  };

  function considerLinkPolicy(candidate: LinkPolicy): void {
    if (!linkPolicy || linkPolicyPriority[candidate] > linkPolicyPriority[linkPolicy]) {
      linkPolicy = candidate;
    }
  }

  function updateManualFlags(partial: ManualRuleFlags): void {
    const merged = mergeManualFlags(manualFlagsAccumulator, partial);
    if (merged) {
      if (typeof merged.minKarma === 'number') {
        manualFlagsAccumulator.minKarma = merged.minKarma;
      }
      if (typeof merged.minAccountAgeDays === 'number') {
        manualFlagsAccumulator.minAccountAgeDays = merged.minAccountAgeDays;
      }
      if (typeof merged.verificationRequired === 'boolean') {
        manualFlagsAccumulator.verificationRequired = merged.verificationRequired;
      }
      if (merged.notes && merged.notes.length > 0) {
        manualFlagsAccumulator.notes = [...merged.notes];
      }
    }
  }

  for (const text of texts) {
    if (!text) {
      continue;
    }
    const lower = text.toLowerCase();

    const tagMatches = text.match(tagRegex);
    if (tagMatches) {
      for (const match of tagMatches) {
        requiredTags.add(match.toUpperCase());
        titleRegexes.add(escapeRegExp(match));
      }
    }

    const bannedPatterns = [
      /no\s+([a-z0-9\s'\-\/,&()]+)/gi,
      /banned\s*:?\s*([a-z0-9\s'\-\/,&()]+)/gi,
      /prohibited\s*:?\s*([a-z0-9\s'\-\/,&()]+)/gi,
      /(?:do not|don't)\s+(?:post|include)\s+([a-z0-9\s'\-\/,&()]+)/gi,
    ];
    for (const pattern of bannedPatterns) {
      let match: RegExpExecArray | null;
      while ((match = pattern.exec(text))) {
        const segment = match[1];
        for (const candidate of splitSegments(segment)) {
          const normalized = normalizeWord(candidate);
          if (normalized && normalized.length > 1) {
            bannedWords.add(normalized);
          }
        }
      }
    }

    for (const domain of domainsToFlag) {
      if (lower.includes(domain)) {
        bodyRegexes.add(escapeRegExp(domain));
      }
    }

    if (/(require|must).{0,20}flair/.test(lower)) {
      flairRequired = true;
    }

    if (/(no\s+links|links?\s+are\s+not\s+allowed|no\s+external\s+links)/.test(lower)) {
      considerLinkPolicy('no-link');
    } else if (/(only\s+one\s+link|single\s+link|1\s+link\s+allowed)/.test(lower)) {
      considerLinkPolicy('one-link');
    } else if (/(links\s+allowed|link\s+posts\s+allowed|links\s+ok)/.test(lower)) {
      considerLinkPolicy('ok');
    }

    const titleLengthMatch = text.match(/title[^\d]{0,40}(\d{2,4})\s*(?:characters|chars)/i);
    if (titleLengthMatch) {
      const lengthValue = Number(titleLengthMatch[1]);
      if (!Number.isNaN(lengthValue) && lengthValue > 0) {
        maxTitleLength = maxTitleLength ? Math.min(maxTitleLength, lengthValue) : lengthValue;
      }
    }

    const bodyLengthMatch = text.match(/(?:self\s?text|body|post)[^\d]{0,40}(\d{2,5})\s*(?:characters|chars)/i);
    if (bodyLengthMatch) {
      const lengthValue = Number(bodyLengthMatch[1]);
      if (!Number.isNaN(lengthValue) && lengthValue > 0) {
        maxBodyLength = maxBodyLength ? Math.min(maxBodyLength, lengthValue) : lengthValue;
      }
    }

    const karmaMatch = text.match(/(\d{2,5})\s*(?:combined\s*)?(?:link|post|comment)?\s*karma/i);
    if (karmaMatch) {
      const karmaValue = Number(karmaMatch[1]);
      if (!Number.isNaN(karmaValue)) {
        updateManualFlags({ minKarma: karmaValue });
      }
    }

    const ageMatch = text.match(/account[^\d]{0,20}(\d{1,3})\s*(day|week|month|year)s?/i);
    if (ageMatch) {
      const amount = Number(ageMatch[1]);
      if (!Number.isNaN(amount)) {
        const unit = ageMatch[2].toLowerCase();
        const multiplier = unit === 'year' ? 365 : unit === 'month' ? 30 : unit === 'week' ? 7 : 1;
        updateManualFlags({ minAccountAgeDays: amount * multiplier });
      }
    }

    if (/(verification|verified)/i.test(lower) && /(required|must)/i.test(lower)) {
      updateManualFlags({ verificationRequired: true });
    }
  }

  const base: RuleSpecBase = {};
  if (bannedWords.size > 0) {
    base.bannedWords = Array.from(bannedWords);
  }
  if (titleRegexes.size > 0) {
    base.titleRegexes = Array.from(titleRegexes);
  }
  if (bodyRegexes.size > 0) {
    base.bodyRegexes = Array.from(bodyRegexes);
  }
  if (typeof flairRequired === 'boolean') {
    base.flairRequired = flairRequired;
  }
  if (linkPolicy) {
    base.linkPolicy = linkPolicy;
  }
  if (requiredTags.size > 0) {
    base.requiredTags = Array.from(requiredTags);
  }
  if (typeof maxTitleLength === 'number') {
    base.maxTitleLength = maxTitleLength;
  }
  if (typeof maxBodyLength === 'number') {
    base.maxBodyLength = maxBodyLength;
  }
  const manualFlags = mergeManualFlags(undefined, manualFlagsAccumulator);
  if (manualFlags) {
    base.manualFlags = manualFlags;
  }
  return base;
}

function parseWikiNotes(wiki: RedditWikiRulesResponse | null): string[] {
  if (!wiki?.data?.content_md) {
    return [];
  }
  return wiki.data.content_md
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => line.replace(/^([*\-]|\d+\.)\s*/, ''))
    .filter((line) => line.length > 0);
}

function gatherAboutRuleTexts(about: RedditAboutRulesResponse | null): string[] {
  if (!about?.rules) {
    return [];
  }
  const items: string[] = [];
  for (const rule of about.rules) {
    const fragments: string[] = [];
    if (rule.short_name) {
      fragments.push(rule.short_name);
    }
    if (rule.description) {
      fragments.push(rule.description);
    }
    if (rule.violation_reason) {
      fragments.push(rule.violation_reason);
    }
    if (fragments.length > 0) {
      items.push(fragments.join(' - '));
    }
  }
  return items;
}

function gatherCommunityRuleTexts(rulesField: unknown): string[] {
  if (!rulesField) {
    return [];
  }
  if (Array.isArray(rulesField)) {
    return rulesField.filter((item): item is string => typeof item === 'string');
  }
  if (typeof rulesField === 'object') {
    const record = rulesField as Record<string, unknown>;
    const segments: string[] = [];
    const possibleKeys = ['titleRules', 'contentRules', 'notes'];
    for (const key of possibleKeys) {
      const value = record[key];
      if (Array.isArray(value)) {
        segments.push(...value.filter((item): item is string => typeof item === 'string'));
      }
    }
    return segments;
  }
  return [];
}

function extractCommunityHints(community: RedditCommunity): CommunityRuleHints {
  const hints: CommunityRuleHints = { requiredTags: [] };
  const manualFlags: ManualRuleFlags = {};

  if (community.verificationRequired) {
    manualFlags.verificationRequired = true;
  }

  const rulesField = community.rules;
  if (rulesField && typeof rulesField === 'object' && !Array.isArray(rulesField)) {
    const record = rulesField as Record<string, unknown>;
    const requiredTags = record.requiredTags;
    if (Array.isArray(requiredTags)) {
      for (const tag of requiredTags) {
        if (typeof tag === 'string') {
          hints.requiredTags.push(tag.trim());
        }
      }
    }
    const minKarma = record.minKarma;
    if (typeof minKarma === 'number') {
      manualFlags.minKarma = minKarma;
    }
    const minAccountAgeDays = record.minAccountAgeDays ?? record.minAccountAge;
    if (typeof minAccountAgeDays === 'number') {
      manualFlags.minAccountAgeDays = minAccountAgeDays;
    }
    const verificationRequired = record.verificationRequired;
    if (typeof verificationRequired === 'boolean') {
      manualFlags.verificationRequired = verificationRequired;
    }
    const notes = record.notes;
    if (Array.isArray(notes)) {
      const parsedNotes = notes.filter((item): item is string => typeof item === 'string');
      if (parsedNotes.length > 0) {
        manualFlags.notes = parsedNotes;
      }
    }
  }

  if (Object.keys(manualFlags).length > 0) {
    hints.manualFlags = manualFlags;
  }

  return hints;
}

function combineManualFlags(...flags: Array<ManualRuleFlags | undefined>): ManualRuleFlags | undefined {
  let combined: ManualRuleFlags | undefined;
  for (const flag of flags) {
    combined = mergeManualFlags(combined, flag);
  }
  return combined;
}

function buildBaseSpec(
  community: RedditCommunity,
  about: RedditAboutRulesResponse | null,
  wiki: RedditWikiRulesResponse | null,
  existingBase: RuleSpecBase | undefined,
): RuleSpecBase {
  const texts: string[] = [];
  texts.push(...gatherAboutRuleTexts(about));
  texts.push(...gatherCommunityRuleTexts(community.rules));

  const wikiNotesFromWiki = parseWikiNotes(wiki);
  if (wikiNotesFromWiki.length > 0) {
    texts.push(...wikiNotesFromWiki);
  }

  const parsedFromTexts = analyzeRuleTexts(texts);
  const hints = extractCommunityHints(community);

  const bannedWords = new Set<string>(parsedFromTexts.bannedWords ?? []);
  const titleRegexes = new Set<string>(parsedFromTexts.titleRegexes ?? []);
  const bodyRegexes = new Set<string>(parsedFromTexts.bodyRegexes ?? []);
  const requiredTags = new Set<string>(parsedFromTexts.requiredTags ?? []);
  const wikiNotes = new Set<string>(wikiNotesFromWiki);

  if (existingBase?.bannedWords) {
    for (const word of existingBase.bannedWords) {
      bannedWords.add(word);
    }
  }
  if (existingBase?.titleRegexes) {
    for (const regex of existingBase.titleRegexes) {
      titleRegexes.add(regex);
    }
  }
  if (existingBase?.bodyRegexes) {
    for (const regex of existingBase.bodyRegexes) {
      bodyRegexes.add(regex);
    }
  }
  if (existingBase?.requiredTags) {
    for (const tag of existingBase.requiredTags) {
      requiredTags.add(tag);
    }
  }
  if (existingBase?.wikiNotes) {
    for (const note of existingBase.wikiNotes) {
      wikiNotes.add(note);
    }
  }
  if (hints.requiredTags.length > 0) {
    for (const tag of hints.requiredTags) {
      requiredTags.add(tag.toUpperCase());
    }
  }

  const combinedManualFlags = combineManualFlags(
    existingBase?.manualFlags,
    parsedFromTexts.manualFlags,
    hints.manualFlags,
  );

  const base: RuleSpecBase = {};
  if (bannedWords.size > 0) {
    base.bannedWords = Array.from(bannedWords);
  }
  if (titleRegexes.size > 0) {
    base.titleRegexes = Array.from(titleRegexes);
  }
  if (bodyRegexes.size > 0) {
    base.bodyRegexes = Array.from(bodyRegexes);
  }
  if (parsedFromTexts.flairRequired ?? existingBase?.flairRequired) {
    base.flairRequired = parsedFromTexts.flairRequired ?? existingBase?.flairRequired;
  }
  const linkPolicy = parsedFromTexts.linkPolicy ?? existingBase?.linkPolicy;
  if (linkPolicy) {
    base.linkPolicy = linkPolicy;
  }
  if (requiredTags.size > 0) {
    base.requiredTags = Array.from(requiredTags);
  }
  base.maxTitleLength = parsedFromTexts.maxTitleLength ?? existingBase?.maxTitleLength;
  base.maxBodyLength = parsedFromTexts.maxBodyLength ?? existingBase?.maxBodyLength;
  if (combinedManualFlags) {
    base.manualFlags = combinedManualFlags;
  }
  if (wikiNotes.size > 0) {
    base.wikiNotes = Array.from(wikiNotes);
  }
  return base;
}

async function persistRuleSpec(subreddit: string, spec: RuleSpec): Promise<void> {
  const now = new Date();
  const payload = insertSubredditRuleSchema.parse({
    subreddit,
    rulesJson: spec,
    updatedAt: now,
  });
  await db
    .insert(subredditRules)
    .values(payload)
    .onConflictDoUpdate({
      target: subredditRules.subreddit,
      set: {
        rulesJson: spec,
        updatedAt: now,
      },
    });
}

function buildSourceMetadata(
  existing: RuleSourceMetadata | undefined,
  aboutUrl: string | null,
  wikiUrl: string | null,
  fetchedAtIso: string,
): RuleSourceMetadata {
  const source: RuleSourceMetadata = { ...(existing || {}) };
  if (aboutUrl) {
    source.aboutRulesUrl = aboutUrl;
  }
  if (wikiUrl) {
    source.wikiRulesUrl = wikiUrl;
  }
  source.fetchedAt = fetchedAtIso;
  return source;
}

function buildRuleSpecForCommunity(
  community: RedditCommunity,
  about: RedditAboutRulesResponse | null,
  aboutUrl: string | null,
  wiki: RedditWikiRulesResponse | null,
  wikiUrl: string | null,
  existingSpec: RuleSpec | null,
): RuleSpec {
  const existingBase = existingSpec?.source?.automatedBase || (existingSpec ? extractBaseFromSpec(existingSpec) : undefined);
  const baseSpec = buildBaseSpec(community, about, wiki, existingBase);
  const fetchedAtIso = new Date().toISOString();
  const source = buildSourceMetadata(existingSpec?.source, aboutUrl, wikiUrl, fetchedAtIso);
  const specWithSource = buildSpecFromBase(baseSpec, source);
  const overrides = existingSpec?.overrides ? cloneRuleOverride(existingSpec.overrides) : undefined;
  const mergedSpec = applyRuleOverrides(specWithSource, overrides);
  if (overrides) {
    mergedSpec.overrides = overrides;
  }
  return mergedSpec;
}

export async function syncSubredditRules(): Promise<void> {
  console.log('🔄 Syncing subreddit rules from Reddit...');
  const communities = await db.select().from(redditCommunities);
  const existing = await db.select().from(subredditRules);
  const existingSpecs = new Map<string, RuleSpec>();
  for (const row of existing) {
    const spec = coerceRuleSpec(row.rulesJson);
    if (spec) {
      existingSpecs.set(row.subreddit, spec);
    }
  }

  let successCount = 0;
  for (const community of communities) {
    const subredditKey = normalizeSubredditName(community.name || community.id);
    const aboutUrl = `https://www.reddit.com/r/${subredditKey}/about/rules.json`;
    const wikiUrl = `https://www.reddit.com/r/${subredditKey}/wiki/rules.json?raw_json=1`;
    const about = await fetchJson<RedditAboutRulesResponse>(aboutUrl);
    const wiki = await fetchJson<RedditWikiRulesResponse>(wikiUrl);
    const existingSpec = existingSpecs.get(subredditKey) ?? null;

    const spec = buildRuleSpecForCommunity(
      community,
      about,
      about ? aboutUrl : null,
      wiki,
      wiki ? wikiUrl : null,
      existingSpec,
    );

    await persistRuleSpec(subredditKey, spec);
    successCount += 1;
    console.log(`✅ Updated rules for r/${subredditKey}`);

    // Be polite to Reddit if hitting many subreddits
    await new Promise((resolve) => setTimeout(resolve, 300));
  }

  console.log(`✅ Completed subreddit rule sync for ${successCount} communities.`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  syncSubredditRules()
    .then(() => {
      process.exit(0);
    })
    .catch((error) => {
      console.error('❌ Failed to sync subreddit rules', error);
      process.exit(1);
    });
}
server/seed-policy-data.ts
+3-71
import { db } from "./db.js";
import { subredditRules, featureFlags } from "@shared/schema";
import type { RuleSpec } from "./lib/policy-linter.js";
import { featureFlags } from "@shared/schema";
import { syncSubredditRules } from "./scripts/sync-subreddit-rules.js";

export async function seedPolicyData() {
  console.log("🌱 Seeding policy data...");

  try {
    const policyData: Array<{
      subreddit: string;
      rules: RuleSpec;
    }> = [
      {
        subreddit: "gonewild",
        rules: {
          bannedWords: ["underage", "minor", "young", "teen", "school", "illegal", "drugs", "violence"],
          titleRegexes: ["^(CLICK|FREE|URGENT)", "!!!+"],
          requiredTags: ["[F]", "[M]", "[MF]", "[FM]"],
          linkPolicy: "one-link",
          maxTitleLength: 300,
          maxBodyLength: 1000,
          flairRequired: false
        }
      },
      {
        subreddit: "realgirls",
        rules: {
          bannedWords: ["underage", "minor", "young", "teen", "school", "selling", "buy", "onlyfans"],
          titleRegexes: ["\\$\\$\\$", "bit\\.ly|tinyurl"],
          linkPolicy: "no-link", // Strict no promotional links
          maxTitleLength: 200,
          maxBodyLength: 500,
          flairRequired: true
        }
      },
      {
        subreddit: "selfie",
        rules: {
          bannedWords: ["underage", "minor", "young", "teen", "school"],
          titleRegexes: ["^[A-Z\\s!?]{20,}"], // No all-caps spam
          linkPolicy: "one-link",
          maxTitleLength: 150,
          maxBodyLength: 800,
          flairRequired: false
        }
      },
      {
        subreddit: "amihot",
        rules: {
          bannedWords: ["underage", "minor", "young", "teen", "school"],
          requiredTags: ["[F]", "[M]", "[NB]"],
          linkPolicy: "no-link",
          maxTitleLength: 100,
          maxBodyLength: 300,
          flairRequired: false
        }
      }
    ];

    // Insert subreddit rules
    for (const { subreddit, rules } of policyData) {
      await db
        .insert(subredditRules)
        .values({
          subreddit,
          rulesJson: rules as any
        })
        .onConflictDoUpdate({
          target: subredditRules.subreddit,
          set: {
            rulesJson: rules as any,
            updatedAt: new Date()
          }
        });
      
      console.log(`✅ Added rules for r/${subreddit}`);
    }
    await syncSubredditRules();

    // Insert policy feature flags
    await db
      .insert(featureFlags)
      .values({
        key: "policy.blockOnWarn",
        enabled: false, // Default: warnings don't block posting
        meta: {
          description: "Block posting when content has policy warnings",
          category: "policy"
        }
      })
      .onConflictDoUpdate({
        target: featureFlags.key,
        set: {
          enabled: false,
          meta: {
            description: "Block posting when content has policy warnings",
            category: "policy"
          },
          updatedAt: new Date()
        }
      });

    console.log("✅ Added policy feature flags");
