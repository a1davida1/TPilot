diff --git a/tests/routes/caption-generation.test.ts b/tests/routes/caption-generation.test.ts
index dfae92a834f50ff443e92a3e1ce4e9a612c09968..a7390c8a799ee319930adafc9eb9523a8e2b5931 100644
--- a/tests/routes/caption-generation.test.ts
+++ b/tests/routes/caption-generation.test.ts
@@ -1,112 +1,139 @@
 import { describe, it, expect, beforeEach, vi } from 'vitest';
 import { pipeline } from '../../server/caption/geminiPipeline.js';
 import { pipelineRewrite } from '../../server/caption/rewritePipeline.js';
 import { pipelineTextOnly } from '../../server/caption/textOnlyPipeline.js';
 
 // Mock dependencies
 vi.mock('../../server/lib/gemini.js', () => ({
   textModel: {
     generateContent: vi.fn(),
   },
   visionModel: {
     generateContent: vi.fn(),
   },
 }));
 
+vi.mock('../../server/caption/openaiFallback.js', () => ({
+  openAICaptionFallback: vi.fn().mockResolvedValue({
+    caption: 'Fallback caption',
+    hashtags: ['#fallback1', '#fallback2', '#fallback3'],
+    safety_level: 'normal',
+    alt: 'Fallback alt text that is sufficiently long',
+    mood: 'neutral',
+    style: 'informative',
+    cta: 'Check this out',
+    nsfw: false,
+  }),
+}));
+
 vi.mock('../../server/storage.js', () => ({
   storage: {
     getUserById: vi.fn(),
     createContentGeneration: vi.fn(),
     updateContentGeneration: vi.fn(),
   },
 }));
 
 describe('Caption Generation', () => {
   beforeEach(() => {
     vi.clearAllMocks();
   });
 
   describe('Gemini Pipeline', () => {
     it('should handle image-based caption generation', async () => {
-      const mockImageUrl = 'data:image/jpeg;base64,abc123';
+      const mockImageUrl =
+        'data:image/jpeg;base64,' +
+        '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAP///////////////wAALCAABAAEBAREA/8QAFAABAAAAAAAAAAAAAAAAAAAACP/EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAD8Af//Z';
       const mockPlatform = 'instagram';
       const mockVoice = 'flirty_playful';
 
       // Mock successful responses
       const mockFactsResponse = {
         response: {
           text: () => JSON.stringify({
             objects: ['woman', 'lingerie'],
             setting: 'bedroom',
             mood: 'seductive',
           }),
         },
       };
 
       const mockVariantsResponse = {
         response: {
-          text: () => JSON.stringify([
-            {
-              caption: 'Feeling gorgeous tonight ✨',
-              hashtags: ['#lingerie', '#confidence'],
-              safety_level: 'spicy_safe',
-              mood: 'confident',
-              style: 'authentic',
-              cta: 'What do you think?',
-            },
-          ]),
+          text: () =>
+            JSON.stringify([
+              {
+                caption: 'Feeling gorgeous tonight ✨',
+                hashtags: ['#lingerie', '#confidence', '#style'],
+                safety_level: 'spicy_safe',
+                mood: 'confident',
+                style: 'authentic',
+                cta: 'What do you think?',
+                alt: 'A glamorous example alt text to satisfy schema',
+                nsfw: false,
+              },
+            ]),
         },
       };
 
       const mockRankResponse = {
         response: {
-          text: () => JSON.stringify({
-            final: {
-              caption: 'Feeling gorgeous tonight ✨',
-              hashtags: ['#lingerie', '#confidence'],
-              safety_level: 'spicy_safe',
-              mood: 'confident',
-              style: 'authentic',
-              cta: 'What do you think?',
-            },
-          }),
+          text: () =>
+            JSON.stringify({
+              winner_index: 0,
+              scores: [5, 4, 3, 2, 1],
+              reason: 'Selected based on engagement potential',
+              final: {
+                caption: 'Feeling gorgeous tonight ✨',
+                hashtags: ['#lingerie', '#confidence', '#style'],
+                safety_level: 'spicy_safe',
+                mood: 'confident',
+                style: 'authentic',
+                cta: 'What do you think?',
+                alt: 'A glamorous example alt text to satisfy schema',
+                nsfw: false,
+              },
+            }),
         },
       };
 
       const { textModel, visionModel } = await import('../../server/lib/gemini.js');
       visionModel.generateContent.mockResolvedValueOnce(mockFactsResponse);
       textModel.generateContent
         .mockResolvedValueOnce(mockVariantsResponse)
         .mockResolvedValueOnce(mockRankResponse);
 
       const result = await pipeline({
         imageUrl: mockImageUrl,
         platform: mockPlatform,
         voice: mockVoice,
       });
 
+      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');
+
+      expect(openAICaptionFallback).not.toHaveBeenCalled();
       expect(result.final).toMatchObject({
         caption: expect.any(String),
         safety_level: expect.stringMatching(/safe|low|spicy_safe/),
       });
     });
 
     it('should handle safety level normalization', async () => {
       const mockResponse = {
         response: {
           text: () => JSON.stringify([
             {
               caption: 'Test caption',
               hashtags: ['#test'],
               safety_level: 'suggestive', // Should be normalized to spicy_safe
               mood: 'confident',
               style: 'authentic',
               cta: 'Check it out',
             },
           ]),
         },
       };
 
       const { textModel } = await import('../../server/lib/gemini.js');
       textModel.generateContent.mockResolvedValue(mockResponse);
 
