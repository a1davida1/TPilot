Update expense routes for business purpose
Sep 22 · a1davida1/TPilot · main
+87-18
1. Update `server/expense-routes.ts` in the `PUT /api/expenses/:id` handler so that when `shouldApplyDefaultBusinessPurpose` is true and no new `categoryId` is provided, it loads the existing expense via `storage.getExpense(expenseId, req.user.id)` and applies that category’s `defaultBusinessPurpose` before calling `updateExpense`.
2. Adjust `DatabaseStorage.updateExpense` in `server/storage.ts` to fetch the current expense whenever `businessPurpose` is empty/whitespace (and not explicitly `null`), ensuring it applies the category’s default even if `categoryId` is unchanged.
3. Add or extend a unit test (for example in `tests/unit/expenses`) to cover clearing a business purpose and expecting the category default to be persisted.

Summary

    When an expense update clears the business purpose without changing categories, the route now loads the existing expense to reapply that category’s default rationale before persisting.

DatabaseStorage.updateExpense now strips empty business-purpose payloads, reuses the existing expense when needed, and reapplies the category default even when the category id remains unchanged.

The expense route tests stub the additional storage lookups and verify that clearing a business purpose results in the category default being written back.

Testing

    ❌ npm run lint *(fails because of pre-existing lint errors in client/src/utils/error-handler.ts and client/src/utils/errorHelpers.ts)*

❌ npm test *(fails: suites require external AI services, image processing, and database/environment configuration that are unavailable in this container)*


server/expense-routes.ts
+15-0
@@ -290,77 +290,92 @@ export function registerExpenseRoutes(app: Express) {
      }

      if (requestBody.expenseDate !== undefined) {
        const expenseDate = new Date(String(requestBody.expenseDate));
        if (Number.isNaN(expenseDate.getTime())) {
          return res.status(400).json({ message: 'Invalid expense date' });
        }
        updates.expenseDate = expenseDate;
      }

      if (requestBody.taxYear !== undefined) {
        const parsedTaxYear = Number.parseInt(String(requestBody.taxYear), 10);
        if (Number.isNaN(parsedTaxYear)) {
          return res.status(400).json({ message: 'Invalid tax year' });
        }
        updates.taxYear = parsedTaxYear;
      }

      const rawBusinessPurpose = requestBody.businessPurpose;
      const trimmedBusinessPurpose =
        typeof rawBusinessPurpose === 'string' ? rawBusinessPurpose.trim() : undefined;
      const shouldApplyDefaultBusinessPurpose =
        (rawBusinessPurpose === undefined ||
          (typeof rawBusinessPurpose === 'string' && (trimmedBusinessPurpose?.length ?? 0) === 0)) &&
        rawBusinessPurpose !== null;
      const shouldApplyDefaultFromExistingCategory =
        shouldApplyDefaultBusinessPurpose &&
        requestBody.categoryId === undefined &&
        rawBusinessPurpose !== undefined;

      if (rawBusinessPurpose === null) {
        updates.businessPurpose = null;
      } else if (typeof trimmedBusinessPurpose === 'string' && trimmedBusinessPurpose.length > 0) {
        updates.businessPurpose = trimmedBusinessPurpose;
      }

      if (requestBody.categoryId !== undefined) {
        const parsedCategoryId = Number.parseInt(String(requestBody.categoryId), 10);
        if (!Number.isInteger(parsedCategoryId)) {
          return res.status(400).json({ message: 'Invalid expense category' });
        }

        const category = await storage.getExpenseCategory(parsedCategoryId);
        if (!category) {
          return res.status(400).json({ message: 'Invalid expense category' });
        }

        const categoryDefaults: ExpenseCategoryWithDefaults = category;
        updates.categoryId = parsedCategoryId;
        updates.deductionPercentage = category.deductionPercentage;

        if (shouldApplyDefaultBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
          updates.businessPurpose = categoryDefaults.defaultBusinessPurpose;
        }
      }

      if (shouldApplyDefaultFromExistingCategory) {
        const existingExpense = await storage.getExpense(expenseId, req.user.id);
        const existingCategoryId = existingExpense?.categoryId;
        if (existingCategoryId !== undefined) {
          const existingCategory = await storage.getExpenseCategory(existingCategoryId);
          if (existingCategory?.defaultBusinessPurpose) {
            updates.businessPurpose = existingCategory.defaultBusinessPurpose;
          }
        }
      }

      const expense = await storage.updateExpense(expenseId, req.user.id, updates);
      res.json(expense);
    } catch (error) {
      console.error('Error updating expense:', error);
      res.status(500).json({ message: 'Failed to update expense' });
    }
  });

  // Delete expense
  app.delete('/api/expenses/:id', authenticateToken, async (req: AuthRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: 'Authentication required' });
      }

      const expenseId = parseInt(req.params.id);
      await storage.deleteExpense(expenseId, req.user.id);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting expense:', error);
      res.status(500).json({ message: 'Failed to delete expense' });
    }
  });

  // Get expense totals and analytics
server/storage.ts
+32-18
@@ -818,78 +818,92 @@ export class DatabaseStorage implements IStorage {
      const results = await query.orderBy(desc(expenses.expenseDate));
      return results.map(r => ({
        ...r.expense,
        category: r.category
      })) as (Expense & { category: ExpenseCategory | null })[];
    } catch (error) {
      console.error('Error getting user expenses:', { error: (error as Error).message });
      return [];
    }
  }

  async getExpense(id: number, userId: number): Promise<Expense | undefined> {
    try {
      const [result] = await db.select().from(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
      return result;
    } catch (error) {
      console.error('Error getting expense:', { error: (error as Error).message });
      return undefined;
    }
  }

  async updateExpense(id: number, userId: number, updates: Partial<Expense>): Promise<Expense> {
    try {
      let updatesToApply: Partial<Expense> = { ...updates };
      const businessPurposeValue = updates.businessPurpose;
      const hasEmptyBusinessPurpose =
        typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0;

      if (hasEmptyBusinessPurpose) {
        delete updatesToApply.businessPurpose;
      }

      const needsExistingExpenseLookup = updates.categoryId !== undefined || hasEmptyBusinessPurpose;
      let existingExpense: Expense | undefined;
      if (needsExistingExpenseLookup) {
        existingExpense = await this.getExpense(id, userId);
      }

      if (updates.categoryId !== undefined) {
        const existingExpense = await this.getExpense(id, userId);
        const categoryChanged = existingExpense ? existingExpense.categoryId !== updates.categoryId : true;
        const category = await this.getExpenseCategory(updates.categoryId);
        if (category) {
          const categoryDefaults: ExpenseCategoryWithDefaults = category;
          const categoryChanged = existingExpense ? existingExpense.categoryId !== updates.categoryId : true;

        if (categoryChanged) {
          const category = await this.getExpenseCategory(updates.categoryId);
          if (category) {
            const categoryDefaults: ExpenseCategoryWithDefaults = category;
          if (categoryChanged) {
            updatesToApply = {
              ...updatesToApply,
              deductionPercentage: category.deductionPercentage,
            };
          }

            const businessPurposeValue = updates.businessPurpose;
            const shouldApplyDefaultBusinessPurpose =
              (businessPurposeValue === undefined ||
                (typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0)) &&
              businessPurposeValue !== null;

            if (shouldApplyDefaultBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
              updatesToApply = {
                ...updatesToApply,
                businessPurpose: categoryDefaults.defaultBusinessPurpose,
              };
            }
          if (hasEmptyBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
            updatesToApply = {
              ...updatesToApply,
              businessPurpose: categoryDefaults.defaultBusinessPurpose,
            };
          }
        }
      } else if (hasEmptyBusinessPurpose && existingExpense?.categoryId !== undefined) {
        const category = await this.getExpenseCategory(existingExpense.categoryId);
        if (category?.defaultBusinessPurpose) {
          updatesToApply = {
            ...updatesToApply,
            businessPurpose: category.defaultBusinessPurpose,
          };
        }
      }

      const [result] = await db.update(expenses)
        .set({ ...updatesToApply, updatedAt: new Date() })
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
        .returning();
      return result;
    } catch (error) {
      console.error('Error updating expense:', { error: (error as Error).message });
      throw error;
    }
  }

  async deleteExpense(id: number, userId: number): Promise<void> {
    try {
      await db.delete(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
    } catch (error) {
      console.error('Error deleting expense:', { error: (error as Error).message });
      throw error;
    }
  }

  async getExpensesByCategory(userId: number, categoryId: number, taxYear?: number): Promise<Expense[]> {
    try {
tests/unit/expenses/receipt-upload.test.ts
+40-0
/* eslint-env node, jest */
import { describe, test, expect, vi, beforeEach, type MockInstance } from 'vitest';
import request from 'supertest';
import express from 'express';
import fs from 'fs/promises';

// Mock dependencies
const mockStorage = vi.hoisted(() => ({
  updateExpense: vi.fn(),
  getExpense: vi.fn(),
  getExpenseCategory: vi.fn(),
}));

const mockMediaManager = vi.hoisted(() => ({
  uploadFile: vi.fn(),
}));

const mockAuthenticateToken = vi.hoisted(() => vi.fn());

vi.mock('../../../server/storage.ts', () => ({ storage: mockStorage }));
vi.mock('../../../server/lib/media.js', () => ({ MediaManager: mockMediaManager }));
vi.mock('../../../server/middleware/auth.js', () => ({ authenticateToken: mockAuthenticateToken }));
vi.mock('fs/promises', () => ({
  default: {
    mkdir: vi.fn(),
    writeFile: vi.fn(),
  },
  mkdir: vi.fn(),
  writeFile: vi.fn(),
}))

// Import after mocking
import { registerExpenseRoutes } from '../../../server/expense-routes';

describe('Receipt Upload with ImageShield Protection', () => {
  let app: express.Express;
@@ -308,50 +310,88 @@ describe('Receipt Upload with ImageShield Protection', () => {
    test('should use local storage when S3 not configured', async () => {
      delete process.env.S3_BUCKET_MEDIA;

      mockStorage.updateExpense.mockResolvedValue({
        id: 1,
        receiptUrl: '/uploads/receipts/protected_test.jpg',
        receiptFileName: 'protected_test.jpg',
      });

      // Create a valid 1x1 PNG image buffer
      const testImageBuffer = Buffer.from(
        '89504e470d0a1a0a0000000d494844520000000100000001080600000001f15c48950000000d49444154789c626001000000050001180dd4010000000049454e44ae426082',
        'hex'
      );

      await request(app)
        .post('/api/expenses/1/receipt')
        .attach('receipt', testImageBuffer, 'test-receipt.jpg')
        .expect(200);

      expect(fs.mkdir).toHaveBeenCalled();
      expect(fs.writeFile).toHaveBeenCalled();
    });
  });

  describe('Business Purpose Updates', () => {
    test('should restore default business purpose when cleared without category change', async () => {
      const existingExpense = {
        id: 42,
        userId: 1,
        categoryId: 7,
      };
      const categoryWithDefault = {
        id: 7,
        name: 'Travel',
        deductionPercentage: 50,
        defaultBusinessPurpose: 'Client travel meeting',
      };
      const updatedExpense = {
        ...existingExpense,
        businessPurpose: categoryWithDefault.defaultBusinessPurpose,
      };

      mockStorage.getExpense.mockResolvedValueOnce(existingExpense);
      mockStorage.getExpenseCategory.mockResolvedValueOnce(categoryWithDefault);
      mockStorage.updateExpense.mockResolvedValueOnce(updatedExpense);

      const response = await request(app)
        .put('/api/expenses/42')
        .send({ businessPurpose: '   ' })
        .expect(200);

      expect(response.body).toEqual(updatedExpense);
      expect(mockStorage.getExpense).toHaveBeenCalledWith(42, 1);
      expect(mockStorage.getExpenseCategory).toHaveBeenCalledWith(existingExpense.categoryId);
      expect(mockStorage.updateExpense).toHaveBeenCalledWith(
        42,
        1,
        expect.objectContaining({ businessPurpose: categoryWithDefault.defaultBusinessPurpose })
      );
    });
  });

  describe('Error Handling', () => {
    test('should handle storage errors gracefully', async () => {
      mockStorage.updateExpense.mockRejectedValue(new Error('Database error'));

      // Create a valid 1x1 PNG image buffer
      const testImageBuffer = Buffer.from(
        '89504e470d0a1a0a0000000d494844520000000100000001080600000001f15c48950000000d49444154789c626001000000050001180dd4010000000049454e44ae426082',
        'hex'
      );

      await request(app)
        .post('/api/expenses/1/receipt')
        .attach('receipt', testImageBuffer, 'test-receipt.jpg')
        .expect(500);
    });

    test('should handle ImageShield protection errors', async () => {
      // Even if protection fails, upload should continue with original buffer
      const mockExpense = {
        id: 1,
        receiptUrl: '/uploads/receipts/protected_test.jpg',
        receiptFileName: 'protected_test.jpg',
      };

      mockStorage.updateExpense.mockResolvedValue(mockExpense);
