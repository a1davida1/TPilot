server/storage.ts
+7-4
@@ -800,54 +800,57 @@ export class DatabaseStorage implements IStorage {
      return result;
    } catch (error) {
      console.error('Error creating expense:', { error: (error as Error).message });
      throw error;
    }
  }

  async getUserExpenses(
    userId: number,
    taxYear?: number
  ): Promise<Array<Expense & { category: ExpenseCategory | null }>> {
    try {
      const query = db.select({
        expense: expenses,
        category: expenseCategories
      })
      .from(expenses)
      .leftJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id))
      .where(
        taxYear 
          ? and(eq(expenses.userId, userId), eq(expenses.taxYear, taxYear))
          : eq(expenses.userId, userId)
      );

      const results = await query.orderBy(desc(expenses.expenseDate));
      return results.map(r => ({
        ...r.expense,
        category: r.category
      })) as (Expense & { category: ExpenseCategory | null })[];
      const flattenedResults: Array<Expense & { category: ExpenseCategory | null }> =
        results.map(({ expense, category }) => ({
          ...expense,
          category,
        }));

      return flattenedResults;
    } catch (error) {
      console.error('Error getting user expenses:', { error: (error as Error).message });
      return [];
    }
  }

  async getExpense(id: number, userId: number): Promise<Expense | undefined> {
    try {
      const [result] = await db.select().from(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
      return result;
    } catch (error) {
      console.error('Error getting expense:', { error: (error as Error).message });
      return undefined;
    }
  }

  async updateExpense(id: number, userId: number, updates: Partial<Expense>): Promise<Expense> {
    try {
      let updatesToApply: Partial<Expense> = { ...updates };
      const businessPurposeValue = updates.businessPurpose;
      const hasEmptyBusinessPurpose =
        typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0;

      if (hasEmptyBusinessPurpose) {
tests/unit/expenses/expense-operations.test.ts
+131-105
@@ -269,156 +269,182 @@ describe('Expense Operations Unit Tests', () => {
        ...updates,
        updatedAt: new Date()
      };

      mockStorage.updateExpense.mockResolvedValueOnce(updatedExpense);

      const result = await storage.updateExpense(expenseId, userId, updates);

      expect(result.amount).toBe(12000);
      expect(result.description).toBe('Updated description');
      expect(mockStorage.updateExpense).toHaveBeenCalledWith(expenseId, userId, updates);
    });

    test('should handle update error', async () => {
      const expenseId = 4;
      const updates = { amount: 15000 };

      mockStorage.updateExpense.mockRejectedValueOnce(new Error('Update failed'));

      await expect(storage.updateExpense(expenseId, userId, updates)).rejects.toThrow('Update failed');
    });
  });

  describe('getUserExpenses', () => {
    test('should fetch user expenses with category information', async () => {
      const mockExpensesWithCategories = [
      const expense = {
        id: 1,
        userId,
        categoryId: 1,
        amount: 75000,
        description: 'Camera lens',
        vendor: null,
        expenseDate: new Date('2024-01-15'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 100,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2024,
        notes: null,
        createdAt: new Date('2024-01-20'),
        updatedAt: new Date('2024-01-20')
      } satisfies Expense;

      const category = {
        id: 1,
        name: 'Technology',
        description: 'Equipment and technology purchases',
        legalExplanation: 'Equipment deduction',
        deductionPercentage: 100,
        itsDeductionCode: null,
        examples: [],
        icon: 'tech',
        color: '#000000',
        isActive: true,
        sortOrder: 1,
        defaultBusinessPurpose: null,
        createdAt: new Date('2024-01-01')
      } satisfies ExpenseCategory;

      const expensesWithCategories: Array<Expense & { category: ExpenseCategory | null }> = [
        {
          id: 1,
          userId,
          categoryId: 1,
          amount: 75000,
          description: 'Camera lens',
          vendor: null,
          expenseDate: new Date('2024-01-15'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 100,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2024,
          notes: null,
          createdAt: new Date('2024-01-20'),
          updatedAt: new Date('2024-01-20'),
          category: {
            id: 1,
            name: 'Technology',
            description: 'Equipment and technology purchases',
            legalExplanation: 'Equipment deduction',
            deductionPercentage: 100,
            itsDeductionCode: null,
            examples: [],
            icon: 'tech',
            color: '#000000',
            isActive: true,
            sortOrder: 1,
            defaultBusinessPurpose: null,
            createdAt: new Date('2024-01-01')
          }
          ...expense,
          category
        }
      ] satisfies Array<Expense & { category: ExpenseCategory | null }>;
      ];

      mockStorage.getUserExpenses.mockResolvedValueOnce(mockExpensesWithCategories);
      mockStorage.getUserExpenses.mockResolvedValueOnce(expensesWithCategories);

      const result = await storage.getUserExpenses(userId, 2024);

      expect(result).toEqual(mockExpensesWithCategories);
      expect(result).toEqual(expensesWithCategories);
      expect(result[0]).toMatchObject({
        ...expense,
        category
      });
      expect(result[0]?.category?.name).toBe('Technology');
      expect(mockStorage.getUserExpenses).toHaveBeenCalledWith(userId, 2024);
    });

    test('should fetch expenses without tax year filter', async () => {
      const mockAllExpenses = [
      const firstExpense = {
        id: 1,
        userId,
        categoryId: 2,
        amount: 12000,
        description: 'Expense 1',
        vendor: null,
        expenseDate: new Date('2023-03-10'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 80,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2023,
        notes: null,
        createdAt: new Date('2023-03-11'),
        updatedAt: new Date('2023-03-11')
      } satisfies Expense;

      const firstCategory = {
        id: 2,
        name: 'Education',
        description: 'Courses and learning materials',
        legalExplanation: 'Education deduction',
        deductionPercentage: 80,
        itsDeductionCode: null,
        examples: ['Online courses'],
        icon: 'book',
        color: '#FFAA00',
        isActive: true,
        sortOrder: 2,
        defaultBusinessPurpose: null,
        createdAt: new Date('2023-01-01')
      } satisfies ExpenseCategory;

      const secondExpense = {
        id: 2,
        userId,
        categoryId: 3,
        amount: 8500,
        description: 'Expense 2',
        vendor: null,
        expenseDate: new Date('2024-02-05'),
        receiptUrl: null,
        receiptFileName: null,
        businessPurpose: null,
        deductionPercentage: 100,
        tags: null,
        isRecurring: false,
        recurringPeriod: null,
        taxYear: 2024,
        notes: null,
        createdAt: new Date('2024-02-06'),
        updatedAt: new Date('2024-02-06')
      } satisfies Expense;

      const secondCategory = {
        id: 3,
        name: 'Travel',
        description: 'Business travel expenses',
        legalExplanation: 'Travel deduction',
        deductionPercentage: 100,
        itsDeductionCode: null,
        examples: ['Flights', 'Hotels'],
        icon: 'plane',
        color: '#3366FF',
        isActive: true,
        sortOrder: 3,
        defaultBusinessPurpose: null,
        createdAt: new Date('2024-01-05')
      } satisfies ExpenseCategory;

      const mockAllExpenses: Array<Expense & { category: ExpenseCategory | null }> = [
        {
          id: 1,
          userId,
          categoryId: 2,
          amount: 12000,
          description: 'Expense 1',
          vendor: null,
          expenseDate: new Date('2023-03-10'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 80,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2023,
          notes: null,
          createdAt: new Date('2023-03-11'),
          updatedAt: new Date('2023-03-11'),
          category: {
            id: 2,
            name: 'Education',
            description: 'Courses and learning materials',
            legalExplanation: 'Education deduction',
            deductionPercentage: 80,
            itsDeductionCode: null,
            examples: ['Online courses'],
            icon: 'book',
            color: '#FFAA00',
            isActive: true,
            sortOrder: 2,
            defaultBusinessPurpose: null,
            createdAt: new Date('2023-01-01')
          }
          ...firstExpense,
          category: firstCategory
        },
        {
          id: 2,
          userId,
          categoryId: 3,
          amount: 8500,
          description: 'Expense 2',
          vendor: null,
          expenseDate: new Date('2024-02-05'),
          receiptUrl: null,
          receiptFileName: null,
          businessPurpose: null,
          deductionPercentage: 100,
          tags: null,
          isRecurring: false,
          recurringPeriod: null,
          taxYear: 2024,
          notes: null,
          createdAt: new Date('2024-02-06'),
          updatedAt: new Date('2024-02-06'),
          category: {
            id: 3,
            name: 'Travel',
            description: 'Business travel expenses',
            legalExplanation: 'Travel deduction',
            deductionPercentage: 100,
            itsDeductionCode: null,
            examples: ['Flights', 'Hotels'],
            icon: 'plane',
            color: '#3366FF',
            isActive: true,
            sortOrder: 3,
            defaultBusinessPurpose: null,
            createdAt: new Date('2024-01-05')
          }
          ...secondExpense,
          category: secondCategory
        }
      ] satisfies Array<Expense & { category: ExpenseCategory | null }>;
      ];

      mockStorage.getUserExpenses.mockResolvedValueOnce(mockAllExpenses);

      const result = await storage.getUserExpenses(userId);

      expect(result).toEqual(mockAllExpenses);
      expect(result[0]).toMatchObject({
        ...firstExpense,
        category: firstCategory
      });
      expect(result).toHaveLength(2);
      expect(mockStorage.getUserExpenses).toHaveBeenCalledWith(userId);
    });
  });
});
