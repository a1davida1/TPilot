 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/unit/caption/nsfw-fallback.test.ts b/tests/unit/caption/nsfw-fallback.test.ts
index 6b533f8d76cca3ceb77b1e829ce1ea089cb18ce5..db5622bd36dd069217835e5a7c0431e73c3dcef5 100644
--- a/tests/unit/caption/nsfw-fallback.test.ts
+++ b/tests/unit/caption/nsfw-fallback.test.ts
@@ -1,33 +1,89 @@
 import { describe, it, expect, beforeEach, vi } from 'vitest';
 import { nsfwCaptionFallback } from '../../../server/caption/nsfwFallback.ts';
 
 describe('nsfwCaptionFallback', () => {
   beforeEach(() => {
     vi.restoreAllMocks();
   });
 
   it('returns caption tagged as NSFW', async () => {
     const imgBuffer = Buffer.from('test');
     const fetchMock = vi.spyOn(global, 'fetch');
 
     fetchMock.mockImplementationOnce(async () => ({
       ok: true,
       arrayBuffer: async () => imgBuffer,
-      headers: new Headers({ 'content-type': 'image/jpeg' })
+      headers: new Headers({ 'content-type': 'image/jpeg' }),
     }) as unknown as Response);
 
     fetchMock.mockImplementationOnce(async () => ({
       ok: true,
-      json: async () => [{ label: 'NSFW', score: 0.9 }]
+      json: async () => [{ label: 'NSFW', score: 0.9 }],
+      headers: new Headers({ 'content-type': 'application/json' }),
     }) as unknown as Response);
 
     fetchMock.mockImplementationOnce(async () => ({
       ok: true,
-      json: async () => [{ generated_text: 'sample caption' }]
+      json: async () => [{ generated_text: 'sample caption' }],
+      headers: new Headers({ 'content-type': 'application/json' }),
+    }) as unknown as Response);
+
+    const result = await nsfwCaptionFallback('https://example.com/image.jpg');
+    expect(result.nsfw).toBe(true);
+    expect(result.caption).toContain('[NSFW] sample caption');
+  });
+
+  it('flags image as NSFW when detection API returns 500', async () => {
+    const imgBuffer = Buffer.from('test');
+    const fetchMock = vi.spyOn(global, 'fetch');
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: true,
+      arrayBuffer: async () => imgBuffer,
+      headers: new Headers({ 'content-type': 'image/jpeg' }),
+    }) as unknown as Response);
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: false,
+      status: 500,
+      headers: new Headers({}),
+    }) as unknown as Response);
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: true,
+      json: async () => [{ generated_text: 'sample caption' }],
+      headers: new Headers({ 'content-type': 'application/json' }),
+    }) as unknown as Response);
+
+    const result = await nsfwCaptionFallback('https://example.com/image.jpg');
+    expect(result.nsfw).toBe(true);
+    expect(result.caption).toContain('[NSFW] sample caption');
+  });
+
+  it('flags image as NSFW when detection API returns 429', async () => {
+    const imgBuffer = Buffer.from('test');
+    const fetchMock = vi.spyOn(global, 'fetch');
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: true,
+      arrayBuffer: async () => imgBuffer,
+      headers: new Headers({ 'content-type': 'image/jpeg' }),
+    }) as unknown as Response);
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: false,
+      status: 429,
+      headers: new Headers({}),
+    }) as unknown as Response);
+
+    fetchMock.mockImplementationOnce(async () => ({
+      ok: true,
+      json: async () => [{ generated_text: 'sample caption' }],
+      headers: new Headers({ 'content-type': 'application/json' }),
     }) as unknown as Response);
 
     const result = await nsfwCaptionFallback('https://example.com/image.jpg');
     expect(result.nsfw).toBe(true);
     expect(result.caption).toContain('[NSFW] sample caption');
   });
 });
 
EOF
)