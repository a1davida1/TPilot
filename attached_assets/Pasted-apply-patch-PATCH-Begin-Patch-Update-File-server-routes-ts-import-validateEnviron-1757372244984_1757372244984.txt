apply_patch <<'PATCH'
*** Begin Patch
*** Update File: server/routes.ts
@@
-import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
+import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
+import { AppError, CircuitBreaker } from "./lib/errors.js";
@@
-import { generateUnifiedAIContent, analyzeImage } from "./services/unified-ai-service.js";
+import { generateUnifiedAIContent, analyzeImage } from "./services/unified-ai-service.js";
@@
-  app.post("/api/generate-content", generationLimiter, authenticateToken, async (req: AuthRequest, res) => {
-    try {
-      if (!req.user?.id) {
-        return res.status(401).json({ message: "Authentication required" });
-      }
-      const { platform, style, theme, timing, allowsPromotion } = req.body;
-      const result = await generateContent(
-        platform || 'reddit',
-        style || 'playful',
-        theme || 'lingerie',
-        timing,
-        allowsPromotion
-      );
-      const photoInstructions = {
-        lighting: Array.isArray(result.photoInstructions.lighting)
-          ? result.photoInstructions.lighting[0]
-          : result.photoInstructions.lighting || 'Natural lighting',
-        cameraAngle: Array.isArray(result.photoInstructions.angles)
-          ? result.photoInstructions.angles[0]
-          : (result.photoInstructions as any).cameraAngle || 'Eye level',
-        composition: Array.isArray(result.photoInstructions.composition)
-          ? result.photoInstructions.composition[0]
-          : result.photoInstructions.composition || 'Center composition',
-        styling: Array.isArray(result.photoInstructions.styling)
-          ? result.photoInstructions.styling[0]
-          : result.photoInstructions.styling || 'Casual styling',
-        mood: (result.photoInstructions as any).mood || 'Confident and natural',
-        technicalSettings: Array.isArray(result.photoInstructions.technical)
-          ? result.photoInstructions.technical[0]
-          : (result.photoInstructions as any).technicalSettings || 'Auto settings'
-      };
-      await storage.createContentGeneration({
-        userId: req.user.id,
-        titles: result.titles || [],
-        content: result.content || '',
-        photoInstructions,
-        platform: platform || "reddit",
-        style: style || 'playful',
-        theme: theme || 'lingerie',
-        createdAt: new Date()
-      });
-      res.json(result);
-    } catch (error) {
-      logger.error("Content generation error:", error);
-      res.status(500).json({ message: "Failed to generate content" });
-    }
-  });
+  const generateContentBreaker = new CircuitBreaker(generateContent);
+  app.post("/api/generate-content", generationLimiter, authenticateToken, async (req: AuthRequest, res, next) => {
+    if (!req.user?.id) {
+      return res.status(401).json({ message: "Authentication required" });
+    }
+    const { platform, style, theme, timing, allowsPromotion } = req.body;
+    try {
+      const result = await generateContentBreaker.call(
+        platform || 'reddit',
+        style || 'playful',
+        theme || 'lingerie',
+        timing,
+        allowsPromotion
+      );
+      const photoInstructions = {
+        lighting: Array.isArray(result.photoInstructions.lighting)
+          ? result.photoInstructions.lighting[0]
+          : result.photoInstructions.lighting || 'Natural lighting',
+        cameraAngle: Array.isArray(result.photoInstructions.angles)
+          ? result.photoInstructions.angles[0]
+          : (result.photoInstructions as any).cameraAngle || 'Eye level',
+        composition: Array.isArray(result.photoInstructions.composition)
+          ? result.photoInstructions.composition[0]
+          : result.photoInstructions.composition || 'Center composition',
+        styling: Array.isArray(result.photoInstructions.styling)
+          ? result.photoInstructions.styling[0]
+          : result.photoInstructions.styling || 'Casual styling',
+        mood: (result.photoInstructions as any).mood || 'Confident and natural',
+        technicalSettings: Array.isArray(result.photoInstructions.technical)
+          ? result.photoInstructions.technical[0]
+          : (result.photoInstructions as any).technicalSettings || 'Auto settings'
+      };
+      await storage.createContentGeneration({
+        userId: req.user.id,
+        titles: result.titles || [],
+        content: result.content || '',
+        photoInstructions,
+        platform: platform || "reddit",
+        style: style || 'playful',
+        theme: theme || 'lingerie',
+        createdAt: new Date()
+      });
+      res.json(result);
+    } catch (error: unknown) {
+      next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
+    }
+  });
@@
-  app.post('/api/generate-unified', generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res) => {
-    try {
-      const { mode, prompt, platform, style, theme, includePromotion, customInstructions } = req.body as any;
-      if (req.user?.id) {
-        const user = await storage.getUser(req.user.id);
-        if (!user) {
-          return res.status(401).json({ error: 'User not found' });
-        }
-        const userTier = user.tier || 'free';
-        const dailyCount = await storage.getDailyGenerationCount(req.user.id);
-        let dailyLimit = 5;
-        if (userTier === 'pro') dailyLimit = 50;
-        else if (userTier === 'starter') dailyLimit = 25;
-        if (dailyLimit !== -1 && dailyCount >= dailyLimit) {
-          return res.status(429).json({
-            error: 'Daily generation limit reached',
-            limit: dailyLimit,
-            used: dailyCount,
-            tier: userTier,
-            message: `You've reached your daily limit of ${dailyLimit} generations. ${userTier === 'free' ? 'Upgrade to Pro for 50 daily generations!' : 'Your limit resets tomorrow.'}`
-          });
-        }
-      }
-      let imageBase64: string | undefined;
-      if (mode === 'image' && req.file) {
-        if (!validateImageFormat(req.file.originalname)) {
-          return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
-        }
-        imageBase64 = imageToBase64(req.file.path);
-        await fs.unlink(req.file.path).catch(console.error);
-      }
-      const result = await generateUnifiedAIContent({
-        mode: (mode as 'text' | 'image') || 'text',
-        prompt,
-        imageBase64,
-        platform: platform || 'reddit',
-        style: style || 'playful',
-        theme,
-        includePromotion: includePromotion === 'true' || includePromotion === true,
-        customInstructions
-      });
-      if (req.user?.id) {
-        await storage.createContentGeneration({
-          userId: req.user.id,
-          platform: platform || 'reddit',
-          style: style || 'playful',
-          theme: theme || 'general',
-          titles: result.titles,
-          content: result.content,
-          photoInstructions: result.photoInstructions,
-          prompt: prompt || customInstructions,
-          allowsPromotion: includePromotion === 'true' || includePromotion === true
-        });
-      }
-      const response = { ...result };
-      res.json(response);
-    } catch (error) {
-      console.error('Unified AI generation error:', error);
-      res.status(500).json({
-        error: 'Failed to generate content',
-        message: error instanceof Error ? error.message : 'Unknown error'
-      });
-    }
-  });
+  const unifiedBreaker = new CircuitBreaker(generateUnifiedAIContent);
+  app.post('/api/generate-unified', generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res, next) => {
+    try {
+      const { mode, prompt, platform, style, theme, includePromotion, customInstructions } = req.body as any;
+
+      if (req.user?.id) {
+        const user = await storage.getUser(req.user.id);
+        if (!user) {
+          return res.status(401).json({ error: 'User not found' });
+        }
+        const userTier = user.tier || 'free';
+        const dailyCount = await storage.getDailyGenerationCount(req.user.id);
+        let dailyLimit = 5;
+        if (userTier === 'pro') dailyLimit = 50;
+        else if (userTier === 'starter') dailyLimit = 25;
+        if (dailyLimit !== -1 && dailyCount >= dailyLimit) {
+          return res.status(429).json({
+            error: 'Daily generation limit reached',
+            limit: dailyLimit,
+            used: dailyCount,
+            tier: userTier,
+            message: `You've reached your daily limit of ${dailyLimit} generations. ${userTier === 'free' ? 'Upgrade to Pro for 50 daily generations!' : 'Your limit resets tomorrow.'}`
+          });
+        }
+      }
+
+      let imageBase64: string | undefined;
+      if (mode === 'image' && req.file) {
+        if (!validateImageFormat(req.file.originalname)) {
+          return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
+        }
+        imageBase64 = imageToBase64(req.file.path);
+        await fs.unlink(req.file.path).catch(console.error);
+      }
+
+      const result = await unifiedBreaker.call({
+        mode: (mode as 'text' | 'image') || 'text',
+        prompt,
+        imageBase64,
+        platform: platform || 'reddit',
+        style: style || 'playful',
+        theme,
+        includePromotion: includePromotion === 'true' || includePromotion === true,
+        customInstructions
+      });
+
+      if (req.user?.id) {
+        await storage.createContentGeneration({
+          userId: req.user.id,
+          platform: platform || 'reddit',
+          style: style || 'playful',
+          theme: theme || 'general',
+          titles: result.titles,
+          content: result.content,
+          photoInstructions: result.photoInstructions,
+          prompt: prompt || customInstructions,
+          allowsPromotion: includePromotion === 'true' || includePromotion === true
+        });
+      }
+
+      res.json({ ...result });
+    } catch (error: unknown) {
+      next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
+    }
+  });
*** End Patch
*** Begin Patch
*** Update File: server/api-routes.ts
@@
-import { AiService } from "./lib/ai-service.js";
-import { generateEnhancedContent } from "./services/enhanced-ai-service.js";
+import { AiService } from "./lib/ai-service.js";
+import { generateEnhancedContent } from "./services/enhanced-ai-service.js";
+import { AppError, CircuitBreaker } from "./lib/errors.js";
@@
-  // AI Content Generation
-  app.post('/api/ai/generate', authenticateToken, async (req: Request, res) => {
-    try {
-      const schema = z.object({
-        prompt: z.string().optional(),
-        platforms: z.array(z.string()).min(1),
-        styleHints: z.array(z.string()).optional(),
-        variants: z.number().min(1).max(5).default(1),
-      });
-      const data = schema.parse(req.body);
-      if (!req.user?.id) {
-        return res.status(401).json({ error: 'Authentication required' });
-      }
-      const result = await AiService.generateContent({
-        userId: req.user.id,
-        ...data,
-      });
-      res.json(result);
-    } catch (error: unknown) {
-      console.error('AI generation failed:', error);
-      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
-    }
-  });
-
-  // Enhanced AI Content Generation
-  app.post('/api/ai/enhanced', authenticateToken, async (req: Request, res) => {
-    try {
-      const schema = z.object({
-        mode: z.enum(['text', 'image', 'hybrid']).default('text'),
-        prompt: z.string().optional(),
-        imageBase64: z.string().optional(),
-        platform: z.enum(['reddit', 'twitter', 'instagram', 'tiktok', 'onlyfans']),
-        style: z.enum(['playful', 'mysterious', 'bold', 'elegant', 'confident', 'authentic', 'sassy', 'professional']),
-        theme: z.string().optional(),
-        tone: z.enum(['casual', 'formal', 'flirty', 'friendly', 'provocative']).optional(),
-        contentType: z.enum(['teasing', 'promotional', 'engagement', 'lifestyle', 'announcement', 'educational']).optional(),
-        includePromotion: z.boolean().optional(),
-        promotionLevel: z.enum(['none', 'subtle', 'moderate', 'direct']).optional(),
-        targetAudience: z.enum(['general', 'fans', 'potential-subscribers', 'premium-tier']).optional(),
-        customInstructions: z.string().optional(),
-        subreddit: z.string().optional(),
-        niche: z.string().optional(),
-        personalBrand: z.string().optional(),
-      });
-      const data = schema.parse(req.body);
-      if (!req.user?.id) {
-        return res.status(401).json({ error: 'Authentication required' });
-      }
-      const result = await generateEnhancedContent({
-        ...data,
-        userId: String(req.user.id),
-      });
-      res.json(result);
-    } catch (error: unknown) {
-      console.error('Enhanced AI generation failed:', error);
-      res.status(500).json({ error: error.message });
-    }
-  });
+  const aiGenerateBreaker = new CircuitBreaker(AiService.generateContent.bind(AiService));
+  const enhancedBreaker = new CircuitBreaker(generateEnhancedContent);
+
+  // AI Content Generation
+  app.post('/api/ai/generate', authenticateToken, async (req: Request, res, next) => {
+    try {
+      const schema = z.object({
+        prompt: z.string().optional(),
+        platforms: z.array(z.string()).min(1),
+        styleHints: z.array(z.string()).optional(),
+        variants: z.number().min(1).max(5).default(1),
+      });
+      const data = schema.parse(req.body);
+      if (!req.user?.id) {
+        return res.status(401).json({ error: 'Authentication required' });
+      }
+      const result = await aiGenerateBreaker.call({
+        userId: req.user.id,
+        ...data,
+      });
+      res.json(result);
+    } catch (error: unknown) {
+      next(error instanceof AppError ? error : new AppError('AI generation failed', 500));
+    }
+  });
+
+  // Enhanced AI Content Generation
+  app.post('/api/ai/enhanced', authenticateToken, async (req: Request, res, next) => {
+    try {
+      const schema = z.object({
+        mode: z.enum(['text', 'image', 'hybrid']).default('text'),
+        prompt: z.string().optional(),
+        imageBase64: z.string().optional(),
+        platform: z.enum(['reddit', 'twitter', 'instagram', 'tiktok', 'onlyfans']),
+        style: z.enum(['playful', 'mysterious', 'bold', 'elegant', 'confident', 'authentic', 'sassy', 'professional']),
+        theme: z.string().optional(),
+        tone: z.enum(['casual', 'formal', 'flirty', 'friendly', 'provocative']).optional(),
+        contentType: z.enum(['teasing', 'promotional', 'engagement', 'lifestyle', 'announcement', 'educational']).optional(),
+        includePromotion: z.boolean().optional(),
+        promotionLevel: z.enum(['none', 'subtle', 'moderate', 'direct']).optional(),
+        targetAudience: z.enum(['general', 'fans', 'potential-subscribers', 'premium-tier']).optional(),
+        customInstructions: z.string().optional(),
+        subreddit: z.string().optional(),
+        niche: z.string().optional(),
+        personalBrand: z.string().optional(),
+      });
+      const data = schema.parse(req.body);
+      if (!req.user?.id) {
+        return res.status(401).json({ error: 'Authentication required' });
+      }
+      const result = await enhancedBreaker.call({
+        ...data,
+        userId: String(req.user.id),
+      });
+      res.json(result);
+    } catch (error: unknown) {
+      next(error instanceof AppError ? error : new AppError('Enhanced AI generation failed', 500));
+    }
+  });
*** End Patch
*** Begin Patch
*** Update File: server/lib/ai-service.ts
@@
-import { GoogleGenerativeAI } from "@google/generative-ai";
-import OpenAI from "openai";
-import crypto from "crypto";
-import { env } from "./config.js";
-import { db } from "../db.js";
-import { aiGenerations } from "@shared/schema.js";
-import { eq } from "drizzle-orm";
+import { GoogleGenerativeAI } from "@google/generative-ai";
+import OpenAI from "openai";
+import crypto from "crypto";
+import { env } from "./config.js";
+import { db } from "../db.js";
+import { aiGenerations } from "@shared/schema.js";
+import { eq } from "drizzle-orm";
+import { CircuitBreaker, AppError } from "./errors.js";
@@
-const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || env.GOOGLE_GENAI_API_KEY || '');
-const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || '' });
+const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || env.GOOGLE_GENAI_API_KEY || '');
+const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || '' });
+const geminiModel = gemini.getGenerativeModel({ model: "gemini-1.5-flash" });
+const geminiBreaker = new CircuitBreaker(geminiModel.generateContent.bind(geminiModel));
+const openaiBreaker = new CircuitBreaker(openai.chat.completions.create.bind(openai.chat.completions));
@@
-    try {
-      // Use Gemini as primary for multi-platform content generation
-      const response = await this.generateWithGemini(inputData);
-      await this.cacheResult(userId, 'gemini', inputHash, inputData, response);
-      return { ...response, cached: false };
-    } catch (error: unknown) {
-      console.error('Gemini generation failed:', error);
-      if (error?.status === 429 || error?.message?.includes('quota')) {
-        console.log('Gemini quota exceeded, trying OpenAI fallback...');
-      }
-      try {
-        const response = await this.generateWithOpenAI(inputData);
-        await this.cacheResult(userId, 'openai', inputHash, inputData, response);
-        return { ...response, cached: false };
-      } catch (fallbackError: unknown) {
-        console.error('OpenAI fallback failed:', fallbackError);
-        if (fallbackError?.code === 'insufficient_quota' || fallbackError?.status === 429) {
-          console.log('API quota exceeded, using template fallback...');
-          const platforms = inputData.platforms || ['reddit'];
-          const fallbackContent = this.createFallbackContent(platforms);
-          return { content: fallbackContent, tokensUsed: 0, model: 'fallback', cached: false };
-        }
-        throw new Error('All AI services failed to generate content');
-      }
-    }
+    try {
+      const response = await this.generateWithGemini(inputData);
+      await this.cacheResult(userId, 'gemini', inputHash, inputData, response);
+      return { ...response, cached: false };
+    } catch (error: unknown) {
+      console.error('Gemini generation failed:', error);
+      try {
+        const response = await this.generateWithOpenAI(inputData);
+        await this.cacheResult(userId, 'openai', inputHash, inputData, response);
+        return { ...response, cached: false };
+      } catch (fallbackError: unknown) {
+        console.error('OpenAI fallback failed:', fallbackError);
+        if (fallbackError instanceof AppError) {
+          throw fallbackError;
+        }
+        if ((fallbackError as any)?.code === 'insufficient_quota' || (fallbackError as any)?.status === 429) {
+          console.log('API quota exceeded, using template fallback...');
+          const platforms = inputData.platforms || ['reddit'];
+          const fallbackContent = this.createFallbackContent(platforms);
+          return { content: fallbackContent, tokensUsed: 0, model: 'fallback', cached: false };
+        }
+        throw new AppError('All AI services failed to generate content', 500, false);
+      }
+    }
@@
-  private static async generateWithGemini(input: unknown): Promise<Omit<AiResponse, 'cached'>> {
-    const model = gemini.getGenerativeModel({ model: "gemini-1.5-flash" });
-    const systemPrompt = this.buildSystemPrompt(input.platforms, input.styleHints);
-    const userPrompt = input.prompt || "Generate engaging content for adult content creator";
-    const result = await model.generateContent([
-      { text: systemPrompt },
-      { text: userPrompt },
-    ]);
+  private static async generateWithGemini(input: any): Promise<Omit<AiResponse, 'cached'>> {
+    const systemPrompt = this.buildSystemPrompt(input.platforms, input.styleHints);
+    const userPrompt = input.prompt || "Generate engaging content for adult content creator";
+    const result = await geminiBreaker.call([
+      { text: systemPrompt },
+      { text: userPrompt },
+    ]);
@@
-  private static async generateWithOpenAI(input: unknown): Promise<Omit<AiResponse, 'cached'>> {
-    const systemPrompt = this.buildSystemPrompt(input.platforms, input.styleHints);
-    const userPrompt = input.prompt || "Generate engaging content for adult content creator";
-    const response = await openai.chat.completions.create({
-      model: "gpt-4o",
-      messages: [
-        { role: "system", content: systemPrompt },
-        { role: "user", content: userPrompt }
-      ],
-      max_tokens: 2000,
-      response_format: { type: "json_object" },
-    });
+  private static async generateWithOpenAI(input: any): Promise<Omit<AiResponse, 'cached'>> {
+    const systemPrompt = this.buildSystemPrompt(input.platforms, input.styleHints);
+    const userPrompt = input.prompt || "Generate engaging content for adult content creator";
+    const response = await openaiBreaker.call({
+      model: "gpt-4o",
+      messages: [
+        { role: "system", content: systemPrompt },
+        { role: "user", content: userPrompt }
+      ],
+      max_tokens: 2000,
+      response_format: { type: "json_object" },
+    });
*** End Patch
PATCH
