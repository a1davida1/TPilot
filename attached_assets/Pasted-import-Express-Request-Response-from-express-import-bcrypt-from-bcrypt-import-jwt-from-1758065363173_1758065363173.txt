import { Express, Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import session from 'express-session';
import { storage } from './storage';
import { emailService } from './services/email-service';
import crypto from 'crypto';
import { z } from 'zod';
import { authLimiter } from './middleware/security.js';
import { safeLog } from './lib/logger-utils.js';
import { FRONTEND_URL } from './config.js';
import { verificationLimiter, passwordResetLimiter, loginLimiter, signupLimiter, passwordChangeLimiter } from './middleware/simple-rate-limit.js';
import { authMetrics } from './services/basic-metrics.js';
import { logger } from './bootstrap/logger.js';
import { verifyAdminCredentials } from './lib/admin-auth.js';
import { validate, ValidationSource, loginValidationSchema, signupValidationSchema, passwordChangeValidationSchema, passwordResetValidationSchema } from './middleware/validation.js';
import { extractAuthToken } from './middleware/extract-token.js';

// Auth validation schemas removed - handled by middleware

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET || /changeme|placeholder/i.test(JWT_SECRET)) {
  throw new Error('JWT_SECRET environment variable is required and must not be a placeholder');
}
// Type assertion after validation
const JWT_SECRET_VALIDATED: string = JWT_SECRET;

export function setupAuth(app: Express) {
  // Regular signup
  app.post('/api/auth/signup', signupLimiter, validate(signupValidationSchema), async (req, res) => {
    const startTime = Date.now();
    try {
      // Input already validated by middleware
      const { username, password, email } = req.body;

      // Check if user exists by username OR email
      const existingUserByUsername = await storage.getUserByUsername(username);
      if (existingUserByUsername) {
        return res.status(400).json({ message: 'Username already exists' });
      }
@@ -134,89 +135,86 @@ export function setupAuth(app: Express) {
          }
        });
      }
      
      // Track signup metrics
      authMetrics.track('signup', true, Date.now() - startTime);
      
    } catch (error) {
      safeLog('error', 'Authentication signup failed', { error: (error as Error).message });
      
      // Track failed signup
      authMetrics.track('signup', false, Date.now() - startTime, (error as Error).message);
      
      res.status(500).json({ message: 'Error creating user' });
    }
  });

  // Regular login
  app.post('/api/auth/login', loginLimiter, validate(loginValidationSchema), async (req, res) => {
    const startTime = Date.now();
    try {
      // Input already validated by middleware
      const { username, password, email } = req.body;
      const loginIdentifier = email || username;

      const ADMIN_EMAIL = process.env.ADMIN_EMAIL;
      const ADMIN_PASSWORD_HASH = process.env.ADMIN_PASSWORD_HASH;
      const adminEmail = await verifyAdminCredentials(loginIdentifier, password);

      if (adminEmail) {

      if (ADMIN_EMAIL && ADMIN_PASSWORD_HASH &&
          loginIdentifier === ADMIN_EMAIL &&
          await bcrypt.compare(password, ADMIN_PASSWORD_HASH)) {
        
        // Create admin token
        const token = jwt.sign(
          {
            id: 999,
            userId: 999,
            username: 'admin',
            isAdmin: true,
            role: 'admin',
            tier: 'admin'
          },
          JWT_SECRET_VALIDATED,
          { expiresIn: '24h' }
        );

        res.cookie('authToken', token, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 24 * 60 * 60 * 1000
        });

          return res.json({
            token,
            user: {
              id: 999,
              username: 'admin',
              email: ADMIN_EMAIL,
              tier: 'admin',
              isAdmin: true,
              role: 'admin'
            }
          });

        return res.json({
          token,
          user: {
            id: 999,
            username: 'admin',
            email: adminEmail,
            tier: 'admin',
            isAdmin: true,
            role: 'admin'
          }
        });
      }

      // Regular user login continues...
      let user;
      if (loginIdentifier && loginIdentifier.includes('@')) {
        // It's an email
        user = await storage.getUserByEmail(loginIdentifier);
      } else {
        // It's a username
        user = await storage.getUserByUsername(loginIdentifier || '');
      }

      if (!user || user.isDeleted) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }

      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }

      if (!user.emailVerified) {
        return res.status(403).json({ 
          message: 'Email not verified. Please check your email or resend verification.',
          code: 'EMAIL_NOT_VERIFIED',
server/lib/admin-auth.ts
New
+31
-0

import bcrypt from 'bcrypt';

export interface AdminCredentials {
  email: string | null;
  passwordHash: string | null;
}

export const getAdminCredentials = (): AdminCredentials => {
  return {
    email: process.env.ADMIN_EMAIL ?? null,
    passwordHash: process.env.ADMIN_PASSWORD_HASH ?? null,
  };
};

export const verifyAdminCredentials = async (
  identifier: string | undefined,
  password: string | undefined
): Promise<string | null> => {
  const { email, passwordHash } = getAdminCredentials();

  if (!email || !passwordHash || typeof identifier !== 'string' || typeof password !== 'string') {
    return null;
  }

  if (identifier !== email) {
    return null;
  }

  const matches = await bcrypt.compare(password, passwordHash);
  return matches ? email : null;
};
server/middleware/auth.ts
+11
-5

import jwt from 'jsonwebtoken';
import express from 'express';
import { logger } from './security.js';
import { db } from '../db.js';
import { users } from '@shared/schema';
import { isTokenBlacklisted } from '../lib/tokenBlacklist';
import { getAdminCredentials } from '../lib/admin-auth.js';

import { eq } from 'drizzle-orm';

// Create a proper User type alias from the schema
type UserType = typeof users.$inferSelect;

export interface AuthRequest extends express.Request {
  user?: UserType;
}

// Get JWT secret (must be set in environment)
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error('JWT_SECRET environment variable is required');
}

// Get admin credentials from environment (required)
if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {
  throw new Error('ADMIN_EMAIL and ADMIN_PASSWORD environment variables are required');
const adminCredentials = getAdminCredentials();

export const ADMIN_EMAIL = adminCredentials.email;
export const ADMIN_PASSWORD_HASH = adminCredentials.passwordHash;

if (!ADMIN_PASSWORD_HASH) {
  logger.warn('ADMIN_PASSWORD_HASH environment variable is not set. Admin login is disabled.');
}

export const ADMIN_EMAIL = process.env.ADMIN_EMAIL;
export const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
if (!ADMIN_EMAIL) {
  logger.warn('ADMIN_EMAIL environment variable is not set. Admin login is disabled.');
}

export const authenticateToken = async (req: AuthRequest, res: express.Response, next: express.NextFunction) => {
  const authHeader = req.headers['authorization'];
  let token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  // Fall back to JWT stored in httpOnly cookie
  if (!token && req.cookies?.authToken) {
    token = req.cookies.authToken;
  }

  // Try JWT token first
  if (token) {
    if (await isTokenBlacklisted(token)) {
      return res.status(401).json({ message: 'Token revoked' });
    }
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { userId: number; email: string; iat: number; exp: number };
      
      // Fetch the full user object from database
      const [user] = await db.select().from(users).where(eq(users.id, decoded.userId));
      
      if (!user) {
        return res.status(401).json({ message: 'User not found' });
      }
      
server/routes.ts
+1
-1

@@ -1220,42 +1220,42 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api'):
      if (Number.isNaN(imageId)) return res.status(400).json({ message: 'Invalid image id' });
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ message: 'Authentication required' });
      const { protectionLevel } = req.body as { protectionLevel?: keyof typeof protectionPresets };
      const image = await storage.getUserImage(imageId, userId);
      if (!image) return res.status(404).json({ message: 'Image not found' });

      const level = protectionLevel && protectionPresets[protectionLevel] ? protectionLevel : 'standard';
      const inputPath = path.join(process.cwd(), image.url.startsWith('/') ? image.url.slice(1) : image.url);
      const protectedName = `protected_${Date.now()}_${image.filename}`;
      const outputPath = path.join(process.cwd(), 'uploads', protectedName);
      await applyImageShieldProtection(inputPath, outputPath, level as 'light' | 'standard' | 'heavy', false);
      await storage.updateUserImage(imageId, userId, { url: `/uploads/${protectedName}`, isProtected: true, protectionLevel: level });

      res.json({ success: true, protectedUrl: `/uploads/${protectedName}`, message: 'Image protected successfully' });
    } catch (error: unknown) {
      logger.error('Failed to protect image:', error);
      res.status(500).json({ message: 'Failed to protect image' });
    }
  });

  // Debug endpoint for environment variables
  app.get('/api/debug/env', (req, res) => {
    res.json({
      hasAdminEmail: !!process.env.ADMIN_EMAIL,
      hasAdminPassword: !!process.env.ADMIN_PASSWORD,
      hasAdminPasswordHash: !!process.env.ADMIN_PASSWORD_HASH,
      adminEmailLength: process.env.ADMIN_EMAIL?.length || 0,
      nodeEnv: process.env.NODE_ENV,
      // Don't send actual values for security!
    });
  });

  // ==========================================
  // ERROR HANDLER (MUST BE LAST)
  // ==========================================
  
  // Apply error handling middleware last
  app.use(errorHandler);

  const httpServer = createServer(app);
  return httpServer;
}
tests/auth/signup.test.ts
+81
-3

/* eslint-env node, jest */
import request from 'supertest';
import express from 'express';
import { describe, it, expect, beforeEach, vi } from 'vitest';

type QueryResult = Array<Record<string, unknown>>;

const dbMock = vi.hoisted(() => {
  let nextResult: QueryResult = [];

  return {
    select: () => ({
      from: (_table: unknown) => ({
        where: async (_condition: unknown): Promise<QueryResult> => nextResult
      })
    }),
    setNextResult: (result: QueryResult) => {
      nextResult = result;
    },
    clear: () => {
      nextResult = [];
    }
  };
});

vi.mock('../../server/db.js', () => ({
  db: {
    select: dbMock.select
  }
}));

// In-memory stores for mocking  
const users: Array<Record<string, unknown>> = [];
const tokens: Array<Record<string, unknown>> = [];

vi.mock('../../server/storage', () => ({
  storage: {
    getUser: vi.fn().mockImplementation(async (id: number) => users.find(u => u.id === id)),
    getUserByUsername: vi.fn().mockImplementation(async (username: string) => users.find(u => u.username === username)),
    getUserByEmail: vi.fn().mockImplementation(async (email: string) => users.find(u => u.email === email)),
    updateUser: vi.fn(),
    createUser: vi.fn().mockImplementation(async (data: Record<string, unknown>) => {
      const user = { id: users.length + 1, emailVerified: false, ...data };
      users.push(user);
      return user;
    }),
    updateUserEmailVerified: vi.fn().mockImplementation(async (userId: number, verified: boolean) => {
      const user = users.find(u => u.id === userId);
      if (user) user.emailVerified = verified;
    }),
    createVerificationToken: vi.fn().mockImplementation(async (data: Record<string, unknown>) => {
      const token = { id: tokens.length + 1, ...data };
      tokens.push(token);
      return token;
    }),
    getVerificationToken: vi.fn().mockImplementation(async (token: string) => tokens.find(t => t.token === token)),
    deleteVerificationToken: vi.fn().mockImplementation(async (token: string) => {
      const idx = tokens.findIndex(t => t.token === token);
      if (idx !== -1) tokens.splice(idx, 1);
    })
  }
}));

vi.mock('../../server/services/email-service', () => ({
  emailService: { 
    sendPasswordResetEmail: vi.fn(), 
  emailService: {
    sendPasswordResetEmail: vi.fn(),
    sendWelcomeEmail: vi.fn(),
    sendVerificationEmail: vi.fn().mockResolvedValue(true)
  }
}));

import { setupAuth } from '../../server/auth';
import { authenticateToken, type AuthRequest } from '../../server/middleware/auth.js';

describe('Signup and email verification', () => {
  beforeEach(() => {
    users.length = 0;
    tokens.length = 0;
    vi.clearAllMocks();
    dbMock.clear();
  });

  it('verifies email before allowing login', async () => {
    const app = express();
    app.use(express.json());
    setupAuth(app);

    const signupRes = await request(app)
      .post('/api/auth/signup')
      .send({ username: 'alice', password: 'Password123!', email: 'alice@example.com' });

    expect(signupRes.status).toBe(201);
    expect(signupRes.body.message).toMatch(/verification email sent/i);
    
    const { emailService } = await import('../../server/services/email-service');
    expect(emailService.sendVerificationEmail).toHaveBeenCalled();

    const token = tokens[0].token;

    const loginBefore = await request(app)
      .post('/api/auth/login')
      .send({ username: 'alice', password: 'Password123!' });
    expect(loginBefore.status).toBe(403);

    const verifyRes = await request(app).get(`/api/auth/verify-email?token=${token}`);
    expect([200, 302]).toContain(verifyRes.status);

    const loginAfter = await request(app)
      .post('/api/auth/login')
      .send({ username: 'alice', password: 'Password123!' });
    expect(loginAfter.status).toBe(200);
    expect(loginAfter.body.token).toBeDefined();
  });
});

  it('allows admin login with hashed secret and authenticates protected routes', async () => {
    const app = express();
    app.use(express.json());
    setupAuth(app);

    app.get('/api/protected', authenticateToken, (req: AuthRequest, res) => {
      res.json({
        authenticated: true,
        email: req.user?.email,
        id: req.user?.id
      });
    });

    const adminEmail = process.env.ADMIN_EMAIL ?? 'admin@example.com';
    const adminPassword = process.env.ADMIN_TEST_PASSWORD ?? 'AdminPassword123!';

    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({ email: adminEmail, password: adminPassword });

    expect(loginRes.status).toBe(200);
    expect(loginRes.body.token).toBeDefined();

    const adminUser: Record<string, unknown> = {
      id: 999,
      email: adminEmail,
      username: 'admin',
      tier: 'admin',
      isAdmin: true,
      role: 'admin',
      password: 'hashed-value',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      emailVerified: true
    };

    dbMock.setNextResult([adminUser]);

    const protectedRes = await request(app)
      .get('/api/protected')
      .set('Authorization', `Bearer ${loginRes.body.token as string}`);

    expect(protectedRes.status).toBe(200);
    expect(protectedRes.body).toEqual(expect.objectContaining({
      authenticated: true,
      email: adminEmail,
      id: 999
    }));
  });
});
tests/vitest-setup.ts
+6
-0

import dotenv from 'dotenv';
import bcrypt from 'bcrypt';
import { beforeEach } from 'vitest';

// Load .env.test file specifically for vitest tests
dotenv.config({ path: '.env.test' });

// Set default test environment variables if not present
process.env.APP_BASE_URL = process.env.APP_BASE_URL || 'https://thottopilot.com';
process.env.DATABASE_URL = process.env.DATABASE_URL || process.env.NEON_DATABASE_URL;
process.env.JWT_SECRET = process.env.JWT_SECRET || 'test-secret-key';
process.env.NODE_ENV = 'test';

const defaultAdminPassword = 'AdminPassword123!';
process.env.ADMIN_EMAIL = process.env.ADMIN_EMAIL || 'admin@example.com';
process.env.ADMIN_PASSWORD_HASH = process.env.ADMIN_PASSWORD_HASH || bcrypt.hashSync(defaultAdminPassword, 10);
process.env.ADMIN_TEST_PASSWORD = process.env.ADMIN_TEST_PASSWORD || defaultAdminPassword;

// Clean up between tests
beforeEach(() => {
  // Reset any global state here if needed
});