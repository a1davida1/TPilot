diff --git a/server/middleware/validation.ts b/server/middleware/validation.ts
@@
 export const passwordChangeValidationSchema = z.object({
   currentPassword: z.string().min(1, 'Current password required'),
   newPassword: passwordSchema,
   confirmPassword: z.string()
 }).refine(data => data.newPassword === data.confirmPassword, {
   message: 'New password and confirmation must match',
   path: ['confirmPassword']
 });
 
+export const passwordResetValidationSchema = z.object({
+  token: z.string().min(1, 'Token required'),
+  newPassword: passwordSchema
+});
diff --git a/server/auth.ts b/server/auth.ts
@@
-import { validate, ValidationSource, loginValidationSchema, signupValidationSchema, passwordChangeValidationSchema } from './middleware/validation.js';
+import { validate, ValidationSource, loginValidationSchema, signupValidationSchema, passwordChangeValidationSchema, passwordResetValidationSchema } from './middleware/validation.js';
@@
-  app.post('/api/auth/reset-password', passwordResetLimiter, async (req, res) => {
-    try {
-      const { token, newPassword } = req.body;
-
-      if (!token || !newPassword) {
-        return res.status(400).json({ message: 'Token and new password required' });
-      }
-
-      // Validate new password first
-      if (newPassword.length < 8) {
-        return res.status(400).json({ message: 'Password must be at least 8 characters long' });
-      }
-
-      // Decode and verify JWT token (generated by forgot-password endpoint)
-      let decoded;
-      try {
-        decoded = jwt.verify(token, JWT_SECRET_VALIDATED) as any;
-      } catch (jwtError) {
-        safeLog('warn', 'Invalid JWT token in password reset', {
-          error: jwtError.message,
-          tokenLength: token?.length || 0
-        });
+  app.post('/api/auth/reset-password', passwordResetLimiter, validate(passwordResetValidationSchema), async (req, res) => {
+    try {
+      const { token, newPassword } = req.body;
+
+      // Decode and verify JWT token (generated by forgot-password endpoint)
+      let decoded: { email?: string };
+      try {
+        decoded = jwt.verify(token, JWT_SECRET_VALIDATED) as { email?: string };
+      } catch (jwtError) {
+        safeLog('warn', 'Invalid JWT token in password reset', {
+          error: (jwtError as Error).message,
+          tokenLength: token.length
+        });
         return res.status(400).json({ message: 'Invalid or expired reset token' });
       }
