 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/social-auth.ts b/server/social-auth.ts
index d297fdba5d749b47da6c299019c6307138780375..1ba230e211385848619f425e3b8c95ac04c88a08 100644
--- a/server/social-auth.ts
+++ b/server/social-auth.ts
@@ -1,49 +1,81 @@
 import passport from 'passport';
 import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
 import { Strategy as FacebookStrategy } from 'passport-facebook';
 import { Strategy as RedditStrategy } from 'passport-reddit';
-import type { Express, NextFunction, Request, Response } from 'express';
+import type { CookieOptions, Express, NextFunction, Request, Response } from 'express';
 import type { AuthenticateOptions } from 'passport';
 import type { User } from '@shared/schema';
 import { storage } from './storage';
 import jwt from 'jsonwebtoken';
 import { blacklistToken } from './lib/tokenBlacklist';
 import { logger } from './bootstrap/logger';
 import { API_PREFIX, prefixApiPath } from './lib/api-prefix.js';
 import { createToken } from './middleware/auth.js';
 
 type RedditAuthenticateOptions = AuthenticateOptions & {
   state?: string;
   duration?: 'temporary' | 'permanent';
 };
 
 const redditCallbackOptions: RedditAuthenticateOptions = {
   failureRedirect: '/login?error=reddit_failed'
   // Note: No successRedirect - we handle cookie + redirect in the callback handler
 };
 
+type SessionCookieConfig = {
+  name: string;
+  options: CookieOptions;
+};
+
+const getSessionCookieConfig = (): SessionCookieConfig => {
+  const cookieName = process.env.SESSION_COOKIE_NAME ?? 'tpilot.sid';
+  const isProduction = process.env.NODE_ENV === 'production';
+  const cookieDomain = process.env.SESSION_COOKIE_DOMAIN?.trim();
+
+  const cookieOptions: CookieOptions = {
+    httpOnly: true,
+    sameSite: 'lax',
+    secure: isProduction,
+    path: '/',
+  };
+
+  if (cookieDomain) {
+    cookieOptions.domain = cookieDomain;
+  }
+
+  return {
+    name: cookieName,
+    options: cookieOptions,
+  };
+};
+
+const clearSessionCookie = (res: Response): void => {
+  const { name, options } = getSessionCookieConfig();
+  res.clearCookie(name, options);
+};
+
 export function setupSocialAuth(app: Express, apiPrefix: string = API_PREFIX) {
   // Note: passport.initialize() and passport.session() are now called from routes.ts
   // after session middleware is initialized
   // Serialization/deserialization is also handled in routes.ts
 
   // Google OAuth Strategy
   if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
     passport.use(new GoogleStrategy({
       clientID: process.env.GOOGLE_CLIENT_ID,
       clientSecret: process.env.GOOGLE_CLIENT_SECRET,
       callbackURL: prefixApiPath('/auth/google/callback', apiPrefix)
     }, async (accessToken, refreshToken, profile, done) => {
       try {
         const email = profile.emails?.[0]?.value || '';
         const username = profile.displayName || email || '';
         const avatar = profile.photos?.[0]?.value;
         
         // First, check by provider ID (most reliable for OAuth)
         let user = await storage.getUserByProviderId('google', profile.id);
         
         if (user) {
           // Update avatar and username if changed
           if (avatar && user.avatar !== avatar || user.username !== username) {
             await storage.updateUser(user.id, { avatar, username });
             user = await storage.getUserById(user.id);
diff --git a/server/social-auth.ts b/server/social-auth.ts
index d297fdba5d749b47da6c299019c6307138780375..1ba230e211385848619f425e3b8c95ac04c88a08 100644
--- a/server/social-auth.ts
+++ b/server/social-auth.ts
@@ -266,199 +298,145 @@ function setupAuthRoutes(app: Express, apiPrefix: string) {
       // Set auth token cookie with SameSite=None for third-party OAuth redirect
       if (req.user) {
         const token = createToken(req.user as User);
         res.cookie('authToken', token, {
           httpOnly: true,
           secure: true, // Must be true for SameSite=None
           sameSite: 'none', // Required for third-party redirect
           maxAge: 86400_000,
           path: '/',
         });
       }
       res.redirect('/dashboard?connected=reddit');
     }
   );
 
   // Logout with comprehensive error handling
   app.post(route('/auth/logout'), async (req: Request, res: Response) => {
     const r = req as Request & {
       session?: { destroy?: (cb: (err?: unknown) => void) => void };
       logout?: (cb: (err?: unknown) => void) => void;
     };
     try {
       // Check if session exists first
       if (!r.session) {
         // No session, just clear cookies and return success
-        res.clearCookie('connect.sid', {
-          httpOnly: true,
-          secure: process.env.NODE_ENV === 'production',
-          sameSite: 'strict'
-        });
+        clearSessionCookie(res);
         res.clearCookie('authToken', {
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict'
         });
-        res.clearCookie('thottopilot.sid', {
-          httpOnly: true,
-          secure: process.env.NODE_ENV === 'production',
-          sameSite: 'strict'
-        });
         const authHeader = req.headers['authorization'];
         const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
         if (token) {
           const decoded = jwt.decode(token) as { exp?: number } | null;
           const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
           await blacklistToken(token, ttl);
         }
         return res.json({ message: 'Logged out successfully' });
       }
 
       // If using Passport and session exists
       if (r.logout) {
         r.logout(async (err) => {
           if (err) {
             logger.error('Passport logout error', { error: err instanceof Error ? err.message : String(err) });
             // Continue with logout anyway
           }
           
           // Destroy session if it exists
           if (r.session && r.session.destroy) {
             r.session.destroy(async (destroyErr) => {
               if (destroyErr) {
                 logger.error('Session destroy error', { error: destroyErr instanceof Error ? destroyErr.message : String(destroyErr) });
               }
               // Clear cookies regardless
-              res.clearCookie('connect.sid', {
-                httpOnly: true,
-                secure: process.env.NODE_ENV === 'production',
-                sameSite: 'strict'
-              });
+              clearSessionCookie(res);
               res.clearCookie('authToken', {
                 httpOnly: true,
                 secure: process.env.NODE_ENV === 'production',
                 sameSite: 'strict'
               });
-              res.clearCookie('thottopilot.sid', {
-                httpOnly: true,
-                secure: process.env.NODE_ENV === 'production',
-                sameSite: 'strict'
-              });
               const authHeader = req.headers['authorization'];
               const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
               if (token) {
                 const decoded = jwt.decode(token) as { exp?: number } | null;
                 const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
                 await blacklistToken(token, ttl);
               }
               res.json({ message: 'Logged out successfully' });
             });
           } else {
             // No session.destroy, just clear cookies
-            res.clearCookie('connect.sid', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
+            clearSessionCookie(res);
             res.clearCookie('authToken', {
               httpOnly: true,
               secure: process.env.NODE_ENV === 'production',
               sameSite: 'strict'
             });
-            res.clearCookie('thottopilot.sid', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
             const authHeader = req.headers['authorization'];
             const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
             if (token) {
               const decoded = jwt.decode(token) as { exp?: number } | null;
               const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
               await blacklistToken(token, ttl);
             }
             res.json({ message: 'Logged out successfully' });
           }
         });
       } else {
         // No passport logout, destroy session directly
         if (r.session && r.session.destroy) {
           r.session.destroy(async (err) => {
             if (err) {
               logger.error('Session destroy error', { error: err instanceof Error ? err.message : String(err) });
             }
-            res.clearCookie('connect.sid', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
+            clearSessionCookie(res);
             res.clearCookie('authToken', {
               httpOnly: true,
               secure: process.env.NODE_ENV === 'production',
               sameSite: 'strict'
             });
-            res.clearCookie('thottopilot.sid', {
-              httpOnly: true,
-              secure: process.env.NODE_ENV === 'production',
-              sameSite: 'strict'
-            });
             const authHeader = req.headers['authorization'];
             const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
             if (token) {
               const decoded = jwt.decode(token) as { exp?: number } | null;
               const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
               await blacklistToken(token, ttl);
             }
             res.json({ message: 'Logged out successfully' });
           });
         } else {
           // Just clear cookies
-          res.clearCookie('connect.sid', {
-            httpOnly: true,
-            secure: process.env.NODE_ENV === 'production',
-            sameSite: 'strict'
-          });
+          clearSessionCookie(res);
           res.clearCookie('authToken', {
             httpOnly: true,
             secure: process.env.NODE_ENV === 'production',
             sameSite: 'strict'
           });
-          res.clearCookie('thottopilot.sid', {
-            httpOnly: true,
-            secure: process.env.NODE_ENV === 'production',
-            sameSite: 'strict'
-          });
           const authHeader = req.headers['authorization'];
           const token = authHeader?.split(' ')[1] || req.cookies?.authToken;
           if (token) {
             const decoded = jwt.decode(token) as { exp?: number } | null;
             const ttl = decoded?.exp ? decoded.exp - Math.floor(Date.now() / 1000) : 86400;
             await blacklistToken(token, ttl);
           }
           res.json({ message: 'Logged out successfully' });
         }
       }
     } catch (error) {
       logger.error('Logout error', { error: error instanceof Error ? (error as Error).message : String(error) });
       // Even on error, clear cookies to help user
-      res.clearCookie('connect.sid', {
-        httpOnly: true,
-        secure: process.env.NODE_ENV === 'production',
-        sameSite: 'strict'
-      });
+      clearSessionCookie(res);
       res.clearCookie('authToken', {
         httpOnly: true,
         secure: process.env.NODE_ENV === 'production',
         sameSite: 'strict'
       });
-      res.clearCookie('thottopilot.sid', {
-        httpOnly: true,
-        secure: process.env.NODE_ENV === 'production',
-        sameSite: 'strict'
-      });
       res.json({ message: 'Logged out (with errors)' });
     }
   });
 
   // Get current user - REMOVED: Duplicate endpoint
   // The main /api/auth/user endpoint is handled in server/auth.ts with JWT support
 }
 
EOF
)