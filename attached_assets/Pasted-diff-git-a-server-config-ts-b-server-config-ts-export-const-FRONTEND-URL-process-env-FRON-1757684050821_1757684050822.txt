diff --git a/server/config.ts b/server/config.ts
@@
 export const FRONTEND_URL =
   process.env.FRONTEND_URL ||
   (process.env.NODE_ENV === 'production'
     ? 'https://thottopilot.com'
     : 'http://localhost:5000');
+
+export const STRIPE_KEYS = {
+  secretKey: process.env.STRIPE_SECRET_KEY,
+  publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
+};
diff --git a/server/visitor-analytics.ts b/server/visitor-analytics.ts
@@
-import type { Request } from 'express';
+import type { Request } from 'express';
+import Stripe from 'stripe';
@@
 class VisitorAnalytics {
   private sessions: Map<string, VisitorSession> = new Map();
   private dailyStats: Map<string, AnalyticsStats> = new Map();
+  private stripe: Stripe | null = null;
+
+  constructor() {
+    const key = process.env.STRIPE_SECRET_KEY;
+    if (key) {
+      this.stripe = new Stripe(key, { apiVersion: '2023-10-16' });
+    }
+  }
@@
   getAnalytics(period: '24h' | '7d' | '30d' = '24h'): AnalyticsStats {
     // existing logic...
   }
+
+  async recordPayment(customerId: string, amount: number): Promise<void> {
+    if (!this.stripe) return;
+    try {
+      await this.stripe.customers.retrieve(customerId);
+      // TODO: persist payment with analytics stats
+    } catch (error) {
+      console.error('Stripe recordPayment error:', error);
+    }
+  }
 }
diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
@@
-import { Request, Response, Express } from 'express';
-import { z } from 'zod';
-import { db } from './db.js';
+import { Request, Response, Express } from 'express';
+import Stripe from 'stripe';
+import { z } from 'zod';
+import { db } from './db.js';
@@
   // POST /api/analytics/events - Collect analytics events (batch)
@@
   });
 
+  app.get('/api/revenue', async (_req: Request, res: Response) => {
+    try {
+      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
+        apiVersion: '2023-10-16',
+      });
+      const balance = await stripe.balance.retrieve();
+      res.json({ available: balance.available[0]?.amount ?? 0 });
+    } catch (error) {
+      console.error('Revenue endpoint error:', error);
+      res.status(500).json({ error: 'Failed to fetch revenue' });
+    }
+  });
 }
diff --git a/client/src/components/analytics/SmartAnalytics.tsx b/client/src/components/analytics/SmartAnalytics.tsx
@@
-        const [analyticsRes, statsRes] = await Promise.all([
+        const [analyticsRes, statsRes, revenueRes] = await Promise.all([
           fetch(`/api/analytics/${timeRange}`, {
             headers: {
               'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
             }
           }),
           fetch('/api/stats', {
             headers: {
               'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
             }
-          })
+          }),
+          fetch('/api/revenue', {
+            headers: {
+              'Authorization': `Bearer ${localStorage.getItem('authToken') || ''}`
+            }
+          })
         ]);
@@
-        if (!analyticsRes.ok || !statsRes.ok) {
-          throw new Error(`Analytics API failed: ${analyticsRes.status} ${statsRes.status}`);
-        }
-
-        const analytics = await analyticsRes.json();
-        const stats = await statsRes.json();
+        if (!analyticsRes.ok || !statsRes.ok) {
+          throw new Error(`Analytics API failed: ${analyticsRes.status} ${statsRes.status}`);
+        }
+
+        const [analytics, stats, revenue] = await Promise.all([
+          analyticsRes.json(),
+          statsRes.json(),
+          revenueRes.ok ? revenueRes.json() : { available: 0 }
+        ]);
@@
-        // Revenue calculation (real revenue tracking not implemented yet)
-        const REVENUE_MULTIPLIER = 0; // No revenue tracking yet
-        const REVENUE_PER_GENERATION = 0; // No revenue tracking yet
+        const totalRevenue = safeNumber(revenue.available, 0) / 100;
 
         // Transform the data to match our interface with safe operations
         return {
-          totalRevenue: Math.round(totalViews * REVENUE_MULTIPLIER),
+          totalRevenue,
           revenueChange: safeNumber(analytics.growthMetrics?.viewsGrowth, 0),
           totalViews,
@@
-                const estimatedRevenue = Math.round(numericCount * REVENUE_PER_GENERATION);
+                const estimatedRevenue = Math.round(
+                  (numericCount / totalGenerations) * totalRevenue
+                );
@@
-                revenue: Math.round(
-                  safeNumber(item?.estimatedViews, 0) * REVENUE_MULTIPLIER
-                ),
+                revenue: Math.round(
+                  safeNumber(item?.estimatedViews, 0) *
+                  safeDivide(totalRevenue, totalViews, 0)
+                ),
               }))
             : [],
diff --git a/server/vite.ts b/server/vite.ts
@@
-export function setupVite(_app: unknown, _server: unknown) {
-  return Promise.resolve();
-}
+import type { Express } from 'express';
+import { ViteDevServer, createServer } from 'vite';
+
+export async function setupVite(app: Express, httpServer: any) {
+  if (process.env.NODE_ENV !== 'development') return;
+  const vite: ViteDevServer = await createServer({
+    server: { middlewareMode: true },
+    appType: 'custom',
+  });
+  app.use(vite.middlewares);
+  httpServer.on('close', () => vite.close());
+}
diff --git a/server/services/scheduling-optimizer.ts b/server/services/scheduling-optimizer.ts
@@
-import { db } from '../db';
-import { socialMediaPosts, platformEngagement } from '@shared/schema';
-import { and, eq, gte, lte, sql, desc } from 'drizzle-orm';
+import { db } from '../db';
+import { socialMediaPosts, platformEngagement, userNiches } from '@shared/schema';
+import { and, eq, gte, lte, sql, desc } from 'drizzle-orm';
+import axios from 'axios';
@@
-  private async getTrendingTopics(): Promise<TrendingTopic[]> {
-    // In production, this would fetch from Reddit API, Twitter API, etc.
-    // For now, return mock trending topics
-    return [
-      { topic: 'Fitness transformation', platform: 'instagram', score: 85, category: 'fitness' },
-      { topic: 'Behind the scenes', platform: 'onlyfans', score: 92, category: 'exclusive' },
-      { topic: 'Cosplay showcase', platform: 'reddit', score: 78, category: 'creative' },
-      { topic: 'Quick tips', platform: 'tiktok', score: 88, category: 'educational' },
-      { topic: 'Q&A session', platform: 'twitter', score: 75, category: 'engagement' }
-    ];
-  }
-
-  private async getUserNiche(userId: number): Promise<string[]> {
-    // Analyze user's past content to determine their niche
-    // For now, return common niches
-    return ['fitness', 'creative', 'lifestyle', 'exclusive'];
-  }
+  private async getTrendingTopics(): Promise<TrendingTopic[]> {
+    try {
+      const { data } = await axios.get('https://www.reddit.com/r/popular.json');
+      return data.data.children.slice(0, 5).map((p: any) => ({
+        topic: p.data.title,
+        platform: 'reddit',
+        score: p.data.score,
+        category: p.data.subreddit.toLowerCase(),
+      }));
+    } catch (error) {
+      console.error('Trending topics error:', error);
+      return [];
+    }
+  }
+
+  private async getUserNiche(userId: number): Promise<string[]> {
+    try {
+      const rows = await db
+        .select()
+        .from(userNiches)
+        .where(eq(userNiches.userId, userId));
+      return rows.map((r) => r.niche);
+    } catch (error) {
+      console.error('User niche fetch error:', error);
+      return [];
+    }
+  }
