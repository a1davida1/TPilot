 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1,32 +1,32 @@
 import type { Express } from "express";
 import express from "express";
 import { createServer, type Server } from "http";
 import session from 'express-session';
 import path from 'path';
 import connectPgSimple from 'connect-pg-simple';
-import * as connectRedis from 'connect-redis';
+import connectRedisPkg from 'connect-redis';
 import { Pool } from 'pg';
 import Redis from 'ioredis';
 import Stripe from 'stripe';
 import passport from 'passport';
 
 // Security and middleware
 import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
 import { AppError, CircuitBreaker } from "./lib/errors.js";
 import { authenticateToken } from "./middleware/auth.js";
 
 // Route modules
 // import { authRoutes } from "./routes/auth.js"; // Removed - using server/auth.ts instead
 import { uploadRoutes, applyImageShieldProtection, protectionPresets } from "./routes/upload.js";
 import { mediaRoutes } from "./routes/media.js";
 import { analyticsRouter } from "./routes/analytics.js";
 import { referralRouter } from "./routes/referrals.js";
 import { registerExpenseRoutes } from "./expense-routes.js";
 import { adminCommunitiesRouter } from "./routes/admin-communities.js";
 
 // Core imports
 import { storage } from "./storage.js";
 import { setupAuth } from "./auth.js";
 import { setupAdminRoutes } from "./admin-routes.js";
 import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
 import { visitorAnalytics } from "./visitor-analytics.js";
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -47,51 +47,92 @@ interface AuthUser {
   isAdmin?: boolean;
 }
 
 // Auth request interface that includes user
 type SessionUser = typeof users.$inferSelect & { subscriptionTier?: string | null };
 
 interface AuthenticatedRequest extends express.Request {
   user?: SessionUser;
 }
 
 // User tier type
 type UserTier = 'free' | 'starter' | 'pro' | 'premium';
 
 // Additional interfaces for type safety
 interface PhotoInstructionsData {
   cameraAngle?: string;
   mood?: string;
   technicalSettings?: string;
   lighting?: string;
   angles?: string[];
   composition?: string;
   styling?: string;
   technical?: string[];
 }
 
-interface SessionWithReddit extends express.Session {
+type PhotoInstructionValue = string | string[] | null | undefined;
+
+const normalizeInstructionValue = (value: PhotoInstructionValue, fallback: string): string => {
+  if (Array.isArray(value)) {
+    for (const entry of value) {
+      if (typeof entry === 'string' && entry.trim().length > 0) {
+        return entry;
+      }
+    }
+    return fallback;
+  }
+
+  if (typeof value === 'string' && value.trim().length > 0) {
+    return value;
+  }
+
+  return fallback;
+};
+
+const normalizePhotoInstructions = (raw: unknown): PhotoInstructionsData => {
+  const source = (raw ?? {}) as {
+    lighting?: PhotoInstructionValue;
+    cameraAngle?: PhotoInstructionValue;
+    angles?: PhotoInstructionValue;
+    composition?: PhotoInstructionValue;
+    styling?: PhotoInstructionValue;
+    mood?: PhotoInstructionValue;
+    technicalSettings?: PhotoInstructionValue;
+    technical?: PhotoInstructionValue;
+  };
+
+  return {
+    lighting: normalizeInstructionValue(source.lighting, 'Natural lighting'),
+    cameraAngle: normalizeInstructionValue(source.cameraAngle ?? source.angles, 'Eye level'),
+    composition: normalizeInstructionValue(source.composition, 'Center composition'),
+    styling: normalizeInstructionValue(source.styling, 'Casual styling'),
+    mood: normalizeInstructionValue(source.mood, 'Confident and natural'),
+    technicalSettings: normalizeInstructionValue(source.technicalSettings ?? source.technical, 'Auto settings'),
+  };
+};
+
+interface SessionWithReddit extends session.Session {
   redditOAuthState?: string;
 }
 
 // ==========================================
 // PRO RESOURCES ROUTES
 // ==========================================
 
 function registerProResourcesRoutes(app: Express) {
   const resolveTier = (tierValue: string | null | undefined): UserTier | undefined => {
     if (tierValue === 'pro' || tierValue === 'premium' || tierValue === 'starter') {
       return tierValue;
     }
     if (tierValue === 'free') {
       return 'free';
     }
     return undefined;
   };
 
   // Helper to get user tier with storage fallback when session lacks tier information
   const getUserTier = async (user: SessionUser | undefined): Promise<UserTier> => {
     if (!user?.id) {
       return 'free';
     }
 
     if (user.subscriptionTier !== undefined && user.subscriptionTier !== null) {
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -205,51 +246,51 @@ function registerProResourcesRoutes(app: Express) {
   });
 
 }
 
 // Session interface with Reddit OAuth properties
 interface RedditSessionData {
   redditOAuthState?: string;
   redditConnected?: boolean;
 }
 
 declare module 'express-session' {
   interface SessionData extends RedditSessionData {}
 }
 
 // Service imports
 import { generateContent } from "./services/content-generator.js";
 import { generateAIContent, analyzeImageForContent } from "./services/ai-generator.js";
 import { generateWithMultiProvider, getProviderStatus } from "./services/multi-ai-provider.js";
 import { generateUnifiedAIContent, analyzeImage } from "./services/unified-ai-service.js";
 import { generateImageCaption, imageToBase64, validateImageFormat } from "./image-caption-generator.js";
 import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage.js";
 import { getRandomTemplates, addWatermark, getTemplateByMood } from "./content-templates.js";
 import { generateAdvancedContent, type ContentParameters } from "./advanced-content-generator.js";
 
 // Reddit communities now handled in reddit-routes.ts
-import { getAvailablePerks, getPerksByCategory, generateReferralCode, getSignupInstructions } from "./pro-perks.js";
+import { getAvailablePerks, getPerksByCategory, getSignupInstructions } from "./pro-perks.js";
 
 type SentryInstance = typeof import('@sentry/node');
 
 interface RegisterRoutesOptions {
   sentry?: SentryInstance | null;
 }
 import type { ProPerk } from "./pro-perks.js";
 import { ReferralManager } from './lib/referral-system.js';
 
 // API route modules
 import { registerApiRoutes } from "./api-routes.js";
 import { registerPolicyRoutes } from "./policy-routes.js";
 import { registerRedditRoutes } from "./reddit-routes.js";
 import { registerAnalyticsRoutes } from "./analytics-routes.js";
 import { createLead, confirmLead } from "./api/leads.js";
 import { getLeads } from './api/admin-leads.js';
 import { getComplianceStatus } from './api/compliance-status.js';
 import { captionRouter } from "./routes/caption.js";
 import { contentGenerationLimiter } from "./middleware/tiered-rate-limit.js";
 import { registerSocialMediaRoutes } from "./social-media-routes.js";
 
 // Schema imports
 import { insertContentGenerationSchema, insertUserImageSchema } from "@shared/schema";
 
 // Core dependencies
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -352,51 +393,51 @@ const deriveSharePercentage = (perk: ProPerk): number => {
 
 
 export async function registerRoutes(app: Express, _apiPrefix: string = '/api', options?: RegisterRoutesOptions): Promise<Server> {
   // ==========================================
   // VALIDATE ENVIRONMENT & APPLY SECURITY
   // ==========================================
 
   // Set trust proxy securely for rate limiters
   app.set('trust proxy', (ip: string) => {
     // Trust localhost and private network ranges
     return ['127.0.0.1', '::1'].includes(ip) || ip.startsWith('10.') || ip.startsWith('192.168.');
   });
 
   // Validate required environment variables first
   validateEnvironment();
 
   // Log IPs first so downstream middleware can use req.userIP
   app.use(ipLoggingMiddleware);
   app.use(securityMiddleware);
 
   // Session configuration (MUST BE BEFORE AUTH ROUTES)
   let store: session.Store | undefined;
 
   if (IS_PRODUCTION) {
     if (REDIS_URL) {
-      const { RedisStore } = connectRedis as { RedisStore: new (options: { client: unknown; prefix: string }) => session.Store };
+      const RedisStore = connectRedisPkg(session);
       const redisClient = new Redis(REDIS_URL);
       store = new RedisStore({ client: redisClient, prefix: 'sess:' });
     } else if (DATABASE_URL) {
       const PgStore = connectPgSimple(session);
       store = new PgStore({
         pool: new Pool({ connectionString: DATABASE_URL })
       });
     } else {
       throw new Error('No REDIS_URL or DATABASE_URL set in production; persistent session store required.');
     }
   }
 
   app.use(session({
     store,
     secret: SESSION_SECRET,
     resave: false, // Prevent session fixation
     saveUninitialized: false, // Only create sessions when needed
     cookie: {
       secure: IS_PRODUCTION, // HTTPS-only in production
       httpOnly: true,
       sameSite: 'lax', // Allows OAuth redirects
       maxAge: 1000 * 60 * 60 * 24 * 7 // 1 week
     },
     name: 'thottopilot.sid', // Custom session name
     rolling: true // Refresh session on activity
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -560,67 +601,69 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
 
       if (plan !== 'pro' && plan !== 'pro_plus') {
         return res.status(400).json({ message: "Invalid plan selected" });
       }
 
       // Get or create Stripe customer
       const user = await storage.getUser(req.user.id);
       let customerId = user?.stripeCustomerId;
 
       if (!customerId) {
         // Create new Stripe customer
         const customer = await stripe.customers.create({
           email: user?.email || undefined,
           metadata: {
             userId: req.user.id.toString(),
             plan: plan
           }
         });
         customerId = customer.id;
 
         // Save customer ID to database
         await storage.updateUser(req.user.id, { stripeCustomerId: customerId });
       }
 
       // Create subscription with trial period
+      const subscriptionItem: Stripe.SubscriptionCreateParams.Item = {
+        price_data: {
+          currency: 'usd',
+          product_data: {
+            name: plan === 'pro_plus' ? 'ThottoPilot Pro Plus' : 'ThottoPilot Pro',
+            description: plan === 'pro_plus'
+              ? 'Premium content creation with advanced features'
+              : 'Professional content creation and protection'
+          },
+          unit_amount: amount,
+          recurring: {
+            interval: 'month',
+          },
+        },
+      };
+
       const subscription = await stripe.subscriptions.create({
         customer: customerId,
-        items: [{
-          price_data: {
-            currency: 'usd',
-            product_data: {
-              name: plan === 'pro_plus' ? 'ThottoPilot Pro Plus' : 'ThottoPilot Pro',
-              description: plan === 'pro_plus'
-                ? 'Premium content creation with advanced features'
-                : 'Professional content creation and protection'
-            },
-            unit_amount: amount,
-            recurring: {
-              interval: 'month',
-            },
-          } as Stripe.PriceCreateParams
-        }],
+        items: [subscriptionItem],
         payment_behavior: 'default_incomplete',
         payment_settings: { save_default_payment_method: 'on_subscription' },
         expand: ['latest_invoice.payment_intent'],
         metadata: {
           userId: req.user.id.toString(),
           plan: plan
         }
       });
 
       const invoice = subscription.latest_invoice as Stripe.Invoice;
       const paymentIntent = (invoice as { payment_intent?: Stripe.PaymentIntent }).payment_intent as Stripe.PaymentIntent;
 
       res.json({
         subscriptionId: subscription.id,
         clientSecret: paymentIntent.client_secret,
       });
     } catch (error: unknown) {
       logger.error("Subscription creation error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({
         message: "Error creating subscription: " + (error instanceof Error ? (error as Error).message : 'Unknown error')
       });
     }
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -636,51 +679,51 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const user = await storage.getUser(req.user.id);
 
       if (!user?.stripeCustomerId) {
         return res.json({ hasSubscription: false, plan: 'free' });
       }
 
       // Get active subscriptions for this customer
       const subscriptions = await stripe.subscriptions.list({
         customer: user.stripeCustomerId,
         status: 'active',
         limit: 1
       });
 
       if (subscriptions.data.length > 0) {
         const subscription = subscriptions.data[0];
         const plan = subscription.metadata?.plan || 'pro';
 
         return res.json({
           hasSubscription: true,
           plan,
           subscriptionId: subscription.id,
-          currentPeriodEnd: (subscription as Stripe.Subscription).current_period_end,
+          currentPeriodEnd: subscription.current_period_end,
         });
       }
 
       return res.json({ hasSubscription: false, plan: 'free' });
     } catch (error) {
       logger.error("Subscription status error:", error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: "Failed to get subscription status" });
     }
   });
 
   // Cancel subscription
   app.post("/api/cancel-subscription", authenticateToken, async (req: AuthRequest, res) => {
     try {
       if (!stripe) {
         return res.status(503).json({ message: "Payment system not configured" });
       }
 
       if (!req.user?.id) {
         return res.status(401).json({ message: "Authentication required" });
       }
 
       const { subscriptionId } = req.body;
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -706,68 +749,51 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
       res.status(500).json({ message: "Failed to cancel subscription" });
     }
   });
 
   // ==========================================
   // CONTENT GENERATION ENDPOINTS
   // ==========================================
 
   const generateContentBreaker = new CircuitBreaker(generateContent);
   const unifiedBreaker = new CircuitBreaker(generateUnifiedAIContent);
 
   // Generate content with rate limiting
   app.post("/api/generate-content", generationLimiter, authenticateToken, async (req: AuthRequest, res, next) => {
     if (!req.user?.id) {
       return res.status(401).json({ message: "Authentication required" });
     }
     const { platform, style, theme, timing, allowsPromotion } = req.body;
     try {
       const result = await generateContentBreaker.call(
         platform || 'reddit',
         style || 'playful',
         theme || 'lingerie',
         timing,
         allowsPromotion
       );
-      const photoInstructions = {
-        lighting: Array.isArray(result.photoInstructions.lighting)
-          ? result.photoInstructions.lighting[0]
-          : result.photoInstructions.lighting || 'Natural lighting',
-        cameraAngle: Array.isArray(result.photoInstructions.angles)
-          ? result.photoInstructions.angles[0]
-          : (result.photoInstructions as PhotoInstructionsData).cameraAngle || 'Eye level',
-        composition: Array.isArray(result.photoInstructions.composition)
-          ? result.photoInstructions.composition[0]
-          : result.photoInstructions.composition || 'Center composition',
-        styling: Array.isArray(result.photoInstructions.styling)
-          ? result.photoInstructions.styling[0]
-          : result.photoInstructions.styling || 'Casual styling',
-        mood: (result.photoInstructions as PhotoInstructionsData).mood || 'Confident and natural',
-        technicalSettings: Array.isArray(result.photoInstructions.technical)
-          ? result.photoInstructions.technical[0]
-          : (result.photoInstructions as PhotoInstructionsData).technicalSettings || 'Auto settings'
-      };
+      const photoInstructions = normalizePhotoInstructions(result.photoInstructions);
       await storage.createContentGeneration({
         userId: req.user.id,
         titles: result.titles || [],
         content: result.content || '',
         photoInstructions,
         platform: platform || "reddit",
         style: style || 'playful',
         theme: theme || 'lingerie',
         createdAt: new Date()
       });
       res.json(result);
     } catch (error: unknown) {
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
     }
   });
 
   // Unified AI generation endpoint - handles both text and image workflows
   app.post('/api/generate-unified', generationLimiter, authenticateToken, upload.single('image'), async (req: AuthRequest, res, next) => {
     try {
       interface GenerationRequestBody {
         mode: string;
         prompt: string;
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -818,51 +844,51 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
           return res.status(400).json({ error: 'Invalid image format. Please use JPG, PNG, or WebP.' });
         }
         imageBase64 = imageToBase64(req.file.path);
         await fs.unlink(req.file.path).catch(console.error);
       }
 
       const result = await unifiedBreaker.call({
         mode: (mode as 'text' | 'image') || 'text',
         prompt,
         imageBase64,
         platform: platform || 'reddit',
         style: style || 'playful',
         theme,
         includePromotion: Boolean(includePromotion),
         customInstructions
       });
 
       if (req.user?.id) {
         await storage.createContentGeneration({
           userId: req.user.id,
           platform: platform || 'reddit',
           style: style || 'playful',
           theme: theme || 'general',
           titles: result.titles,
           content: result.content,
-          photoInstructions: result.photoInstructions,
+          photoInstructions: normalizePhotoInstructions(result.photoInstructions),
           prompt: prompt || customInstructions,
           allowsPromotion: Boolean(includePromotion)
         });
       }
 
       res.json({ ...result });
     } catch (error: unknown) {
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       next(error instanceof AppError ? error : new AppError('Failed to generate content', 500));
     }
   });
 
   // Get user stats
   // Debug endpoint for Reddit OAuth troubleshooting (temporary)
   app.get('/api/debug/session', (req: express.Request, res) => {
     res.json({
       sessionId: req.sessionID,
       hasSession: !!req.session,
       redditState: req.session?.redditOAuthState,
       redditConnected: req.session?.redditConnected,
       cookies: req.headers.cookie ? 'present' : 'missing'
     });
   });
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1179,68 +1205,68 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
       res.status(500).json({ message: 'Failed to fetch storage usage' });
     }
   });
 
   // AI generation endpoint - REAL
   app.post('/api/ai/generate', authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const { prompt, platforms, styleHints } = req.body;
 
       const results = await Promise.all(
         platforms.map(async (platform: string) => {
           const generated = await generateUnifiedAIContent({
             mode: 'text',
             prompt: prompt,
             platform: platform,
             style: styleHints?.[0] || 'authentic',
             theme: 'general',
             includePromotion: false,
             customInstructions: prompt
           });
 
           return {
             platform,
             titles: generated.titles,
             body: generated.content,
-            photoInstructions: generated.photoInstructions,
+            photoInstructions: normalizePhotoInstructions(generated.photoInstructions),
             hashtags: generated.hashtags || [],
             style: styleHints?.[0] || 'authentic',
             confidence: 0.95
           };
         })
       );
 
       if (req.user?.id) {
         for (const result of results) {
           await storage.createContentGeneration({
             userId: req.user.id,
             platform: result.platform,
             style: result.style,
             theme: 'general',
             titles: result.titles,
             content: result.body,
-            photoInstructions: result.photoInstructions,
+            photoInstructions: normalizePhotoInstructions(result.photoInstructions),
             prompt: prompt
           });
         }
       }
 
       res.json({
         content: results,
         tokensUsed: results.length * 250,
         model: 'multi-provider',
         cached: false
       });
     } catch (error) {
       logger.error('AI generation failed:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Generation failed' });
     }
   });
 
   // Billing payment link endpoint - REAL
   app.post('/api/billing/payment-link', authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       const { plan, provider = 'stripe' } = req.body;
       const engines = {
diff --git a/server/routes.ts b/server/routes.ts
index de66a6e90ef8532518ea0d05f4db52a4e86f9a70..d023e2a2867c4aa4e27257cf2aeb009abcf15433 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -1321,51 +1347,51 @@ export async function registerRoutes(app: Express, _apiPrefix: string = '/api',
       }
       const user = await storage.getUser(req.user.id);
 
       if (!user?.stripeCustomerId || !stripe) {
         return res.json({
           subscription: null,
           isPro: false,
           tier: user?.tier || 'free'
         });
       }
 
       const subscriptions = await stripe.subscriptions.list({
         customer: user.stripeCustomerId,
         status: 'active',
         limit: 1
       });
 
       if (subscriptions.data.length > 0) {
         const sub = subscriptions.data[0];
         return res.json({
           subscription: {
             id: sub.id,
             status: sub.status,
             plan: sub.metadata?.plan || user.tier,
             amount: sub.items.data[0].price.unit_amount,
-            nextBillDate: new Date((sub as Stripe.Subscription).current_period_end * 1000).toISOString(),
+            nextBillDate: new Date(sub.current_period_end * 1000).toISOString(),
             createdAt: new Date(sub.created * 1000).toISOString()
           },
           isPro: ['pro', 'starter'].includes(user.tier || ''),
           tier: user.tier || 'free'
         });
       }
 
       res.json({
         subscription: null,
         isPro: false,
         tier: user.tier || 'free'
       });
     } catch (error) {
       logger.error('Failed to fetch subscription:', error);
       if (options?.sentry) {
         options.sentry.captureException(error);
       }
       res.status(500).json({ message: 'Failed to fetch subscription' });
     }
   });
 
   // Social media quick post endpoint - REAL
   app.post('/api/social-media/quick-post', authenticateToken, async (req: AuthenticatedRequest, res) => {
     try {
       if (!req.user?.id) {
 
EOF
)