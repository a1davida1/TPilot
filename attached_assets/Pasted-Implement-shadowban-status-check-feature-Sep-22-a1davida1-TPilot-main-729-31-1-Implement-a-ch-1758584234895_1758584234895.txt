Implement shadowban status check feature
Sep 22 ¬∑ a1davida1/TPilot ¬∑ main
+729-31
1. Implement a `checkShadowbanStatus` helper on `RedditManager` that compares self-view vs. public listing of recent submissions to infer hidden posts.
2. Expose a protected endpoint (e.g., `GET /api/reddit/shadowban-status`) in `server/reddit-routes.ts` that returns the detection result.
3. Surface the status in the client dashboard/posting flow with clear remediation messaging.
4. Provide tests that stub Reddit API responses to cover visible vs. shadowbanned scenarios.

Summary

    Added the ShadowbanCheckResult model and a checkShadowbanStatus helper on RedditManager to normalise authenticated submissions, fetch the public listing, and flag discrepancies with timestamps and public profile links.

Published an authenticated /api/reddit/shadowban-status route that returns the new helper output for connected Reddit accounts.

Shared Reddit visibility types and surfaced proactive messaging across the posting experience and dashboard, including remediation guidance, refetch controls, and quick access to the public profile.

Added unit coverage that stubs snoowrap and fetch to prove the helper distinguishes visible submissions from shadowbanned ones.

Testing

    ‚úÖ npm run lint

‚ö†Ô∏è npm test *(aborted after numerous pre-existing suite failures and missing external credentials)*


client/src/components/modern-dashboard.tsx
+168-2
import React, { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/useAuth";
import { 
import {
  Upload,
  Sparkles,
  Shield,
  Target,
  Scale,
  BarChart3,
  Calculator,
  Gift,
  Menu,
  X,
  Clock,
  Bell,
  Settings,
  ChevronRight,
  Home,
  Brain,
  Users,
  Hash,
  History,
  ImageIcon,
  Wand2,
  Zap,
  ListChecks,
  Command
  Command,
  AlertTriangle,
  CheckCircle,
  ExternalLink,
  RefreshCw
} from "lucide-react";
import { FaReddit } from "react-icons/fa";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ShadowbanStatusResponse } from "@/types/reddit";

interface ModernDashboardProps {
  isRedditConnected?: boolean;
  user?: { id: number; username: string; email?: string; tier?: string; isVerified?: boolean };
  userTier?: 'guest' | 'free' | 'basic' | 'starter' | 'pro' | 'premium' | 'admin';
  isAdmin?: boolean;
}

interface DashboardStatsResponse {
  postsToday: number;
  engagementRate: number;
  takedownsFound: number;
  estimatedTaxSavings: number;
}

interface DashboardActivityResponse {
  recentMedia: Array<{
    id: number;
    url: string;
    alt: string;
    createdAt: string | null;
  }>;
}

export type { DashboardStatsResponse, DashboardActivityResponse };
@@ -101,50 +107,87 @@ export function ModernDashboard({ isRedditConnected = false, user, userTier = 'f
  const isAdminUser = Boolean(authUser?.isAdmin || authUser?.role === 'admin' || resolvedTier === 'admin' || isAdmin);
  const isPremium = isAdminUser || resolvedTier === 'premium' || resolvedTier === 'pro';
  const displayName = resolvedUser?.username ?? resolvedUser?.email ?? 'Creator';
  const dashboardPrompt = isAdminUser
    ? 'Review platform performance and respond to creator needs.'
    : 'What would you like to do today?';

  const {
    data: statsData,
    isLoading: statsLoading,
    error: statsError,
  } = useQuery<DashboardStatsResponse>({
    queryKey: ['/api/dashboard/stats'],
    enabled: Boolean(resolvedUser?.id),
  });

  const {
    data: activityData,
    isLoading: activityLoading,
    error: activityError,
  } = useQuery<DashboardActivityResponse>({
    queryKey: ['/api/dashboard/activity'],
    enabled: Boolean(resolvedUser?.id),
  });

  const {
    data: shadowbanStatus,
    isLoading: shadowbanLoading,
    error: shadowbanError,
    refetch: refetchShadowbanStatus,
  } = useQuery<ShadowbanStatusResponse>({
    queryKey: ['/api/reddit/shadowban-status'],
    enabled: Boolean(resolvedUser?.id && isRedditConnected),
    retry: false,
  });

  const shadowbanErrorMessage = shadowbanError instanceof Error
    ? shadowbanError.message
    : 'Unable to verify Reddit visibility.';

  const formatVisibilityCheckTime = (timestamp?: string) => {
    if (!timestamp) {
      return 'just now';
    }
    const parsed = new Date(timestamp);
    if (Number.isNaN(parsed.getTime())) {
      return 'just now';
    }
    return parsed.toLocaleString();
  };

  const formatHiddenPostDate = (createdUtc?: number) => {
    if (typeof createdUtc !== 'number') {
      return null;
    }
    const date = new Date(createdUtc * 1000);
    if (Number.isNaN(date.getTime())) {
      return null;
    }
    return date.toLocaleDateString();
  };

  useEffect(() => {
    if (statsError instanceof Error) {
      toast({
        title: "Unable to load dashboard stats",
        description: statsError.message,
      });
    }
  }, [statsError, toast]);

  useEffect(() => {
    if (activityError instanceof Error) {
      toast({
        title: "Unable to load media activity",
        description: activityError.message,
      });
    }
  }, [activityError, toast]);
  
  // Get current time greeting
  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return "Good morning";
    if (hour < 18) return "Good afternoon";
    return "Good evening";
  };
@@ -456,50 +499,173 @@ export function ModernDashboard({ isRedditConnected = false, user, userTier = 'f
        {/* Welcome Section */}
        <div className="mb-8">
          <h1 className="text-4xl md:text-5xl font-bold text-white mb-2">
            {getGreeting()}, {displayName}! üëã
          </h1>
          <p className="text-xl text-gray-300">
            {dashboardPrompt}
          </p>
        </div>

        {/* Stats Row */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
          {statsCards.map((stat) => (
            <Card key={stat.label} className="bg-gray-800 border-gray-700">
              <CardContent className="p-6">
                <div className="flex items-center justify-between mb-2">
                  <span className={stat.color}>{stat.icon}</span>
                  <span className="text-2xl font-bold text-white">{stat.value}</span>
                </div>
                <p className="text-gray-400 text-sm">{stat.label}</p>
              </CardContent>
            </Card>
          ))}
        </div>

        {isRedditConnected ? (
          <Card className="bg-gray-800 border-gray-700 mb-8">
            <CardHeader className="pb-3">
              <CardTitle className="flex items-center gap-2 text-white">
                <Shield className="h-5 w-5 text-purple-400" />
                Reddit Visibility Monitor
              </CardTitle>
              <CardDescription className="text-gray-400">
                We compare your logged-in submissions with the public feed to flag hidden posts before scheduling.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {shadowbanLoading ? (
                <div className="flex items-center gap-3 text-gray-300">
                  <div className="h-4 w-4 border-2 border-purple-400 border-t-transparent rounded-full animate-spin" />
                  <span>Running latest visibility check‚Ä¶</span>
                </div>
              ) : shadowbanError ? (
                <Alert variant="destructive" className="border-red-500/40 bg-red-500/10 text-red-100">
                  <AlertTriangle className="h-5 w-5" />
                  <AlertTitle className="text-red-100">Unable to verify Reddit visibility</AlertTitle>
                  <AlertDescription className="text-red-100/80">
                    {shadowbanErrorMessage}
                  </AlertDescription>
                </Alert>
              ) : shadowbanStatus ? (
                shadowbanStatus.isShadowbanned ? (
                  <Alert variant="destructive" className="border-orange-500/40 bg-orange-500/10 text-orange-100">
                    <AlertTriangle className="h-5 w-5" />
                    <AlertTitle className="text-orange-100">Hidden posts detected</AlertTitle>
                    <AlertDescription className="text-orange-100/90">
                      <div className="space-y-3">
                        <p>
                          {shadowbanStatus.statusMessage} {shadowbanStatus.hiddenPosts.length} of the last {shadowbanStatus.totalSelfPosts || shadowbanStatus.hiddenPosts.length} submissions are missing from the public profile.
                        </p>
                        <div className="space-y-2">
                          <p className="text-sm font-medium text-orange-50 uppercase tracking-wide">Immediate actions</p>
                          <ul className="list-disc space-y-1 pl-5 text-orange-100/80 text-sm">
                            <li>Pause all Reddit posting for 24 hours to reset account trust.</li>
                            <li>Remove or edit posts that might violate subreddit automation or link rules.</li>
                            <li>Message moderators if compliant posts stay hidden.</li>
                          </ul>
                        </div>
                      </div>
                    </AlertDescription>
                  </Alert>
                ) : (
                  <Alert className="border-emerald-500/40 bg-emerald-500/10 text-emerald-100">
                    <CheckCircle className="h-5 w-5" />
                    <AlertTitle className="text-emerald-100">All clear ‚Äì posts are visible</AlertTitle>
                    <AlertDescription className="text-emerald-100/80">
                      <div className="space-y-2">
                        <p>
                          {shadowbanStatus.publicCount} of the last {shadowbanStatus.totalSelfPosts || shadowbanStatus.publicCount} submissions appear publicly. Keep spacing posts by 10-15 minutes to stay safe.
                        </p>
                        {shadowbanStatus.error ? (
                          <p className="text-xs text-emerald-200/70">
                            Visibility note: {shadowbanStatus.error}
                          </p>
                        ) : null}
                      </div>
                    </AlertDescription>
                  </Alert>
                )
              ) : (
                <Alert className="border-purple-500/40 bg-purple-500/10 text-purple-100">
                  <Shield className="h-5 w-5" />
                  <AlertTitle className="text-purple-100">Monitoring enabled</AlertTitle>
                  <AlertDescription className="text-purple-100/80">
                    Connect a Reddit account and publish at least one post to activate visibility tracking.
                  </AlertDescription>
                </Alert>
              )}

              {shadowbanStatus?.hiddenPosts.length ? (
                <div className="rounded-lg border border-orange-500/30 bg-orange-500/5 p-4">
                  <p className="text-xs uppercase tracking-wide text-orange-200/80 mb-2">Hidden post samples</p>
                  <ul className="space-y-2 text-sm text-orange-100/90">
                    {shadowbanStatus.hiddenPosts.slice(0, 2).map((post) => {
                      const createdDate = formatHiddenPostDate(post.createdUtc);
                      return (
                        <li key={post.id}>
                          <span className="font-medium">{post.title}</span>
                          {createdDate ? <span className="text-xs text-orange-200/80"> ‚Ä¢ {createdDate}</span> : null}
                        </li>
                      );
                    })}
                  </ul>
                </div>
              ) : null}

              {shadowbanStatus ? (
                <div className="flex flex-wrap items-center justify-between gap-3 text-xs text-gray-400">
                  <span>
                    Last checked {formatVisibilityCheckTime(shadowbanStatus.checkedAt)}
                  </span>
                  <div className="flex flex-wrap items-center gap-3">
                    <Button
                      size="sm"
                      variant="outline"
                      className="border-purple-500/60 text-purple-100 hover:bg-purple-500/10"
                      onClick={() => refetchShadowbanStatus()}
                      disabled={shadowbanLoading}
                    >
                      <RefreshCw className="h-4 w-4 mr-1" />
                      Re-run check
                    </Button>
                    <a
                      href={shadowbanStatus.publicListingUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="flex items-center gap-1 text-purple-200 hover:text-purple-100"
                    >
                      View public profile
                      <ExternalLink className="h-3 w-3" />
                    </a>
                  </div>
                </div>
              ) : null}
            </CardContent>
          </Card>
        ) : null}

        {/* Action Cards Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
          {actionCards.map((card) => (
            <Card
              key={card.id}
              className={cn(
                "bg-gray-800 border-gray-700 cursor-pointer transition-all hover:scale-105",
                selectedCard === card.id && "ring-2 ring-purple-500"
              )}
              onClick={() => handleCardClick(card)}
              onMouseEnter={() => setSelectedCard(card.id)}
              onMouseLeave={() => setSelectedCard(null)}
            >
              <CardContent className="p-6">
                <div className={cn(
                  "w-12 h-12 rounded-lg bg-gradient-to-br flex items-center justify-center mb-4",
                  card.color
                )}>
                  {card.icon}
                </div>
                <h3 className="text-white font-semibold mb-1">{card.title}</h3>
                <p className="text-gray-400 text-sm">{card.description}</p>
                {card.comingSoon && (
                  <Badge className="mt-2" variant="outline">Coming Soon</Badge>
                )}
client/src/pages/reddit-posting.tsx
+172-28
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/useAuth';
import { apiRequest } from '@/lib/queryClient';
import { AuthModal } from '@/components/auth-modal';
import { 
  Send, 
  Calendar,
  User,
  Eye,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Link as LinkIcon,
  Globe,
  Settings,
  Clock,
  BarChart3,
  Users,
  TrendingUp,
  Zap,
  Shield,
  FileText,
  TestTube,
  ExternalLink,
  ImageIcon,
  Images,
  LogIn,
  UserCheck
  UserCheck,
  RefreshCw
} from 'lucide-react';
import { MediaLibrarySelector } from '@/components/MediaLibrarySelector';
import { ShadowbanStatusResponse } from '@/types/reddit';

interface RedditAccount {
  id: number;
  username: string;
  isActive: boolean;
  connectedAt: string;
  karma: number;
  verified: boolean;
}

interface SubredditCommunity {
  id: string;
  name: string;
  displayName: string;
  members: number;
  engagementRate: number;
  category: string;
  promotionAllowed: string;
  bestPostingTimes: string[];
  averageUpvotes: number;
  successProbability: number;
  description: string;
  rules: {
    minKarma: number;
    minAccountAge: number;
@@ -156,62 +158,97 @@ export default function RedditPostingPage() {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const toggleMediaSelection = (assetId: number) => {
    setSelectedMediaIds((prev) => {
      if (prev.includes(assetId)) {
        return prev.filter((id) => id !== assetId);
      }
      return [...prev, assetId];
    });
  };

  const handleCaptionChange = (assetId: number, caption: string) => {
    setMediaCaptions((prev) => ({ ...prev, [assetId]: caption }));
  };

  // Fetch Reddit accounts
  const { data: accounts = [], isLoading: accountsLoading } = useQuery<RedditAccount[]>({
    queryKey: ['/api/reddit/accounts'],
    retry: false,
  });

  const {
    data: shadowbanStatus,
    isLoading: shadowbanLoading,
    isError: shadowbanError,
    error: shadowbanStatusError,
    refetch: refetchShadowbanStatus,
  } = useQuery<ShadowbanStatusResponse>({
    queryKey: ['/api/reddit/shadowban-status'],
    enabled: !accountsLoading && accounts.length > 0,
    retry: false,
  });

  // Fetch subreddit communities data
  const { data: communities = [] } = useQuery<SubredditCommunity[]>({
    queryKey: ['/api/reddit/communities'],
    retry: false,
  });

  // Fetch media assets
  const { data: mediaAssets = [], isLoading: mediaLoading } = useQuery<MediaAsset[]>({
    queryKey: ['/api/media'],
    retry: false,
  });

  const shadowbanErrorMessage = shadowbanStatusError instanceof Error
    ? shadowbanStatusError.message
    : 'Unable to verify Reddit visibility.';

  const formatVisibilityCheckTime = (timestamp: string) => {
    const parsed = new Date(timestamp);
    if (Number.isNaN(parsed.getTime())) {
      return 'just now';
    }
    return parsed.toLocaleString();
  };

  const formatHiddenPostDate = (createdUtc?: number) => {
    if (typeof createdUtc !== 'number') {
      return null;
    }
    const date = new Date(createdUtc * 1000);
    if (Number.isNaN(date.getTime())) {
      return null;
    }
    return date.toLocaleDateString();
  };

  const selectedAssets = mediaAssets.filter((asset) => selectedMediaIds.includes(asset.id));

  // Test Reddit connection
  const { mutate: testConnection, isPending: testingConnection } = useMutation({
    mutationFn: async () => {
      const response = await apiRequest('POST', '/api/reddit/test');
      return response.json();
    },
    onSuccess: (data: ConnectionTestResponse) => {
      toast({
        title: "‚úÖ Connection Test",
        description: data.connected ? 
          `Connected as ${data.profile?.username} (${data.profile?.karma} karma)` : 
          "Connection failed",
        variant: data.connected ? "default" : "destructive"
      });
    },
    onError: (error: Error) => {
      toast({
        title: "‚ùå Connection Failed",
        description: error.message,
        variant: "destructive"
      });
    }
  });
@@ -438,79 +475,186 @@ export default function RedditPostingPage() {
              </div>
            </div>
          </CardHeader>
        </Card>

        <div className="grid lg:grid-cols-3 gap-6">
          
          {/* Main Posting Interface */}
          <div className="lg:col-span-2 space-y-6">
            
            {/* Account Status */}
            <Card className="bg-white/90 backdrop-blur-sm border-pink-200 shadow-lg">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <User className="h-5 w-5" />
                  Reddit Account Status
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {accountsLoading ? (
                    <div className="flex items-center gap-2">
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-orange-500 border-t-transparent" />
                      <span className="text-sm text-gray-600">Loading accounts...</span>
                    </div>
                  ) : accounts?.length > 0 ? (
                    <div className="space-y-3">
                      {accounts.map((account) => (
                        <div key={account.id} className="flex items-center justify-between p-3 bg-green-50 rounded-lg border border-green-200">
                          <div className="flex items-center gap-3">
                            <div className="w-3 h-3 bg-green-500 rounded-full" />
                            <div>
                              <p className="font-medium text-green-800">u/{account.username}</p>
                              <p className="text-sm text-green-600">{account.karma} karma ‚Ä¢ Connected {new Date(account.connectedAt).toLocaleDateString()}</p>
                  ) : accounts.length > 0 ? (
                    <>
                      <div className="space-y-3">
                        {accounts.map((account) => (
                          <div key={account.id} className="flex items-center justify-between p-3 bg-green-50 rounded-lg border border-green-200">
                            <div className="flex items-center gap-3">
                              <div className="w-3 h-3 bg-green-500 rounded-full" />
                              <div>
                                <p className="font-medium text-green-800">u/{account.username}</p>
                                <p className="text-sm text-green-600">{account.karma} karma ‚Ä¢ Connected {new Date(account.connectedAt).toLocaleDateString()}</p>
                              </div>
                            </div>
                            <div className="flex gap-2">
                              <Badge variant="outline" className="text-green-700 border-green-300">
                                {account.verified ? 'Verified' : 'Active'}
                              </Badge>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => testConnection()}
                                disabled={testingConnection}
                                className="border-green-300 text-green-700 hover:bg-green-50"
                              >
                                <TestTube className="h-4 w-4 mr-1" />
                                Test
                              </Button>
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Badge variant="outline" className="text-green-700 border-green-300">
                              {account.verified ? 'Verified' : 'Active'}
                            </Badge>
                            <Button 
                              size="sm" 
                              variant="outline"
                              onClick={() => testConnection()}
                              disabled={testingConnection}
                              className="border-green-300 text-green-700 hover:bg-green-50"
                            >
                              <TestTube className="h-4 w-4 mr-1" />
                              Test
                            </Button>
                        ))}
                      </div>
                      <div className="pt-4 border-t border-green-200 space-y-3">
                        {shadowbanLoading ? (
                          <div className="flex items-center gap-2 text-sm text-green-700">
                            <div className="animate-spin rounded-full h-4 w-4 border-2 border-green-500 border-t-transparent" />
                            <span>Checking for hidden posts...</span>
                          </div>
                        </div>
                      ))}
                    </div>
                        ) : shadowbanError ? (
                          <Alert variant="destructive" className="border-red-300 bg-red-50 text-red-700">
                            <AlertTriangle className="h-5 w-5" />
                            <AlertTitle className="text-red-800">Unable to verify Reddit visibility</AlertTitle>
                            <AlertDescription>
                              <p>{shadowbanErrorMessage}</p>
                              <p className="mt-2 text-xs text-red-600">
                                Reconnect your Reddit account or try again later.
                              </p>
                            </AlertDescription>
                          </Alert>
                        ) : shadowbanStatus ? (
                          shadowbanStatus.isShadowbanned ? (
                            <Alert variant="destructive" className="border-orange-300 bg-orange-50 text-orange-800">
                              <AlertTriangle className="h-5 w-5" />
                              <AlertTitle className="text-orange-900">Posts may be hidden from the public feed</AlertTitle>
                              <AlertDescription>
                                <div className="space-y-3">
                                  <p>
                                    {shadowbanStatus.statusMessage} We found {shadowbanStatus.hiddenPosts.length} of your last {shadowbanStatus.totalSelfPosts || shadowbanStatus.hiddenPosts.length} posts missing from the public profile view.
                                  </p>
                                  {shadowbanStatus.hiddenPosts.length > 0 && (
                                    <div className="space-y-1">
                                      <p className="font-medium text-orange-900">Hidden post samples:</p>
                                      <ul className="list-disc space-y-1 pl-5 text-orange-800/90">
                                        {shadowbanStatus.hiddenPosts.slice(0, 3).map((post) => {
                                          const createdDate = formatHiddenPostDate(post.createdUtc);
                                          return (
                                            <li key={post.id}>
                                              <span className="font-medium">{post.title}</span>
                                              {createdDate ? <span className="text-xs text-orange-700"> ‚Ä¢ {createdDate}</span> : null}
                                            </li>
                                          );
                                        })}
                                      </ul>
                                    </div>
                                  )}
                                  <div className="space-y-1">
                                    <p className="font-medium text-orange-900">Recommended recovery steps:</p>
                                    <ul className="list-disc space-y-1 pl-5 text-orange-800/90">
                                      <li>Pause all Reddit posting for 24 hours to reset trust and avoid additional hidden posts.</li>
                                      <li>Review subreddit rules and remove content that might trigger moderator filters.</li>
                                      <li>Reach out to subreddit moderators if legitimate posts remain hidden.</li>
                                    </ul>
                                  </div>
                                </div>
                              </AlertDescription>
                            </Alert>
                          ) : (
                            <Alert className="border-green-300 bg-green-50 text-green-700">
                              <CheckCircle className="h-5 w-5" />
                              <AlertTitle className="text-green-800">Recent posts are visible</AlertTitle>
                              <AlertDescription>
                                <div className="space-y-2">
                                  <p>
                                    {shadowbanStatus.publicCount} of your last {shadowbanStatus.totalSelfPosts || shadowbanStatus.publicCount} posts are showing on your public profile.
                                  </p>
                                  <p className="text-xs text-green-700/80">
                                    Keep spacing posts by 10-15 minutes and avoid repetitive links to stay in good standing.
                                  </p>
                                  {shadowbanStatus.error ? (
                                    <p className="text-xs text-green-700/70">
                                      Visibility note: {shadowbanStatus.error}
                                    </p>
                                  ) : null}
                                </div>
                              </AlertDescription>
                            </Alert>
                          )
                        ) : null}
                        {shadowbanStatus ? (
                          <div className="flex flex-wrap items-center justify-between gap-3 text-xs text-green-700/80">
                            <span>
                              Last checked {formatVisibilityCheckTime(shadowbanStatus.checkedAt)}
                            </span>
                            <div className="flex flex-wrap items-center gap-3">
                              <Button
                                size="sm"
                                variant="outline"
                                className="border-green-300 text-green-700 hover:bg-green-100"
                                onClick={() => refetchShadowbanStatus()}
                                disabled={shadowbanLoading}
                              >
                                <RefreshCw className="h-4 w-4 mr-1" />
                                Re-run check
                              </Button>
                              <a
                                href={shadowbanStatus.publicListingUrl}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="flex items-center gap-1 text-green-700 hover:text-green-800"
                              >
                                View public profile
                                <ExternalLink className="h-3 w-3" />
                              </a>
                            </div>
                          </div>
                        ) : null}
                      </div>
                    </>
                  ) : (
                    <div className="text-center p-6 bg-orange-50 rounded-lg border border-orange-200">
                      <Globe className="h-12 w-12 text-orange-500 mx-auto mb-3" />
                      <h3 className="font-medium text-orange-800 mb-2">No Reddit Account Connected</h3>
                      <p className="text-sm text-orange-600 mb-4">Connect your Reddit account to start posting</p>
                      <Button 
                        onClick={() => connectReddit()}
                        disabled={connectingReddit}
                        className="bg-orange-500 hover:bg-orange-600 text-white"
                      >
                        {connectingReddit ? (
                          <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2" />
                        ) : (
                          <LinkIcon className="h-4 w-4 mr-2" />
                        )}
                        Connect Reddit Account
                      </Button>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Post Creation */}
            <Card className="bg-white/90 backdrop-blur-sm border-pink-200 shadow-lg">
client/src/types/reddit.ts
New
+19-0
export interface ShadowbanSubmission {
  id: string;
  title: string;
  permalink: string;
  createdUtc?: number;
}

export interface ShadowbanStatusResponse {
  username: string;
  isShadowbanned: boolean;
  hiddenPosts: ShadowbanSubmission[];
  recentSubmissions: Array<ShadowbanSubmission & { isPublic: boolean }>;
  publicCount: number;
  totalSelfPosts: number;
  checkedAt: string;
  statusMessage: string;
  publicListingUrl: string;
  error?: string;
}
server/lib/reddit.ts
+214-0
@@ -23,50 +23,74 @@ export interface RedditPostOptions {
  title: string;
  body?: string;
  url?: string;
  nsfw?: boolean;
  spoiler?: boolean;
}

export interface RedditPostResult {
  success: boolean;
  postId?: string;
  url?: string;
  error?: string;
}

export interface PostingPermission {
  canPost: boolean;
  reason?: string;
  nextAllowedPost?: Date;
}

interface RedditSubmission {
  id: string;
  permalink: string;
}

export interface ShadowbanCheckResult {
  username: string;
  isShadowbanned: boolean;
  hiddenPosts: Array<{
    id: string;
    title: string;
    permalink: string;
    createdUtc?: number;
  }>;
  recentSubmissions: Array<{
    id: string;
    title: string;
    permalink: string;
    createdUtc?: number;
    isPublic: boolean;
  }>;
  publicCount: number;
  totalSelfPosts: number;
  checkedAt: string;
  statusMessage: string;
  publicListingUrl: string;
  error?: string;
}

export class RedditManager {
  private reddit: snoowrap;
  private userId: number;

  constructor(accessToken: string, refreshToken: string, userId: number) {
    this.userId = userId;
    this.reddit = new snoowrap({
      userAgent: REDDIT_USER_AGENT,
      clientId: REDDIT_CLIENT_ID,
      clientSecret: REDDIT_CLIENT_SECRET,
      accessToken,
      refreshToken,
    });
  }

  /**
   * Get Reddit manager for a specific user
   */
  static async forUser(userId: number): Promise<RedditManager | null> {
    try {
      const [account] = await db
        .select()
        .from(creatorAccounts)
        .where(
          and(
@@ -468,50 +492,240 @@ export class RedditManager {
      const user = await (this.reddit as unknown as {
        getMe(): Promise<{
          name: string;
          link_karma: number;
          comment_karma: number;
          created_utc: number;
          verified: boolean;
          is_gold: boolean;
          has_mail: boolean;
        }>;
      }).getMe();
      return {
        username: user.name,
        karma: user.link_karma + user.comment_karma,
        created: user.created_utc,
        verified: user.verified,
        goldStatus: user.is_gold,
        hasMail: user.has_mail,
      };
    } catch (error) {
      console.error('Failed to get Reddit profile:', error);
      return null;
    }
  }

  /**
   * Compare authenticated vs public listings to infer hidden submissions
   */
  async checkShadowbanStatus(limit = 5): Promise<ShadowbanCheckResult> {
    let username = 'unknown';

    try {
      const reddit = await this.initReddit();
      const me = await (reddit as unknown as {
        getMe(): Promise<{ name: string }>;
      }).getMe();

      username = me.name || 'unknown';
      const normalizedUsername = username.replace(/^u\//, '');

      const userSubmissions = await (reddit as unknown as {
        getUser(name: string): {
          getSubmissions(input: { limit: number }): Promise<Array<{
            id?: string;
            name?: string;
            title?: string;
            permalink?: string;
            created_utc?: number;
            created?: number;
          }>>;
        };
      }).getUser(normalizedUsername).getSubmissions({ limit });

      const makeAbsolutePermalink = (permalink: string | undefined): string => {
        if (!permalink) {
          return '';
        }
        return permalink.startsWith('http') ? permalink : `https://www.reddit.com${permalink}`;
      };

      const normalizeSubmission = (submission: {
        id?: string;
        name?: string;
        title?: string;
        permalink?: string;
        created_utc?: number;
        created?: number;
      }): {
        id: string;
        title: string;
        permalink: string;
        createdUtc?: number;
      } | null => {
        const submissionId = submission.id
          || (submission.name && submission.name.includes('_') ? submission.name.split('_')[1] : submission.name)
          || '';

        if (!submissionId) {
          return null;
        }

        const createdUtc = typeof submission.created_utc === 'number'
          ? submission.created_utc
          : typeof submission.created === 'number'
            ? submission.created
            : undefined;

        return {
          id: submissionId,
          title: submission.title ?? 'Untitled post',
          permalink: makeAbsolutePermalink(submission.permalink),
          createdUtc,
        };
      };

      const normalizedSelfSubmissions = userSubmissions
        .map(normalizeSubmission)
        .filter((submission): submission is {
          id: string;
          title: string;
          permalink: string;
          createdUtc?: number;
        } => Boolean(submission));

      const publicListingUrl = `https://www.reddit.com/user/${normalizedUsername}/submitted/`;
      let publicListingFailed = false;

      let publicIds = new Set<string>();
      try {
        const response = await fetch(`${publicListingUrl}.json?limit=${limit}`, {
          headers: {
            'User-Agent': REDDIT_USER_AGENT,
          },
        });

        if (!response.ok) {
          publicListingFailed = true;
        } else {
          const payload = (await response.json()) as unknown;
          const children = (payload as {
            data?: {
              children?: Array<unknown>;
            };
          })?.data?.children ?? [];

          const publicSubmissions = children
            .map((child) => {
              if (!child || typeof child !== 'object') {
                return null;
              }
              const childData = (child as { data?: unknown }).data;
              if (!childData || typeof childData !== 'object') {
                return null;
              }
              const submissionData = childData as {
                id?: string;
                permalink?: string;
                title?: string;
                created_utc?: number;
              };
              if (!submissionData.id) {
                return null;
              }
              return {
                id: submissionData.id,
                permalink: makeAbsolutePermalink(submissionData.permalink),
                title: submissionData.title ?? 'Untitled post',
                createdUtc: submissionData.created_utc,
              };
            })
            .filter((submission): submission is {
              id: string;
              permalink: string;
              title: string;
              createdUtc?: number;
            } => Boolean(submission));

          publicIds = new Set(publicSubmissions.map((submission) => submission.id));
        }
      } catch (error) {
        console.error('Failed to fetch public Reddit listing:', error);
        publicListingFailed = true;
      }

      if (publicListingFailed) {
        publicIds = new Set(normalizedSelfSubmissions.map((submission) => submission.id));
      }

      const recentSubmissions = normalizedSelfSubmissions.map((submission) => ({
        ...submission,
        isPublic: publicIds.has(submission.id),
      }));

      const hiddenPosts = recentSubmissions.filter((submission) => !submission.isPublic);
      const totalSelfPosts = recentSubmissions.length;
      const publicCount = recentSubmissions.filter((submission) => submission.isPublic).length;

      const isShadowbanned = hiddenPosts.length > 0 && !publicListingFailed;

      return {
        username: normalizedUsername,
        isShadowbanned,
        hiddenPosts: hiddenPosts.map((submission) => ({
          id: submission.id,
          title: submission.title,
          permalink: submission.permalink,
          createdUtc: submission.createdUtc,
        })),
        recentSubmissions,
        publicCount,
        totalSelfPosts,
        checkedAt: new Date().toISOString(),
        statusMessage: isShadowbanned
          ? 'Recent submissions are missing from the public profile.'
          : 'Recent submissions are visible on the public profile.',
        publicListingUrl,
        error: publicListingFailed ? 'Unable to verify public listing. Shadowban status may be incomplete.' : undefined,
      };
    } catch (error) {
      console.error('Failed to check Reddit shadowban status:', error);
      return {
        username,
        isShadowbanned: false,
        hiddenPosts: [],
        recentSubmissions: [],
        publicCount: 0,
        totalSelfPosts: 0,
        checkedAt: new Date().toISOString(),
        statusMessage: 'Unable to verify Reddit visibility at this time.',
        publicListingUrl: `https://www.reddit.com/user/${username}/submitted/`,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Test Reddit connection
   */
  async testConnection(): Promise<boolean> {
    try {
      await (this.reddit as unknown as {
        getMe(): Promise<unknown>;
      }).getMe();
      return true;
    } catch (error) {
      console.error('Reddit connection test failed:', error);
      return false;
    }
  }

  /**
   * Refresh access token if needed
   */
  async refreshTokenIfNeeded(): Promise<void> {
    try {
      // snoowrap handles token refresh automatically
      await (this.reddit as unknown as {
        getMe(): Promise<unknown>;
      }).getMe();
    } catch (error) {
server/reddit-routes.ts
+21-1
import type { Express } from 'express';
import crypto from 'crypto';
import { RedditManager, getRedditAuthUrl, exchangeRedditCode } from './lib/reddit.js';
import { RedditManager, getRedditAuthUrl, exchangeRedditCode, type ShadowbanCheckResult } from './lib/reddit.js';
import { db } from './db.js';
import { creatorAccounts } from '@shared/schema';
import { eq, and } from 'drizzle-orm';
import { authenticateToken, type AuthRequest } from './middleware/auth.js';
import { stateStore, encrypt, decrypt, rateLimit } from './services/state-store.js';
import {
  listCommunities,
  searchCommunities,
  getCommunityInsights,
  createCommunity,
  updateCommunity,
  deleteCommunity
} from './reddit-communities.js';
import { logger } from './bootstrap/logger.js';

interface RedditProfile {
  username: string;
  karma?: number;
  verified?: boolean;
}

export function registerRedditRoutes(app: Express) {
  
  // Start Reddit OAuth flow - SECURE VERSION
  app.get('/api/reddit/connect', rateLimit, authenticateToken, async (req: AuthRequest, res) => {
@@ -340,50 +340,70 @@ export function registerRedditRoutes(app: Express) {
                lastTested: Date.now()
              },
              updatedAt: new Date()
            })
            .where(eq(creatorAccounts.id, account.id));
        }
        
        res.json({ 
          connected: true, 
          profile: {
            username: profile?.username,
            karma: profile?.karma,
            verified: profile?.verified
          }
        });
      } else {
        res.json({ connected: false });
      }

    } catch (error) {
      console.error('Reddit test error:', error);
      res.status(500).json({ error: 'Failed to test Reddit connection' });
    }
  });

  app.get('/api/reddit/shadowban-status', authenticateToken, async (req: AuthRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const redditManager = await RedditManager.forUser(userId);
      if (!redditManager) {
        return res.status(404).json({ error: 'No active Reddit account found' });
      }

      const status: ShadowbanCheckResult = await redditManager.checkShadowbanStatus();
      return res.json(status);
    } catch (error) {
      console.error('Failed to check Reddit shadowban status:', error);
      return res.status(500).json({ error: 'Unable to determine Reddit shadowban status' });
    }
  });

  // Enhanced submit endpoint with image support
  app.post('/api/reddit/submit', authenticateToken, async (req: AuthRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      
      const { subreddit, title, body, url, nsfw, spoiler, postType, imageData } = req.body;

      if (!subreddit || !title) {
        return res.status(400).json({ error: 'Subreddit and title are required' });
      }

      // Get Reddit manager
      const reddit = await RedditManager.forUser(userId);
      if (!reddit) {
        return res.status(404).json({ 
          error: 'No active Reddit account found. Please connect your Reddit account first.' 
        });
      }

      let result;
      
      // Handle different post types
tests/unit/reddit/shadowban-status.test.ts
New
+135-0
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { RedditManager } from '../../../server/lib/reddit';

type SubmissionShape = {
  id?: string;
  title?: string;
  permalink?: string;
  created_utc?: number;
};

type GetSubmissionsFn = (input: { limit: number }) => Promise<SubmissionShape[]>;

const getMeMock = vi.fn<[], Promise<{ name: string }>>();
const getSubmissionsMock = vi.fn<GetSubmissionsFn>();
const getUserMock = vi.fn<(username: string) => { getSubmissions: GetSubmissionsFn }>();

vi.mock('snoowrap', () => ({
  default: vi.fn().mockImplementation(() => ({
    getMe: getMeMock,
    getUser: getUserMock,
  })),
}));

describe('RedditManager.checkShadowbanStatus', () => {
  let redditManager: RedditManager;
  const originalFetch: typeof fetch = global.fetch;

  beforeEach(() => {
    getMeMock.mockReset();
    getSubmissionsMock.mockReset();
    getUserMock.mockReset();

    getMeMock.mockResolvedValue({ name: 'shadowban_tester' });
    getUserMock.mockReturnValue({ getSubmissions: getSubmissionsMock });
    global.fetch = originalFetch;

    redditManager = new RedditManager('access-token', 'refresh-token', 42);
  });

  afterEach(() => {
    global.fetch = originalFetch;
    vi.clearAllMocks();
  });

  it('returns non-shadowbanned status when public listings match', async () => {
    const submissions: SubmissionShape[] = [
      {
        id: 'abc123',
        title: 'Visible Post 1',
        permalink: '/r/test/comments/abc123/visible_post_1',
        created_utc: 1700000000,
      },
      {
        id: 'def456',
        title: 'Visible Post 2',
        permalink: '/r/test/comments/def456/visible_post_2',
        created_utc: 1700000500,
      },
    ];

    getSubmissionsMock.mockResolvedValue(submissions);

    const fetchMock = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => ({
        data: {
          children: submissions.map((submission) => ({
            data: {
              id: submission.id,
              title: submission.title,
              permalink: submission.permalink,
              created_utc: submission.created_utc,
            },
          })),
        },
      }),
    } as Response);

    global.fetch = fetchMock as unknown as typeof fetch;

    const status = await redditManager.checkShadowbanStatus();

    expect(status.isShadowbanned).toBe(false);
    expect(status.hiddenPosts).toHaveLength(0);
    expect(status.publicCount).toBe(2);
    expect(status.totalSelfPosts).toBe(2);
    expect(status.recentSubmissions.every((submission) => submission.isPublic)).toBe(true);
  });

  it('marks missing submissions as hidden when public listing omits them', async () => {
    const submissions: SubmissionShape[] = [
      {
        id: 'abc123',
        title: 'Visible Post',
        permalink: '/r/test/comments/abc123/visible_post',
        created_utc: 1700000000,
      },
      {
        id: 'def456',
        title: 'Potentially Hidden Post',
        permalink: '/r/test/comments/def456/hidden_post',
        created_utc: 1700000600,
      },
    ];

    getSubmissionsMock.mockResolvedValue(submissions);

    const fetchMock = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => ({
        data: {
          children: [
            {
              data: {
                id: submissions[0]?.id,
                title: submissions[0]?.title,
                permalink: submissions[0]?.permalink,
                created_utc: submissions[0]?.created_utc,
              },
            },
          ],
        },
      }),
    } as Response);

    global.fetch = fetchMock as unknown as typeof fetch;

    const status = await redditManager.checkShadowbanStatus();

    expect(status.isShadowbanned).toBe(true);
    expect(status.hiddenPosts).toHaveLength(1);
    expect(status.hiddenPosts[0]?.id).toBe('def456');
    expect(status.recentSubmissions.find((submission) => submission.id === 'def456')?.isPublic).toBe(false);
  });
});
