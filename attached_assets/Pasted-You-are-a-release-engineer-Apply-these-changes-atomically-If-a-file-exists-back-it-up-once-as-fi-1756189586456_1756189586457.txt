You are a release engineer. Apply these changes atomically. If a file exists, back it up once as <filename>.bak before writing. Stop on any error and print the failing command and last 100 lines.

GOAL
- Add Stripe billing with Starter + Pro (Pro price A/B test via 3 price IDs)
- Add checkout endpoints + Stripe webhook
- Add simple feature gating by tier (Starter vs Pro)
- Add minimal analytics event logger using existing event_logs table
- DO NOT drop or modify DB tables beyond writing rows into existing tables

PRECHECK
RUN: node -e "console.log('node',process.version)"
RUN: npm -v

1) Install Stripe (types are bundled):
RUN: npm i stripe

2) Package.json scripts sanity (keep dev/start as TSX with tsconfig-paths if already set; do NOT remove existing db:* scripts)
RUN: node -e "const fs=require('fs');const p=require('./package.json');if(!p.scripts.typecheck){p.scripts.typecheck='tsc -p tsconfig.json --noEmit';fs.writeFileSync('package.json',JSON.stringify(p,null,2))}"

3) Create billing client:
WRITE: server/lib/billing/stripe.ts
<<<TS
import Stripe from "stripe";
export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-06-20",
});
TS

4) Event tracking utility -> inserts into event_logs (Drizzle expected):
WRITE: server/lib/analytics.ts
<<<TS
import { db } from "@server/db";
import { eventLogs } from "@shared/schema";
export async function trackEvent(userId: number | null, type: string, meta: any = {}) {
  try {
    await db.insert(eventLogs).values({
      userId: userId ?? null,
      type,
      meta
    });
  } catch (e) {
    // swallow analytics errors
    console.error("trackEvent failed", e);
  }
}
TS

5) Pro pricing A/B buckets (3 Stripe prices). Stable per-user:
WRITE: server/lib/pricing.ts
<<<TS
import crypto from "crypto";

export type ProBucket = "a"|"b"|"c";
export function bucketForUser(userId: string): ProBucket {
  const h = crypto.createHash("sha1").update(userId).digest();
  const n = h[0]; // 0..255
  if (n < 85) return "a";   // ~33%
  if (n < 170) return "b";  // ~33%
  return "c";               // ~33%
}

export function proPriceIdForBucket(b: ProBucket): string {
  const map: Record<ProBucket,string> = {
    a: process.env.STRIPE_PRICE_PRO_29!,
    b: process.env.STRIPE_PRICE_PRO_39!,
    c: process.env.STRIPE_PRICE_PRO_49!,
  };
  return map[b];
}
TS

6) Feature gating middleware (pull tier from users or subscriptions). This uses the users.tier if present; if not, falls back to subscriptions.status=active:
WRITE: server/middleware/require-tier.ts
<<<TS
import type { RequestHandler } from "express";
import { db } from "@server/db";
import { users, subscriptions } from "@shared/schema";
import { eq } from "drizzle-orm";

const ranks = ["starter","pro","premium","enterprise"] as const;
type Tier = typeof ranks[number];

function rankOf(tier: string | null | undefined): number {
  const i = ranks.indexOf((tier ?? "starter") as Tier);
  return i >= 0 ? i : 0;
}

export function requireTier(minTier: Tier): RequestHandler {
  return async (req: any, res, next) => {
    try {
      const uid = req.user?.id as number | undefined;
      if (!uid) return res.status(401).json({ error: "unauthorized" });

      // 1) prefer users.tier if exists
      const u = (await db.select({ tier: users.tier }).from(users).where(eq(users.id, uid)).limit(1))[0];
      let tier = u?.tier ?? "starter";

      // 2) if users.tier absent/unknown, check subscriptions
      if (!u?.tier || u.tier === "starter") {
        const sub = (await db.select({
          status: subscriptions.status, plan: subscriptions.plan
        }).from(subscriptions).where(eq(subscriptions.userId, uid)).limit(1))[0];
        if (sub?.status === "active" && sub.plan) tier = sub.plan; // 'pro' or 'premium'
      }

      if (rankOf(tier) < rankOf(minTier)) {
        return res.status(402).json({ error: "upgrade_required", required: minTier, current: tier });
      }
      next();
    } catch (e) {
      next(e);
    }
  };
}
TS

7) Billing routes: list prices (with user bucket), create checkout session
WRITE: server/routes/billing.ts
<<<TS
import type { Express, Request, Response } from "express";
import { stripe } from "@server/lib/billing/stripe";
import { bucketForUser, proPriceIdForBucket } from "@server/lib/pricing";
import { trackEvent } from "@server/lib/analytics";

function getBaseUrl(req: Request) {
  const h = req.headers["x-forwarded-host"] || req.headers.host;
  const proto = (req.headers["x-forwarded-proto"] as string) || "https";
  return `${proto}://${h}`;
}

export function mountBillingRoutes(app: Express) {
  // returns which Pro price this user sees (A/B bucket)
  app.get("/api/billing/prices", async (req: any, res: Response) => {
    const uid = req.user?.id?.toString() || req.ip;
    const bucket = bucketForUser(uid);
    const proPriceId = proPriceIdForBucket(bucket);
    res.json({
      starter: { id: process.env.STRIPE_PRICE_STARTER || null, label: "$9.99" },
      pro: { id: proPriceId, bucket, label: "Pro" }
    });
  });

  // creates a Stripe Checkout Session and returns url
  app.post("/api/billing/checkout", async (req: any, res: Response) => {
    const user = req.user;
    if (!user) return res.status(401).json({ error: "unauthorized" });
    const uid = user.id.toString();
    const bucket = bucketForUser(uid);
    const priceId = (req.body?.priceId as string) || proPriceIdForBucket(bucket);

    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      payment_method_types: ["card"],
      line_items: [{ price: priceId, quantity: 1 }],
      customer_email: user.email || undefined,
      success_url: `${getBaseUrl(req)}/billing/success`,
      cancel_url: `${getBaseUrl(req)}/billing/cancel`,
      metadata: { userId: uid, bucket },
    });

    await trackEvent(user.id, "checkout_started", { priceId, bucket });
    res.json({ url: session.url });
  });
}
TS

8) Stripe webhook: update subscriptions/invoices & mirror users.tier
WRITE: server/routes/webhooks.stripe.ts
<<<TS
import type { Express, Request, Response } from "express";
import { stripe } from "@server/lib/billing/stripe";
import { db } from "@server/db";
import { subscriptions, invoices, users } from "@shared/schema";
import { eq } from "drizzle-orm";

export function mountStripeWebhook(app: Express) {
  // IMPORTANT: raw body for Stripe signature verification. Ensure your server uses express.raw on this path.
  app.post("/api/webhooks/stripe", async (req: Request, res: Response) => {
    const sig = req.headers["stripe-signature"] as string;
    let event;
    try {
      // @ts-expect-error raw body provided by express.raw in server bootstrap
      event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
    } catch (err: any) {
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    switch (event.type) {
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "customer.subscription.deleted": {
        const sub = event.data.object as any;
        const uid = Number(sub.metadata?.userId);
        const plan = (sub.items?.data?.[0]?.price?.nickname || sub.items?.data?.[0]?.price?.metadata?.plan || "pro").toLowerCase();

        if (uid) {
          // upsert subscription
          await db.insert(subscriptions).values({
            userId: uid,
            status: sub.status,
            plan: plan,
            priceCents: (sub.items?.data?.[0]?.price?.unit_amount ?? 0),
            processor: "stripe",
            processorSubId: sub.id
          }).onConflictDoUpdate({
            target: subscriptions.userId,
            set: {
              status: sub.status, plan,
              priceCents: (sub.items?.data?.[0]?.price?.unit_amount ?? 0),
              processor: "stripe",
              processorSubId: sub.id
            }
          });

          // mirror to users.tier for quick checks
          const newTier = sub.status === "active" ? plan : "starter";
          await db.update(users).set({ tier: newTier }).where(eq(users.id, uid));
        }
        break;
      }

      case "invoice.paid":
      case "invoice.payment_failed": {
        const inv = event.data.object as any;
        const uid = Number(inv.metadata?.userId);
        if (uid) {
          await db.insert(invoices).values({
            subscriptionId: 0, // unknown without join; keep 0 or extend schema/lookup if needed
            amountCents: inv.amount_paid ?? 0,
            status: inv.paid ? "paid" : "failed",
            processor: "stripe",
            processorRef: inv.id
          }).catch(()=>{});
        }
        break;
      }
    }
    res.json({ received: true });
  });
}
TS

9) Wire routes into your server. Modify server/index.ts to ensure:
- express.raw on /api/webhooks/stripe
- mountStripeWebhook and mountBillingRoutes
- keep existing routes

BACKUP: server/index.ts
EDIT (append or patch safely): server/index.ts
FIND (once): "import { registerRoutes } from \"./routes\""
IF NOT FOUND, just proceed to next steps (assume your project has equivalent).
ENSURE the following imports exist (add them if missing):
ADD IMPORT: import express from "express";
ADD IMPORT: import { mountStripeWebhook } from "./routes/webhooks.stripe";
ADD IMPORT: import { mountBillingRoutes } from "./routes/billing";

Ensure raw body ONLY on the webhook path, and json elsewhere. If you currently call app.use(express.json()) before everything, insert this BEFORE that line:
INSERT BEFORE JSON PARSER:
app.post("/api/webhooks/stripe", express.raw({ type: "application/json" }), (_req,_res,next)=>next());

Then, after parsers/sessions and before registerRoutes(app) call, add:
mountStripeWebhook(app);
mountBillingRoutes(app);

10) Minimal pricing API smoke:
WRITE: scripts/smoke-billing.sh
<<<BASH
#!/usr/bin/env bash
set -euo pipefail
: "${URL:?Set URL to your running base}"
curl -sfS "$URL/api/billing/prices" | grep -E '"pro"|bucket' >/dev/null
echo "billing prices endpoint OK"
BASH
RUN: chmod +x scripts/smoke-billing.sh

11) Typecheck:
RUN: npm run typecheck

12) Reminders (print):
PRINT:
Set these in Replit Secrets (workspace AND deployment):
- STRIPE_SECRET_KEY
- STRIPE_WEBHOOK_SECRET
- STRIPE_PRICE_STARTER (optional if you expose Starter in checkout)
- STRIPE_PRICE_PRO_29, STRIPE_PRICE_PRO_39, STRIPE_PRICE_PRO_49
After deploy, run: URL="https://<your-deploy>" ./scripts/smoke-billing.sh
