Update ranking criteria and tests
Sep 20 · a1davida1/TPilot · main
+620-93
1. Update `prompts/rank.txt` to add criteria such as “Disqualify any option containing sparkle-filler (‘Check out this amazing content’, ‘✨ Enhanced’), generic hashtags, or repeated CTA templates; explain the specific violations in the reason.”
2. In both `rankAndSelect` functions, inspect the chosen `final` caption; if it matches a banned phrase regex, trigger another ranking round with a hint or discard the offending variant before re-ranking.
3. Create regression tests confirming the ranking layer never returns captions containing the known filler phrases and instead surfaces human-sounding alternatives.

Summary

    Updated the ranking prompt to explicitly reject sparkle filler, generic hashtags, and repeated CTA templates while documenting the retry payload format.

Introduced a shared ranking guard that normalizes placeholders, filters banned phrases/hashtags/CTAs, and rewires the Gemini, text-only, and rewrite rankers to retry with hints before falling back to sanitized variants.

Added regression tests that confirm the ranking layer suppresses the known filler phrases and returns human-sounding alternatives.

Testing

    ✅ npm run lint

❌ npm test (fails due to numerous pre-existing environment-dependent integration/unit test issues such as missing storage queue configuration, payment provider mocks, and image shield dependencies)

✅ npx vitest run tests/unit/caption-ranking.test.ts


prompts/rank.txt
+4-1
Rank the 5 for Relevance(40), Voice(25), Originality(20), CTA(10), Safety(5).
Disqualify any option containing sparkle-filler ("Check out this amazing content", "✨ Enhanced"), generic placeholder hashtags (#content, #creative, #amazing, #lifestyle), or repeated CTA templates like "Check it out"/"Click the link". Explain the exact violations in the reason.
You receive JSON: {"variants":[...],"retry_hint":string|null,"banned_examples":string[]}.
If retry_hint is provided, obey it strictly, drop the flagged options, and choose the most human alternative.
Return JSON:
{"winner_index":0,"scores":[0,0,0,0,0],"reason":"<240 chars","final":{"caption":"","alt":"","hashtags":[],"cta":"","mood":"","style":"","safety_level":""}}
Trim hashtags to platform limits.
Trim hashtags to platform limits.
server/caption/geminiPipeline.ts
+113-28
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { visionModel, textModel } from "../lib/gemini";
import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  bannedExamples,
  detectRankingViolations,
  formatViolations,
  sanitizeVariantForRanking,
  safeFallbackCaption,
  safeFallbackCta,
  safeFallbackHashtags,
  normalizeVariantForRanking,
  truncateReason,
  type CaptionVariant,
} from "./rankingGuards";

// Custom error class for image validation failures
export class InvalidImageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidImageError';
  }
}

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: z.infer<typeof CaptionItem>;
  facts?: Record<string, unknown>;
  variants?: z.infer<typeof CaptionArray>;
  ranked?: z.infer<typeof RankResult>;
}

async function load(p: string): Promise<string> {
  return fs.readFile(path.join(process.cwd(), "prompts", p), "utf8");
}
async function b64(url: string): Promise<{ base64: string; mimeType: string }> {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new InvalidImageError(`fetch failed: ${r.status} ${r.statusText}`);
@@ -206,118 +218,191 @@ export async function generateVariants(params: {
  mood?: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
}): Promise<z.infer<typeof CaptionArray>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}IMAGE_FACTS: ${JSON.stringify(params.facts)}\nNSFW: ${params.nsfw || false}\n${params.hint?`HINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json = stripToJSON(res.response.text()) as unknown[];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length < 2) variant.mood = "engaging";
      if(typeof variant.style !== 'string' || variant.style.length < 2) variant.style = "authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = "Check it out";
      if(typeof variant.cta !== 'string' || variant.cta.length < 2) variant.cta = safeFallbackCta;
      if(typeof variant.alt !== 'string' || variant.alt.length < 20) variant.alt = "Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags = ["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length < 1) variant.caption = "Check out this amazing content!";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 1) variant.hashtags = [...safeFallbackHashtags];
      if(typeof variant.caption !== 'string' || variant.caption.trim().length < 1) variant.caption = safeFallbackCaption;
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        caption: safeFallbackCaption,
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        hashtags: [...safeFallbackHashtags],
        cta: safeFallbackCta,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
const MAX_RANK_ATTEMPTS = 3;

interface PromptBundle {
  sys: string;
  guard: string;
  prompt: string;
}

interface RankingAttemptResult {
  parsed: z.infer<typeof RankResult>;
  normalizedFinal: CaptionVariant;
  violations: string[];
}

async function executeRankingAttempt(
  variants: z.infer<typeof CaptionArray>,
  prompts: PromptBundle,
  retryHint?: string
): Promise<RankingAttemptResult> {
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
    const payload = {
      variants,
      retry_hint: retryHint ?? null,
      banned_examples: bannedExamples,
    };
    res = await textModel.generateContent([
      { text: `${prompts.sys}\n${prompts.guard}\n${prompts.prompt}\n${JSON.stringify(payload)}` },
    ]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];

  if (Array.isArray(json)) {
    const winner = (json[0] as CaptionVariant | undefined) ?? variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
      final: winner,
    };
  }
  
  // Accept any safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

  if (!json || typeof json !== 'object') {
    throw new Error('Ranking response missing body');
  }

  const container = json as { final?: Record<string, unknown> };
  if (!container.final || typeof container.final !== 'object') {
    throw new Error('Ranking response missing final caption');
  }
  return RankResult.parse(json);

  const normalizedFinal = normalizeVariantForRanking(container.final);
  const violations = detectRankingViolations(normalizedFinal);
  const sanitizedFinal = sanitizeVariantForRanking(normalizedFinal);
  container.final = sanitizedFinal;

  const parsed = RankResult.parse(json);

  return { parsed, normalizedFinal, violations };
}

async function rankAndSelectWithRetry(
  variants: z.infer<typeof CaptionArray>,
  attempt: number,
  prompts: PromptBundle,
  retryHint?: string
): Promise<z.infer<typeof RankResult>> {
  const { parsed, normalizedFinal, violations } = await executeRankingAttempt(variants, prompts, retryHint);

  if (violations.length === 0) {
    return parsed;
  }

  if (attempt + 1 >= MAX_RANK_ATTEMPTS) {
    const safeIndex = variants.findIndex((variant) => detectRankingViolations(variant).length === 0);
    if (safeIndex >= 0) {
      const safeVariant = sanitizeVariantForRanking(variants[safeIndex]);
      return {
        ...parsed,
        winner_index: safeIndex,
        final: safeVariant,
        reason: truncateReason(
          `Fallback to variant ${safeIndex + 1} after violations: ${formatViolations(violations)}`
        ),
      };
    }

    const sanitized = sanitizeVariantForRanking(normalizedFinal);
    return {
      ...parsed,
      final: sanitized,
      reason: truncateReason(`Sanitized disqualified caption (${formatViolations(violations)})`),
    };
  }

  const hint = `Previous winner broke rules (${formatViolations(violations)}). Ignore those entries and pick the most human alternative.`;
  return rankAndSelectWithRetry(variants, attempt + 1, prompts, hint);
}

export async function rankAndSelect(variants: z.infer<typeof CaptionArray>): Promise<z.infer<typeof RankResult>> {
  const prompts: PromptBundle = {
    sys: await load("system.txt"),
    guard: await load("guard.txt"),
    prompt: await load("rank.txt"),
  };
  return rankAndSelectWithRetry(variants, 0, prompts);
}

export async function pipeline({ imageUrl, platform, voice = "flirty_playful", style, mood, nsfw = false }: {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  style?: string;
  mood?: string;
  nsfw?: boolean;
}): Promise<CaptionResult> {
  try {
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, style, mood, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({ platform, voice, facts, hint:`Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`, nsfw });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
server/caption/rankingGuards.ts
New
+151-0
import { z } from "zod";
import { CaptionItem } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";

const CAPTION_RULES: Array<{ pattern: RegExp; description: string }> = [
  { pattern: /check out this amazing content!?/i, description: 'sparkle filler "Check out this amazing content"' },
  { pattern: /\u2728\s*enhanced/i, description: 'sparkle filler "✨ Enhanced"' },
];

const CTA_RULES: Array<{ pattern: RegExp; description: string }> = [
  { pattern: /check (it )?out!?/i, description: 'recycled CTA "Check it out"' },
  { pattern: /click (the )?link/i, description: 'recycled CTA "Click the link"' },
  { pattern: /learn more/i, description: 'recycled CTA "Learn more"' },
];

const GENERIC_HASHTAGS = new Set([
  '#content',
  '#creative',
  '#amazing',
  '#lifestyle',
  '#viral',
  '#follow',
  '#instagood',
]);

const SAFE_HASHTAG_POOL = ['#dailyvibes', '#behindthescenes', '#personalnote', '#momentcaptured'];
const SAFE_CTA = 'Tell me what you think';
const SAFE_CAPTION_REPLACEMENT = 'Sharing a little moment from today.';

export const bannedExamples = [
  'Check out this amazing content!',
  '✨ Enhanced',
  '#content / #creative / #amazing',
  'CTA: Check it out',
];

export type CaptionVariant = z.infer<typeof CaptionItem>;

function dedupeHashtags(tags: string[]): string[] {
  const seen = new Set<string>();
  const result: string[] = [];
  for (const tag of tags) {
    const normalized = tag.trim();
    if (!normalized) continue;
    const key = normalized.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    result.push(normalized);
  }
  return result;
}

export function detectRankingViolations(variant: CaptionVariant): string[] {
  const issues: string[] = [];

  for (const rule of CAPTION_RULES) {
    if (rule.pattern.test(variant.caption)) {
      issues.push(rule.description);
    }
  }

  const flaggedTags = variant.hashtags.filter((tag) => GENERIC_HASHTAGS.has(tag.toLowerCase()));
  if (flaggedTags.length > 0) {
    issues.push(`generic hashtags (${flaggedTags.join(', ')})`);
  }

  for (const rule of CTA_RULES) {
    if (rule.pattern.test(variant.cta)) {
      issues.push(rule.description);
      break;
    }
  }

  return issues;
}

export function hasRankingViolations(variant: CaptionVariant): boolean {
  return detectRankingViolations(variant).length > 0;
}

function ensureHashtagCount(existing: string[]): string[] {
  const filled = [...existing];
  for (const tag of SAFE_HASHTAG_POOL) {
    if (filled.length >= Math.max(existing.length, 3)) break;
    if (!filled.some((existingTag) => existingTag.toLowerCase() === tag.toLowerCase())) {
      filled.push(tag);
    }
  }
  return filled.length > 0 ? filled : SAFE_HASHTAG_POOL.slice(0, 3);
}

export function sanitizeVariantForRanking(variant: CaptionVariant): CaptionVariant {
  let caption = variant.caption;
  for (const rule of CAPTION_RULES) {
    caption = caption.replace(rule.pattern, SAFE_CAPTION_REPLACEMENT);
  }
  caption = caption.replace(/\s{2,}/g, ' ').trim();

  const filteredTags = dedupeHashtags(
    variant.hashtags.filter((tag) => !GENERIC_HASHTAGS.has(tag.toLowerCase()))
  );
  const hashtags = ensureHashtagCount(filteredTags);

  const needsCtaReplacement = CTA_RULES.some((rule) => rule.pattern.test(variant.cta));
  const cta = needsCtaReplacement ? SAFE_CTA : variant.cta;

  return {
    ...variant,
    caption,
    hashtags,
    cta,
  };
}

export function formatViolations(violations: string[]): string {
  return violations.join('; ');
}

export const safeFallbackCta = SAFE_CTA;
export const safeFallbackCaption = SAFE_CAPTION_REPLACEMENT;
export const safeFallbackHashtags = SAFE_HASHTAG_POOL.slice(0, 3);

export function normalizeVariantForRanking(final: Record<string, unknown>): CaptionVariant {
  const candidate = {
    caption: typeof final.caption === 'string' ? final.caption : SAFE_CAPTION_REPLACEMENT,
    alt:
      typeof final.alt === 'string' && final.alt.length >= 20
        ? final.alt
        : "Engaging social media content",
    hashtags:
      Array.isArray(final.hashtags) && final.hashtags.length > 0
        ? final.hashtags.map(tag => String(tag)).slice(0, 10)
        : SAFE_HASHTAG_POOL.slice(0, 3),
    cta:
      typeof final.cta === 'string' && final.cta.length >= 2
        ? final.cta
        : SAFE_CTA,
    mood: typeof final.mood === 'string' && final.mood.length >= 2 ? final.mood : 'engaging',
    style: typeof final.style === 'string' && final.style.length >= 2 ? final.style : 'authentic',
    safety_level: normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    ),
    nsfw: typeof final.nsfw === 'boolean' ? final.nsfw : false,
  } satisfies Record<string, unknown>;

  return CaptionItem.parse(candidate);
}

export function truncateReason(text: string, limit = 240): string {
  return text.length > limit ? `${text.slice(0, limit - 3)}...` : text;
}
server/caption/rewritePipeline.ts
+115-27
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { textModel, visionModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  bannedExamples,
  detectRankingViolations,
  formatViolations,
  normalizeVariantForRanking,
  sanitizeVariantForRanking,
  safeFallbackCaption,
  safeFallbackCta,
  safeFallbackHashtags,
  truncateReason,
  type CaptionVariant,
} from "./rankingGuards";

// CaptionResult interface for type safety
interface CaptionResult {
  provider: string;
  final: unknown;
  facts?: unknown;
  variants?: unknown;
  ranked?: unknown;
}

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
async function b64(url:string){ const r=await fetch(url); if(!r.ok) throw new Error("fetch failed"); const b=Buffer.from(await r.arrayBuffer()); return b.toString("base64"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

export async function variantsRewrite(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, existingCaption:string, facts?:Record<string, unknown>, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rewrite.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}EXISTING_CAPTION: "${params.existingCaption}"${params.facts?`\nIMAGE_FACTS: ${JSON.stringify(params.facts)}`:""}\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  const json=stripToJSON(res.response.text()) as unknown;
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta=safeFallbackCta;
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags)) variant.hashtags=["#content", "#creative", "#amazing"];
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content, you'll love it and want more!";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length<1) variant.hashtags=[...safeFallbackHashtags];
      if(typeof variant.caption !== 'string' || variant.caption.trim().length<1) variant.caption=safeFallbackCaption;
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content, you'll love it and want more!",
        caption: safeFallbackCaption,
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        hashtags: [...safeFallbackHashtags],
        cta: safeFallbackCta,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} This enhanced version provides much more engaging content and better call-to-action for your audience! (Variant ${json.length + 1})`
        caption: `${template.caption as string} Freshened up with sharper detail and a warmer invitation for readers. (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[]){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
const MAX_RANK_ATTEMPTS = 3;

interface PromptBundle {
  sys: string;
  guard: string;
  prompt: string;
}

interface RankingAttemptResult {
  parsed: z.infer<typeof RankResult>;
  normalizedFinal: CaptionVariant;
  violations: string[];
}

async function executeRankingAttempt(
  variants: z.infer<typeof CaptionArray>,
  prompts: PromptBundle,
  retryHint?: string
): Promise<RankingAttemptResult> {
  let res;
  try {
    res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
    const payload = {
      variants,
      retry_hint: retryHint ?? null,
      banned_examples: bannedExamples,
    };
    res = await textModel.generateContent([
      { text: `${prompts.sys}\n${prompts.guard}\n${prompts.prompt}\n${JSON.stringify(payload)}` },
    ]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object

  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
    const winner = (json[0] as CaptionVariant | undefined) ?? variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
    };
  }
  
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags)) final.hashtags=["#content", "#creative", "#amazing"];
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

  if(!json || typeof json !== 'object') {
    throw new Error('Ranking response missing body');
  }

  const container = json as { final?: Record<string, unknown> };
  if(!container.final || typeof container.final !== 'object') {
    throw new Error('Ranking response missing final caption');
  }

  const normalizedFinal = normalizeVariantForRanking(container.final);
  const violations = detectRankingViolations(normalizedFinal);
  const sanitizedFinal = sanitizeVariantForRanking(normalizedFinal);
  container.final = sanitizedFinal;

  const parsed = RankResult.parse(json);

  return { parsed, normalizedFinal, violations };
}

async function rankAndSelectWithRetry(
  variants: z.infer<typeof CaptionArray>,
  attempt: number,
  prompts: PromptBundle,
  retryHint?: string
): Promise<z.infer<typeof RankResult>> {
  const { parsed, normalizedFinal, violations } = await executeRankingAttempt(variants, prompts, retryHint);

  if (violations.length === 0) {
    return parsed;
  }

  if (attempt + 1 >= MAX_RANK_ATTEMPTS) {
    const safeIndex = variants.findIndex((variant) => detectRankingViolations(variant).length === 0);
    if (safeIndex >= 0) {
      const safeVariant = sanitizeVariantForRanking(variants[safeIndex]);
      return {
        ...parsed,
        winner_index: safeIndex,
        final: safeVariant,
        reason: truncateReason(
          `Fallback to variant ${safeIndex + 1} after violations: ${formatViolations(violations)}`
        ),
      };
    }

    const sanitized = sanitizeVariantForRanking(normalizedFinal);
    return {
      ...parsed,
      final: sanitized,
      reason: truncateReason(`Sanitized disqualified caption (${formatViolations(violations)})`),
    };
  }
  return RankResult.parse(json);

  const hint = `Previous winner broke rules (${formatViolations(violations)}). Ignore those entries and pick the most human alternative.`;
  return rankAndSelectWithRetry(variants, attempt + 1, prompts, hint);
}

export async function rankAndSelect(variants: unknown[]){
  const typedVariants = CaptionArray.parse(variants);
  const prompts: PromptBundle = {
    sys: await load("system.txt"),
    guard: await load("guard.txt"),
    prompt: await load("rank.txt"),
  };
  return rankAndSelectWithRetry(typedVariants, 0, prompts);
}

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;
    let variants = await variantsRewrite({ platform, voice, style, mood, existingCaption, facts, nsfw });
    let ranked = await rankAndSelect(variants);
    let out = ranked.final;
    
    // Ensure rewritten caption is longer and more engaging than original
    if(out.caption.length <= existingCaption.length) {
      out.caption = existingCaption + " ✨ Enhanced with engaging content and call-to-action that drives better engagement!";
      out.caption = `${existingCaption} — refreshed with richer detail and a clearer invite to respond.`;
    }

    const err = platformChecks(platform, out);
    if (err) {
      variants = await variantsRewrite({ platform, voice, existingCaption, facts, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, existingCaption, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/textOnlyPipeline.ts
+126-37
import fs from "node:fs/promises";
import path from "node:path";
import { z } from "zod";
import { textModel } from "../lib/gemini";
import { CaptionArray, RankResult, platformChecks } from "./schema";
import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
import {
  bannedExamples,
  detectRankingViolations,
  formatViolations,
  normalizeVariantForRanking,
  sanitizeVariantForRanking,
  safeFallbackCaption,
  safeFallbackCta,
  safeFallbackHashtags,
  truncateReason,
  type CaptionVariant,
} from "./rankingGuards";

async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
  const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }

export async function generateVariantsTextOnly(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, style?:string, mood?:string, theme:string, context?:string, hint?:string, nsfw?:boolean}){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants_textonly.txt");
  const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\n${params.style ? `STYLE: ${params.style}\n` : ''}${params.mood ? `MOOD: ${params.mood}\n` : ''}THEME: "${params.theme}"\nCONTEXT: "${params.context||''}"\nNSFW: ${params.nsfw || false}${params.hint?`\nHINT:${params.hint}`:""}`;
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
  const raw=stripToJSON(res.response.text());
  const json=Array.isArray(raw)?raw:[raw];
  // Fix common safety_level values and missing fields
  if(Array.isArray(json)){
    json.forEach((item) => {
      const variant = item as Record<string, unknown>;
      variant.safety_level = normalizeSafetyLevel(
        typeof variant.safety_level === 'string' ? variant.safety_level : 'normal'
      );
      // Fix other fields
      if(typeof variant.mood !== 'string' || variant.mood.length<2) variant.mood="engaging";
      if(typeof variant.style !== 'string' || variant.style.length<2) variant.style="authentic";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta="Check it out";
      if(typeof variant.cta !== 'string' || variant.cta.length<2) variant.cta=safeFallbackCta;
      if(typeof variant.alt !== 'string' || variant.alt.length<20) variant.alt="Engaging social media content";
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 3) {
      if(!Array.isArray(variant.hashtags) || variant.hashtags.length < 1) {
        const base = [...safeFallbackHashtags];
        if(params.platform === 'instagram') {
          variant.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
        } else {
          variant.hashtags=["#content", "#creative", "#amazing"];
          base.push('#capturedtoday');
        }
        variant.hashtags = base;
      }
      if(typeof variant.caption !== 'string' || variant.caption.length<1) variant.caption="Check out this amazing content!";
      if(typeof variant.caption !== 'string' || variant.caption.trim().length<1) variant.caption=safeFallbackCaption;
    });

    // Ensure exactly 5 variants by padding with variations if needed
    while(json.length < 5) {
      const template = (json[0] as Record<string, unknown>) || {
        caption: "Check out this amazing content!",
        caption: safeFallbackCaption,
        alt: "Engaging social media content",
        hashtags: ["#content", "#creative", "#amazing"],
        cta: "Check it out",
        hashtags: [...safeFallbackHashtags],
        cta: safeFallbackCta,
        mood: "engaging",
        style: "authentic",
        safety_level: normalizeSafetyLevel('normal'),
        nsfw: false
      };
      json.push({
        ...template,
        caption: `${template.caption as string} (Variant ${json.length + 1})`
      });
    }

    // Trim to exactly 5 if more than 5
    if(json.length > 5) {
      json.splice(5);
    }
  }
  return CaptionArray.parse(json);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
  const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
  let json=stripToJSON(res.response.text()) as unknown;
  
  // Handle case where AI returns array instead of ranking object
  if(Array.isArray(json)) {
    const winner = json[0] || variants[0];
const MAX_RANK_ATTEMPTS = 3;

interface PromptBundle {
  sys: string;
  guard: string;
  prompt: string;
}

interface RankingAttemptResult {
  parsed: z.infer<typeof RankResult>;
  normalizedFinal: CaptionVariant;
  violations: string[];
}

async function executeRankingAttempt(
  variants: z.infer<typeof CaptionArray>,
  prompts: PromptBundle,
  retryHint?: string
): Promise<RankingAttemptResult> {
  let res;
  try {
    const payload = {
      variants,
      retry_hint: retryHint ?? null,
      banned_examples: bannedExamples,
    };
    res = await textModel.generateContent([
      { text: `${prompts.sys}\n${prompts.guard}\n${prompts.prompt}\n${JSON.stringify(payload)}` },
    ]);
  } catch (error) {
    console.error('Gemini textModel.generateContent failed:', error);
    throw error;
  }
  let json = stripToJSON(res.response.text()) as unknown;

  if (Array.isArray(json)) {
    const winner = (json[0] as CaptionVariant | undefined) ?? variants[0];
    json = {
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: "Selected based on engagement potential",
      final: winner
      final: winner,
    };
  }
  
  // Fix safety_level in final result
  if((json as Record<string, unknown>).final){
    const final = (json as { final: Record<string, unknown> }).final;
    final.safety_level = normalizeSafetyLevel(
      typeof final.safety_level === 'string' ? final.safety_level : 'normal'
    );
    if(typeof final.mood !== 'string' || final.mood.length<2) final.mood="engaging";
    if(typeof final.style !== 'string' || final.style.length<2) final.style="authentic";
    if(typeof final.cta !== 'string' || final.cta.length<2) final.cta="Check it out";
    if(typeof final.alt !== 'string' || final.alt.length<20) final.alt="Engaging social media content";
    if(!Array.isArray(final.hashtags) || final.hashtags.length < 3) {
      if(params?.platform === 'instagram') {
        final.hashtags=["#content", "#creative", "#amazing", "#lifestyle"];
      } else {
        final.hashtags=["#content", "#creative", "#amazing"];
      }

  if (!json || typeof json !== 'object') {
    throw new Error('Ranking response missing body');
  }

  const container = json as { final?: Record<string, unknown> };
  if (!container.final || typeof container.final !== 'object') {
    throw new Error('Ranking response missing final caption');
  }

  const normalizedFinal = normalizeVariantForRanking(container.final);
  const violations = detectRankingViolations(normalizedFinal);
  const sanitizedFinal = sanitizeVariantForRanking(normalizedFinal);
  container.final = sanitizedFinal;

  const parsed = RankResult.parse(json);

  return { parsed, normalizedFinal, violations };
}

async function rankAndSelectWithRetry(
  variants: z.infer<typeof CaptionArray>,
  attempt: number,
  prompts: PromptBundle,
  retryHint?: string
): Promise<z.infer<typeof RankResult>> {
  const { parsed, normalizedFinal, violations } = await executeRankingAttempt(variants, prompts, retryHint);

  if (violations.length === 0) {
    return parsed;
  }

  if (attempt + 1 >= MAX_RANK_ATTEMPTS) {
    const safeIndex = variants.findIndex((variant) => detectRankingViolations(variant).length === 0);
    if (safeIndex >= 0) {
      const safeVariant = sanitizeVariantForRanking(variants[safeIndex]);
      return {
        ...parsed,
        winner_index: safeIndex,
        final: safeVariant,
        reason: truncateReason(
          `Fallback to variant ${safeIndex + 1} after violations: ${formatViolations(violations)}`
        ),
      };
    }
    if(typeof final.caption !== 'string' || final.caption.length<1) final.caption="Check out this amazing content!";

    const sanitized = sanitizeVariantForRanking(normalizedFinal);
    return {
      ...parsed,
      final: sanitized,
      reason: truncateReason(`Sanitized disqualified caption (${formatViolations(violations)})`),
    };
  }
  return RankResult.parse(json);

  const hint = `Previous winner broke rules (${formatViolations(violations)}). Ignore those entries and pick the most human alternative.`;
  return rankAndSelectWithRetry(variants, attempt + 1, prompts, hint);
}

export async function rankAndSelect(variants: unknown[], params?: { platform?: string; nsfw?: boolean }){
  const typedVariants = CaptionArray.parse(variants);
  const prompts: PromptBundle = {
    sys: await load("system.txt"),
    guard: await load("guard.txt"),
    prompt: await load("rank.txt"),
  };
  void params?.nsfw;
  void params?.platform;
  return rankAndSelectWithRetry(typedVariants, 0, prompts);
}

export async function pipelineTextOnly({ platform, voice="flirty_playful", style, mood, theme, context, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, theme:string, context?:string, nsfw?:boolean }){
  let variants = await generateVariantsTextOnly({ platform, voice, style, mood, theme, context, nsfw });
  let ranked = await rankAndSelect(variants, { platform, nsfw });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, hint:`Fix: ${err}. Be specific and engaging.`, nsfw });
    ranked = await rankAndSelect(variants);
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/unit/caption-ranking.test.ts
New
+111-0
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { rankAndSelect as rankGemini } from '../../server/caption/geminiPipeline.js';
import { rankAndSelect as rankTextOnly } from '../../server/caption/textOnlyPipeline.js';
import { CaptionArray } from '../../server/caption/schema.js';

vi.mock('../../server/lib/gemini.js', () => ({
  textModel: {
    generateContent: vi.fn(),
  },
  visionModel: {
    generateContent: vi.fn(),
  },
}));

const bannedVariant = {
  caption: 'Check out this amazing content!',
  alt: 'A descriptive alt text that easily exceeds twenty characters for validation.',
  hashtags: ['#content', '#creative', '#amazing'],
  cta: 'Check it out',
  mood: 'engaging',
  style: 'authentic',
  safety_level: 'normal',
  nsfw: false,
};

const baseSafeVariant = {
  alt: 'A descriptive alt text that easily exceeds twenty characters for validation.',
  hashtags: ['#morning', '#coffee', '#quiettime'],
  cta: 'Tell me what you think',
  mood: 'calm',
  style: 'authentic',
  safety_level: 'normal',
  nsfw: false,
};

function buildSafeVariant(caption: string, hashtags: string[]): (typeof baseSafeVariant & { caption: string }) {
  return {
    ...baseSafeVariant,
    caption,
    hashtags,
  };
}

function rankingResponse(finalVariant: unknown, winnerIndex = 0) {
  return {
    response: {
      text: () =>
        JSON.stringify({
          winner_index: winnerIndex,
          scores: [5, 4, 3, 2, 1],
          reason: 'Selected during test',
          final: finalVariant,
        }),
    },
  };
}

describe('ranking guardrails', () => {
  beforeEach(async () => {
    const { textModel } = await import('../../server/lib/gemini.js');
    (textModel.generateContent as unknown as { mockClear: () => void }).mockClear?.();
    vi.clearAllMocks();
  });

  it('reranks to avoid sparkle filler for the gemini pipeline', async () => {
    const variants = CaptionArray.parse([
      bannedVariant,
      buildSafeVariant('Morning light, favorite mug, ready to edit.', ['#morning', '#coffee', '#workflow']),
      buildSafeVariant('Studio glow and a playlist on repeat.', ['#studio', '#playlist', '#focusmode']),
      buildSafeVariant('City skyline check-in before the day starts.', ['#city', '#sunrise', '#dailyview']),
      buildSafeVariant('Notes spread out and ideas flowing freely.', ['#brainstorm', '#notes', '#makerlife']),
    ]);

    const { textModel } = await import('../../server/lib/gemini.js');
    (textModel.generateContent as unknown as { mockResolvedValueOnce: Function })
      .mockResolvedValueOnce(rankingResponse(bannedVariant, 0))
      .mockResolvedValueOnce(rankingResponse(variants[1], 1));

    const result = await rankGemini(variants);

    expect(result.final.caption).toBe(variants[1].caption);
    expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
    expect(result.final.hashtags).not.toContain('#content');
    expect((textModel.generateContent as unknown as { mock: { calls: unknown[][] } }).mock.calls.length).toBe(2);
  });

  it('sanitizes repetitive filler when the ranker refuses to change its mind', async () => {
    const variants = CaptionArray.parse([
      bannedVariant,
      buildSafeVariant('Cozy desk vibes and a to-do I actually want to tackle.', ['#desk', '#today', '#intentional']),
      buildSafeVariant('Golden hour walk to reset the brain.', ['#goldenhour', '#walk', '#reset']),
      buildSafeVariant('Packing up gear for tonight\'s shoot.', ['#gear', '#shoot', '#prep']),
      buildSafeVariant('Quick journaling session before lights out.', ['#journal', '#nightly', '#routine']),
    ]);

    const bannedResponse = rankingResponse(bannedVariant, 0);
    const { textModel } = await import('../../server/lib/gemini.js');
    (textModel.generateContent as unknown as { mockImplementation: (fn: () => unknown) => void })
      .mockImplementation(() => bannedResponse);

    const result = await rankTextOnly(variants, { platform: 'instagram' });

    expect(result.final.caption).not.toMatch(/Check out this amazing content/i);
    expect(result.final.hashtags).not.toContain('#content');
    expect(result.final.cta).not.toMatch(/Check it out/i);
    expect(result.reason).toMatch(/Sanitized disqualified caption|Fallback to variant/i);
    expect(result.final.hashtags.length).toBeGreaterThan(0);
    const { textModel: retryModel } = await import('../../server/lib/gemini.js');
    expect((retryModel.generateContent as unknown as { mock: { calls: unknown[][] } }).mock.calls.length).toBeGreaterThanOrEqual(3);
  });
});
