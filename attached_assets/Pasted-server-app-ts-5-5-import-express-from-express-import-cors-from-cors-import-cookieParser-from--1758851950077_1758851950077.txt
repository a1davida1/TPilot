server/app.ts
+5-5
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { v4 as uuidv4 } from 'uuid';
import { registerRoutes } from './routes.js';
import { authLimiter, generalLimiter, sanitize, notFoundHandler } from './middleware/security.js';
import { setupAuth } from './auth.js';
import { setupSocialAuth } from './social-auth.js';
import { mountStripeWebhook } from './routes/webhooks.stripe.js';
import { mountBillingRoutes } from './routes/billing.js';
import { logger } from './bootstrap/logger.js';
import { startQueue } from './bootstrap/queue.js';
import { prepareResponseLogPayload, truncateLogLine } from './lib/request-logger.js';
import passport from 'passport'; // Assuming passport is imported elsewhere or needs to be imported here
import { createSessionMiddleware } from './middleware/session.js'; // Assuming this middleware is defined
import { initializeSentry } from './bootstrap/sentry.js'; // Assuming Sentry initialization function
import { createSessionMiddleware } from './bootstrap/session.js';
import { initializeSentry } from './bootstrap/sentry.js';

export interface CreateAppOptions {
  startQueue?: boolean;
  configureStaticAssets?: boolean;
  enableVite?: boolean;
}

export interface CreateAppResult {
  app: express.Express;
  server: import('http').Server;
}

export const API_PREFIX = '/api/v1';

declare global {
  namespace Express {
    interface Request {
      id: string;
    }
  }
}

function configureCors(app: express.Express): void {
  const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',').map((origin) => origin.trim()) ?? [];

@@ -246,42 +246,42 @@ export async function createApp(options: CreateAppOptions = {}): Promise<CreateA
  app.use(passport.session());

  applyRequestLogging(app);

  const startQueueOption = options.startQueue ?? true;
  const configureStaticOption = options.configureStaticAssets ?? true;
  const enableVite = options.enableVite ?? (app.get('env') === 'development');
  const queuePrerequisitesPresent = Boolean(process.env.REDIS_URL || process.env.DATABASE_URL);
  const shouldStartQueue = startQueueOption && queuePrerequisitesPresent;

  try {
    app.use(`${API_PREFIX}/auth`, authLimiter);

    if (shouldStartQueue) {
      await startQueue();
    } else if (startQueueOption) {
      logger.info(
        'Queue startup skipped: provide REDIS_URL or DATABASE_URL environment variables to enable background workers.'
      );
    } else {
      logger.info('Queue startup disabled for current execution context.');
    }

    const sentry = await initializeSentry();

    setupAuth(app, API_PREFIX);
    setupSocialAuth(app, API_PREFIX);  // Register social auth routes including logout
    mountStripeWebhook(app);
    setupAuth(app);
    setupSocialAuth(app);  // Register social auth routes including logout
    mountStripeWebhook(app, API_PREFIX);
    mountBillingRoutes(app);

    const server = await registerRoutes(app, API_PREFIX, { sentry });

    if (configureStaticOption) {
      await configureStaticAssets(app, server, enableVite);
    }

    return { app, server };
  } catch (error) {
    logger.error('Failed to initialise application:', error);
    throw error;
  }
}
server/auth.ts
+0-1
import { Express, Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import session from 'express-session';
import { storage } from './storage';
import { emailService } from './services/email-service';
import crypto from 'crypto';
import { z } from 'zod';
import { authLimiter } from './middleware/security.js';
import { safeLog } from './lib/logger-utils.js';
import { FRONTEND_URL } from './config.js';
import { verificationLimiter, passwordResetLimiter, loginLimiter, signupLimiter, passwordChangeLimiter } from './middleware/simple-rate-limit.js';
import { authMetrics } from './services/basic-metrics.js';
import { logger } from './bootstrap/logger.js';
import { verifyAdminCredentials } from './lib/admin-auth.js';
import { validate, ValidationSource, loginValidationSchema, signupValidationSchema, passwordChangeValidationSchema, passwordResetValidationSchema } from './middleware/validation.js';
import { extractAuthToken } from './middleware/extract-token.js';

// Auth validation schemas removed - handled by middleware

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET || /changeme|placeholder/i.test(JWT_SECRET)) {
  throw new Error('JWT_SECRET environment variable is required and must not be a placeholder');
}
// Type assertion after validation
const JWT_SECRET_VALIDATED: string = JWT_SECRET;

export function setupAuth(app: Express) {
  // Regular signup
server/bootstrap/logger.ts
+0-98
@@ -239,148 +239,50 @@ export function validateSentryConfig(): { isValid: boolean; warnings: string[];
  // Environment-specific warnings
  if (environment === 'development' && dsn) {
    warnings.push('Sentry enabled in development - consider disabling for local development');
  }
  
  if (environment === 'production' && !dsn) {
    errors.push('SENTRY_DSN should be configured in production for error tracking');
  }
  
  // Check for sample rate configuration
  const sampleRate = process.env.SENTRY_SAMPLE_RATE;
  if (sampleRate) {
    const rate = parseFloat(sampleRate);
    if (isNaN(rate) || rate < 0 || rate > 1) {
      errors.push('SENTRY_SAMPLE_RATE must be a number between 0 and 1');
    }
  }
  
  return {
    isValid: errors.length === 0,
    warnings,
    errors
  };
}

// Initialize Sentry with comprehensive validation
export async function initializeSentry(): Promise<typeof import('@sentry/node') | null> {
  let Sentry: typeof import('@sentry/node') | null = null;
  
  // Validate Sentry configuration
  const configValidation = validateSentryConfig();
  
  // Log warnings
  configValidation.warnings.forEach(warning => {
    logger.warn(`Sentry configuration warning: ${warning}`);
  });
  
  // Log errors and exit early if invalid
  if (!configValidation.isValid) {
    configValidation.errors.forEach(error => {
      logger.error(`Sentry configuration error: ${error}`);
    });
    return null;
  }
  
  const dsn = process.env.SENTRY_DSN;
  if (!dsn) {
    return null; // Not configured, but that's okay
  }
  
  try {
    // Dynamic import with proper error handling for optional dependency
    let SentryModule: (typeof import("@sentry/node")) | null = null;
    try {
      SentryModule = await import("@sentry/node");
    } catch {
      SentryModule = null;
    }
    if (SentryModule) {
      Sentry = SentryModule;
      
      // Enhanced Sentry configuration
      const sentryConfig = {
        dsn,
        environment: process.env.NODE_ENV,
        tracesSampleRate: parseFloat(process.env.SENTRY_SAMPLE_RATE || '0.1'),
        profilesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
        integrations: [Sentry.expressIntegration()],
        
        // Enhanced error filtering
        beforeSend(event: unknown, hint: unknown) {
          // Filter out non-critical errors in development
          if (process.env.NODE_ENV === 'development') {
            // Don't send client-side errors in development
            if ((event as Record<string, unknown>).request && 
                typeof (event as Record<string, unknown>).request === 'object' &&
                ((event as Record<string, unknown>).request as Record<string, unknown>)?.url?.toString().includes('/_vite/')) {
              return null;
            }
          }
          
          // Filter out known non-critical errors
          const error = (hint as Record<string, unknown>)?.originalException;
          if (error?.message?.includes('ECONNRESET') || 
              error?.message?.includes('EPIPE')) {
            return null; // Don't send network errors
          }
          
          return event as Record<string, unknown>;
        },
        
        // Enhanced release tracking
        release: process.env.GIT_COMMIT_SHA,
        
        // Set user context
        initialScope: {
          tags: {
            component: 'backend',
            node_env: process.env.NODE_ENV
          }
        }
      };
      
      Sentry.init(sentryConfig);
      
      logger.info('Sentry initialized successfully', {
        environment: sentryConfig.environment,
        tracesSampleRate: sentryConfig.tracesSampleRate,
        release: sentryConfig.release
      });
      
    } else {
      logger.warn("Sentry module not available, continuing without error tracking");
    }
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    const stack = err instanceof Error ? err.stack : undefined;
    logger.error('Sentry initialization failed', { error: message, stack });
  }
  
  return Sentry;
}

// Export a function to add request ID to logger context
export function createRequestLogger(requestId: string) {
  return {
    info: (message: string, meta: Record<string, unknown> = {}) =>
      logger.info(message, { requestId, ...meta }),
    warn: (message: string, meta: Record<string, unknown> = {}) =>
      logger.warn(message, { requestId, ...meta }),
    error: (message: string, meta: Record<string, unknown> = {}) =>
      logger.error(message, { requestId, ...meta }),
    debug: (message: string, meta: Record<string, unknown> = {}) =>
      logger.debug(message, { requestId, ...meta })
  };
}

// Security logging utility
export function logSecurityEvent(event: string, details?: unknown) {
  logger.warn(event, { security: true, ...(details as Record<string, unknown>) });
}

// Performance logging utility
export function logPerformanceMetric(metric: string, value: number, details?: unknown) {
  logger.info(`Performance: ${metric}`, { 
    metrics: true, 
    performance: true, 
    metric, 
server/bootstrap/sentry.ts
New
+109-0
import * as loggerModule from './logger.js';

export type SentryModule = typeof import('@sentry/node');

type ValidateResult = { isValid: boolean; warnings: string[]; errors: string[] };

const logger = loggerModule.logger ?? {
  info: (...args: unknown[]) => console.info(...args),
  warn: (...args: unknown[]) => console.warn(...args),
  error: (...args: unknown[]) => console.error(...args),
};

const validateSentryConfig: () => ValidateResult =
  typeof loggerModule.validateSentryConfig === 'function'
    ? loggerModule.validateSentryConfig
    : () => ({ isValid: true, warnings: [], errors: [] });

const isRecord = (value: unknown): value is Record<string, unknown> => {
  return typeof value === 'object' && value !== null;
};

export async function initializeSentry(): Promise<SentryModule | null> {
  let Sentry: SentryModule | null = null;

  const configValidation = validateSentryConfig();

  configValidation.warnings.forEach((warning) => {
    logger.warn(`Sentry configuration warning: ${warning}`);
  });

  if (!configValidation.isValid) {
    configValidation.errors.forEach((error) => {
      logger.error(`Sentry configuration error: ${error}`);
    });
    return null;
  }

  const dsn = process.env.SENTRY_DSN;
  if (!dsn) {
    return null;
  }

  try {
    let SentryModule: SentryModule | null = null;
    try {
      SentryModule = await import('@sentry/node');
    } catch {
      SentryModule = null;
    }

    if (!SentryModule) {
      logger.warn('Sentry module not available, continuing without error tracking');
      return null;
    }

    Sentry = SentryModule;

    const tracesSampleRate = Number.parseFloat(process.env.SENTRY_SAMPLE_RATE ?? '0.1');
    const profilesSampleRate = process.env.NODE_ENV === 'production' ? 0.1 : 1.0;

    const sentryConfig: Parameters<SentryModule['init']>[0] = {
      dsn,
      environment: process.env.NODE_ENV,
      tracesSampleRate: Number.isFinite(tracesSampleRate) ? tracesSampleRate : 0.1,
      profilesSampleRate,
      integrations: [Sentry.expressIntegration()],
      beforeSend(event, hint) {
        if (process.env.NODE_ENV === 'development' && isRecord(event.request)) {
          const url = event.request.url;
          if (typeof url === 'string' && url.includes('/_vite/')) {
            return null;
          }
        }

        if (hint && isRecord(hint)) {
          const originalException = hint.originalException;
          if (isRecord(originalException) && typeof originalException.message === 'string') {
            if (originalException.message.includes('ECONNRESET') || originalException.message.includes('EPIPE')) {
              return null;
            }
          }
        }

        return event;
      },
      release: process.env.GIT_COMMIT_SHA,
      initialScope: {
        tags: {
          component: 'backend',
          node_env: process.env.NODE_ENV,
        },
      },
    };

    Sentry.init(sentryConfig);

    logger.info('Sentry initialized successfully', {
      environment: sentryConfig.environment,
      tracesSampleRate: sentryConfig.tracesSampleRate,
      release: sentryConfig.release,
    });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    const stack = error instanceof Error ? error.stack : undefined;
    logger.error('Sentry initialization failed', { error: message, stack });
  }

  return Sentry;
}
server/routes.ts
+2-43
import type { Express } from "express";
import express from "express";
import { createServer, type Server } from "http";
import session from 'express-session';
import path from 'path';
import connectPgSimple from 'connect-pg-simple';
import * as connectRedis from 'connect-redis';
import { Pool } from 'pg';
import Redis from 'ioredis';
import Stripe from 'stripe';
import passport from 'passport';
import { createSessionMiddleware } from './bootstrap/session.js';

// Security and middleware
import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
import { AppError, CircuitBreaker } from "./lib/errors.js";
import { authenticateToken } from "./middleware/auth.js";

// Route modules
// import { authRoutes } from "./routes/auth.js"; // Removed - using server/auth.ts instead
import { uploadRoutes, applyImageShieldProtection, protectionPresets } from "./routes/upload.js";
import { mediaRoutes } from "./routes/media.js";
import { analyticsRouter } from "./routes/analytics.js";
import { referralRouter } from "./routes/referrals.js";
import { registerExpenseRoutes } from "./expense-routes.js";
import { adminCommunitiesRouter } from "./routes/admin-communities.js";

// Core imports
import { storage } from "./storage.js";
import { setupAuth } from "./auth.js";
import { setupAdminRoutes } from "./admin-routes.js";
import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
import { visitorAnalytics } from "./visitor-analytics.js";
import { makePaxum, makeCoinbase, makeStripe } from "./payments/payment-providers.js";
import { deriveStripeConfig } from "./payments/stripe-config.js";
// Analytics request type
interface AnalyticsRequest extends express.Request {
@@ -239,58 +235,51 @@ import { ReferralManager } from './lib/referral-system.js';

// API route modules
import { registerApiRoutes } from "./api-routes.js";
import { registerPolicyRoutes } from "./policy-routes.js";
import { registerRedditRoutes } from "./reddit-routes.js";
import { registerAnalyticsRoutes } from "./analytics-routes.js";
import { createLead, confirmLead } from "./api/leads.js";
import { getLeads } from './api/admin-leads.js';
import { getComplianceStatus } from './api/compliance-status.js';
import { captionRouter } from "./routes/caption.js";
import { contentGenerationLimiter } from "./middleware/tiered-rate-limit.js";
import { registerSocialMediaRoutes } from "./social-media-routes.js";

// Schema imports
import { insertContentGenerationSchema, insertUserImageSchema } from "@shared/schema";

// Core dependencies
import multer from 'multer';
import fs from 'fs/promises';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import csrf from 'csurf';

// Get secure environment variables (no fallbacks)
const rawSessionSecret = process.env.SESSION_SECRET;
if (!rawSessionSecret) {
  throw new Error('SESSION_SECRET missing');
}
const SESSION_SECRET: string = rawSessionSecret;
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const DATABASE_URL = process.env.DATABASE_URL;
const REDIS_URL = process.env.REDIS_URL;
const stripeConfig = deriveStripeConfig({
  env: process.env,
  logger,
});

// Initialize Stripe if configured
const stripe = stripeConfig ? new Stripe(stripeConfig.secretKey, {
  apiVersion: stripeConfig.apiVersion as Stripe.LatestApiVersion,
}) : null;

// Configure multer for optional image uploads
const upload = multer({
  dest: 'uploads/',
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'));
    }
  }
});

// Auth request interface
interface AuthRequest extends express.Request {
@@ -348,81 +337,51 @@ const deriveSharePercentage = (perk: ProPerk): number => {
    });

    return Math.max(...normalizedPercents);
  };


export async function registerRoutes(app: Express, _apiPrefix: string = '/api', options?: RegisterRoutesOptions): Promise<Server> {
  // ==========================================
  // VALIDATE ENVIRONMENT & APPLY SECURITY
  // ==========================================

  // Set trust proxy securely for rate limiters
  app.set('trust proxy', (ip: string) => {
    // Trust localhost and private network ranges
    return ['127.0.0.1', '::1'].includes(ip) || ip.startsWith('10.') || ip.startsWith('192.168.');
  });

  // Validate required environment variables first
  validateEnvironment();

  // Log IPs first so downstream middleware can use req.userIP
  app.use(ipLoggingMiddleware);
  app.use(securityMiddleware);

  // Session configuration (MUST BE BEFORE AUTH ROUTES)
  let store: session.Store | undefined;

  if (IS_PRODUCTION) {
    if (REDIS_URL) {
      const { RedisStore } = connectRedis as { RedisStore: new (options: { client: unknown; prefix: string }) => session.Store };
      const redisClient = new Redis(REDIS_URL);
      store = new RedisStore({ client: redisClient, prefix: 'sess:' });
    } else if (DATABASE_URL) {
      const PgStore = connectPgSimple(session);
      store = new PgStore({
        pool: new Pool({ connectionString: DATABASE_URL })
      });
    } else {
      throw new Error('No REDIS_URL or DATABASE_URL set in production; persistent session store required.');
    }
  }

  app.use(session({
    store,
    secret: SESSION_SECRET,
    resave: false, // Prevent session fixation
    saveUninitialized: false, // Only create sessions when needed
    cookie: {
      secure: IS_PRODUCTION, // HTTPS-only in production
      httpOnly: true,
      sameSite: 'lax', // Allows OAuth redirects
      maxAge: 1000 * 60 * 60 * 24 * 7 // 1 week
    },
    name: 'thottopilot.sid', // Custom session name
    rolling: true // Refresh session on activity
  }));
  app.use(createSessionMiddleware());

  // Initialize Passport after session middleware
  app.use(passport.initialize());
  app.use(passport.session());

  // Configure Passport serialization for admin
  passport.serializeUser((user, done) => {
    done(null, (user as AuthUser).id);
  });

  passport.deserializeUser(async (id: unknown, done) => {
    try {
      if (typeof id !== 'number') {
        return done(new Error('Invalid user ID'), null);
      }
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error instanceof Error ? error : new Error(String(error)), null);
    }
  });

  // CSRF protection for session-based routes
  const csrfProtection: express.RequestHandler = csrf({
    cookie: {
