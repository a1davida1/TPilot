 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/routes/upload.ts b/server/routes/upload.ts
index 6fdfbd4bf623067ab97ecf12fb8f2eb16a47cb80..b4f148ac2c9c5101d69e2b4d70c2af2b0e587452 100644
--- a/server/routes/upload.ts
+++ b/server/routes/upload.ts
@@ -188,51 +188,51 @@ async function validateImageFile(filePath: string, originalMimeType: string): Pr
   } catch (error) {
     logger.error('File validation error', { error: (error as Error).message, filePath });
     return { isValid: false, error: 'File validation failed' };
   }
 }
 
 // Basic malware detection patterns (enhanced in production)
 function performBasicMalwareCheck(buffer: Buffer): boolean {
   const malwareSignatures = [
     Buffer.from('eval('), // JavaScript injection
     Buffer.from('<?php'), // PHP injection
     Buffer.from('<script'), // Script injection
     Buffer.from('javascript:'), // JavaScript protocol
     Buffer.from('%PDF-'), // PDF files
     Buffer.from('PK\x03\x04'), // ZIP files (potential zip bombs)
     Buffer.from('\x7fELF'), // ELF executables
     Buffer.from('MZ'), // Windows executables
   ];
   
   return malwareSignatures.some(sig => buffer.includes(sig));
 }
 
 // New streaming upload endpoint with enhanced progress tracking
 router.post('/stream', uploadLimiter, tierProtectionLimiter, authenticateToken, cleanupUploadedFiles, imageStreamingUpload, async (req: Request, res: Response) => {
   const authReq = req as UploadAuthRequest;
-  let processedFilePath = '';
+  let processedFilePath: string | undefined;
   
   try {
     // Check if files were uploaded via streaming
     if (!authReq.streamingFiles || authReq.streamingFiles.length === 0) {
       return res.status(400).json({ message: 'No file uploaded' });
     }
 
     const uploadedFile = authReq.streamingFiles[0];
     const tempFilePath = uploadedFile.path;
 
     if (!tempFilePath) {
       return res.status(400).json({ message: 'Invalid file path' });
     }
     
     // Real MIME type validation using file content analysis
     const fileValidation = await validateImageFile(tempFilePath, uploadedFile.mimetype || 'application/octet-stream');
     if (!fileValidation.isValid) {
       await fs.unlink(tempFilePath);
       logger.warn('Streaming file validation failed', {
         userId: authReq.user?.id,
         originalName: uploadedFile.originalname || 'unknown',
         declaredMime: uploadedFile.mimetype,
         detectedType: fileValidation.detectedType,
         error: fileValidation.error
       });
diff --git a/server/routes/upload.ts b/server/routes/upload.ts
index 6fdfbd4bf623067ab97ecf12fb8f2eb16a47cb80..b4f148ac2c9c5101d69e2b4d70c2af2b0e587452 100644
--- a/server/routes/upload.ts
+++ b/server/routes/upload.ts
@@ -260,57 +260,73 @@ router.post('/stream', uploadLimiter, tierProtectionLimiter, authenticateToken,
       declaredMime: uploadedFile.mimetype,
       detectedType: fileValidation.detectedType,
       uploadSize: uploadedFile.size
     });
     
     // Validate request body with Zod schema
     let validatedRequest: UploadRequestBody;
     try {
       validatedRequest = uploadRequestSchema.parse(authReq.body);
     } catch (error) {
       await fs.unlink(tempFilePath);
       if (error instanceof ZodError) {
         logger.warn('Streaming upload validation failed', {
           userId: authReq.user?.id,
           errors: error.errors
         });
         return res.status(400).json({ 
           message: 'Invalid request parameters',
           errors: error.errors 
         });
       }
       throw error;
     }
 
     // Generate secure output filename
-    const outputFilename = `protected-${crypto.randomBytes(16).toString('hex')}.jpg`;
-    processedFilePath = path.join(process.cwd(), 'uploads', outputFilename);
+    let outputFilename: string | undefined;
+    try {
+      outputFilename = `protected-${crypto.randomBytes(16).toString('hex')}.jpg`;
+      processedFilePath = path.join(process.cwd(), 'uploads', outputFilename);
+    } catch (filenameError) {
+      logger.error('Failed to generate secure filename for streaming upload', {
+        userId: authReq.user?.id,
+        error: filenameError instanceof Error ? filenameError.message : String(filenameError)
+      });
+    }
+
+    if (!processedFilePath || !outputFilename) {
+      await fs.unlink(tempFilePath).catch(() => {});
+      logger.error('Processed file path missing after filename generation', {
+        userId: authReq.user?.id
+      });
+      return res.status(500).json({ message: 'Upload processing failed' });
+    }
     
     // Apply ImageShield protection with retry and timeout
     const protect = () => applyImageShieldProtection(
       tempFilePath,
-      processedFilePath!,
+      processedFilePath,
       validatedRequest.protectionLevel,
       validatedRequest.addWatermark,
       String(authReq.user?.id)
     );
     let lastError: unknown;
     for (let attempt = 0; attempt < 3; attempt++) {
       try {
         await Promise.race([
           protect(),
           new Promise((_, reject) =>
             setTimeout(() => reject(new Error('ImageShield timeout')), 30_000)
           )
         ]);
         break;
       } catch (err) {
         lastError = err;
         if (attempt === 2) throw err;
         await new Promise(res => setTimeout(res, 1_000 * Math.pow(2, attempt)));
       }
     }
     
     // Clean up original uploaded file
     await fs.unlink(tempFilePath);
     
     logger.info('ImageShield protection applied successfully (streaming)', {
 
EOF
)