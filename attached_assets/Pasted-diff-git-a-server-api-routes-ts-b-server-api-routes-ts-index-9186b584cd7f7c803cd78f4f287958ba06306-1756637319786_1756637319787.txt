diff --git a/server/api-routes.ts b/server/api-routes.ts
index 9186b584cd7f7c803cd78f4f287958ba06306513..83099f5ea91566c7c4b315db9141288ea4f2c357 100644
--- a/server/api-routes.ts
+++ b/server/api-routes.ts
@@ -1,29 +1,30 @@
 import type { Express } from "express";
 import { z } from "zod";
 import { db } from "./db.js";
 import { AiService } from "./lib/ai-service.js";
+import { generateEnhancedContent } from "./services/enhanced-ai-service.js";
 import { MediaManager } from "./lib/media.js";
 import { CCBillProcessor } from "./lib/billing.js";
 import { PolicyLinter } from "./lib/policyLinter.js";
 import { PostScheduler } from "./lib/scheduling.js";
 import { addJob } from "./lib/queue/index.js";
 import { RedditManager } from "./lib/reddit.js";
 import { postJobs, subscriptions, mediaAssets, creatorAccounts } from "@shared/schema.js";
 import { eq, desc } from "drizzle-orm";
 import multer from "multer";
 // Import from routes.ts where authenticateToken is defined
 // We'll create a separate auth helper file for this
 import jwt from 'jsonwebtoken';
 import type { Request, Response, NextFunction } from 'express';
 
 interface AuthRequest extends Request {
   user?: any;
 }
 
 const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
 
 const authenticateToken = async (req: AuthRequest, res: Response, next: NextFunction) => {
   const authHeader = req.headers['authorization'];
   const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
 
   if (!token) {
diff --git a/server/api-routes.ts b/server/api-routes.ts
index 9186b584cd7f7c803cd78f4f287958ba06306513..83099f5ea91566c7c4b315db9141288ea4f2c357 100644
--- a/server/api-routes.ts
+++ b/server/api-routes.ts
@@ -55,50 +56,89 @@ export function registerApiRoutes(app: Express) {
       const schema = z.object({
         prompt: z.string().optional(),
         platforms: z.array(z.string()).min(1),
         styleHints: z.array(z.string()).optional(),
         variants: z.number().min(1).max(5).default(1),
       });
 
       const data = schema.parse(req.body);
       
       if (!req.user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
       }
 
       const result = await AiService.generateContent({
         userId: req.user.id,
         ...data,
       });
 
       res.json(result);
     } catch (error: any) {
       console.error('AI generation failed:', error);
       res.status(500).json({ error: error.message });
     }
   });
 
+  // Enhanced AI Content Generation
+  app.post('/api/ai/enhanced', authenticateToken, async (req: AuthRequest, res) => {
+    try {
+      const schema = z.object({
+        mode: z.enum(['text', 'image', 'hybrid']).default('text'),
+        prompt: z.string().optional(),
+        imageBase64: z.string().optional(),
+        platform: z.enum(['reddit', 'twitter', 'instagram', 'tiktok', 'onlyfans']),
+        style: z.enum(['playful', 'mysterious', 'bold', 'elegant', 'confident', 'authentic', 'sassy', 'professional']),
+        theme: z.string().optional(),
+        tone: z.enum(['casual', 'formal', 'flirty', 'friendly', 'provocative']).optional(),
+        contentType: z.enum(['teasing', 'promotional', 'engagement', 'lifestyle', 'announcement', 'educational']).optional(),
+        includePromotion: z.boolean().optional(),
+        promotionLevel: z.enum(['none', 'subtle', 'moderate', 'direct']).optional(),
+        targetAudience: z.enum(['general', 'fans', 'potential-subscribers', 'premium-tier']).optional(),
+        customInstructions: z.string().optional(),
+        subreddit: z.string().optional(),
+        niche: z.string().optional(),
+        personalBrand: z.string().optional(),
+      });
+
+      const data = schema.parse(req.body);
+
+      if (!req.user?.id) {
+        return res.status(401).json({ error: 'Authentication required' });
+      }
+
+      const result = await generateEnhancedContent({
+        ...data,
+        userId: String(req.user.id),
+      });
+
+      res.json(result);
+    } catch (error: any) {
+      console.error('Enhanced AI generation failed:', error);
+      res.status(500).json({ error: error.message });
+    }
+  });
+
   // Media Upload
   app.post('/api/media/upload', authenticateToken, upload.single('file'), async (req: AuthRequest, res) => {
     try {
       if (!req.file) {
         return res.status(400).json({ error: 'No file provided' });
       }
 
       if (!req.user?.id) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       
       const userId = req.user.id;
       const applyWatermark = req.body.watermark === 'true';
 
       const result = await MediaManager.uploadFile(req.file.buffer, {
         userId,
         filename: req.file.originalname,
         visibility: 'private',
         applyWatermark,
       });
 
       res.json(result);
     } catch (error: any) {
       console.error('Media upload failed:', error);
       res.status(500).json({ error: error.message });
