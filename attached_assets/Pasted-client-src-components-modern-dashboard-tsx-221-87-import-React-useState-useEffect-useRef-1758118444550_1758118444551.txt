client/src/components/modern-dashboard.tsx
+221
-87

import React, { useState, useEffect, useRef } from "react";
import React, { useState, useEffect, useMemo } from "react";
import type { ReactNode } from "react";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/useAuth";
import { 
import { useQuery } from "@tanstack/react-query";
import {
  Upload,
  Sparkles,
  Shield,
  Target,
  Scale,
  BarChart3,
  Calculator,
  Gift,
  Menu,
  X,
  Clock,
  Bell,
  Settings,
  ChevronRight,
  Home,
  Brain,
  Users,
  Hash,
  History,
  ImageIcon,
  Wand2,
  Zap,
  ListChecks,
  Command
} from "lucide-react";
import { FaReddit } from "react-icons/fa";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { useToast } from "@/hooks/use-toast";

interface ModernDashboardProps {
  isRedditConnected?: boolean;
  user?: { id: number; username: string; email?: string; tier?: string; isVerified?: boolean };
  userTier?: 'guest' | 'free' | 'basic' | 'starter' | 'pro' | 'premium' | 'admin';
  isAdmin?: boolean;
}

export function ModernDashboard({ isRedditConnected = false, user, userTier = 'free', isAdmin = false }: ModernDashboardProps) {
interface DashboardStats {
  postsToday: number;
  upcomingPosts: number;
  generatedContent: number;
  mediaAssets: number;
}

interface DashboardMediaItem {
  id: number;
  filename: string;
  thumbnailUrl: string;
  createdAt: string;
}

interface DashboardScheduledPost {
  id: number;
  title: string;
  subreddit: string;
  scheduledAt: string;
  status: string;
}

interface DashboardOverviewResponse {
  stats: DashboardStats;
  gallery: DashboardMediaItem[];
  scheduledPosts: DashboardScheduledPost[];
}

const minuteInMs = 60 * 1000;
const hourInMs = 60 * minuteInMs;
const dayInMs = 24 * hourInMs;

function ensureSubredditPrefix(subreddit: string): string {
  if (!subreddit) {
    return "r/unknown";
  }

  return subreddit.startsWith("r/") ? subreddit : `r/${subreddit}`;
}

function formatRelativeTime(dateInput: string): string {
  const scheduledAt = new Date(dateInput);

  if (Number.isNaN(scheduledAt.getTime())) {
    return "Scheduled";
  }

  const diff = scheduledAt.getTime() - Date.now();

  if (diff <= 0) {
    return "Ready to post";
  }

  if (diff < minuteInMs) {
    return "In less than a minute";
  }

  if (diff < hourInMs) {
    const minutes = Math.round(diff / minuteInMs);
    return `In ${minutes} minute${minutes === 1 ? "" : "s"}`;
  }

  if (diff < dayInMs) {
    const hours = Math.round(diff / hourInMs);
    return `In ${hours} hour${hours === 1 ? "" : "s"}`;
  }

  const days = Math.round(diff / dayInMs);
  return `In ${days} day${days === 1 ? "" : "s"}`;
}

export function ModernDashboard({ isRedditConnected: _isRedditConnected = false, user, userTier = 'free', isAdmin = false }: ModernDashboardProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const [selectedCard, setSelectedCard] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const { user: authUser } = useAuth();
  

  const {
    data,
    isLoading,
    isError,
    error,
  } = useQuery<DashboardOverviewResponse>({
    queryKey: ["/api/dashboard/overview"],
  });

  useEffect(() => {
    if (isError) {
      const message = error instanceof Error ? error.message : "Unable to fetch dashboard data.";
      toast({
        title: "Dashboard data unavailable",
        description: message,
      });
    }
  }, [isError, error, toast]);

  // Determine premium status
  const isPremium = isAdmin || userTier === 'premium' || userTier === 'pro' || userTier === 'admin';
  

  // Get current time greeting
  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return "Good morning";
    if (hour < 18) return "Good afternoon";
    return "Good evening";
  };

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const stats = [
    {
      label: "Posts Today",
      value: "12",
      icon: <Upload className="h-5 w-5" />,
      color: "text-purple-400"
    },
    {
      label: "Engagement Rate",
      value: "94.2%",
      icon: <Target className="h-5 w-5" />,
      color: "text-green-400"
    },
    {
      label: "Takedowns Found",
      value: "3",
      icon: <Shield className="h-5 w-5" />,
      color: "text-yellow-400"
    },
    {
      label: "Tax Saved",
      value: "$847",
      icon: <Calculator className="h-5 w-5" />,
      color: "text-blue-400"
    }
  ];
  const statConfig = useMemo<Array<{ key: keyof DashboardStats; label: string; icon: ReactNode; color: string }>>(
    () => [
      {
        key: "postsToday",
        label: "Posts Today",
        icon: <Upload className="h-5 w-5" />,
        color: "text-purple-400",
      },
      {
        key: "upcomingPosts",
        label: "Scheduled Posts",
        icon: <Clock className="h-5 w-5" />,
        color: "text-blue-400",
      },
      {
        key: "generatedContent",
        label: "AI Generations",
        icon: <Sparkles className="h-5 w-5" />,
        color: "text-green-400",
      },
      {
        key: "mediaAssets",
        label: "Media Library",
        icon: <ImageIcon className="h-5 w-5" />,
        color: "text-pink-400",
      },
    ],
    [],
  );

  const statsData = data?.stats;
  const galleryItems = data?.gallery ?? [];
  const galleryPreviewItems = galleryItems.slice(0, 4);
  const scheduledPosts = data?.scheduledPosts ?? [];

  const actionCards = [
    {
      id: "quick-post",
      title: "Quick Post",
      description: "Upload a post in seconds",
      icon: <Upload className="h-6 w-6" />,
      color: "from-purple-500 to-purple-600",
      route: "/reddit"
    },
    {
      id: "generate-caption",
      title: "Generate Caption",
      description: "AI-powered content",
      icon: <Sparkles className="h-6 w-6" />,
      color: "from-blue-500 to-blue-600",
      route: "/caption-generator"
    },
    {
      id: "protect-image",
      title: "Protect Image",
      description: "Image/Video protection",
      icon: <Shield className="h-6 w-6" />,
      color: "from-green-500 to-green-600",
      route: "/imageshield"
@@ -341,166 +427,214 @@ export function ModernDashboard({ isRedditConnected = false, user, userTier = 'f
                <Command className="h-4 w-4 mr-2" />
                Command Center
              </Button>
              <Button
                onClick={handleTaskFlow}
                className="bg-gray-800 hover:bg-gray-700 text-white"
              >
                <ListChecks className="h-4 w-4 mr-2" />
                Task Flow
              </Button>
            </div>
            <div className="flex gap-3">
              <Button variant="ghost" size="icon" className="text-white">
                <Bell className="h-5 w-5" />
              </Button>
              <Button variant="ghost" size="icon" className="text-white">
                <Settings className="h-5 w-5" />
              </Button>
            </div>
          </div>
        </div>

        {/* Welcome Section */}
        <div className="mb-8">
          <h1 className="text-4xl md:text-5xl font-bold text-white mb-2">
            {getGreeting()}, {user?.username || 'Creator'}! ðŸ‘‹
            {getGreeting()}, {user?.username || authUser?.username || 'Creator'}! ðŸ‘‹
          </h1>
          <p className="text-xl text-gray-300">
            What would you like to do today?
          </p>
        </div>

        {/* Stats Row */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
          {stats.map((stat, index) => (
            <Card key={index} className="bg-gray-800 border-gray-700">
              <CardContent className="p-6">
                <div className="flex items-center justify-between mb-2">
                  <span className={stat.color}>{stat.icon}</span>
                  <span className="text-2xl font-bold text-white">{stat.value}</span>
                </div>
                <p className="text-gray-400 text-sm">{stat.label}</p>
              </CardContent>
            </Card>
          ))}
          {statConfig.map((stat) => {
            const value = statsData?.[stat.key] ?? 0;

            return (
              <Card key={stat.key} className="bg-gray-800 border-gray-700">
                <CardContent className="p-6">
                  <div className="flex items-center justify-between mb-2">
                    <span className={stat.color}>{stat.icon}</span>
                    {isLoading ? (
                      <Skeleton className="h-6 w-12" />
                    ) : (
                      <span className="text-2xl font-bold text-white">
                        {value.toLocaleString()}
                      </span>
                    )}
                  </div>
                  <p className="text-gray-400 text-sm">{stat.label}</p>
                </CardContent>
              </Card>
            );
          })}
        </div>

        {/* Action Cards Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
          {actionCards.map((card) => (
            <Card
              key={card.id}
              className={cn(
                "bg-gray-800 border-gray-700 cursor-pointer transition-all hover:scale-105",
                selectedCard === card.id && "ring-2 ring-purple-500"
              )}
              onClick={() => handleCardClick(card)}
              onMouseEnter={() => setSelectedCard(card.id)}
              onMouseLeave={() => setSelectedCard(null)}
            >
              <CardContent className="p-6">
                <div className={cn(
                  "w-12 h-12 rounded-lg bg-gradient-to-br flex items-center justify-center mb-4",
                  card.color
                )}>
                  {card.icon}
                </div>
                <h3 className="text-white font-semibold mb-1">{card.title}</h3>
                <p className="text-gray-400 text-sm">{card.description}</p>
                {card.comingSoon && (
                  <Badge className="mt-2" variant="outline">Coming Soon</Badge>
                )}
                {card.premium && !isPremium && (
                  <Badge className="mt-2" variant="outline">Pro</Badge>
                )}
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Bottom Sections */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Recent Gallery */}
          <Card className="bg-gray-800 border-gray-700">
            <CardHeader>
              <CardTitle className="text-white">Recent Gallery</CardTitle>
              <CardDescription className="text-gray-400">
                Your latest uploads
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-4 gap-2">
                {galleryItems.map((item) => (
                {isLoading && (
                  <>
                    {Array.from({ length: 4 }).map((_, index) => (
                      <Skeleton
                        key={`gallery-skeleton-${index}`}
                        className="aspect-square w-full rounded-lg"
                      />
                    ))}
                  </>
                )}
                {!isLoading && galleryPreviewItems.map((item) => (
                  <div
                    key={item.id}
                    className="aspect-square bg-gray-700 rounded-lg overflow-hidden"
                  >
                    <img
                      src={item.url}
                      alt={item.alt}
                      src={item.thumbnailUrl}
                      alt={item.filename}
                      className="w-full h-full object-cover"
                      loading="lazy"
                    />
                  </div>
                ))}
              </div>
              <Button 
              {!isLoading && galleryPreviewItems.length === 0 && (
                <p className="text-gray-400 text-sm mt-3">
                  Upload media to populate your gallery preview.
                </p>
              )}
              <Button
                className="w-full mt-4 bg-purple-600 hover:bg-purple-700"
                onClick={() => setLocation('/gallery')}
              >
                View All
                <ChevronRight className="h-4 w-4 ml-2" />
              </Button>
            </CardContent>
          </Card>

          {/* Scheduled Posts */}
          <Card className="bg-gray-800 border-gray-700">
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="text-white">Scheduled Posts</CardTitle>
                <Badge className="bg-orange-500 text-white">2 PENDING</Badge>
                <Badge className="bg-orange-500 text-white">
                  {isLoading ? 'Loadingâ€¦' : `${scheduledPosts.length} UPCOMING`}
                </Badge>
              </div>
              <CardDescription className="text-gray-400">
                Upcoming content
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                <div className="flex items-center justify-between p-3 bg-gray-700 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Clock className="h-5 w-5 text-purple-400" />
                    <div>
                      <p className="text-white text-sm font-medium">Morning Selfie</p>
                      <p className="text-gray-400 text-xs">r/SelfieWorld â€¢ In 2 hours</p>
                    </div>
                  </div>
                </div>
                <div className="flex items-center justify-between p-3 bg-gray-700 rounded-lg">
                  <div className="flex items-center gap-3">
                    <Clock className="h-5 w-5 text-purple-400" />
                    <div>
                      <p className="text-white text-sm font-medium">Sunset Vibes</p>
                      <p className="text-gray-400 text-xs">r/FreeKarma4U â€¢ In 6 hours</p>
                {isLoading && (
                  <>
                    {Array.from({ length: 3 }).map((_, index) => (
                      <div key={`schedule-skeleton-${index}`} className="p-3 bg-gray-700 rounded-lg">
                        <div className="flex items-center gap-3">
                          <Skeleton className="h-5 w-5 rounded-full" />
                          <div className="flex-1 space-y-2">
                            <Skeleton className="h-4 w-32" />
                            <Skeleton className="h-3 w-24" />
                          </div>
                        </div>
                      </div>
                    ))}
                  </>
                )}
                {!isLoading && scheduledPosts.map((post) => {
                  const statusLabel = post.status ? post.status.replace(/_/g, ' ') : 'pending';

                  return (
                    <div
                      key={post.id}
                      className="flex items-center justify-between p-3 bg-gray-700 rounded-lg"
                    >
                      <div className="flex items-center gap-3">
                        <Clock className="h-5 w-5 text-purple-400" />
                        <div>
                          <p className="text-white text-sm font-medium">{post.title}</p>
                          <p className="text-gray-400 text-xs">
                            {ensureSubredditPrefix(post.subreddit)} â€¢ {formatRelativeTime(post.scheduledAt)}
                          </p>
                        </div>
                      </div>
                      <Badge variant="secondary" className="bg-purple-500/10 text-purple-200 border border-purple-500/30">
                        {statusLabel}
                      </Badge>
                    </div>
                  </div>
                </div>
                  );
                })}
              </div>
              <Button 
              {!isLoading && scheduledPosts.length === 0 && (
                <p className="text-gray-400 text-sm mt-2">
                  No upcoming posts scheduled yet. Queue a post to see it here.
                </p>
              )}
              <Button
                className="w-full mt-4 bg-purple-600 hover:bg-purple-700"
                onClick={() => {
                  toast({
                    title: "Scheduler",
                    description: "Post scheduler coming soon!",
                  });
                }}
                onClick={() => setLocation('/reddit')}
              >
                Manage Schedule
                <ChevronRight className="h-4 w-4 ml-2" />
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
fix-type-errors.cjs
+0
-2

#!/usr/bin/env node

/* eslint-env node */
const fs = require('fs');
const path = require('path');

// Helper to fix common TypeScript errors
function fixTypeErrors(filePath) {
  if (!fs.existsSync(filePath)) return;
  
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Fix error.message patterns
  content = content.replace(/(\s)error\.message/g, '$1(error as Error).message');
  content = content.replace(/(\s)error\.stack/g, '$1(error as Error).stack');
  
  // Fix implicit any in map functions
  content = content.replace(/\.map\(\(([^,)]+),\s*([^)]+)\)/g, '.map(($1: any, $2: number)');
  
  // Fix implicit any in function parameters
  content = content.replace(/function\s+(\w+)\(([^:)]+)\)/g, 'function $1($2: any)');
  
  fs.writeFileSync(filePath, content);
}

// Process all TypeScript files
const files = process.argv.slice(2);
files.forEach(fixTypeErrors);

console.log('âœ… Type errors fixed in', files.length, 'files');
server/lib/media.ts
+2
-2

import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import sharp from "sharp";
import crypto from "crypto";
import Redis from "ioredis";
import { env, config } from "./config.js";
import { db } from "../db.js";
import { mediaAssets, mediaUsages } from "@shared/schema";
import { eq, sum, and } from "drizzle-orm";
import { eq, sum, and, desc } from "drizzle-orm";
import fs from "fs/promises";
import path from "path";

// Check if S3 is configured
const isS3Configured = !!(env.AWS_ACCESS_KEY_ID && env.AWS_SECRET_ACCESS_KEY && env.S3_BUCKET_MEDIA);

// S3 client configuration (only if configured)
const s3Client = isS3Configured ? new S3Client({
  region: env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY!,
  },
}) : null;

// Ensure uploads directory exists
const uploadsDir = path.join(process.cwd(), 'uploads');
fs.mkdir(uploadsDir, { recursive: true }).catch(() => {});

type MediaAssetRow = typeof mediaAssets.$inferSelect;

interface DownloadTokenPayload {
  assetId: number;
  userId: number;
  key: string;
@@ -237,51 +237,51 @@ export class MediaManager {
    }).returning();
    
    return this.buildAssetResponse(asset);
  }
  
  static async getAsset(id: number, userId?: number): Promise<MediaAssetWithUrl | null> {
    const whereCondition = userId 
      ? and(eq(mediaAssets.id, id), eq(mediaAssets.userId, userId))
      : eq(mediaAssets.id, id);
    
    const [asset] = await db
      .select()
      .from(mediaAssets)
      .where(whereCondition)
      .limit(1);
    if (!asset) return null;
    
    return this.buildAssetResponse(asset);
  }
  
  static async getUserAssets(userId: number, limit: number = 50): Promise<MediaAssetWithUrl[]> {
    const assets = await db
      .select()
      .from(mediaAssets)
      .where(eq(mediaAssets.userId, userId))
      .orderBy(mediaAssets.createdAt)
      .orderBy(desc(mediaAssets.createdAt))
      .limit(limit);
    
    return Promise.all(assets.map(async (asset) => this.buildAssetResponse(asset)));
  }
  
  static async deleteAsset(id: number, userId: number): Promise<boolean> {
    const [asset] = await db
      .select()
      .from(mediaAssets)
      .where(and(eq(mediaAssets.id, id), eq(mediaAssets.userId, userId)))
      .limit(1);
      
    if (!asset) return false;
    
    try {
      // Delete from S3 or local filesystem
      if (isS3Configured && s3Client) {
        await s3Client.send(new DeleteObjectCommand({
          Bucket: env.S3_BUCKET_MEDIA!,
          Key: asset.key,
        }));
      } else {
        // Delete from local filesystem
        const localPath = this.getLocalAssetPath(asset.key);
        await fs.unlink(localPath).catch(() => {});
server/routes.ts
+4
-0

import type { Express, Response, NextFunction } from "express";
import express from "express";
import { createServer, type Server } from "http";
import session from 'express-session';
import path from 'path';
import connectPgSimple from 'connect-pg-simple';
import * as connectRedis from 'connect-redis';
import { Pool } from 'pg';
import Redis from 'ioredis';
import Stripe from 'stripe';
import passport from 'passport';

// Security and middleware
import { validateEnvironment, securityMiddleware, ipLoggingMiddleware, errorHandler, logger, generationLimiter } from "./middleware/security.js";
import { AppError, CircuitBreaker } from "./lib/errors.js";
import { authenticateToken } from "./middleware/auth.js";

// Route modules
// import { authRoutes } from "./routes/auth.js"; // Removed - using server/auth.ts instead
import { uploadRoutes, applyImageShieldProtection, protectionPresets } from "./routes/upload.js";
import { mediaRoutes } from "./routes/media.js";
import { dashboardRoutes } from "./routes/dashboard.js";
import { registerExpenseRoutes } from "./expense-routes.js";

// Core imports
import { storage } from "./storage.js";
import { setupAuth } from "./auth.js";
import { setupAdminRoutes } from "./admin-routes.js";
import { configureSocialAuth, socialAuthRoutes } from "./social-auth-config.js";
import { visitorAnalytics } from "./visitor-analytics.js";
import { makePaxum, makeCoinbase, makeStripe } from "./payments/payment-providers.js";
import { deriveStripeConfig } from "./payments/stripe-config.js";
// Analytics request type
interface AnalyticsRequest extends express.Request {
  sessionID: string;
}

// Import users table for type inference
import { users, type ContentGeneration } from "@shared/schema";

// AuthUser interface for passport serialization
interface AuthUser {
  id: number;
  username?: string;
  isAdmin?: boolean;
}

@@ -287,50 +288,53 @@ export async function registerRoutes(app: Express, apiPrefix: string = '/api'):
  });

  // ==========================================
  // AUTHENTICATION SETUP
  // ==========================================
  
  // Setup authentication
  setupAuth(app);
  setupAdminRoutes(app);
  
  // Configure social authentication
  configureSocialAuth();

  // ==========================================
  // ROUTE REGISTRATION
  // ==========================================
  
  // Authentication routes - handled by setupAuth() in server/auth.ts
  // app.use('/api/auth', authRoutes); // Removed - duplicate auth system
  
  // Upload routes
  app.use('/api/upload', uploadRoutes);
  
  // Media routes
  app.use('/api/media', mediaRoutes);

  // Dashboard routes
  app.use('/api/dashboard', dashboardRoutes);
  
  // Social auth routes
  app.get('/api/auth/google', socialAuthRoutes.googleAuth);
  app.get('/api/auth/google/callback', socialAuthRoutes.googleCallback);
  app.get('/api/auth/facebook', socialAuthRoutes.facebookAuth);
  app.get('/api/auth/facebook/callback', socialAuthRoutes.facebookCallback);
  app.get('/api/auth/reddit', socialAuthRoutes.redditAuth);
  app.get('/api/auth/reddit/callback', socialAuthRoutes.redditCallback);

  // Serve uploaded files securely
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // ==========================================
  // STRIPE PAYMENT ENDPOINTS
  // ==========================================
  
  // Create subscription payment intent
  app.post("/api/create-subscription", authenticateToken, async (req: AuthRequest, res) => {
    try {
      if (!stripe) {
        return res.status(503).json({ 
          message: "Payment system is not configured. Please try again later." 
        });
      }

server/routes/dashboard.ts
New
+146
-0

import express from 'express';
import { sql, and, eq, gte, asc } from 'drizzle-orm';
import type { Request } from 'express';

import { authenticateToken } from '../middleware/auth.js';
import { MediaManager, type MediaAssetWithUrl } from '../lib/media.js';
import { db } from '../db.js';
import { postJobs, contentGenerations, mediaAssets } from '@shared/schema';

const router = express.Router();

interface AuthenticatedRequest extends Request {
  user?: { id: number };
}

interface DashboardStats {
  postsToday: number;
  upcomingPosts: number;
  generatedContent: number;
  mediaAssets: number;
}

interface DashboardMediaItem {
  id: number;
  filename: string;
  thumbnailUrl: string;
  createdAt: string;
}

interface DashboardScheduledPost {
  id: number;
  title: string;
  subreddit: string;
  scheduledAt: string;
  status: string;
}

const MAX_GALLERY_ITEMS = 8;
const MAX_SCHEDULED_POSTS = 5;

function toIsoString(value: Date | string): string {
  if (value instanceof Date) {
    return value.toISOString();
  }

  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? new Date().toISOString() : parsed.toISOString();
}

function mapMediaAsset(asset: MediaAssetWithUrl): DashboardMediaItem | null {
  const thumbnailUrl = asset.signedUrl ?? asset.downloadUrl ?? '';

  if (!thumbnailUrl) {
    return null;
  }

  return {
    id: asset.id,
    filename: asset.filename,
    thumbnailUrl,
    createdAt: toIsoString(asset.createdAt),
  };
}

router.get('/overview', authenticateToken, async (req: AuthenticatedRequest, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: 'Authentication required' });
    }

    const now = new Date();
    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);

    const [
      postsTodayResult,
      upcomingResult,
      generatedResult,
      mediaCountResult,
      upcomingPostsRows,
      galleryAssets,
    ] = await Promise.all([
      db
        .select({ count: sql<number>`count(*)` })
        .from(postJobs)
        .where(and(eq(postJobs.userId, userId), gte(postJobs.createdAt, startOfDay))),
      db
        .select({ count: sql<number>`count(*)` })
        .from(postJobs)
        .where(and(eq(postJobs.userId, userId), gte(postJobs.scheduledAt, now))),
      db
        .select({ count: sql<number>`count(*)` })
        .from(contentGenerations)
        .where(eq(contentGenerations.userId, userId)),
      db
        .select({ count: sql<number>`count(*)` })
        .from(mediaAssets)
        .where(eq(mediaAssets.userId, userId)),
      db
        .select({
          id: postJobs.id,
          titleFinal: postJobs.titleFinal,
          subreddit: postJobs.subreddit,
          scheduledAt: postJobs.scheduledAt,
          status: postJobs.status,
        })
        .from(postJobs)
        .where(and(eq(postJobs.userId, userId), gte(postJobs.scheduledAt, now)))
        .orderBy(asc(postJobs.scheduledAt))
        .limit(MAX_SCHEDULED_POSTS),
      MediaManager.getUserAssets(userId, MAX_GALLERY_ITEMS),
    ]);

    const stats: DashboardStats = {
      postsToday: Number(postsTodayResult[0]?.count ?? 0),
      upcomingPosts: Number(upcomingResult[0]?.count ?? 0),
      generatedContent: Number(generatedResult[0]?.count ?? 0),
      mediaAssets: Number(mediaCountResult[0]?.count ?? 0),
    };

    const scheduledPosts: DashboardScheduledPost[] = upcomingPostsRows.map((post) => ({
      id: post.id,
      title: post.titleFinal,
      subreddit: post.subreddit,
      scheduledAt: toIsoString(post.scheduledAt),
      status: post.status,
    }));

    const gallery = galleryAssets
      .map(mapMediaAsset)
      .filter((asset): asset is DashboardMediaItem => asset !== null);

    res.json({
      stats,
      scheduledPosts,
      gallery,
    });
  } catch (error) {
    console.error('Failed to load dashboard overview:', error);
    res.status(500).json({ message: 'Failed to load dashboard data' });
  }
});

export { router as dashboardRoutes };
tests/integration/modern-dashboard.test.tsx
New
+149
-0

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import React from 'react';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { createRoot, Root } from 'react-dom/client';
import { act } from 'react-dom/test-utils';

import { ModernDashboard } from '@/components/modern-dashboard';

vi.mock('wouter', () => ({
  useLocation: () => ['', vi.fn()],
}));

vi.mock('@/hooks/useAuth', () => ({
  useAuth: () => ({ user: { id: 1, username: 'TestUser', tier: 'pro' } }),
}));

const toastMock = vi.fn();
vi.mock('@/hooks/use-toast', () => ({
  useToast: () => ({ toast: toastMock }),
}));

const originalFetch = globalThis.fetch;

function createMockFetch(responseBody: unknown) {
  return vi.fn(async () =>
    new Response(JSON.stringify(responseBody), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    }),
  ) as unknown as typeof fetch;
}

describe('ModernDashboard component', () => {
  let container: HTMLDivElement;
  let root: Root | undefined;

  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2024-07-01T08:00:00Z'));
    toastMock.mockReset();
    window.innerWidth = 1280;
    container = document.createElement('div');
    document.body.appendChild(container);
  });

  afterEach(() => {
    if (root) {
      act(() => {
        root?.unmount();
      });
      root = undefined;
    }
    container.remove();
    vi.useRealTimers();
    vi.clearAllMocks();
    globalThis.fetch = originalFetch;
  });

  it('renders fetched stats, gallery, and schedule entries', async () => {
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false, cacheTime: 0, staleTime: 0 },
      },
    });

    const overviewResponse = {
      stats: {
        postsToday: 4,
        upcomingPosts: 1,
        generatedContent: 12,
        mediaAssets: 9,
      },
      gallery: [
        {
          id: 1,
          filename: 'highlight.jpg',
          thumbnailUrl: '/media/highlight.jpg',
          createdAt: '2024-06-01T10:00:00.000Z',
        },
      ],
      scheduledPosts: [
        {
          id: 301,
          title: 'Morning Session',
          subreddit: 'SelfieWorld',
          scheduledAt: '2024-07-01T10:00:00.000Z',
          status: 'queued',
        },
      ],
    };

    globalThis.fetch = createMockFetch(overviewResponse);

    await act(async () => {
      root = createRoot(container);
      root.render(
        <QueryClientProvider client={queryClient}>
          <ModernDashboard user={{ id: 1, username: 'TestUser' }} />
        </QueryClientProvider>,
      );
    });

    await act(async () => {
      await Promise.resolve();
    });

    expect(container.querySelector('img[alt="highlight.jpg"]')).not.toBeNull();
    expect(container.textContent).toContain('Morning Session');
    expect(container.textContent).toContain('1 UPCOMING');
  });

  it('shows empty states when no data is returned', async () => {
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false, cacheTime: 0, staleTime: 0 },
      },
    });

    const overviewResponse = {
      stats: {
        postsToday: 0,
        upcomingPosts: 0,
        generatedContent: 0,
        mediaAssets: 0,
      },
      gallery: [],
      scheduledPosts: [],
    };

    globalThis.fetch = createMockFetch(overviewResponse);

    await act(async () => {
      root = createRoot(container);
      root.render(
        <QueryClientProvider client={queryClient}>
          <ModernDashboard user={{ id: 2, username: 'Creator' }} />
        </QueryClientProvider>,
      );
    });

    await act(async () => {
      await Promise.resolve();
    });

    expect(container.textContent).toContain('Upload media to populate your gallery preview.');
    expect(container.textContent).toContain('No upcoming posts scheduled yet. Queue a post to see it here.');
    expect(container.textContent).toContain('0 UPCOMING');
  });
});
tests/routes/dashboard.test.ts
New
+143
-0

import express from 'express';
import request from 'supertest';
import { beforeEach, describe, expect, it, vi } from 'vitest';

const countsQueueDefault = ['postsToday', 'upcomingPosts', 'generatedContent', 'mediaAssets'] as const;
type CountKey = typeof countsQueueDefault[number];

const mockCounts: Record<CountKey, number> = {
  postsToday: 3,
  upcomingPosts: 2,
  generatedContent: 7,
  mediaAssets: 5,
};

const upcomingRows = [
  {
    id: 101,
    titleFinal: 'Sunrise Session',
    subreddit: 'SelfieWorld',
    scheduledAt: new Date('2024-07-01T12:00:00Z'),
    status: 'queued',
  },
  {
    id: 102,
    titleFinal: 'Evening Glow',
    subreddit: 'FreeKarma4U',
    scheduledAt: new Date('2024-07-01T18:00:00Z'),
    status: 'processing',
  },
];

interface MockMediaAsset {
  id: number;
  filename: string;
  signedUrl: string;
  downloadUrl: string;
  createdAt: Date;
  key: string;
  bytes: number;
  mime: string;
  visibility: string;
}

const mediaAssetsResponse: MockMediaAsset[] = [
  {
    id: 201,
    filename: 'gallery-one.jpg',
    signedUrl: '/media/gallery-one.jpg',
    downloadUrl: '/media/gallery-one.jpg',
    createdAt: new Date('2024-06-01T10:00:00Z'),
    key: 'gallery-one.jpg',
    bytes: 1234,
    mime: 'image/jpeg',
    visibility: 'private',
  },
];

let countsQueue: CountKey[] = [...countsQueueDefault];

const mediaManagerMock = {
  getUserAssets: vi.fn<(userId: number, limit?: number) => Promise<MockMediaAsset[]>>(),
};

vi.mock('../../server/middleware/auth.js', () => ({
  authenticateToken: (req: express.Request, _res: express.Response, next: express.NextFunction) => {
    (req as express.Request & { user?: { id: number } }).user = { id: 42 };
    next();
  },
}));

vi.mock('../../server/lib/media.js', () => ({
  MediaManager: mediaManagerMock,
}));

vi.mock('../../server/db.js', () => ({
  db: {
    select: (selection: Record<string, unknown>) => {
      if ('titleFinal' in selection) {
        return {
          from: () => ({
            where: () => ({
              orderBy: () => ({
                limit: async () => upcomingRows,
              }),
            }),
          }),
        };
      }

      return {
        from: () => ({
          where: async () => {
            const key = countsQueue.shift();
            const value = key ? mockCounts[key] : 0;
            return [{ count: value }];
          },
        }),
      };
    },
  },
}));

const { dashboardRoutes } = await import('../../server/routes/dashboard.js');

describe('Dashboard routes', () => {
  beforeEach(() => {
    countsQueue = [...countsQueueDefault];
    mediaManagerMock.getUserAssets.mockReset();
    mediaManagerMock.getUserAssets.mockResolvedValue(mediaAssetsResponse);
  });

  it('returns aggregated metrics, gallery, and schedule data', async () => {
    const app = express();
    app.use(express.json());
    app.use('/api/dashboard', dashboardRoutes);

    const response = await request(app).get('/api/dashboard/overview').expect(200);

    expect(response.body.stats).toEqual({
      postsToday: mockCounts.postsToday,
      upcomingPosts: mockCounts.upcomingPosts,
      generatedContent: mockCounts.generatedContent,
      mediaAssets: mockCounts.mediaAssets,
    });

    expect(response.body.gallery).toHaveLength(mediaAssetsResponse.length);
    expect(response.body.gallery[0]).toMatchObject({
      id: mediaAssetsResponse[0].id,
      filename: mediaAssetsResponse[0].filename,
      thumbnailUrl: mediaAssetsResponse[0].signedUrl,
    });
    expect(typeof response.body.gallery[0].createdAt).toBe('string');

    expect(response.body.scheduledPosts).toHaveLength(upcomingRows.length);
    expect(response.body.scheduledPosts[0]).toMatchObject({
      id: upcomingRows[0].id,
      title: upcomingRows[0].titleFinal,
      subreddit: upcomingRows[0].subreddit,
      status: upcomingRows[0].status,
    });
    expect(response.body.scheduledPosts[0].scheduledAt).toBe(upcomingRows[0].scheduledAt.toISOString());
  });
});
