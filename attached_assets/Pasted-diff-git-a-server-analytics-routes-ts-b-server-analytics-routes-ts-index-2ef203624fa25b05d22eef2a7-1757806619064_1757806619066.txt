diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
index 2ef203624fa25b05d22eef2a7120e8cfb5da511b..3f0bb2d3b77e467bc0f34ad7e9ad6a8e9e6655a2 100644
--- a/server/analytics-routes.ts
+++ b/server/analytics-routes.ts
@@ -42,51 +42,51 @@ const eventsPayloadSchema = z.object({
 
 const dateRangeSchema = z.object({
   startDate: z.string().optional(),
   endDate: z.string().optional(),
   period: z.enum(['7d', '30d', '90d']).optional().default('7d')
 });
 
 export function registerAnalyticsRoutes(app: Express) {
 
   // POST /api/analytics/events - Collect analytics events (batch)
   app.post('/api/analytics/events', async (req: Request, res: Response) => {
     try {
       const validation = eventsPayloadSchema.safeParse(req.body);
       if (!validation.success) {
         return res.status(400).json({
           error: 'Invalid events payload',
           details: validation.error.issues
         });
       }
 
       const { events } = validation.data;
       const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
 
       // Process each event
       for (const event of events) {
-        await processAnalyticsEvent(event, ipAddress);
+        await processAnalyticsEvent(event as AnalyticsEvent, ipAddress);
       }
 
       res.json({ success: true, processed: events.length });
     } catch (error) {
       console.error('Analytics events error:', error);
       res.status(500).json({ error: 'Failed to process analytics events' });
     }
   });
 
   // GET /api/analytics/:period - Get analytics data for dashboard
   app.get('/api/analytics/:period', async (req: Request, res: Response) => {
     try {
       const { period } = req.params;
       const validation = dateRangeSchema.safeParse({ period });
       if (!validation.success) {
         return res.status(400).json({ error: 'Invalid period' });
       }
 
       const { startDate, endDate } = getDateRange(period);
       const userId = getUserIdFromRequest(req);
 
       const analytics = await getAnalyticsData(userId, startDate, endDate);
       res.json(analytics);
     } catch (error) {
       console.error('Analytics fetch error:', error);
diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
index 2ef203624fa25b05d22eef2a7120e8cfb5da511b..3f0bb2d3b77e467bc0f34ad7e9ad6a8e9e6655a2 100644
--- a/server/analytics-routes.ts
+++ b/server/analytics-routes.ts
@@ -169,159 +169,215 @@ export function registerAnalyticsRoutes(app: Express) {
         .orderBy(desc(userSessions.startedAt))
         .limit(limit);
 
       res.json(sessions);
     } catch (error) {
       console.error('Sessions analytics error:', error);
       res.status(500).json({ error: 'Failed to fetch session analytics' });
     }
   });
 
   app.get('/api/revenue', async (_req: Request, res: Response) => {
     try {
       const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
         apiVersion: '2023-10-16',
       });
       const balance = await stripe.balance.retrieve();
       res.json({ available: balance.available[0]?.amount ?? 0 });
     } catch (error) {
       console.error('Revenue endpoint error:', error);
       res.status(500).json({ error: 'Failed to fetch revenue' });
     }
   });
 }
 
 // Helper Functions
+interface BaseAnalyticsEvent extends z.infer<typeof analyticsEventSchema> {}
 
-type AnalyticsEvent = z.infer<typeof analyticsEventSchema>;
+interface PageViewEvent extends BaseAnalyticsEvent {
+  eventType: 'page_view';
+  path: string;
+  title: string;
+}
+
+interface PageEndEvent extends BaseAnalyticsEvent {
+  eventType: 'page_end';
+  path: string;
+  timeOnPage?: number;
+  scrollDepth?: number;
+  exitPage?: boolean;
+}
+
+interface EngagementEvent extends BaseAnalyticsEvent {
+  eventType: 'engagement_event';
+  type: string;
+  element?: string;
+  page?: string;
+  metadata?: unknown;
+  value?: number;
+}
+
+interface ContentViewEvent extends BaseAnalyticsEvent {
+  eventType: 'content_view';
+  contentId: number;
+  platform?: string;
+  subreddit?: string;
+  viewType?: string;
+  timeSpent?: number;
+}
+
+interface SessionEndEvent extends BaseAnalyticsEvent {
+  eventType: 'session_end';
+  duration?: number;
+}
+
+type AnalyticsEvent =
+  | PageViewEvent
+  | PageEndEvent
+  | EngagementEvent
+  | ContentViewEvent
+  | SessionEndEvent;
+
+interface DeviceInfo {
+  deviceType: string;
+  browser: string;
+  os: string;
+}
+
+type LocationInfo = { country?: string; city?: string };
 
 async function processAnalyticsEvent(event: AnalyticsEvent, ipAddress: string) {
   const deviceInfo = parseUserAgent(event.userAgent ?? '');
   const locationInfo = await getLocationFromIP(ipAddress);
 
   switch (event.eventType) {
     case 'page_view':
       await handlePageView(event, ipAddress, deviceInfo, locationInfo);
       break;
     case 'page_end':
       await handlePageEnd(event);
       break;
     case 'engagement_event':
       await handleEngagementEvent(event);
       break;
     case 'content_view':
       await handleContentView(event, ipAddress);
       break;
     case 'session_end':
       await handleSessionEnd(event);
       break;
     default:
       // Log unknown event types for debugging
       console.log('Unknown analytics event type:', event.eventType);
   }
 }
 
-async function handlePageView(event: any, ipAddress: string, deviceInfo: any, locationInfo: any) {
+async function handlePageView(
+  event: PageViewEvent,
+  ipAddress: string,
+  deviceInfo: DeviceInfo,
+  locationInfo: LocationInfo | null
+) {
   // Create or update session
   await db.insert(userSessions).values({
     sessionId: event.sessionId,
     userId: event.userId ? parseInt(event.userId) : null,
     ipAddress,
     userAgent: event.userAgent,
     referrer: event.referrer,
     utmSource: extractUTMParam(event.url, 'utm_source'),
     utmMedium: extractUTMParam(event.url, 'utm_medium'),
     utmCampaign: extractUTMParam(event.url, 'utm_campaign'),
     deviceType: deviceInfo.deviceType,
     browser: deviceInfo.browser,
     os: deviceInfo.os,
     country: locationInfo?.country || null,
     city: locationInfo?.city || null,
     startedAt: new Date(event.timestamp),
     pageCount: 1
   }).onConflictDoUpdate({
     target: userSessions.sessionId,
     set: {
       pageCount: sql`${userSessions.pageCount} + 1`,
       endedAt: new Date(event.timestamp)
     }
   });
 
   // Record page view
   await db.insert(pageViews).values({
     sessionId: event.sessionId,
     userId: event.userId ? parseInt(event.userId) : null,
     path: event.path,
     title: event.title,
     referrer: event.referrer,
     createdAt: new Date(event.timestamp)
   });
 }
 
-async function handlePageEnd(event: any) {
+async function handlePageEnd(event: PageEndEvent) {
   if (!event.timeOnPage) return;
 
   // Update the latest page view with time spent
   await db.update(pageViews)
     .set({
       timeOnPage: event.timeOnPage,
       scrollDepth: event.scrollDepth,
       exitPage: event.exitPage
     })
     .where(and(
       eq(pageViews.sessionId, event.sessionId),
       eq(pageViews.path, event.path)
     ));
 }
 
-async function handleEngagementEvent(event: any) {
+async function handleEngagementEvent(event: EngagementEvent) {
   await db.insert(engagementEvents).values({
     sessionId: event.sessionId,
     userId: event.userId ? parseInt(event.userId) : null,
     eventType: event.type,
     element: event.element,
     page: event.page,
     metadata: event.metadata,
     value: event.value,
     createdAt: new Date(event.timestamp)
   });
 }
 
-async function handleContentView(event: any, ipAddress: string) {
+async function handleContentView(event: ContentViewEvent, ipAddress: string) {
   await db.insert(contentViews).values({
     contentId: event.contentId,
     sessionId: event.sessionId,
     userId: event.userId ? parseInt(event.userId) : null,
     platform: event.platform,
     subreddit: event.subreddit,
     viewType: event.viewType,
     ipAddress,
     timeSpent: event.timeSpent
   });
 }
 
-async function handleSessionEnd(event: any) {
+async function handleSessionEnd(event: SessionEndEvent) {
   await db.update(userSessions)
     .set({
       endedAt: new Date(event.timestamp),
       duration: event.duration
     })
     .where(eq(userSessions.sessionId, event.sessionId));
 }
 
 async function getAnalyticsData(userId: number | null, startDate: Date, endDate: Date) {
   const where = userId 
     ? and(eq(userSessions.userId, userId), gte(userSessions.startedAt, startDate), lte(userSessions.startedAt, endDate))
     : and(gte(userSessions.startedAt, startDate), lte(userSessions.startedAt, endDate));
 
   // Get basic metrics
   const sessionStats = await db
     .select({
       totalSessions: count(),
       totalPageViews: sum(userSessions.pageCount),
       avgDuration: avg(userSessions.duration),
       uniqueUsers: count(sql`DISTINCT ${userSessions.userId}`)
     })
     .from(userSessions)
     .where(where);
 
   // Get content generation stats
diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
index 2ef203624fa25b05d22eef2a7120e8cfb5da511b..3f0bb2d3b77e467bc0f34ad7e9ad6a8e9e6655a2 100644
--- a/server/analytics-routes.ts
+++ b/server/analytics-routes.ts
@@ -449,64 +505,64 @@ function getDateRange(period: string): { startDate: Date; endDate: Date } {
     case '7d':
       startDate.setDate(endDate.getDate() - 7);
       break;
     case '30d':
       startDate.setDate(endDate.getDate() - 30);
       break;
     case '90d':
       startDate.setDate(endDate.getDate() - 90);
       break;
     default:
       startDate.setDate(endDate.getDate() - 7);
   }
   
   return { startDate, endDate };
 }
 
 function extractUTMParam(url: string, param: string): string | null {
   try {
     const urlObj = new URL(url);
     return urlObj.searchParams.get(param);
   } catch {
     return null;
   }
 }
 
-function parseUserAgent(userAgent?: string): unknown {
+function parseUserAgent(userAgent?: string): DeviceInfo {
   // Simple user agent parsing - can be enhanced with a library like 'ua-parser-js'
   if (!userAgent) return { deviceType: 'unknown', browser: 'unknown', os: 'unknown' };
   
   const mobile = /Mobile|Android|iPhone|iPad/i.test(userAgent);
   const tablet = /iPad|Tablet/i.test(userAgent);
   
   let deviceType = 'desktop';
   if (tablet) deviceType = 'tablet';
   else if (mobile) deviceType = 'mobile';
 
   let browser = 'unknown';
   if (userAgent.includes('Chrome')) browser = 'Chrome';
   else if (userAgent.includes('Firefox')) browser = 'Firefox';
   else if (userAgent.includes('Safari')) browser = 'Safari';
   else if (userAgent.includes('Edge')) browser = 'Edge';
 
   let os = 'unknown';
   if (userAgent.includes('Windows')) os = 'Windows';
   else if (userAgent.includes('Mac')) os = 'macOS';
   else if (userAgent.includes('Linux')) os = 'Linux';
   else if (userAgent.includes('Android')) os = 'Android';
   else if (userAgent.includes('iOS')) os = 'iOS';
 
   return { deviceType, browser, os };
 }
 
-async function getLocationFromIP(ipAddress: string): Promise<{ country?: string; city?: string } | null> {
+async function getLocationFromIP(ipAddress: string): Promise<LocationInfo | null> {
   if (!geoReader) return null;
   try {
     const record = await geoReader.city(ipAddress);
     return {
       country: record.country?.isoCode,
       city: record.city?.names?.en,
     };
   } catch {
     return null;
   }
 }
