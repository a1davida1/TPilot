apply_patch <<'PATCH'
*** Begin Patch
*** Add File: server/lib/errors.ts
@@
+export class AppError extends Error {
+  public readonly statusCode: number;
+  public readonly isOperational: boolean;
+
+  constructor(message: string, statusCode = 500, isOperational = true) {
+    super(message);
+    this.statusCode = statusCode;
+    this.isOperational = isOperational;
+    Object.setPrototypeOf(this, new.target.prototype);
+  }
+}
+
+type AsyncFn<TArgs extends unknown[], TResult> = (...args: TArgs) => Promise<TResult>;
+
+export class CircuitBreaker<TArgs extends unknown[], TResult> {
+  private failures = 0;
+  private nextAttempt = 0;
+
+  constructor(
+    private readonly fn: AsyncFn<TArgs, TResult>,
+    private readonly threshold = 5,
+    private readonly timeout = 60_000
+  ) {}
+
+  async call(...args: TArgs): Promise<TResult> {
+    if (this.failures >= this.threshold) {
+      if (Date.now() < this.nextAttempt) {
+        throw new AppError('Service temporarily unavailable', 503);
+      }
+      this.failures = 0;
+    }
+
+    try {
+      const result = await this.fn(...args);
+      this.failures = 0;
+      return result;
+    } catch (error) {
+      this.failures++;
+      if (this.failures >= this.threshold) {
+        this.nextAttempt = Date.now() + this.timeout;
+      }
+      throw error;
+    }
+  }
+}
*** End Patch
*** Begin Patch
*** Add File: server/types/express.d.ts
@@
+interface PendingOperation {
+  cleanup: () => Promise<unknown>;
+}
+
+declare global {
+  namespace Express {
+    interface Request {
+      pendingOperations?: PendingOperation[];
+    }
+  }
+}
+
+export {};
*** End Patch
*** Begin Patch
*** Update File: server/middleware/security.ts
@@
-import express from "express";
-import { logger as appLogger, validateSentryDSN } from "../bootstrap/logger.js";
+import express from "express";
+import * as Sentry from "@sentry/node";
+import { logger as appLogger, validateSentryDSN } from "../bootstrap/logger.js";
+import { AppError } from "../lib/errors.js";
@@
-export const errorHandler = (err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
-  logger.error('Error:', {
-    message: err.message,
-    stack: err.stack,
-    path: req.path,
-    method: req.method,
-    ip: req.userIP
-  });
-
-  // Don't leak error details in production
-  if (process.env.NODE_ENV === 'production') {
-    return res.status(err.status || 500).json({
-      error: 'An error occurred processing your request'
-    });
-  }
-
-  // Development - send full error
-  return res.status(err.status || 500).json({
-    error: err.message,
-    stack: err.stack
-  });
-};
+export const errorHandler = async (
+  err: Error,
+  req: express.Request,
+  res: express.Response,
+  _next: express.NextFunction
+) => {
+  const appError =
+    err instanceof AppError
+      ? err
+      : new AppError(err.message || "Internal Server Error", (err as any).status ?? 500, false);
+
+  logger.error("Error:", {
+    message: err.message,
+    stack: err.stack,
+    path: req.path,
+    method: req.method,
+    ip: (req as any).userIP
+  });
+
+  if (!appError.isOperational) {
+    Sentry.captureException(err, {
+      user: (req as any).user?.id,
+      tags: { endpoint: req.path }
+    });
+  }
+
+  if (req.pendingOperations) {
+    await Promise.all(req.pendingOperations.map(op => op.cleanup().catch(() => undefined)));
+  }
+
+  if (process.env.NODE_ENV === "production") {
+    return res.status(appError.statusCode).json({
+      error: appError.isOperational ? appError.message : "An unexpected error occurred"
+    });
+  }
+
+  return res.status(appError.statusCode).json({
+    error: appError.message,
+    stack: err.stack
+  });
+};
*** End Patch
*** Begin Patch
*** Update File: server/index.ts
@@
-    app.use((err: unknown, req: Request, res: Response, _next: NextFunction) => {
-      const status = err.status || err.statusCode || 500;
-      const message = err.message || "Internal Server Error";
-
-      res.status(status).json({ message });
-      logger.error(message, { requestId: req.id, stack: err.stack });
-      if (Sentry) {
-        Sentry.captureException(err);
-      }
-      // Don't throw - let Express handle the error response
-    });
+    // Global error handler is applied within registerRoutes
*** End Patch
PATCH
