diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
index 9253c727ab5850dba4db2d130f21518d7f1f22ab..febb61a62aeca55ba81de713ee65fca41b5a47e0 100644
--- a/server/caption/textOnlyPipeline.ts
+++ b/server/caption/textOnlyPipeline.ts
@@ -1,52 +1,50 @@
 import * as fs from "node:fs/promises";
 import * as path from "node:path";
 import { z } from "zod";
-import { getTextModel } from "../lib/gemini-client";
-import type { GenerativeModel } from "@google/generative-ai";
+import { getTextModel, type GeminiModel } from "../lib/gemini-client";
 import { CaptionArray, CaptionItem, RankResult, platformChecks } from "./schema";
 import { enrichWithTitleCandidates } from "./geminiPipeline";
 import { normalizeSafetyLevel } from "./normalizeSafetyLevel";
 import { extractToneOptions } from "./toneOptions";
 import { variantContainsBannedWord } from "./bannedWords";
 import { buildVoiceGuideBlock } from "./stylePack";
 import { serializePromptField } from "./promptUtils";
 import { ensureFallbackCompliance } from "./inferFallbackFromFacts";
 import { dedupeVariantsForRanking } from "./dedupeVariants";
 import { dedupeCaptionVariants } from "./dedupeCaptionVariants";
 import {
   buildRerankHint,
   detectVariantViolations,
   fallbackHashtags,
   formatViolationSummary,
   sanitizeFinalVariant
 } from "./rankGuards";
 
 type GeminiResponse = {
-  response?: {
-    text(): string;
-  };
+  text?: (() => unknown) | string;
+  response?: unknown;
 };
 
 const _MAX_VARIANT_ATTEMPTS = 4;
 const VARIANT_TARGET = 5;
 const _VARIANT_RETRY_LIMIT = 4;
 const CAPTION_KEY_LENGTH = 80;
 
 function _captionKey(caption: string): string {
   return caption.trim().slice(0, 80).toLowerCase();
 }
 
 function _hintSnippet(caption: string): string {
   const normalized = caption.trim().replace(/\s+/g, " ");
   return normalized.length > 60 ? `${normalized.slice(0, 57)}â€¦` : normalized;
 }
 
 function uniqueCaptionKey(caption: string): string {
   return caption.trim().slice(0, CAPTION_KEY_LENGTH).toLowerCase();
 }
 
 function truncateForHint(caption: string): string {
   const trimmed = caption.trim();
   if (trimmed.length <= 60) {
     return trimmed;
   }
diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
index 9253c727ab5850dba4db2d130f21518d7f1f22ab..febb61a62aeca55ba81de713ee65fca41b5a47e0 100644
--- a/server/caption/textOnlyPipeline.ts
+++ b/server/caption/textOnlyPipeline.ts
@@ -101,87 +99,78 @@ function _normalizeVariantFields(
       platform,
       theme,
       context,
       existingCaption: existingCaption || (typeof next.caption === 'string' ? next.caption : undefined),
     }
   );
   
   next.hashtags = fallback.hashtags;
   next.cta = fallback.cta;
   next.alt = fallback.alt;
   
   if (typeof next.caption !== "string" || next.caption.trim().length < 1) {
     next.caption = existingCaption || "Here's something I'm proud of today.";
   }
   
   return CaptionItem.parse(next);
 }
 
 async function load(p:string){ return fs.readFile(path.join(process.cwd(),"prompts",p),"utf8"); }
 function stripToJSON(txt:string){ const i=Math.min(...[txt.indexOf("{"),txt.indexOf("[")].filter(x=>x>=0));
   const j=Math.max(txt.lastIndexOf("}"),txt.lastIndexOf("]")); return JSON.parse((i>=0&&j>=0)?txt.slice(i,j+1):txt); }
 
 type ResponseTextFunction = () => unknown;
 
 interface GeminiTextEnvelope {
-  response?: {
-    text?: ResponseTextFunction | string;
-  };
-}
-
-type TextModelFunction = (prompt: Array<{ text: string }>) => Promise<unknown>;
-
-interface TextModelObject {
-  generateContent(prompt: Array<{ text: string }>): Promise<unknown>;
+  text?: ResponseTextFunction | string;
+  response?: unknown;
 }
 
 async function invokeTextModel(prompt: Array<{ text: string }>): Promise<unknown> {
-  const model = getTextModel() as unknown;
-  if (typeof model === "function") {
-    return await (model as TextModelFunction)(prompt);
-  }
-  if (model && typeof (model as TextModelObject).generateContent === "function") {
-    return await (model as TextModelObject).generateContent(prompt);
-  }
-  throw new Error("Gemini text model is neither callable nor exposes generateContent");
+  const model = getTextModel();
+  return model.generateContent(prompt);
 }
 
 async function resolveResponseText(payload: unknown): Promise<string | undefined> {
+  if (typeof payload === "string") {
+    return payload;
+  }
+
   if (!payload || typeof payload !== "object") {
     return undefined;
   }
-  const { response } = payload as GeminiTextEnvelope;
-  if (!response) {
-    return undefined;
+
+  const { text, response } = payload as GeminiTextEnvelope;
+  if (typeof text === "string") {
+    return text;
   }
-  const { text } = response;
   if (typeof text === "function") {
     const value = await Promise.resolve(text());
     return typeof value === "string" ? value : undefined;
   }
-  if (typeof text === "string") {
-    return text;
+  if (response) {
+    return resolveResponseText(response);
   }
   return undefined;
 }
 
 function normalizeCaptionText(caption: string): string {
   return caption
     .normalize("NFKD")
     .toLowerCase()
     .replace(/[\u2018\u2019]/g, "'")
     .replace(/[\u201c\u201d]/g, '"')
     .replace(/[^\p{L}\p{N}]+/gu, " ")
     .replace(/\s+/g, " ")
     .trim();
 }
 
 function levenshtein(a: string, b: string): number {
   const rows = a.length + 1;
   const cols = b.length + 1;
   const dist: number[][] = Array.from({ length: rows }, (_, i) => {
     const row = new Array<number>(cols);
     row[0] = i;
     return row;
   });
 
   for (let j = 0; j < cols; j += 1) {
diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
index 9253c727ab5850dba4db2d130f21518d7f1f22ab..febb61a62aeca55ba81de713ee65fca41b5a47e0 100644
--- a/server/caption/textOnlyPipeline.ts
+++ b/server/caption/textOnlyPipeline.ts
@@ -223,51 +212,51 @@ function captionsAreSimilar(a: string, b: string): boolean {
   const unionSize = new Set([...tokensA, ...tokensB]).size || 1;
   const jaccard = intersectionSize / unionSize;
 
   return jaccard > 0.82;
 }
 
 type TextOnlyVariantParams = {
   platform:"instagram"|"x"|"reddit"|"tiktok";
   voice:string;
   theme:string;
   context?:string;
   hint?:string;
   nsfw?:boolean;
   style?: string;
   mood?: string;
 };
 
 export async function generateVariantsTextOnly(params: TextOnlyVariantParams): Promise<z.infer<typeof CaptionArray>> {
   const [sys, guard, prompt] = await Promise.all([
     load("system.txt"),
     load("guard.txt"),
     load("variants_textonly.txt")
   ]);
   const textModel = getTextModel();
 
-  const _voiceGuide = buildVoiceGuideBlock(params.voice);
+  const voiceGuide = buildVoiceGuideBlock(params.voice);
   const isRecord = (value: unknown): value is Record<string, unknown> =>
     typeof value === "object" && value !== null;
 
   const sanitizeVariant = (item: Record<string, unknown>): z.infer<typeof CaptionItem> => {
     const safetyLevel = normalizeSafetyLevel(
       typeof item.safety_level === "string" ? item.safety_level : "normal"
     );
 
 
     const caption = typeof item.caption === "string" && item.caption.trim().length > 0
       ? item.caption
       : "Sharing something I'm proud of today.";
 
     const mood = typeof item.mood === "string" && item.mood.trim().length >= 2
       ? item.mood
       : "engaging";
     const style = typeof item.style === "string" && item.style.trim().length >= 2
       ? item.style
       : "authentic";
     
     const cta = typeof item.cta === "string" && item.cta.trim().length >= 2
       ? item.cta
       : "Comment your thoughts below! ðŸ’­";
 
     const alt = typeof item.alt === "string" && item.alt.trim().length >= 20
diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
index 9253c727ab5850dba4db2d130f21518d7f1f22ab..febb61a62aeca55ba81de713ee65fca41b5a47e0 100644
--- a/server/caption/textOnlyPipeline.ts
+++ b/server/caption/textOnlyPipeline.ts
@@ -336,52 +325,57 @@ export async function generateVariantsTextOnly(params: TextOnlyVariantParams): P
     Array.from({ length: VARIANT_TARGET }, (_, index) => ({
       caption: `${safeFallbackCaption} (fallback ${index + 1})`,
       alt: `${safeFallbackAlt} (fallback ${index + 1})`,
       hashtags: [...safeFallbackHashtags],
       cta: safeFallbackCta,
       mood: params.mood ?? "engaging",
       style: params.style ?? "authentic",
       safety_level: "normal" as const,
       nsfw: params.nsfw ?? false,
     }));
 
   const fetchVariants = async (varietyHint: string | undefined, existingCaptions: string[]) => {
     const user = buildUserPrompt(varietyHint, existingCaptions);
 
     // Apply tone to system prompt if available
     const toneLines: string[] = [];
     if (params.style) toneLines.push(`STYLE: ${params.style}`);
     if (params.mood) toneLines.push(`MOOD: ${params.mood}`);
     const sysWithTone = toneLines.length > 0 ? `${sys}\n${toneLines.join('\n')}` : sys;
 
     const fallbackBatch = buildFallbackBatch();
     let candidates: unknown[] = fallbackBatch;
 
     try {
       const textModel = getTextModel();
+      const promptSections = [sysWithTone, guard, prompt, user];
+      if (voiceGuide) {
+        promptSections.push(voiceGuide);
+      }
+
       const response = await textModel.generateContent([
-        { text: `${sysWithTone}\n${guard}\n${prompt}\n${user}` }
+        { text: promptSections.join("\n") }
       ]);
 
       const rawText = await resolveResponseText(response);
       if (typeof rawText === "string" && rawText.trim().length > 0) {
         try {
           const json = stripToJSON(rawText);
           if (Array.isArray(json)) {
             candidates = json;
           } else {
             console.error("Gemini: variant payload was not an array in text-only pipeline");
           }
         } catch (parseError) {
           console.error("Gemini text-only variant parsing failed:", parseError);
         }
       } else {
         console.error("Gemini: empty response received in text-only pipeline");
       }
     } catch (error) {
       console.error("Gemini textModel.generateContent failed:", error);
     }
 
     return candidates;
   };
 
   const uniqueVariants: z.infer<typeof CaptionItem>[] = [];
diff --git a/server/caption/textOnlyPipeline.ts b/server/caption/textOnlyPipeline.ts
index 9253c727ab5850dba4db2d130f21518d7f1f22ab..febb61a62aeca55ba81de713ee65fca41b5a47e0 100644
--- a/server/caption/textOnlyPipeline.ts
+++ b/server/caption/textOnlyPipeline.ts
@@ -502,106 +496,106 @@ function _prepareVariantsForRanking(
       caption: safeFallbackCaption,
       alt: safeFallbackAlt,
       hashtags: [...safeFallbackHashtags],
       cta: safeFallbackCta,
       mood: "engaging",
       style: "authentic",
       safety_level: "normal",
       nsfw: false,
     });
 
     while (preparedVariants.length < options.targetLength) {
       const index = preparedVariants.length + 1;
       const captionSeed = baseVariant.caption || "Here's something I'm proud of today.";
       preparedVariants.push({
         ...baseVariant,
         caption: `${captionSeed} (filler ${index})`,
         alt: `${baseVariant.alt} (filler ${index})`,
       });
     }
   }
   // Deduplicate variants based on similarity if needed, though `generateVariantsTextOnly` already aims for uniqueness
   return dedupeCaptionVariants(preparedVariants).slice(0, options.targetLength);
 }
 
 async function requestTextOnlyRanking(
-  model: GenerativeModel,
+  model: GeminiModel,
   variantsInput: unknown[],
   serializedVariants: string,
   promptBlock: string,
   platform?: string,
   extraHint?: string
 ): Promise<unknown> {
   const hintBlock = extraHint && extraHint.trim().length > 0 ? `\nREMINDER: ${extraHint.trim()}` : "";
   const safeFallbackCaption = "Here's something I'm proud of today.";
   const safeFallbackAlt = "Engaging description that highlights the visual story.";
   const safeFallbackHashtags = fallbackHashtags(platform || "instagram");
   const safeFallbackCta = "Comment your thoughts below! ðŸ’­";
   const defaultScores = [5, 4, 3, 2, 1] as const;
 
   const fallbackFinalVariant = CaptionItem.parse({
     caption: safeFallbackCaption,
     alt: safeFallbackAlt,
     hashtags: [...safeFallbackHashtags],
     cta: safeFallbackCta,
     mood: "engaging",
     style: "authentic",
     safety_level: "normal",
     nsfw: false,
   });
 
   const fallbackResult = () => ({
     winner_index: 0,
     scores: [...defaultScores],
     reason: "Gemini unavailable - using fallback ranking",
     final: { ...fallbackFinalVariant },
   });
 
   let res: unknown;
   try {
     res = await model.generateContent([{ text: `${promptBlock}${hintBlock}\n${serializedVariants}` }]);
   } catch (error) {
     console.error("Text-only textModel.generateContent failed:", error);
     return fallbackResult();
   }
 
   let textOutput: string | null = null;
   const resolved = await resolveResponseText(res);
   if (typeof resolved === "string") {
     textOutput = resolved;
   } else if (res && typeof res === "object") {
     const geminiRes = res as GeminiResponse;
-    if (geminiRes.response && typeof geminiRes.response.text === "function") {
+    if (typeof geminiRes.text === "string") {
+      textOutput = geminiRes.text;
+    } else if (typeof geminiRes.text === "function") {
       try {
-        const raw = geminiRes.response.text();
+        const raw = geminiRes.text();
         textOutput = typeof raw === "string" ? raw : null;
       } catch (invokeError) {
         console.error("Gemini: failed to read text-only ranking response:", invokeError);
       }
     }
-  } else if (typeof res === "string") {
-    textOutput = res;
   }
 
   if (typeof textOutput !== "string" || textOutput.trim().length === 0) {
     console.error("Gemini: empty text-only ranking response");
     return fallbackResult();
   }
 
   let json: unknown;
   try {
     json = stripToJSON(textOutput) as unknown;
   } catch (parseError) {
     console.error("Gemini text-only ranking parsing failed:", parseError);
     return fallbackResult();
   }
 
   if (Array.isArray(json)) {
     const winner = json[0] as Record<string, unknown> | undefined;
     return {
       winner_index: 0,
       scores: [...defaultScores],
       reason: "Selected based on engagement potential",
       final: winner ?? { ...fallbackFinalVariant },
     };
   }
 
