diff --git a/moderation/validateContent.js b/moderation/validateContent.js
new file mode 100644
--- /dev/null
+++ b/moderation/validateContent.js
@@
-import { getSubredditRules, getUserRecentPosts, calculateSimilarity, mlSafetyCheck, generateSuggestions } from './moderation-utils.js';
+import {
+  getSubredditRules,
+  getUserRecentPosts,
+  calculateSimilarity,
+  mlSafetyCheck,
+  generateSuggestions,
+  getUserPostingStats,
+  detectBenignKeywords
+} from './moderation-utils.js';
 
-export function validateContent(text) {
-  if (text.includes('banned_word')) return false;
-  if (text.length > 280) return false;
-  return true;
-}
+export async function validateContent(content, context = {}) {
+  const violations = [];
+  const { subreddit, userId, allowNSFW = false } = context;
+
+  /* length check */
+  if (content.length > 280) {
+    violations.push({ type: 'length', severity: 'block' });
+  }
+
+  /* subreddit rules */
+  if (subreddit) {
+    const rules = await getSubredditRules(subreddit);
+    if (rules?.bannedDomains?.some(domain => content.includes(domain))) {
+      violations.push({ type: 'banned_domain', severity: 'block' });
+    }
+  }
+
+  /* disguised links */
+  const shorteners = [/bit\.ly/i, /tinyurl\.com/i, /goo\.gl/i, /t\.co/i, /is\.gd/i, /ow\.ly/i];
+  if (shorteners.some(rx => rx.test(content))) {
+    violations.push({ type: 'url_shortener', severity: 'warn' });
+  }
+
+  /* repetitive/spam */
+  if (userId) {
+    const recent = await getUserRecentPosts(userId);
+    const score = calculateSimilarity(content, recent);
+    if (score > 0.8) {
+      violations.push({ type: 'repetitive_content', severity: 'throttle' });
+    }
+  }
+
+  /* rateâ€‘limit circumvention */
+  if (userId) {
+    const stats = await getUserPostingStats(userId);
+    if (stats.requests > stats.allowed) {
+      violations.push({ type: 'rate_limit', severity: 'throttle' });
+    }
+  }
+
+  /* ML safety check */
+  try {
+    const safety = await mlSafetyCheck(content);
+    if (safety.nsfw > 0.7 && !allowNSFW) {
+      violations.push({ type: 'nsfw_content', severity: 'block' });
+    }
+  } catch (err) {
+    violations.push({ type: 'ml_error', severity: 'warn', detail: err.message });
+  }
+
+  /* context-aware filtering */
+  if (detectBenignKeywords(content)) {
+    const idx = violations.findIndex(v => v.type === 'nsfw_content');
+    if (idx !== -1) violations.splice(idx, 1);
+  }
+
+  return {
+    allowed: !violations.some(v => v.severity === 'block'),
+    violations,
+    suggestions: generateSuggestions(violations)
+  };
+}
diff --git a/moderation/moderation-utils.js b/moderation/moderation-utils.js
new file mode 100644
--- /dev/null
+++ b/moderation/moderation-utils.js
@@
+// Utilities supporting validateContent
+
+export async function getSubredditRules(subreddit) {
+  // TODO: replace with real datastore lookup
+  return { bannedDomains: ['spam.com', 'badsite.org'] };
+}
+
+export async function getUserRecentPosts(userId) {
+  // TODO: fetch recent posts from persistence layer
+  return [];
+}
+
+export function calculateSimilarity(content, posts) {
+  if (!posts.length) return 0;
+  const tokens = new Set(content.toLowerCase().split(/\W+/));
+  const scores = posts.map(p => {
+    const pTokens = new Set(p.toLowerCase().split(/\W+/));
+    const intersection = [...tokens].filter(t => pTokens.has(t));
+    return intersection.length / pTokens.size;
+  });
+  return Math.max(...scores);
+}
+
+export async function getUserPostingStats(userId) {
+  // TODO: integrate with rate-limit store
+  return { requests: 0, allowed: 10 };
+}
+
+export async function mlSafetyCheck(content) {
+  // TODO: hook up to ML service
+  return { nsfw: 0 };
+}
+
+export function generateSuggestions(violations) {
+  if (!violations.length) return [];
+  return violations.map(v => `Please avoid ${v.type}`);
+}
+
+export function detectBenignKeywords(content) {
+  const whitelist = [/medical/i, /education/i];
+  return whitelist.some(rx => rx.test(content));
+}
