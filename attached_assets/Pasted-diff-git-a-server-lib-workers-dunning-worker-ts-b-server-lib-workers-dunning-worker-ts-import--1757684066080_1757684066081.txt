diff --git a/server/lib/workers/dunning-worker.ts b/server/lib/workers/dunning-worker.ts
@@
-import { registerProcessor } from "../queue-factory.js";
-import { QUEUE_NAMES, type DunningJobData } from "../queue/index.js";
-import { db } from "../../db.js";
-import { users, eventLogs } from "@shared/schema.js";
-import { eq } from "drizzle-orm";
-import { logger } from "../logger.js";
+import { registerProcessor } from "../queue-factory.js";
+import { QUEUE_NAMES, type DunningJobData } from "../queue/index.js";
+import { db } from "../../db.js";
+import { users, eventLogs, subscriptions } from "@shared/schema.js";
+import { eq } from "drizzle-orm";
+import { logger } from "../logger.js";
+import fetch from "node-fetch";
@@
-export class DunningWorker {
+interface RetryResult {
+  success: boolean;
+  provider: 'stripe' | 'ccbill';
+  transactionId?: string;
+  error?: string;
+}
+
+export class DunningWorker {
@@
-  private async getSubscriptionDetails(subscriptionId: number) {
-    // In full implementation, this would query a subscriptions table
-    // For now, return mock data
-    return {
-      id: subscriptionId,
-      userId: 1, // Mock user ID
-      plan: 'pro',
-      status: 'past_due',
-      paymentMethodId: 'pm_123',
-      amount: 2999, // $29.99
-    };
-  }
+  private async getSubscriptionDetails(subscriptionId: number) {
+    const [subscription] = await db
+      .select()
+      .from(subscriptions)
+      .where(eq(subscriptions.id, subscriptionId))
+      .limit(1);
+    return subscription ?? null;
+  }
@@
-  private async retryPayment(subscription: unknown) {
+  private async retryPayment(subscription: any): Promise<RetryResult> {
@@
-        return await this.retryStripePayment(subscription);
+        return await this.retryStripePayment(subscription);
       } else if (process.env.CCBILL_ACCOUNT_NUMBER && subscription.ccbillSubscriptionId) {
-        return await this.retryCCBillPayment(subscription);
+        return await this.retryCCBillPayment(subscription);
       } else {
         logger.warn('No payment provider configured for retry');
-        return { success: false, error: 'No payment method available for retry' };
+        return { success: false, provider: 'stripe', error: 'No payment method available for retry' };
       }
     } catch (error: unknown) {
       logger.error('Payment retry error:', { error });
-      return { success: false, error: error.message };
+      return { success: false, provider: 'stripe', error: error instanceof Error ? error.message : 'Unknown error' };
     }
   }
@@
-  private async retryStripePayment(subscription: unknown) {
+  private async retryStripePayment(subscription: any): Promise<RetryResult> {
@@
-        return { success: true, transactionId: paymentIntent.id, provider: 'stripe' };
+        return { success: true, transactionId: paymentIntent.id, provider: 'stripe' };
@@
-        return { success: false, error: `Payment failed: ${paymentIntent.status}`, provider: 'stripe' };
+        return { success: false, error: `Payment failed: ${paymentIntent.status}`, provider: 'stripe' };
@@
-    } catch (error: unknown) {
-      const errorMessage = error.decline_code || error.message || 'Payment failed';
-      return { success: false, error: errorMessage, provider: 'stripe' };
+    } catch (error: any) {
+      const errorMessage = error?.decline_code || error?.message || 'Payment failed';
+      return { success: false, error: errorMessage, provider: 'stripe' };
     }
   }
 
-  private async retryCCBillPayment(subscription: unknown) {
-    try {
-      // CCBill retry would use their API to process a new transaction
-      logger.info(`Retrying CCBill payment for subscription ${subscription.ccbillSubscriptionId}`);
-
-      // For now, log that CCBill retry is not yet implemented
-      return {
-        success: false,
-        error: 'CCBill retry not yet implemented',
-        provider: 'ccbill'
-      };
-    } catch (error: unknown) {
-      return { success: false, error: error.message, provider: 'ccbill' };
-    }
-  }
+  private async retryCCBillPayment(subscription: any): Promise<RetryResult> {
+    try {
+      const res = await fetch('https://datalink.ccbill.com/', {
+        method: 'POST',
+        body: new URLSearchParams({
+          subscriptionId: subscription.ccbillSubscriptionId,
+          amount: String(subscription.amount),
+        }),
+      });
+      if (!res.ok) {
+        return { success: false, provider: 'ccbill', error: `HTTP ${res.status}` };
+      }
+      const data = await res.json();
+      return {
+        success: Boolean(data.success),
+        transactionId: data.id,
+        provider: 'ccbill',
+      };
+    } catch (error: unknown) {
+      return {
+        success: false,
+        provider: 'ccbill',
+        error: error instanceof Error ? error.message : 'Unknown error',
+      };
+    }
+  }
diff --git a/server/analytics-routes.ts b/server/analytics-routes.ts
@@
-import { Request, Response, Express } from 'express';
-import Stripe from 'stripe';
+import { Request, Response, Express } from 'express';
+import Stripe from 'stripe';
+import { Reader } from '@maxmind/geoip2-node';
@@
-import { eq, desc, gte, lte, and, count, sum, avg, sql } from 'drizzle-orm';
+import { eq, desc, gte, lte, and, count, sum, avg, sql } from 'drizzle-orm';
@@
-export function registerAnalyticsRoutes(app: Express) {
+let geoReader: Reader | null = null;
+export async function initGeoReader() {
+  if (process.env.MAXMIND_DB_PATH) {
+    geoReader = await Reader.open(process.env.MAXMIND_DB_PATH);
+  }
+}
+
+export function registerAnalyticsRoutes(app: Express) {
@@
 async function getLocationFromIP(ipAddress: string): Promise<{ country?: string; city?: string } | null> {
-  // For now, return default values
-  return {
-    country: 'Unknown',
-    city: 'Unknown'
-  };
+  if (!geoReader) return null;
+  try {
+    const record = geoReader.city(ipAddress);
+    return {
+      country: record.country.isoCode,
+      city: record.city?.names?.en,
+    };
+  } catch {
+    return null;
+  }
 }
diff --git a/server/lib/referral-system.ts b/server/lib/referral-system.ts
@@
-import { db } from '../db';
-import { users } from '@shared/schema';
-import { eq, sql } from 'drizzle-orm';
-import { customAlphabet } from 'nanoid';
+import { db } from '../db';
+import { users, referralRewards } from '@shared/schema';
+import { eq, sql } from 'drizzle-orm';
+import { customAlphabet } from 'nanoid';
+import { notificationService } from '../services/notification-service.js';
@@
-    // In a real implementation, you would:
-    // 1. Credit the referrer's account
-    // 2. Send notification
-    // 3. Update referral tracking metrics
-
-    // For now, return the reward that would be given
-    return {
-      type: 'commission',
-      amount: 5, // $5 commission
-      description: 'Referral commission for successful subscription',
-    };
+    await db.insert(referralRewards).values({
+      referrerId: user.referredBy,
+      referredId: subscribingUserId,
+      amount: 5,
+    });
+    await notificationService.notifyReferralReward(
+      user.referredBy,
+      subscribingUserId,
+      5
+    );
+    return {
+      type: 'commission',
+      amount: 5,
+      description: 'Referral commission for successful subscription',
+    };
diff --git a/shared/schema.ts b/shared/schema.ts
@@
   lastLogin: timestamp("last_login"),
   passwordResetAt: timestamp("password_reset_at"),
-  deletedAt: timestamp("deleted_at"),
+  deletedAt: timestamp("deleted_at"),
+  isDeleted: boolean("is_deleted").default(false),
 });
@@
   pageCount: integer("page_count").default(0),
-  createdAt: timestamp("created_at").defaultNow(),
+  revokedAt: timestamp("revoked_at"),
+  createdAt: timestamp("created_at").defaultNow(),
 });
@@
 export const referrals = pgTable("referrals", {
   id: serial("id").primaryKey(),
   codeId: integer("code_id").references(() => referralCodes.id).notNull(),
   referrerId: integer("referrer_id").references(() => users.id).notNull(),
   receiverId: integer("receiver_id").references(() => users.id),
   createdAt: timestamp("created_at").defaultNow().notNull(),
 });
+
+export const referralRewards = pgTable("referral_rewards", {
+  id: serial("id").primaryKey(),
+  referrerId: integer("referrer_id").references(() => users.id).notNull(),
+  referredId: integer("referred_id").references(() => users.id).notNull(),
+  amount: integer("amount").notNull(),
+  createdAt: timestamp("created_at").defaultNow().notNull(),
+});
@@
 export type ReferralCode = typeof referralCodes.$inferSelect;
 export type Referral = typeof referrals.$inferSelect;
+export type ReferralReward = typeof referralRewards.$inferSelect;
diff --git a/server/storage.ts b/server/storage.ts
@@
   verificationTokens,
-  invoices
+  invoices,
+  userSessions
 } from "@shared/schema";
@@
   async getUserByUsername(username: string): Promise<User | undefined> {
     try {
-      const result = await db.select().from(users).where(eq(users.username, username)).limit(1);
+      const result = await db
+        .select()
+        .from(users)
+        .where(and(eq(users.username, username), eq(users.isDeleted, false)))
+        .limit(1);
       return result[0];
     } catch (error) {
       safeLog('error', 'Storage operation failed - getting user by username:', { error: error.message });
       return undefined;
     }
   }
 
   async getUserByEmail(email: string): Promise<User | undefined> {
     try {
-      const result = await db.select().from(users).where(eq(users.email, email)).limit(1);
+      const result = await db
+        .select()
+        .from(users)
+        .where(and(eq(users.email, email), eq(users.isDeleted, false)))
+        .limit(1);
       return result[0];
     } catch (error) {
       safeLog('error', 'Storage operation failed - getting user by email:', { error: error.message });
       return undefined;
     }
   }
@@
   async deleteUser(userId: number): Promise<void> {
     try {
-      await db
-        .update(users)
-        .set({ deletedAt: new Date(), email: null, username: `deleted_${userId}` })
-        .where(eq(users.id, userId));
+      const now = new Date();
+      await db
+        .update(users)
+        .set({ deletedAt: now, isDeleted: true, email: null, username: `deleted_${userId}` })
+        .where(eq(users.id, userId));
+      await db
+        .update(userSessions)
+        .set({ revokedAt: now })
+        .where(eq(userSessions.userId, userId));
     } catch (error) {
       safeLog('error', 'Storage operation failed - deleting user:', { error: error.message });
       throw error;
     }
   }
diff --git a/server/auth.ts b/server/auth.ts
@@
       let user;
       if (loginIdentifier && loginIdentifier.includes('@')) {
         // It's an email
         user = await storage.getUserByEmail(loginIdentifier);
       } else {
         // It's a username
         user = await storage.getUserByUsername(loginIdentifier || '');
       }
 
-      if (!user) {
+      if (!user || user.isDeleted) {
         return res.status(401).json({ message: 'Invalid credentials' });
       }
