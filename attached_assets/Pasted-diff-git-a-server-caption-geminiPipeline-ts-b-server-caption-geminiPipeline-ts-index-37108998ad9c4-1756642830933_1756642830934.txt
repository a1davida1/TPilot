diff --git a/server/caption/geminiPipeline.ts b/server/caption/geminiPipeline.ts
index 37108998ad9c40f0f2d243935691ab644da9bb82..35acaf8505b237d2b791a519c32185f38073870f 100644
--- a/server/caption/geminiPipeline.ts
+++ b/server/caption/geminiPipeline.ts
@@ -37,68 +37,68 @@ export async function extractFacts(imageUrl:string){
       imageData = await b64(imageUrl);
     }
     
     const img={ inlineData:{ data: imageData, mimeType } };
     console.log('Sending to Gemini for fact extraction...');
     const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
     const result = stripToJSON(res.response.text());
     console.log('Fact extraction completed successfully');
     return result;
   } catch (error) {
     console.error('Error in extractFacts:', error);
     throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
   }
 }
 
 export async function generateVariants(params:{platform:"instagram"|"x"|"reddit"|"tiktok", voice:string, facts:any, hint?:string}){
   const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("variants.txt");
   const user=`PLATFORM: ${params.platform}\nVOICE: ${params.voice}\nIMAGE_FACTS: ${JSON.stringify(params.facts)}\n${params.hint?`HINT:${params.hint}`:""}`;
   const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+user }]);
   const json=stripToJSON(res.response.text());
   // Fix common safety_level values
   if(Array.isArray(json)){
     json.forEach((item:any)=>{
       // Fix safety_level variations
       if(!item.safety_level || item.safety_level==="safe" || item.safety_level==="1" || item.safety_level===1) item.safety_level="normal";
-      else if(item.safety_level==="2" || item.safety_level===2) item.safety_level="spicy_safe";
+      else if(item.safety_level==="2" || item.safety_level===2 || item.safety_level==="suggestive") item.safety_level="spicy_safe";
       else if(item.safety_level==="3" || item.safety_level===3) item.safety_level="needs_review";
       // Fix other fields
       if(!item.mood || item.mood.length<2) item.mood="engaging";
       if(!item.style || item.style.length<2) item.style="authentic";
       if(!item.cta || item.cta.length<2) item.cta="Check it out";
     });
   }
   return CaptionArray.parse(json);
 }
 
 export async function rankAndSelect(variants:any){
   const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("rank.txt");
   const res=await textModel.generateContent([{ text: sys+"\n"+guard+"\n"+prompt+"\n"+JSON.stringify(variants) }]);
   const json=stripToJSON(res.response.text());
   // Fix safety_level in final result
   if(json.final){
     if(!json.final.safety_level || json.final.safety_level==="safe" || json.final.safety_level==="1" || json.final.safety_level===1) json.final.safety_level="normal";
-    else if(json.final.safety_level==="2" || json.final.safety_level===2) json.final.safety_level="spicy_safe";
+    else if(json.final.safety_level==="2" || json.final.safety_level===2 || json.final.safety_level==="suggestive") json.final.safety_level="spicy_safe";
     else if(json.final.safety_level==="3" || json.final.safety_level===3) json.final.safety_level="needs_review";
     if(!json.final.mood || json.final.mood.length<2) json.final.mood="engaging";
     if(!json.final.style || json.final.style.length<2) json.final.style="authentic";
     if(!json.final.cta || json.final.cta.length<2) json.final.cta="Check it out";
   }
   return RankResult.parse(json);
 }
 
 export async function pipeline({ imageUrl, platform, voice="flirty_playful" }:{
   imageUrl:string, platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string }){
   const facts = await extractFacts(imageUrl);
   let variants = await generateVariants({ platform, voice, facts });
   let ranked = await rankAndSelect(variants);
   let out = ranked.final;
 
   const err = platformChecks(platform, out);
   if (err) {
     variants = await generateVariants({ platform, voice, facts, hint:`Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.` });
     ranked = await rankAndSelect(variants);
     out = ranked.final;
   }
 
   return { facts, variants, ranked, final: out };
 }
