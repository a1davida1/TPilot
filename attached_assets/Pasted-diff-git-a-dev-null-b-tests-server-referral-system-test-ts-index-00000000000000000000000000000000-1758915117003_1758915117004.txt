diff --git a//dev/null b/tests/server/referral-system.test.ts
index 0000000000000000000000000000000000000000..8a1ed6cba8805033800f680bd77527fdd7307671 100644
--- a//dev/null
+++ b/tests/server/referral-system.test.ts
@@ -0,0 +1,112 @@
+import { beforeEach, describe, expect, it, vi } from 'vitest';
+
+const mockDb = {
+  select: vi.fn(),
+  update: vi.fn(),
+  insert: vi.fn(),
+};
+
+vi.mock('../../server/db.js', () => ({
+  db: mockDb,
+}));
+
+vi.mock('../../server/bootstrap/logger.js', () => ({
+  logger: {
+    info: vi.fn(),
+    error: vi.fn(),
+    warn: vi.fn(),
+  },
+}));
+
+import { ReferralManager } from '../../server/lib/referral-system.js';
+
+describe('ReferralManager.applyReferralCode', () => {
+  const referralCodeId = 10;
+  const referrerId = 20;
+  const newUserId = 30;
+
+  beforeEach(() => {
+    vi.clearAllMocks();
+    mockDb.select.mockReset();
+    mockDb.update.mockReset();
+    mockDb.insert.mockReset();
+  });
+
+  const primeSelectMocks = (existingReferral: boolean = false) => {
+    mockDb.select.mockImplementationOnce(() => ({
+      from: vi.fn().mockReturnValue({
+        where: vi.fn().mockReturnValue({
+          limit: vi.fn().mockResolvedValue([{ id: referralCodeId, ownerId: referrerId }]),
+        }),
+      }),
+    }))
+      .mockImplementationOnce(() => ({
+        from: vi.fn().mockReturnValue({
+          where: vi.fn().mockReturnValue({
+            limit: vi.fn().mockResolvedValue([{ id: referrerId, subscriptionStatus: 'active' }]),
+          }),
+        }),
+      }))
+      .mockImplementationOnce(() => ({
+        from: vi.fn().mockReturnValue({
+          where: vi.fn().mockReturnValue({
+            limit: vi.fn().mockResolvedValue(existingReferral ? [{ id: 1 }] : []),
+          }),
+        }),
+      }));
+  };
+
+  const primeUpdateMock = (setSpy: (values: Record<string, unknown>) => void) => {
+    mockDb.update.mockReturnValue({
+      set: vi.fn((values: Record<string, unknown>) => {
+        setSpy(values);
+        return {
+          where: vi.fn().mockResolvedValue([]),
+        };
+      }),
+    });
+  };
+
+  const primeInsertMock = (valuesSpy: (values: Record<string, unknown>) => void) => {
+    mockDb.insert.mockReturnValue({
+      values: vi.fn((values: Record<string, unknown>) => {
+        valuesSpy(values);
+        return Promise.resolve([]);
+      }),
+    });
+  };
+
+  it('updates referredBy without mutating createdAt and records referral history', async () => {
+    const setValues: Array<Record<string, unknown>> = [];
+    const insertedValues: Array<Record<string, unknown>> = [];
+
+    primeSelectMocks(false);
+    primeUpdateMock((values) => setValues.push(values));
+    primeInsertMock((values) => insertedValues.push(values));
+
+    const result = await ReferralManager.applyReferralCode(newUserId, 'SAMPLE123');
+
+    expect(result).toEqual({ success: true, referrerId });
+    expect(setValues).toHaveLength(1);
+    expect(setValues[0]).toEqual({ referredBy: referrerId });
+    expect(insertedValues).toHaveLength(1);
+    expect(insertedValues[0]).toEqual({
+      codeId: referralCodeId,
+      referrerId,
+      receiverId: newUserId,
+    });
+  });
+
+  it('does not insert duplicate referral records when one already exists', async () => {
+    const insertedValues: Array<Record<string, unknown>> = [];
+
+    primeSelectMocks(true);
+    primeUpdateMock(() => undefined);
+    primeInsertMock((values) => insertedValues.push(values));
+
+    const result = await ReferralManager.applyReferralCode(newUserId, 'SAMPLE123');
+
+    expect(result).toEqual({ success: true, referrerId });
+    expect(insertedValues).toHaveLength(0);
+  });
+});
