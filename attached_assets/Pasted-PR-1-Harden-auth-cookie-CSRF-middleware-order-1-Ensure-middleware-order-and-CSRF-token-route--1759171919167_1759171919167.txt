PR-1: Harden auth cookie + CSRF + middleware order
1) Ensure middleware order and CSRF token route

server/app.ts (or wherever you build the Express app):

+ import cookieParser from 'cookie-parser';
+ import csrf from 'csurf';

  const app = express();
+ app.set('trust proxy', 1); // needed if behind proxy to get secure cookies right

  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
- // (Make sure cookie-parser wasn’t after csrf/session before)
+ app.use(cookieParser(process.env.COOKIE_SECRET)); // MUST come before csurf if using cookie-based CSRF

+ // CSRF cookie (double-submit cookie pattern)
+ const isProd = process.env.NODE_ENV === 'production';
+ app.use(
+   csrf({
+     cookie: {
+       key: '_csrf',
+       httpOnly: true,
+       secure: isProd,
+       sameSite: isProd ? 'Strict' : 'Lax',
+       path: '/',
+     },
+   })
+ );

+ // Expose a safe endpoint to fetch a CSRF token for the client
+ app.get('/api/csrf-token', (req, res) => {
+   const token = (req as any).csrfToken();
+   // Non-HttpOnly mirror for frontend frameworks to read and echo back
+   res.cookie('XSRF-TOKEN', token, {
+     secure: isProd,
+     sameSite: isProd ? 'Strict' : 'Lax',
+     path: '/',
+   });
+   res.json({ csrfToken: token });
+ });


Why: Fixes “Error: misconfigured csrf” (cookie parser before csurf; consistent cookie options), and gives the frontend a stable way to fetch/echo the token.

2) Set the auth cookie with SameSite=Strict in production

Where you create the JWT on signup/login (e.g. server/routes/auth.ts):

  const token = jwt.sign(payload, process.env.JWT_SECRET!, { expiresIn: '1d' });

+ const isProd = process.env.NODE_ENV === 'production';
+ const baseCookie = {
+   httpOnly: true,
+   secure: isProd,
+   sameSite: isProd ? 'Strict' : 'Lax',
+   maxAge: 24 * 60 * 60 * 1000,
+   path: '/',
+ } as const;

- res.cookie('authToken', token, { httpOnly: true, secure: true, sameSite: 'Lax', maxAge: 86400000, path: '/' });
+ res.cookie('authToken', token, baseCookie);


Why: Satisfies tests/auth/signup.test.ts which expects SameSite=Strict for “production signup”.

OAuth exception (Reddit callback only): On the OAuth callback route, if you rely on cross-site redirect behavior, override to SameSite:'Lax' only there:

// server/routes/oauth-reddit.ts (callback)
res.cookie('authToken', token, {
  httpOnly: true,
  secure: isProd,
  sameSite: 'Lax', // allow cross-site redirect set
  maxAge: 24 * 60 * 60 * 1000,
  path: '/',
});

3) Make authenticateToken resilient (cookie + header, clear bad cookie)

server/middleware/auth.ts

+ import jwt from 'jsonwebtoken';

+ const isProd = process.env.NODE_ENV === 'production';
+ const cookieOpts = {
+   httpOnly: true,
+   secure: isProd,
+   sameSite: isProd ? 'Strict' : 'Lax',
+   path: '/',
+ } as const;

export function authenticateToken(required = true) {
  return (req, res, next) => {
-   const authHeader = req.headers['authorization'];
-   const token = authHeader && authHeader.split(' ')[1];
+   const authHeader = req.get('authorization');
+   const bearer = authHeader?.startsWith('Bearer ') ? authHeader.slice(7) : undefined;
+   const cookieToken = (req as any).signedCookies?.authToken || (req as any).cookies?.authToken;
+   const token = bearer || cookieToken;

    if (!token) {
      if (required) return res.status(401).json({ error: 'Access token required' });
      return next();
    }

    try {
      const payload = jwt.verify(token, process.env.JWT_SECRET!);
      (req as any).user = payload;
      return next();
    } catch (err) {
+     // Clear poisoned cookie so repeated requests don’t keep failing
+     res.clearCookie('authToken', cookieOpts);
      if (required) return res.status(401).json({ error: 'Invalid or expired token' });
      return next();
    }
  };
}


Why: Fixes “Auth error: jwt malformed” by (a) reading from cookie or header, and (b) actively clearing bad cookies.

4) Ensure protected admin routes actually require auth

Where you mount admin routes (e.g. server/routes/admin/*.ts or router setup):

- app.use('/api/admin/communities', adminCommunitiesRouter);
+ import { authenticateToken } from '../middleware/auth';
+ import { requireAdmin } from '../middleware/roles'; // if you have one

+ app.use('/api/admin/communities', authenticateToken(true), requireAdmin, adminCommunitiesRouter);


Why: Fixes the failing test that expected 401 without a token (you were returning 200).