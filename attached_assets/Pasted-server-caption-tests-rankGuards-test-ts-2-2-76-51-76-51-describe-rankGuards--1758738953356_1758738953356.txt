server/caption/__tests__/rankGuards.test.ts
+2-2
@@ -76,51 +76,51 @@ describe('rankGuards', () => {
        })
      );
    });

    it('should return no violations for clean content', () => {
      const caption = createTestCaption({
        caption: "Enjoying the peaceful morning in my garden",
        alt: "Person tending to flowers in a sunlit garden",
        hashtags: ["#gardening", "#morninglight", "#peaceful"],
        cta: "What's your favorite flower?"
      });
      
      const violations = detectVariantViolations(caption);
      expect(violations).toHaveLength(0);
    });

    it('should detect multiple violation types', () => {
      const caption = createTestCaption({
        caption: "Check out this amazing content! âœ¨",
        alt: "A photo",
        hashtags: ["#content", "#amazing"],
        cta: "Link in bio!"
      });
      
      const violations = detectVariantViolations(caption);
      expect(violations).toHaveLength(3); // banned_phrase, generic_hashtag, canned_cta
      expect(violations).toHaveLength(4); // banned_word, banned_phrase, generic_hashtag, canned_cta
    });
  });

  describe('sanitizeFinalVariant', () => {
    it('should sanitize caption with fallback content', () => {
      const caption = createTestCaption({
        caption: "âœ¨ Amazing content! Check it out! âœ¨",
        alt: "A photo",
        hashtags: ["#content", "#creative"],
        cta: "Link in bio!"
      });
      
      const sanitized = sanitizeFinalVariant(caption, 'instagram');
      
      expect(sanitized.caption).not.toContain('âœ¨');
      expect(sanitized.caption).not.toContain('Amazing content');
      expect(sanitized.cta).toBe(HUMAN_CTA);
      expect(sanitized.hashtags).toEqual(fallbackHashtags('instagram'));
    });

    it('should preserve good content unchanged', () => {
      const caption = createTestCaption({
        caption: "Enjoying the peaceful morning in my garden",
        alt: "Person tending to flowers in a sunlit garden",
        hashtags: ["#gardening", "#morninglight"],
@@ -170,51 +170,51 @@ describe('rankGuards', () => {
    });

    it('should return empty string for no violations', () => {
      const hint = buildRerankHint([]);
      expect(hint).toBe('');
    });
  });

  describe('formatViolationSummary', () => {
    it('should format violation summary', () => {
      const violations = [
        { type: 'banned_phrase' as const, field: 'caption' as const, content: 'âœ¨ Amazing!' },
        { type: 'canned_cta' as const, field: 'cta' as const, content: 'Link in bio!' }
      ];
      
      const summary = formatViolationSummary(violations);
      expect(summary).toContain('Sanitized');
      expect(summary).toContain('sparkle');
      expect(summary).toContain('canned CTA');
    });
  });

  describe('fallbackHashtags', () => {
    it('should return platform-specific hashtags', () => {
      expect(fallbackHashtags('instagram')).toEqual(['#behindthescenes', '#handcrafted', '#maker', '#creator']);
      expect(fallbackHashtags('x')).toEqual(['#thoughts']);
      expect(fallbackHashtags('x')).toEqual(['#thoughts', '#freshperspective']);
      expect(fallbackHashtags('reddit')).toEqual([]);
      expect(fallbackHashtags('tiktok')).toEqual(['#niche', '#authentic']);
    });

    it('should not return banned hashtags', () => {
      const allFallbacks = [
        ...fallbackHashtags('instagram'),
        ...fallbackHashtags('x'), 
        ...fallbackHashtags('tiktok')
      ];
      
      // Ensure no fallback hashtags are in the banned list
      const bannedHashtags = ['#content', '#creative', '#amazing', '#lifestyle', '#mood', '#vibes'];
      const intersection = allFallbacks.filter(tag => bannedHashtags.includes(tag));
      expect(intersection).toHaveLength(0);
    });
  });

  describe('HUMAN_CTA', () => {
    it('should be a human-sounding CTA', () => {
      expect(HUMAN_CTA).toBe("What do you think?");
      expect(HUMAN_CTA).not.toContain('link');
      expect(HUMAN_CTA).not.toContain('bio');
      expect(HUMAN_CTA).not.toContain('follow');
    });
server/caption/rankGuards.ts
+25-28
@@ -16,83 +16,85 @@ function normalizeCTA(value: string): string {
// Banned sparkle-filler phrases that should be detected and replaced
const BANNED_PHRASES = [
  /Check out this amazing content/i,
  /âœ¨ Enhanced/i,
  /Amazing content/i,
  /Check it out/i,
  /Click the link/i,
  /Don't miss out/i,
  /You won't believe/i,
  /This is incredible/i,
  /Must see/i,
  /Absolutely stunning/i,
  /âœ¨/,  // Any sparkle emojis
  /ðŸŒŸ/,  // Star emojis
  /â­/   // Star emojis
];

// Generic hashtags that indicate low-quality content
const GENERIC_HASHTAGS = new Set([
  "#content", "#creative", "#amazing", "#lifestyle",
  "#follow", "#like", "#share", "#viral", "#trending",
  "#awesome", "#incredible", "#mustfollow", "#epic",
  "#mood", "#vibes"
]);

const X_FALLBACK_HASHTAGS = ["#thoughts", "#freshperspective"] as const;

// Canned CTA templates that should be avoided
const RAW_CANNED_CTAS = [
  "Check it out", "Click the link", "Don't miss out",
  "Link in comments", "See more", "Find out more",
  "Click here", "Tap the link", "Visit my page",
  "Link in bio", "Link in bio!", "Link in bio!!", "Link in bio!!!",
  "Link in bio.", "Link in bio...", "Link in bio?",
  "Link in bio for more!", "Link in bio for more", "Link in bio for more!!",
  "Learn more", "Follow for more", "Link in profile",
  "Link in page", "Swipe up", "Check my bio"
];

const CANNED_CTAS = new Set(RAW_CANNED_CTAS.map(normalizeCTA));

function isCannedCTA(value: unknown): value is string {
  if (typeof value !== "string") return false;
  const normalized = normalizeCTA(value);
  if (!normalized) return false;
  return CANNED_CTAS.has(normalized);
}

export function fallbackHashtags(platform?: string): string[] {
  switch (platform) {
    case "instagram":
      return ["#behindthescenes", "#handcrafted", "#maker", "#creator"];
    case "tiktok":
      return ["#niche", "#authentic"];
    case "x":
      return ["#thoughts"];
      return [...X_FALLBACK_HASHTAGS];
    case "reddit":
      return ["community insights"]; // Reddit descriptive labels instead of hashtags
      return [];
    default:
      return ["#thoughts"];
      return [...X_FALLBACK_HASHTAGS];
  }
}

export interface Violation {
  type: "banned_phrase" | "generic_hashtag" | "canned_cta" | "banned_word";
  content: string;
  field: "caption" | "hashtags" | "cta";
}

export function detectVariantViolations(variant: any): Violation[] {
  const violations: Violation[] = [];

  // Check for banned words first
  if (variantContainsBannedWord(variant)) {
    violations.push({
      type: "banned_word",
      content: variant.caption || "",
      field: "caption"
    });
  }

  // Check caption for banned phrases
  if (typeof variant.caption === "string") {
    for (const regex of BANNED_PHRASES) {
      if (regex.test(variant.caption)) {
@@ -116,78 +118,78 @@ export function detectVariantViolations(variant: any): Violation[] {
        type: "generic_hashtag",
        content: variant.hashtags.join(" "),
        field: "hashtags"
      });
    }
  }

  // Check CTA for canned templates
  if (isCannedCTA(variant.cta)) {
    violations.push({
      type: "canned_cta",
      content: String(variant.cta),
      field: "cta"
    });
  }

  return violations;
}

export function buildRerankHint(violations: Violation[]): string {
  const hints: string[] = [];

  for (const violation of violations) {
    switch (violation.type) {
      case "banned_phrase":
        hints.push("avoid sparkle-filler phrases like 'Check out this amazing content'");
        hints.push("avoid sparkle emojis and sparkle-filler phrases like 'Check out this amazing content'");
        break;
      case "generic_hashtag":
        hints.push("use specific, authentic hashtags instead of generic ones like #content #creative #amazing");
        hints.push("swap out generic hashtags for specific, engaging tags instead of filler like #content #creative #amazing");
        break;
      case "canned_cta":
        hints.push("create unique calls-to-action instead of templates like 'Check it out'");
        hints.push("create a unique call-to-action instead of a canned CTA template like 'Check it out'");
        break;
      case "banned_word":
        hints.push("avoid banned words (ai, ai-generated, content)");
        break;
    }
  }

  return hints.length > 0 
    ? `Previous selection had issues: ${hints.join(", ")}. Choose options with authentic, human-sounding content.`
    : "";
}

export function formatViolationSummary(violations: Violation[]): string {
  if (violations.length === 0) return "";

  const summaries: string[] = [];
  
  for (const violation of violations) {
    switch (violation.type) {
      case "banned_phrase":
        summaries.push("sanitized sparkle-filler caption");
        summaries.push("sanitized sparkle emojis and filler caption");
        break;
      case "banned_word":
        summaries.push("removed banned words");
        break;
      case "generic_hashtag":
        summaries.push("replaced generic hashtags");
        break;
      case "canned_cta":
        summaries.push("upgraded canned CTA");
        break;
    }
  }

  return `Sanitized: ${summaries.join(", ")}`;
}

export function sanitizeFinalVariant(variant: any, platform?: string): any {
  const sanitized = { ...variant };

  // Sanitize caption for banned words first
  if (typeof sanitized.caption === "string") {
    if (containsBannedWord(sanitized.caption)) {
      sanitized.caption = replaceBannedWords(sanitized.caption);
      if (!sanitized.caption || sanitized.caption.trim().length === 0) {
        sanitized.caption = "Sharing something I'm genuinely proud of.";
@@ -214,60 +216,55 @@ export function sanitizeFinalVariant(variant: any, platform?: string): any {
  if (typeof sanitized.cta === "string") {
    if (containsBannedWord(sanitized.cta)) {
      sanitized.cta = replaceBannedWords(sanitized.cta);
      if (!sanitized.cta || sanitized.cta.trim().length === 0) {
        sanitized.cta = HUMAN_CTA;
      }
    }
  }

  // Sanitize alt text for banned words and ensure it's always present
  if (typeof sanitized.alt === "string") {
    if (containsBannedWord(sanitized.alt)) {
      sanitized.alt = replaceBannedWords(sanitized.alt);
      if (!sanitized.alt || sanitized.alt.trim().length < 20) {
        sanitized.alt = "Descriptive photo for the post";
      }
    }
  } else if (!sanitized.alt) {
    // Ensure alt is always present, even if not originally provided
    sanitized.alt = "Descriptive photo for the post";
  }

  // Enhanced hashtag sanitization with platform-specific rules
  if (Array.isArray(sanitized.hashtags)) {
    // Filter out banned words and generic hashtags
    let cleanedHashtags = sanitized.hashtags
      .filter((tag: any) => typeof tag === "string" && !containsBannedWord(tag))
      .filter((tag: any) => !GENERIC_HASHTAGS.has(tag.toLowerCase()));
    
    let cleanedHashtags: string[] = sanitized.hashtags
      .filter((tag): tag is string => typeof tag === "string")
      .filter((tag) => !containsBannedWord(tag))
      .filter((tag) => !GENERIC_HASHTAGS.has(tag.toLowerCase()));

    // Reddit special case: strip leading # from descriptive labels
    if (platform === 'reddit') {
      cleanedHashtags = cleanedHashtags.map((tag: string) => 
        tag.startsWith('#') ? tag.substring(1) : tag
      );
    if (platform === "reddit") {
      cleanedHashtags = cleanedHashtags
        .map((tag) => (tag.startsWith("#") ? tag.substring(1) : tag))
        .filter((tag) => tag.length > 0);
    }
    

    // Apply platform-specific hashtag limits after cleaning
    if (platform === 'x' && cleanedHashtags.length > 3) {
      cleanedHashtags = cleanedHashtags.slice(0, 3);
    } else if (platform === 'reddit' && cleanedHashtags.length > 1) {
      cleanedHashtags = cleanedHashtags.slice(0, 1);
    const limit = platform === "x" ? 2 : platform === "reddit" ? 0 : undefined;
    if (typeof limit === "number") {
      cleanedHashtags = limit === 0 ? [] : cleanedHashtags.slice(0, limit);
    }
    // Instagram and TikTok: no limit enforced
    
    // Enforce minimum requirements or fall back
    const fallback = fallbackHashtags(platform);
    const minRequired = platform === 'reddit' ? 1 : 1; // At least 1 hashtag or label
    
    if (cleanedHashtags.length < minRequired) {
      sanitized.hashtags = fallback;

    if (cleanedHashtags.length === 0) {
      sanitized.hashtags = fallbackHashtags(platform);
    } else {
      sanitized.hashtags = cleanedHashtags;
    }
  } else {
    // No hashtags provided, use fallback
    sanitized.hashtags = fallbackHashtags(platform);
  }

  return sanitized;
}
