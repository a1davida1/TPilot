server/caption/rewritePipeline.ts
+8-8
@@ -378,106 +378,106 @@ type RewritePipelineArgs = {
  imageUrl?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};

/**
 * Caption rewriting pipeline that enhances existing captions while preserving tone.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
type CaptionItemType = z.infer<typeof CaptionItem>;
type CaptionArrayResult = z.infer<typeof CaptionArray>;
type RankResultType = z.infer<typeof RankResult>;

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;

    const doNotDrop = extractKeyEntities(existingCaption);

    const attemptHints: (string | undefined)[] = [
    const lengthHints: (string | undefined)[] = [
      undefined,
      "Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.",
      facts
        ? "Make it 25% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 25% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
        ? "Make it 30% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 30% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
    ];

    const baseParams = { platform, voice, style, mood, existingCaption, facts, nsfw, doNotDrop } as const;

    type AttemptResult = { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType };

    const performAttempt = async (hint?: string): Promise<AttemptResult> => {
      const attemptVariants = await variantsRewrite({ ...baseParams, hint });
      const attemptRanked = await rankAndSelect(attemptVariants);
      return { variants: attemptVariants, ranked: attemptRanked, final: attemptRanked.final };
    };

    const enforceMandatoryTokens = async (
      attempt: AttemptResult,
      priorHint?: string
    ): Promise<AttemptResult> => {
      if (doNotDrop.length === 0) {
        return attempt;
      }
      const missing = doNotDrop.filter((token) => !attempt.final.caption.includes(token));
      if (missing.length === 0) {
        return attempt;
      }
      const messageParts = [
        priorHint,
        `ABSOLUTE RULE: Keep these tokens verbatim in the caption: ${doNotDrop.join(", ")}`,
        `Previous attempt removed: ${missing.join(", ")}`
      ].filter((part): part is string => Boolean(part && part.trim()));
      const retried = await performAttempt(messageParts.join(" "));
      const retryMissing = doNotDrop.filter((token) => !retried.final.caption.includes(token));
      if (retryMissing.length > 0) {
        throw new Error(`Missing mandatory tokens after retry: ${retryMissing.join(", ")}`);
      }
      return retried;
    };

    let lastAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType } | undefined;
    let successfulAttempt: { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType } | undefined;
    const attemptHistory: AttemptResult[] = [];
    let successfulAttempt: AttemptResult | undefined;

    for (const hint of attemptHints) {
    for (const hint of lengthHints) {
      let attempt = await performAttempt(hint);
      attempt = await enforceMandatoryTokens(attempt, hint);
      lastAttempt = attempt;
      attemptHistory.push(attempt);
      if (attempt.final.caption.length > existingCaption.length) {
        successfulAttempt = attempt;
        break;
      }
    }

    const chosenAttempt = successfulAttempt ?? lastAttempt;
    const chosenAttempt = successfulAttempt ?? attemptHistory.at(-1);

    if (!chosenAttempt || chosenAttempt.final.caption.length <= existingCaption.length) {
      throw new Error('Rewrite did not produce a longer caption');
    }

    let { variants, ranked, final: out } = chosenAttempt;

    const enforceCoverage = async () => {
      if (!facts) {
        return;
      }
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        let nextAttempt = await performAttempt(coverage.hint);
        nextAttempt = await enforceMandatoryTokens(nextAttempt, coverage.hint);
        ({ variants, ranked, final: out } = nextAttempt);
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    await enforceCoverage();

    if (out.caption.length <= existingCaption.length) {
tests/routes/caption-generation.test.ts
+178-0
@@ -1457,50 +1457,228 @@ describe('Caption Generation', () => {
      generateContentMock
        .mockResolvedValueOnce(shortVariantsCast)
        .mockResolvedValueOnce(shortRankCast)
        .mockResolvedValueOnce(longVariantsCast)
        .mockResolvedValueOnce(longRankCast);

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
      });

      expect((result.final as CaptionResult).caption.length).toBeGreaterThan(existingCaption.length);
      expect((result.final as CaptionResult).caption).toBe(longerCaption);
      expect((result.final as CaptionResult).caption).not.toContain('Enhanced with engaging content and call-to-action that drives better engagement');

      const promptCalls = [...generateContentMock.mock.calls];
      expect(promptCalls).toHaveLength(4);
      expect(promptCalls[2]?.[0]?.[0]?.text).toContain(
        'Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.'
      );

      generateContentMock.mockRestore();
    });

    it('escalates rewrite hints with image facts before falling back', async () => {
      const existingCaption = 'Baseline caption ready for rewrite';
      const longAltText =
        'Detailed alt text describing the golden-hour boardwalk scene with warm light, reflective water, and friends arriving.';

      const makeVariants = (caption: string) =>
        Array.from({ length: 5 }, () => ({
          caption,
          hashtags: ['#vibes', '#style', '#moments'],
          safety_level: 'normal',
          mood: 'engaging',
          style: 'authentic',
          cta: 'Tell me what you think',
          alt: longAltText,
          nsfw: false,
        }));

      const firstVariantsResponse = {
        response: {
          text: () => JSON.stringify(makeVariants(existingCaption)),
        },
      } satisfies MockResponse;

      const firstRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Short rewrite selected',
              final: {
                caption: existingCaption,
                hashtags: ['#vibes', '#style', '#moments'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Tell me what you think',
                alt: longAltText,
                nsfw: false,
              },
            }),
        },
      } satisfies MockResponse;

      const secondVariantsResponse = {
        response: {
          text: () => JSON.stringify(makeVariants(existingCaption)),
        },
      } satisfies MockResponse;

      const secondRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Still short after first hint',
              final: {
                caption: existingCaption,
                hashtags: ['#vibes', '#style', '#moments'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Tell me what you think',
                alt: longAltText,
                nsfw: false,
              },
            }),
        },
      } satisfies MockResponse;

      const thirdCaption =
        'Baseline caption ready for rewrite, now painting the golden-hour boardwalk glow and inviting you to meet us tonight.';

      const thirdVariantsResponse = {
        response: {
          text: () => JSON.stringify(makeVariants(thirdCaption)),
        },
      } satisfies MockResponse;

      const thirdRankResponse = {
        response: {
          text: () =>
            JSON.stringify({
              winner_index: 0,
              scores: [5, 4, 3, 2, 1],
              reason: 'Long rewrite with imagery and CTA',
              final: {
                caption: thirdCaption,
                hashtags: ['#vibes', '#style', '#moments'],
                safety_level: 'normal',
                mood: 'engaging',
                style: 'authentic',
                cta: 'Tell me what you think',
                alt: longAltText,
                nsfw: false,
              },
            }),
        },
      } satisfies MockResponse;

      const factsPayload = {
        scene: 'boardwalk',
        lighting: 'golden hour',
        detail: 'reflections pulling everyone back tonight',
      } satisfies Record<string, string>;

      const { textModel, visionModel } = await import('../../server/lib/gemini.js');
      const generateContentMock = vi.spyOn(textModel, 'generateContent');
      const visionMock = vi.spyOn(visionModel, 'generateContent');

      const firstVariantsCast = firstVariantsResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;
      const firstRankCast = firstRankResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;
      const secondVariantsCast = secondVariantsResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;
      const secondRankCast = secondRankResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;
      const thirdVariantsCast = thirdVariantsResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;
      const thirdRankCast = thirdRankResponse as unknown as Awaited<
        ReturnType<(typeof textModel)['generateContent']>
      >;

      generateContentMock
        .mockResolvedValueOnce(firstVariantsCast)
        .mockResolvedValueOnce(firstRankCast)
        .mockResolvedValueOnce(secondVariantsCast)
        .mockResolvedValueOnce(secondRankCast)
        .mockResolvedValueOnce(thirdVariantsCast)
        .mockResolvedValueOnce(thirdRankCast);

      const visionCast = {
        response: {
          text: () => JSON.stringify(factsPayload),
        },
      } as MockResponse;

      visionMock.mockResolvedValueOnce(
        visionCast as unknown as Awaited<ReturnType<(typeof visionModel)['generateContent']>>
      );

      const result = await pipelineRewrite({
        platform: 'instagram',
        voice: 'engaging',
        existingCaption,
        imageUrl: 'https://example.com/photo.jpg',
      });

      const finalCaption = (result.final as CaptionResult).caption;
      expect(finalCaption).toBe(thirdCaption);
      expect(finalCaption.length).toBeGreaterThan(existingCaption.length);
      expect(finalCaption).not.toContain('✨ Enhanced with engaging content and call-to-action that drives better engagement!');
      expect(finalCaption).not.toContain('Enhanced with engaging content and call-to-action that drives better engagement');

      const promptCalls = [...generateContentMock.mock.calls];
      expect(promptCalls).toHaveLength(6);
      expect(promptCalls[2]?.[0]?.[0]?.text).toContain(
        'Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clichés.'
      );
      expect(promptCalls[4]?.[0]?.[0]?.text).toContain(
        'Make it 30% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded.'
      );

      const { openAICaptionFallback } = await import('../../server/caption/openaiFallback.js');
      expect(openAICaptionFallback).not.toHaveBeenCalled();
      expect(visionMock).toHaveBeenCalledTimes(1);

      generateContentMock.mockRestore();
      visionMock.mockRestore();
    });

    it('retries when mandatory tokens are dropped without platform errors', async () => {
      const existingCaption = 'Launch day! RSVP at https://example.com/launch with @LaunchHQ on 12/25 for the "Mega Launch" by MegaCorp™ #LaunchDay';
      const variantFactory = (caption: string) => ({
        caption,
        hashtags: ['#LaunchDay', '#EventTime', '#RSVPNow'],
        safety_level: 'normal',
        mood: 'excited',
        style: 'authentic',
        cta: 'Reserve your spot',
        alt: 'Detailed alt text describing the MegaCorp launch announcement in a complete sentence.',
        nsfw: false,
      });

      const missingVariants = {
        response: {
          text: () => JSON.stringify(
            Array.from({ length: 5 }, (_, index) =>
              variantFactory(`Variant ${index + 1} without mandatory tokens`)
            )
          ),
        },
      };

      const missingRank = {
        response: {
