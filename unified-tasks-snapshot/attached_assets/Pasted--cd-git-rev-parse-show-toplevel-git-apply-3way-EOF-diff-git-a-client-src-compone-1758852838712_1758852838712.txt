 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/client/src/components/PolicyPreview.tsx b/client/src/components/PolicyPreview.tsx
index 5c3297646b88c92f6db7f2ec43c3f2bdd3837791..cd16b69b39a07a3569029161a12f1b8c4aa86802 100644
--- a/client/src/components/PolicyPreview.tsx
+++ b/client/src/components/PolicyPreview.tsx
@@ -1,98 +1,124 @@
 import { useState } from 'react';
 import { Button } from '@/components/ui/button';
 import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
 import { Badge } from '@/components/ui/badge';
 import { AlertTriangle, CheckCircle, XCircle, Shield, Clock } from 'lucide-react';
 import { Alert, AlertDescription } from '@/components/ui/alert';
 // import { Progress } from '@/components/ui/progress';
 import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
-import { apiRequest as _apiRequest } from '@/lib/queryClient';
+import { useToast } from '@/hooks/use-toast';
+import { apiRequest, type ApiError } from '@/lib/queryClient';
 
 interface PolicyResult {
   state: 'ok' | 'warn' | 'block';
   warnings: string[];
 }
 
 interface PreviewStats {
   okCount14d: number;
   totalPreviews14d: number;
   canQueue: boolean;
   required: number;
 }
 
 interface PolicyPreviewProps {
   subreddit: string;
   title: string;
   body: string;
   hasLink?: boolean;
   onPreviewComplete?: (result: PolicyResult) => void;
 }
 
 export function PolicyPreview({ subreddit, title, body, hasLink = false, onPreviewComplete }: PolicyPreviewProps) {
   const queryClient = useQueryClient();
   const [lastPreviewResult, setLastPreviewResult] = useState<PolicyResult | null>(null);
+  const { toast } = useToast();
 
   // Get user's preview gate stats
   const { data: previewStats, isLoading: statsLoading } = useQuery<PreviewStats>({
     queryKey: ['/api/user/previewStats'],
     refetchInterval: 30000, // Refresh every 30 seconds
   });
 
   // Get policy feature flags
   const { data: policyFlags } = useQuery<{ blockOnWarn: boolean }>({
     queryKey: ['/api/policy/flags'],
   });
 
   // Preview content mutation
+  const isApiError = (error: unknown): error is ApiError => {
+    if (!error || typeof error !== 'object') {
+      return false;
+    }
+
+    return 'status' in error && 'statusText' in error;
+  };
+
   const previewMutation = useMutation({
     mutationFn: async (previewData: { subreddit: string; title: string; body: string; hasLink: boolean }) => {
-      const response = await fetch('/api/preview', {
-        method: 'POST',
-        body: JSON.stringify(previewData),
-        headers: { 'Content-Type': 'application/json' }
-      });
-      if (!response.ok) throw new Error('Preview failed');
-      return response.json();
+      const response = await apiRequest('POST', '/api/preview', previewData);
+      const resultData = await response.json() as { policyState: 'ok' | 'warn' | 'block'; warnings?: string[] };
+      return {
+        policyState: resultData.policyState,
+        warnings: Array.isArray(resultData.warnings) ? resultData.warnings : [],
+      };
     },
-    onSuccess: (result: unknown) => {
-      const resultData = result as { policyState: 'ok' | 'warn' | 'block'; warnings: string[] };
+    onSuccess: (result) => {
       const policyResult: PolicyResult = {
-        state: resultData.policyState,
-        warnings: resultData.warnings
+        state: result.policyState,
+        warnings: result.warnings,
       };
       setLastPreviewResult(policyResult);
       onPreviewComplete?.(policyResult);
-      
+
       // Refresh preview stats
       queryClient.invalidateQueries({ queryKey: ['/api/user/previewStats'] });
     },
-    onError: (error) => {
+    onError: (error: unknown) => {
       console.error('Preview error:', error);
+      let toastTitle = 'Preview failed';
+      let description = 'Content review temporarily unavailable';
+
+      if (isApiError(error)) {
+        if (error.isAuthError) {
+          toastTitle = 'Please log in';
+        }
+        description = error.userMessage ?? error.message;
+      } else if (error instanceof Error) {
+        description = error.message;
+      }
+
+      toast({
+        title: toastTitle,
+        description,
+        variant: 'destructive',
+      });
+
       setLastPreviewResult({
         state: 'warn',
-        warnings: ['Content review temporarily unavailable']
+        warnings: [description]
       });
     }
   });
 
   const handlePreview = () => {
     previewMutation.mutate({
       subreddit,
       title,
       body,
       hasLink
     });
   };
 
   const getStateIcon = (state: 'ok' | 'warn' | 'block') => {
     switch (state) {
       case 'ok':
         return <CheckCircle className="w-4 h-4 text-green-500" />;
       case 'warn':
         return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
       case 'block':
         return <XCircle className="w-4 h-4 text-red-500" />;
     }
   };
 
   const getStateBadgeVariant = (state: 'ok' | 'warn' | 'block') => {
 
EOF
)