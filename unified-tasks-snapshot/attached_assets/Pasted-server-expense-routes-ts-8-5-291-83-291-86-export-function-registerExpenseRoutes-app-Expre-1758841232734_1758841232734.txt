server/expense-routes.ts
+8-5
@@ -291,83 +291,86 @@ export function registerExpenseRoutes(app: Express) {

      if (requestBody.expenseDate !== undefined) {
        const expenseDate = new Date(String(requestBody.expenseDate));
        if (Number.isNaN(expenseDate.getTime())) {
          return res.status(400).json({ message: 'Invalid expense date' });
        }
        updates.expenseDate = expenseDate;
      }

      if (requestBody.taxYear !== undefined) {
        const parsedTaxYear = Number.parseInt(String(requestBody.taxYear), 10);
        if (Number.isNaN(parsedTaxYear)) {
          return res.status(400).json({ message: 'Invalid tax year' });
        }
        updates.taxYear = parsedTaxYear;
      }

      const rawBusinessPurpose = requestBody.businessPurpose;
      const trimmedBusinessPurpose =
        typeof rawBusinessPurpose === 'string' ? rawBusinessPurpose.trim() : undefined;
      const shouldApplyDefaultBusinessPurpose =
        (rawBusinessPurpose === undefined ||
          (typeof rawBusinessPurpose === 'string' && (trimmedBusinessPurpose?.length ?? 0) === 0)) &&
        rawBusinessPurpose !== null;
      const shouldApplyDefaultFromExistingCategory =
        shouldApplyDefaultBusinessPurpose &&
        requestBody.categoryId === undefined &&
        rawBusinessPurpose !== undefined;
        shouldApplyDefaultBusinessPurpose && requestBody.categoryId === undefined;

      let existingExpenseForBusinessPurpose: Expense | undefined;

      if (rawBusinessPurpose === null) {
        updates.businessPurpose = null;
      } else if (typeof trimmedBusinessPurpose === 'string' && trimmedBusinessPurpose.length > 0) {
        updates.businessPurpose = trimmedBusinessPurpose;
      }

      if (requestBody.categoryId !== undefined) {
        const parsedCategoryId = Number.parseInt(String(requestBody.categoryId), 10);
        if (!Number.isInteger(parsedCategoryId)) {
          return res.status(400).json({ message: 'Invalid expense category' });
        }

        const category = await storage.getExpenseCategory(parsedCategoryId);
        if (!category) {
          return res.status(400).json({ message: 'Invalid expense category' });
        }

        const categoryDefaults: ExpenseCategoryWithDefaults = category;
        updates.categoryId = parsedCategoryId;
        updates.deductionPercentage = category.deductionPercentage;

        if (shouldApplyDefaultBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
          updates.businessPurpose = categoryDefaults.defaultBusinessPurpose;
        }
      }

      if (shouldApplyDefaultFromExistingCategory) {
        const existingExpense = await storage.getExpense(expenseId, req.user.id);
        const existingCategoryId = existingExpense?.categoryId;
        if (!existingExpenseForBusinessPurpose) {
          existingExpenseForBusinessPurpose = await storage.getExpense(expenseId, req.user.id);
        }

        const existingCategoryId = existingExpenseForBusinessPurpose?.categoryId;
        if (existingCategoryId !== undefined) {
          const existingCategory = await storage.getExpenseCategory(existingCategoryId);
          if (existingCategory?.defaultBusinessPurpose) {
            updates.businessPurpose = existingCategory.defaultBusinessPurpose;
          }
        }
      }

      const expense = await storage.updateExpense(expenseId, req.user.id, updates);
      res.json(expense);
    } catch (error) {
      console.error('Error updating expense:', error);
      res.status(500).json({ message: 'Failed to update expense' });
    }
  });

  // Delete expense
  app.delete('/api/expenses/:id', authenticateToken, async (req: AuthRequest, res) => {
    try {
      if (!req.user?.id) {
        return res.status(401).json({ message: 'Authentication required' });
      }

      const expenseId = parseInt(req.params.id);
      await storage.deleteExpense(expenseId, req.user.id);
server/storage.ts
+16-9
@@ -826,98 +826,105 @@ export class DatabaseStorage implements IStorage {
          ...expense,
          category,
        }));

      return flattenedResults;
    } catch (error) {
      console.error('Error getting user expenses:', { error: (error as Error).message });
      return [];
    }
  }

  async getExpense(id: number, userId: number): Promise<Expense | undefined> {
    try {
      const [result] = await db.select().from(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
      return result;
    } catch (error) {
      console.error('Error getting expense:', { error: (error as Error).message });
      return undefined;
    }
  }

  async updateExpense(id: number, userId: number, updates: Partial<Expense>): Promise<Expense> {
    try {
      let updatesToApply: Partial<Expense> = { ...updates };
      const businessPurposeValue = updates.businessPurpose;
      const hasBusinessPurposeField = Object.prototype.hasOwnProperty.call(updates, 'businessPurpose');
      const businessPurposeValue = hasBusinessPurposeField ? updates.businessPurpose : undefined;
      const trimmedBusinessPurpose =
        typeof businessPurposeValue === 'string' ? businessPurposeValue.trim() : undefined;
      const hasEmptyBusinessPurpose =
        typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0;

      if (hasEmptyBusinessPurpose) {
        trimmedBusinessPurpose !== undefined && trimmedBusinessPurpose.length === 0;
      const isBusinessPurposeUndefined = hasBusinessPurposeField && businessPurposeValue === undefined;
      const isClearingBusinessPurpose =
        hasBusinessPurposeField &&
        businessPurposeValue !== null &&
        (isBusinessPurposeUndefined || hasEmptyBusinessPurpose);

      if (hasEmptyBusinessPurpose || isBusinessPurposeUndefined) {
        delete updatesToApply.businessPurpose;
      }

      const needsExistingExpenseLookup = updates.categoryId !== undefined || hasEmptyBusinessPurpose;
      const needsExistingExpenseLookup = updates.categoryId !== undefined || isClearingBusinessPurpose;
      let existingExpense: Expense | undefined;
      if (needsExistingExpenseLookup) {
        existingExpense = await this.getExpense(id, userId);
      }

      if (updates.categoryId !== undefined) {
        const categoryChanged = existingExpense ? existingExpense.categoryId !== updates.categoryId : true;
        const category = await this.getExpenseCategory(updates.categoryId);

        if (category) {
          const categoryDefaults: ExpenseCategoryWithDefaults = category;

          if (categoryChanged) {
            updatesToApply = {
              ...updatesToApply,
              deductionPercentage: category.deductionPercentage,
            };

            const shouldApplyDefaultBusinessPurpose =
              (businessPurposeValue === undefined ||
                (typeof businessPurposeValue === 'string' && businessPurposeValue.trim().length === 0)) &&
              (businessPurposeValue === undefined || hasEmptyBusinessPurpose) &&
              businessPurposeValue !== null;

            if (shouldApplyDefaultBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
              updatesToApply = {
                ...updatesToApply,
                businessPurpose: categoryDefaults.defaultBusinessPurpose,
              };
            }
          }

          if (hasEmptyBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
          if (isClearingBusinessPurpose && categoryDefaults.defaultBusinessPurpose) {
            updatesToApply = {
              ...updatesToApply,
              businessPurpose: categoryDefaults.defaultBusinessPurpose,
            };
          }
        }
      } else if (hasEmptyBusinessPurpose && existingExpense?.categoryId !== undefined) {
      } else if (isClearingBusinessPurpose && existingExpense?.categoryId !== undefined) {
        const category = await this.getExpenseCategory(existingExpense.categoryId);
        if (category?.defaultBusinessPurpose) {
          updatesToApply = {
            ...updatesToApply,
            businessPurpose: category.defaultBusinessPurpose,
          };
        }
      }

      const [result] = await db.update(expenses)
        .set({ ...updatesToApply, updatedAt: new Date() })
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)))
        .returning();
      return result;
    } catch (error) {
      console.error('Error updating expense:', { error: (error as Error).message });
      throw error;
    }
  }

  async deleteExpense(id: number, userId: number): Promise<void> {
    try {
      await db.delete(expenses)
        .where(and(eq(expenses.id, id), eq(expenses.userId, userId)));
    } catch (error) {
tests/unit/expenses/expense-storage.business-purpose.test.ts
New
+119-0
import { describe, test, expect, beforeEach, vi } from 'vitest';
import type { Expense, ExpenseCategory } from '../../../shared/schema.js';
import { DatabaseStorage } from '../../../server/storage.ts';

const updateMock = vi.hoisted(() => vi.fn());
const setMock = vi.hoisted(() => vi.fn());
const whereMock = vi.hoisted(() => vi.fn());
const returningMock = vi.hoisted(() => vi.fn());

vi.mock('../../../server/db.js', () => ({
  db: {
    update: (...args: unknown[]) => updateMock(...args),
  },
}));

class TestableStorage extends DatabaseStorage {
  constructor(private readonly expense: Expense, private readonly category: ExpenseCategory) {
    super();
  }

  async getExpense(id: number, userId: number): Promise<Expense | undefined> {
    if (id === this.expense.id && userId === this.expense.userId) {
      return this.expense;
    }

    return undefined;
  }

  async getExpenseCategory(categoryId: number): Promise<ExpenseCategory | undefined> {
    if (categoryId === this.category.id) {
      return this.category;
    }

    return undefined;
  }
}

describe('DatabaseStorage.updateExpense business purpose handling', () => {
  let lastSetPayload: Partial<Expense> | undefined;

  beforeEach(() => {
    lastSetPayload = undefined;
    updateMock.mockReset();
    setMock.mockReset();
    whereMock.mockReset();
    returningMock.mockReset();

    setMock.mockImplementation((value: Partial<Expense>) => {
      lastSetPayload = value;
      return { where: whereMock };
    });

    whereMock.mockImplementation(() => ({ returning: returningMock }));
    updateMock.mockImplementation(() => ({ set: setMock }));
  });

  test('applies category default when business purpose is cleared without category change', async () => {
    const now = new Date('2024-01-01T00:00:00.000Z');
    const defaultBusinessPurpose = 'Client meeting travel';

    const existingExpense: Expense = {
      id: 42,
      userId: 7,
      categoryId: 9,
      amount: 12500,
      description: 'Flight to client site',
      vendor: null,
      expenseDate: now,
      receiptUrl: null,
      receiptFileName: null,
      businessPurpose: 'Custom purpose to remove',
      deductionPercentage: 100,
      tags: null,
      isRecurring: false,
      recurringPeriod: null,
      taxYear: 2024,
      notes: null,
      createdAt: now,
      updatedAt: now,
    };

    const categoryWithDefault: ExpenseCategory = {
      id: existingExpense.categoryId,
      name: 'Travel',
      description: 'Business travel expenses',
      legalExplanation: 'Deductible when travel is primarily for business.',
      deductionPercentage: 100,
      examples: ['Flights', 'Hotels'],
      icon: 'plane',
      color: '#0055AA',
      isActive: true,
      sortOrder: 1,
      itsDeductionCode: null,
      defaultBusinessPurpose,
      createdAt: now,
    };

    const updatedExpense: Expense = {
      ...existingExpense,
      businessPurpose: defaultBusinessPurpose,
      updatedAt: new Date('2024-01-02T00:00:00.000Z'),
    };

    returningMock.mockResolvedValueOnce([updatedExpense]);

    const storage = new TestableStorage(existingExpense, categoryWithDefault);

    const result = await storage.updateExpense(existingExpense.id, existingExpense.userId, {
      businessPurpose: undefined,
    });

    expect(result.businessPurpose).toBe(defaultBusinessPurpose);
    expect(lastSetPayload?.businessPurpose).toBe(defaultBusinessPurpose);
    expect(updateMock).toHaveBeenCalledTimes(1);
    expect(setMock).toHaveBeenCalledTimes(1);
    expect(whereMock).toHaveBeenCalledTimes(1);
    expect(returningMock).toHaveBeenCalledTimes(1);
  });
});
