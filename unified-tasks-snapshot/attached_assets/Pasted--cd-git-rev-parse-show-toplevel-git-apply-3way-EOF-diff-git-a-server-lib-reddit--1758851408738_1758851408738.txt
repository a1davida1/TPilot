 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server/lib/reddit.ts b/server/lib/reddit.ts
index fa152228c78a49f172c77d82cbb1f759f0a240d6..19bd6f5a852210e2546ff4e81077559e22291285 100644
--- a/server/lib/reddit.ts
+++ b/server/lib/reddit.ts
@@ -477,50 +477,135 @@ function deriveCooldownMinutes(rules?: NormalizedSubredditRules): number | null
 
 function deriveDailyLimit(rules?: NormalizedSubredditRules): number | null {
   if (!rules?.postingLimits) {
     return null;
   }
 
   const { postingLimits } = rules;
   const candidates: Array<number | undefined> = [
     postingLimits.perDay,
     postingLimits.per24h,
     postingLimits.daily,
   ];
 
   for (const value of candidates) {
     if (typeof value === 'number' && Number.isFinite(value) && value > 0) {
       return value;
     }
   }
 
   return null;
 }
 
 interface RedditSubmission {
   id: string;
   permalink: string;
+  name?: string;
+  score?: number;
+  upvote_ratio?: number;
+  num_comments?: number;
+  view_count?: number;
+}
+
+interface SnoowrapSubmissionDetails {
+  id?: string;
+  name?: string;
+  permalink?: string;
+  score?: number;
+  upvote_ratio?: number;
+  num_comments?: number;
+  view_count?: number;
+}
+
+function normalizeSubmissionId(submission: SnoowrapSubmissionDetails, fallbackId: string): string {
+  if (submission.id && submission.id.trim().length > 0) {
+    return submission.id;
+  }
+
+  if (submission.name && submission.name.startsWith('t3_')) {
+    const derivedId = submission.name.slice(3);
+    if (derivedId.trim().length > 0) {
+      return derivedId;
+    }
+  }
+
+  return fallbackId;
+}
+
+function normalizeSubmissionPermalink(submission: SnoowrapSubmissionDetails, normalizedId: string): string {
+  const permalink = submission.permalink;
+
+  if (typeof permalink === 'string' && permalink.trim().length > 0) {
+    const trimmed = permalink.trim();
+    if (/^https?:\/\//i.test(trimmed)) {
+      return trimmed;
+    }
+
+    if (trimmed.startsWith('/')) {
+      return `https://www.reddit.com${trimmed}`;
+    }
+
+    return `https://www.reddit.com/${trimmed}`;
+  }
+
+  return `https://www.reddit.com/comments/${normalizedId}`;
+}
+
+function coerceNumber(value: number | undefined, fallback: number): number {
+  if (typeof value === 'number' && Number.isFinite(value)) {
+    return value;
+  }
+
+  return fallback;
+}
+
+function coerceOptionalNumber(value: number | undefined): number | undefined {
+  if (typeof value === 'number' && Number.isFinite(value)) {
+    return value;
+  }
+
+  return undefined;
+}
+
+function normalizeSubmissionDetails(submission: SnoowrapSubmissionDetails, fallbackId: string): RedditSubmission {
+  const normalizedId = normalizeSubmissionId(submission, fallbackId);
+
+  const normalized: RedditSubmission = {
+    id: normalizedId,
+    name: submission.name,
+    permalink: normalizeSubmissionPermalink(submission, normalizedId),
+    score: coerceNumber(submission.score, 0),
+    upvote_ratio: coerceNumber(submission.upvote_ratio, 0),
+    num_comments: coerceNumber(submission.num_comments, 0),
+  };
+
+  const viewCount = coerceOptionalNumber(submission.view_count);
+  if (typeof viewCount === 'number') {
+    normalized.view_count = viewCount;
+  }
+
+  return normalized;
 }
 
 function normalizeSubredditNameForComparison(value: string | null | undefined): string | null {
   if (typeof value !== 'string') {
     return null;
   }
 
   const trimmed = value.trim();
   if (!trimmed) {
     return null;
   }
 
   return trimmed.replace(/^r\//i, '').toLowerCase();
 }
 
 function extractVerifiedFromMetadata(metadata: unknown): boolean | undefined {
   if (typeof metadata !== 'object' || metadata === null) {
     return undefined;
   }
 
   const record = metadata as Record<string, unknown>;
   const value = record.verified;
 
   if (typeof value === 'boolean') {
     return value;
diff --git a/server/lib/reddit.ts b/server/lib/reddit.ts
index fa152228c78a49f172c77d82cbb1f759f0a240d6..19bd6f5a852210e2546ff4e81077559e22291285 100644
--- a/server/lib/reddit.ts
+++ b/server/lib/reddit.ts
@@ -569,51 +654,52 @@ export class RedditManager {
     try {
       const [account] = await db
         .select()
         .from(creatorAccounts)
         .where(
           and(
             eq(creatorAccounts.userId, userId),
             eq(creatorAccounts.platform, 'reddit'),
             eq(creatorAccounts.isActive, true)
           )
         );
 
       if (!account || !account.oauthToken) {
         return null;
       }
 
       // Decrypt tokens
       const accessToken = decrypt(account.oauthToken);
       const refreshToken = account.oauthRefresh ? decrypt(account.oauthRefresh) : '';
 
       if (!accessToken) {
         console.error('Failed to decrypt access token for user:', userId);
         return null;
       }
 
-      return new RedditManager(accessToken, refreshToken, userId);
+      const manager: RedditManager = new RedditManager(accessToken, refreshToken, userId);
+      return manager;
     } catch (error) {
       console.error('Failed to create Reddit manager for user:', error);
       return null;
     }
   }
 
   /**
    * Submit a post to Reddit
    */
   async submitPost(options: RedditPostOptions): Promise<RedditPostResult> {
     let permission: PostingPermission | undefined;
     try {
       console.log(`Submitting post to r/${options.subreddit}: "${options.title}"`);
 
       // Check if we can post to this subreddit
       permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit, {
         hasLink: Boolean(options.url),
         intendedAt: new Date(),
         title: options.title,
         body: options.body || options.url || '',
       });
 
       if (!permission.canPost) {
         return {
           success: false,
diff --git a/server/lib/reddit.ts b/server/lib/reddit.ts
index fa152228c78a49f172c77d82cbb1f759f0a240d6..19bd6f5a852210e2546ff4e81077559e22291285 100644
--- a/server/lib/reddit.ts
+++ b/server/lib/reddit.ts
@@ -689,50 +775,71 @@ export class RedditManager {
         stack: error instanceof Error ? error.stack : undefined,
       });
 
       let errorMessage = 'Failed to submit post';
 
       // Parse common Reddit API errors
       const errorObj = error as { message?: string };
       if (errorObj.message?.includes('RATELIMIT')) {
         errorMessage = 'Rate limited by Reddit. Please try again later.';
       } else if (errorObj.message?.includes('SUBREDDIT_NOTALLOWED')) {
         errorMessage = 'Not allowed to post in this subreddit';
       } else if (errorObj.message?.includes('NO_TEXT')) {
         errorMessage = 'Post content cannot be empty';
       } else if (errorObj.message?.includes('TOO_LONG')) {
         errorMessage = 'Post title or content is too long';
       }
 
       return {
         success: false,
         error: errorMessage,
         decision: permission,
       };
     }
   }
 
+  async getSubmission(postId: string): Promise<RedditSubmission> {
+    const trimmedId = postId.trim();
+    if (!trimmedId) {
+      throw new Error('Post ID is required to fetch submission metrics');
+    }
+
+    try {
+      const reddit = await this.initReddit();
+      const submission = await (reddit as unknown as {
+        getSubmission(id: string): {
+          fetch(): Promise<SnoowrapSubmissionDetails>;
+        };
+      }).getSubmission(trimmedId).fetch();
+
+      return normalizeSubmissionDetails(submission, trimmedId);
+    } catch (error) {
+      console.error('Failed to fetch Reddit submission metrics:', error);
+      throw error;
+    }
+  }
+
   /**
    * Submit image post with direct upload to Reddit
    */
   async submitImagePost(options: {
     subreddit: string;
     title: string;
     imageUrl?: string;
     imageBuffer?: Buffer;
     imagePath?: string;
     nsfw?: boolean;
     spoiler?: boolean;
   }): Promise<RedditPostResult> {
     let permission: PostingPermission | undefined;
     try {
       // Check posting permission (image uploads are not link posts unless falling back to URL)
       permission = await RedditManager.canPostToSubreddit(this.userId, options.subreddit, {
         hasLink: false, // Direct image uploads are not link posts
         intendedAt: new Date(),
         title: options.title,
         body: options.imageUrl || '',
       });
 
       if (!permission.canPost) {
         return {
           success: false,
 
EOF
)