server/caption/geminiPipeline.ts
+6-11
@@ -369,53 +369,51 @@ export async function extractFacts(imageUrl: string): Promise<Record<string, unk
          colors: ['colorful', 'dynamic'],
          vibe: 'animated',
          setting: 'digital',
          wardrobe: ['various'],
          angles: ['dynamic'],
          mood: 'playful',
          style: 'animated'
        };
      }

      throw error;
    }
  } catch (error) {
    console.error('Error in extractFacts:', error);
    if (error instanceof InvalidImageError) throw error;
    throw new Error(`Failed to extract facts: ${error instanceof Error ? error.message : String(error)}`);
  }
}

type GeminiVariantParams = {
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice: string;
  facts: Record<string, unknown>;
  hint?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};
} & ToneOptions;

export async function generateVariants(params: GeminiVariantParams): Promise<z.infer<typeof CaptionArray>> {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("variants.txt")
  ]);

  const sanitizeVariant = (item: Record<string, unknown>): Record<string, unknown> => {
    const variant = { ...item } as Record<string, unknown>;

    variant.safety_level = normalizeSafetyLevel(
      typeof variant.safety_level === "string" ? variant.safety_level : "normal"
    );

    const caption = typeof variant.caption === "string" && variant.caption.trim().length > 0
      ? variant.caption
      : "Check out this amazing content!";
    variant.caption = caption;

    variant.mood = typeof variant.mood === "string" && variant.mood.trim().length >= 2
      ? variant.mood
      : "engaging";
    variant.style = typeof variant.style === "string" && variant.style.trim().length >= 2
      ? variant.style
@@ -742,83 +740,80 @@ export async function rankAndSelect(
    params?.platform,
    buildRerankHint(violations),
    params?.facts
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type GeminiPipelineArgs = {
  imageUrl: string;
  platform: "instagram" | "x" | "reddit" | "tiktok";
  voice?: string;
  nsfw?: boolean;
  style?: string;
  mood?: string;
};
} & ToneOptions;

/**
 * Primary image captioning pipeline backed by Gemini vision + text models.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
export async function pipeline({ imageUrl, platform, voice = "flirty_playful", nsfw = false, style, mood, ...toneRest }: GeminiPipelineArgs): Promise<CaptionResult> {
export async function pipeline({ imageUrl, platform, voice = "flirty_playful", nsfw = false, ...toneInput }: GeminiPipelineArgs): Promise<CaptionResult> {
  try {
    const tone = extractToneOptions(toneRest);
    const tone = extractToneOptions(toneInput);
    const facts = await extractFacts(imageUrl);
    let variants = await generateVariants({ platform, voice, facts, nsfw, ...tone });
    variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
    let ranked = await rankAndSelect(variants, { platform, facts });
    let out = ranked.final;

    const enforceCoverage = async () => {
      let attempts = 0;
      let coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      while (!coverage.ok && coverage.hint && attempts < 2) {
        attempts += 1;
        variants = await generateVariants({ platform, voice, facts, hint: coverage.hint, nsfw, ...tone });
        variants = dedupeVariantsForRanking(variants, 5, { platform, facts });
        ranked = await rankAndSelect(variants, { platform, facts });
        out = ranked.final;
        coverage = ensureFactCoverage({ facts, caption: out.caption, alt: out.alt });
      }
    };

    await enforceCoverage();

    const err = platformChecks(platform, out);
    if (err) {
      variants = await generateVariants({
        platform,
        voice,
        style,
        mood,
        facts,
        hint: `Fix: ${err}. Use IMAGE_FACTS nouns/colors/setting explicitly.`,
        nsfw
        nsfw,
        ...tone
      });
      ranked = await rankAndSelect(variants);
      out = ranked.final;
    }

    return { provider: 'gemini', facts, variants, ranked, final: out };
  } catch (error) {
    const { openAICaptionFallback } = await import('./openaiFallback');
    const final = await openAICaptionFallback({ platform, voice, imageUrl });
    return { provider: 'openai', final } as CaptionResult;
  }
}
server/caption/rewritePipeline.ts
+5-9
@@ -137,53 +137,51 @@ export function extractKeyEntities(existingCaption: string): string[] {
  }

  return result;
}

export async function extractFacts(imageUrl:string){
  const sys=await load("system.txt"), guard=await load("guard.txt"), prompt=await load("extract.txt");
  const img={ inlineData:{ data: await b64(imageUrl), mimeType:"image/jpeg" } };
  try {
    const res=await visionModel.generateContent([{text:sys+"\n"+guard+"\n"+prompt}, img]);
    return stripToJSON(res.response.text());
  } catch (error) {
    console.error('Gemini visionModel.generateContent failed:', error);
    throw error;
  }
}

type RewriteVariantsParams = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice:string;
  existingCaption:string;
  facts?:Record<string, unknown>;
  hint?:string;
  nsfw?:boolean;
  doNotDrop?: string[];
  style?: string;
  mood?: string
};
} & ToneOptions;

const VARIANT_TARGET = 5;
const VARIANT_RETRY_LIMIT = 3;

export async function variantsRewrite(params: RewriteVariantsParams) {
  const [sys, guard, prompt] = await Promise.all([
    load("system.txt"),
    load("guard.txt"),
    load("rewrite.txt")
  ]);

  let attempts = 0;
  let currentHint = params.hint;
  const mandatoryTokens = params.doNotDrop && params.doNotDrop.length > 0
    ? `MANDATORY TOKENS: ${params.doNotDrop.join(" | ")}`
    : "";
  const variants: { caption: string; hashtags: string[]; cta?: string; alt?: string }[] = [];

  while (attempts < VARIANT_RETRY_LIMIT && variants.length < VARIANT_TARGET) {
    attempts += 1;

    const voiceContext = formatVoiceContext(params.voice);
    const user = [
      `PLATFORM: ${params.platform}`,
      `VOICE: ${params.voice}`,
@@ -355,82 +353,80 @@ export async function rankAndSelect(
    params?.platform,
    "Previous attempt had violations. Try again with better compliance."
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectRankingViolations(parsed.final);

  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = parsed.final;
  const summary = formatViolations(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type RewritePipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  existingCaption:string;
  imageUrl?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};
} & ToneOptions;

/**
 * Caption rewriting pipeline that enhances existing captions while preserving tone.
 *
 * @remarks
 * Persona controls such as `style`, `mood`, and future tone keys must persist through
 * retries. When platform validation fails we re-run Gemini with the exact same tone
 * payload so the caller's requested persona stays intact.
 */
type CaptionItemType = z.infer<typeof CaptionItem>;
type CaptionArrayResult = z.infer<typeof CaptionArray>;
type RankResultType = z.infer<typeof RankResult>;

export async function pipelineRewrite({ platform, voice="flirty_playful", style, mood, existingCaption, imageUrl, nsfw=false }:{
  platform:"instagram"|"x"|"reddit"|"tiktok", voice?:string, style?:string, mood?:string, existingCaption:string, imageUrl?:string, nsfw?:boolean }){
export async function pipelineRewrite({ platform, voice="flirty_playful", existingCaption, imageUrl, nsfw=false, ...toneInput }:RewritePipelineArgs){
  try {
    const facts = imageUrl ? await extractFacts(imageUrl) : undefined;

    const doNotDrop = extractKeyEntities(existingCaption);

    const attemptHints: (string | undefined)[] = [
      undefined,
      "Make it 20% longer with a natural hook and CTA; keep it human, no sparkle clich√©s.",
      facts
        ? "Make it 25% longer with a natural hook and CTA; rewrite with concrete imagery from IMAGE_FACTS and stay grounded."
        : "Make it 25% longer with a natural hook and CTA; weave in concrete sensory imagery and stay grounded.",
    ];

    const baseParams = { platform, voice, style, mood, existingCaption, facts, nsfw, doNotDrop } as const;
    const tone = extractToneOptions(toneInput);
    const baseParams = { platform, voice, existingCaption, facts, nsfw, doNotDrop, ...tone } as const;

    type AttemptResult = { variants: CaptionArrayResult; ranked: RankResultType; final: CaptionItemType };

    const performAttempt = async (hint?: string): Promise<AttemptResult> => {
      const attemptVariants = await variantsRewrite({ ...baseParams, hint });
      const attemptRanked = await rankAndSelect(attemptVariants);
      return { variants: attemptVariants, ranked: attemptRanked, final: attemptRanked.final };
    };

    const enforceMandatoryTokens = async (
      attempt: AttemptResult,
      priorHint?: string
    ): Promise<AttemptResult> => {
      if (doNotDrop.length === 0) {
        return attempt;
      }
      const missing = doNotDrop.filter((token) => !attempt.final.caption.includes(token));
      if (missing.length === 0) {
        return attempt;
      }
      const messageParts = [
        priorHint,
        `ABSOLUTE RULE: Keep these tokens verbatim in the caption: ${doNotDrop.join(", ")}`,
        `Previous attempt removed: ${missing.join(", ")}`
      ].filter((part): part is string => Boolean(part && part.trim()));
server/caption/textOnlyPipeline.ts
+1-3
@@ -398,53 +398,51 @@ export async function rankAndSelect(
    params?.platform,
    buildRerankHint(violations)
  );
  parsed = RankResult.parse(rerank);
  const rerankViolations = detectVariantViolations(parsed.final);
  
  if (rerankViolations.length === 0) {
    return parsed;
  }

  const sanitizedFinal = sanitizeFinalVariant(parsed.final, params?.platform);
  const summary = formatViolationSummary(rerankViolations) || parsed.reason;
  return RankResult.parse({
    ...parsed,
    final: sanitizedFinal,
    reason: summary
  });
}

type TextOnlyPipelineArgs = {
  platform:"instagram"|"x"|"reddit"|"tiktok";
  voice?:string;
  theme:string;
  context?:string;
  nsfw?:boolean;
  style?: string;
  mood?: string;
};
} & ToneOptions;

/**
 * Text-only caption pipeline for brainstorming without an image upload.
 *
 * @remarks
 * Persona settings (`style`, `mood`, etc.) are forwarded to every Gemini retry so the
 * voice remains consistent even when a platform validation retry is required.
 */
export async function pipelineTextOnly({ platform, voice="flirty_playful", theme, context, nsfw=false, ...toneRest }:TextOnlyPipelineArgs){
  const tone = extractToneOptions(toneRest);
  let variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone });
  variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
  let ranked = await rankAndSelect(variants, { platform, theme, context });
  let out = ranked.final;

  const err = platformChecks(platform, out);
  if (err) {
    variants = await generateVariantsTextOnly({ platform, voice, theme, context, nsfw, ...tone, hint:`Fix: ${err}. Be specific and engaging.` });
    variants = dedupeVariantsForRanking(variants, 5, { platform, theme, context });
    ranked = await rankAndSelect(variants, { platform, theme, context });
    out = ranked.final;
  }

  return { variants, ranked, final: out };
}
tests/unit/caption/pipeline-tone-retry.test.ts
+196-0
@@ -233,26 +233,222 @@ describe('Gemini pipelines keep persona tone on retry', () => {
    const textOnlyModule = await import('../../../server/caption/textOnlyPipeline.js');

    const failing = createVariantSet(LONG_FAILING_CAPTION, ['#one', '#two', '#three', '#four']);
    const passing = createVariantSet('Text-only attempt passes platform rules', ['#one', '#two']);

    configureTextModelMock(textModel, failing, passing);

    await textOnlyModule.pipelineTextOnly({
      platform: 'x',
      voice: 'Persona Voice',
      theme: 'Testing theme',
      context: 'Testing context',
      style: 'Bold Persona',
      mood: 'Upbeat',
      nsfw: false
    });

    const variantPrompts = extractVariantPrompts(textModel.generateContent.mock.calls);

    expect(variantPrompts).toHaveLength(2);
    const retryPrompt = variantPrompts[1];
    expect(retryPrompt).toContain('Fix:');
    expect(retryPrompt).toContain('STYLE: Bold Persona');
    expect(retryPrompt).toContain('MOOD: Upbeat');
  });

  it('includes tone payload on Gemini platform retry parameters', async () => {
    vi.doMock('../../../server/caption/dedupeVariants.js', () => ({
      dedupeVariantsForRanking: <T>(variants: T) => variants,
      dedupeCaptionVariants: <T>(variants: T) => variants
    }));
    vi.doMock('../../../server/caption/ensureFactCoverage.js', () => ({
      ensureFactCoverage: () => ({ ok: true })
    }));
    vi.doMock('../../../server/caption/inferFallbackFromFacts.js', () => ({
      inferFallbackFromFacts: vi.fn(),
      ensureFallbackCompliance: (
        fields: { caption?: string; hashtags?: string[]; cta?: string; alt?: string }
      ) => ({
        caption: fields.caption ?? 'Check out this amazing content!',
        hashtags: fields.hashtags ?? ['#content', '#creative', '#amazing'],
        cta: fields.cta ?? 'Check it out',
        alt: fields.alt ?? 'Detailed alt text describing the scene.'
      })
    }));
    vi.doMock('../../../server/lib/gemini.js', () => ({ textModel: {}, visionModel: {} }));

    const geminiModule = await import('../../../server/caption/geminiPipeline.js');

    const toneCallParams: Array<Parameters<typeof geminiModule.generateVariants>[0]> = [];
    let lastVariants: MockVariant[] = [];

    const buildVariant = (caption: string): MockVariant => ({
      caption,
      alt: 'Detailed alt text describing the scene for validation.',
      hashtags: ['#one', '#two', '#three'],
      cta: 'Check it out',
      mood: 'Upbeat',
      style: 'Bold Persona',
      safety_level: 'normal',
      nsfw: false
    });

    vi.spyOn(geminiModule, 'extractFacts').mockResolvedValue({ setting: 'studio' });

    const generateVariantsSpy = vi
      .spyOn(geminiModule, 'generateVariants')
      .mockImplementation(async (params) => {
        toneCallParams.push(params);
        const caption = params.hint
          ? 'Persona stays intact while meeting the X caption limit.'
          : 'Persona rich caption that intentionally overruns the strict X character count to force a retry.'.padEnd(260, '!');
        const variant = buildVariant(`${caption} Anchor token`);
        lastVariants = Array.from({ length: 5 }, (_, index) => ({
          ...variant,
          caption: `${variant.caption} ${index}`
        }));
        return lastVariants as unknown as Awaited<ReturnType<typeof geminiModule.generateVariants>>;
      });

    vi.spyOn(geminiModule, 'rankAndSelect').mockImplementation(async () => ({
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: 'test harness',
      final: lastVariants[0]
    }));

    await geminiModule.pipeline({
      imageUrl: 'https://example.com/image.png',
      platform: 'x',
      voice: 'Persona Voice',
      style: 'Bold Persona',
      mood: 'Upbeat',
      nsfw: false
    });

    expect(generateVariantsSpy).toHaveBeenCalledTimes(2);
    const retryParams = toneCallParams[1];
    expect(retryParams?.style).toBe('Bold Persona');
    expect(retryParams?.mood).toBe('Upbeat');
  });

  it('includes tone payload on rewrite platform retry parameters', async () => {
    vi.doMock('../../../server/caption/ensureFactCoverage.js', () => ({
      ensureFactCoverage: () => ({ ok: true })
    }));
    vi.doMock('../../../server/lib/gemini.js', () => ({ textModel: {}, visionModel: {} }));

    const rewriteModule = await import('../../../server/caption/rewritePipeline.js');

    const toneCallParams: Array<Parameters<typeof rewriteModule.variantsRewrite>[0]> = [];
    let lastVariants: MockVariant[] = [];

    const buildVariant = (caption: string): MockVariant => ({
      caption,
      alt: 'Detailed alt text describing the rewrite variant.',
      hashtags: ['#one', '#two', '#three'],
      cta: 'Check it out',
      mood: 'Upbeat',
      style: 'Bold Persona',
      safety_level: 'normal',
      nsfw: false
    });

    const variantsRewriteSpy = vi
      .spyOn(rewriteModule, 'variantsRewrite')
      .mockImplementation(async (params) => {
        toneCallParams.push(params);
        const caption = params.hint
          ? 'Anchor token rewrite stays concise for X while keeping persona vivid.'
          : 'Anchor token rewrite intentionally runs past the safe X character allowance to trigger platform validation.'.padEnd(260, '!');
        const variant = buildVariant(`${caption} Anchor`);
        lastVariants = Array.from({ length: 5 }, (_, index) => ({
          ...variant,
          caption: `${variant.caption} ${index}`
        }));
        return lastVariants as unknown as Awaited<ReturnType<typeof rewriteModule.variantsRewrite>>;
      });

    vi.spyOn(rewriteModule, 'rankAndSelect').mockImplementation(async () => ({
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: 'test harness',
      final: lastVariants[0]
    }));

    await rewriteModule.pipelineRewrite({
      platform: 'x',
      voice: 'Persona Voice',
      existingCaption: 'Anchor',
      style: 'Bold Persona',
      mood: 'Upbeat',
      nsfw: false
    });

    expect(variantsRewriteSpy).toHaveBeenCalledTimes(2);
    const retryParams = toneCallParams[1];
    expect(retryParams?.style).toBe('Bold Persona');
    expect(retryParams?.mood).toBe('Upbeat');
  });

  it('includes tone payload on text-only platform retry parameters', async () => {
    vi.doMock('../../../server/caption/dedupeVariants.js', () => ({
      dedupeVariantsForRanking: <T>(variants: T) => variants,
      dedupeCaptionVariants: <T>(variants: T) => variants
    }));
    vi.doMock('../../../server/lib/gemini.js', () => ({ textModel: {} }));

    const textOnlyModule = await import('../../../server/caption/textOnlyPipeline.js');

    const toneCallParams: Array<Parameters<typeof textOnlyModule.generateVariantsTextOnly>[0]> = [];
    let lastVariants: MockVariant[] = [];

    const buildVariant = (caption: string): MockVariant => ({
      caption,
      alt: 'Detailed alt text describing the brainstormed caption.',
      hashtags: ['#one', '#two', '#three'],
      cta: 'Check it out',
      mood: 'Upbeat',
      style: 'Bold Persona',
      safety_level: 'normal',
      nsfw: false
    });

    const generateVariantsSpy = vi
      .spyOn(textOnlyModule, 'generateVariantsTextOnly')
      .mockImplementation(async (params) => {
        toneCallParams.push(params);
        const caption = params.hint
          ? 'Persona aligned caption keeps X safe length while staying lively.'
          : 'Persona aligned caption purposefully goes way beyond the platform length rules to trigger the retry flow.'.padEnd(260, '!');
        const variant = buildVariant(`${caption} Anchor`);
        lastVariants = Array.from({ length: 5 }, (_, index) => ({
          ...variant,
          caption: `${variant.caption} ${index}`
        }));
        return lastVariants as unknown as Awaited<ReturnType<typeof textOnlyModule.generateVariantsTextOnly>>;
      });

    vi.spyOn(textOnlyModule, 'rankAndSelect').mockImplementation(async () => ({
      winner_index: 0,
      scores: [5, 4, 3, 2, 1],
      reason: 'test harness',
      final: lastVariants[0]
    }));

    await textOnlyModule.pipelineTextOnly({
      platform: 'x',
      voice: 'Persona Voice',
      theme: 'Anchor theme',
      context: 'Anchor context',
      style: 'Bold Persona',
      mood: 'Upbeat',
      nsfw: false
    });

    expect(generateVariantsSpy).toHaveBeenCalledTimes(2);
    const retryParams = toneCallParams[1];
    expect(retryParams?.style).toBe('Bold Persona');
    expect(retryParams?.mood).toBe('Upbeat');
  });
});
